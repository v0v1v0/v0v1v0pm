<div class="container">

<table style="width: 100%;"><tr>
<td>mapa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiple Aggregation Prediction Algorithm (Wrapper)</h2>

<h3>Description</h3>

<p>Wrapper to estimate and produce MAPA in- and out-of-sample forecasts. 
Uses mapaest and mapafor.</p>


<h3>Usage</h3>

<pre><code class="language-R">mapa(y, ppy, fh=ppy, ifh=1, minimumAL=1, maximumAL=ppy, 
     comb=c("w.mean","w.median","mean","median","wght"), paral=c(0,1,2), 
     display=c(0,1), outplot=c(0,1), hybrid=c(TRUE,FALSE), model="ZZZ", 
     type=c("ets","es"), conf.lvl=NULL, xreg=NULL, pr.comp=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>In sample observations of a time series (vector). If y == "paper" then it prints paper reference.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ppy</code></td>
<td>

<p>Periods in a season of the time series at the sampled frequency.
If insample is a ts object then this is taken from its frequency, unless overriden.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fh</code></td>
<td>

<p>Forecast horizon. Default = ppy.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ifh</code></td>
<td>

<p>Lower aggregation level to use. Default = 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minimumAL</code></td>
<td>

<p>Lowest aggregation level to use. Default = 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximumAL</code></td>
<td>

<p>Highest aggregation level to use. Default = ppy, maximumAL&gt;1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comb</code></td>
<td>

<p>Combination operator. This can be: "mean"; "median"; "wght" - where each aggregation level is weighted inversly to aggregation; "w.mean" - level and trend components are averaged, but seasonal and xreg follow the wght combination; "w.median" - as w.mean, but with median. It is suggested that for data with high sampling frequency to use one of the "w.mean" and "w.median".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paral</code></td>
<td>

<p>Use parallel processing. 0 = no; 1 = yes (requires initialised cluster); 2 = yes and initialise cluster. Default is 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>display</code></td>
<td>

<p>Display calculation progress in console. 0 = no; 1 = yes. Default is 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outplot</code></td>
<td>

<p>Provide output plot. 0 = no; 1 = yes. Default is 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hybrid</code></td>
<td>

<p>Provide hybrid forecasts, as in Kourentzes et al. paper. If minimumAL &gt; 1 then the minimumAL ETS forecasts are used. Default is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>Allow only that type of ETS at each aggregation level. This follows similar coding to the ets function. The first letter refers to the error type ("A", "M" or "Z"); the second letter refers to the trend type ("N","A","Ad","M","Md", "Z", "X" or "Y"); and the third letter refers to the season type ("N","A","M", "Z", "X" or "Y"). The letters mean: "N"=none, "A"=additive, "M"=multiplicative, "Z"=automatically selected, "X"=automatically select between none and additive and "Y"=automatically select between none and multiplicative. A "d" for trend implies damped. "X" and "Y" supported only by type=="es". If used with type=="ets" a warning will be given and they will default to "Z". By default model="ZZZ". If due to sample limitation ETS cannot be calculated at an aggregation level for the selected model, then no estimation is done for that specific level. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>What type of exponential smoothing implementation to use. "es" = use from the smooth package; "ets" = use from the forecast package. Default is "es"
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.lvl</code></td>
<td>

<p>Vector of confidence level for prediction intervals. Values must be (0,1). If conf.lvl == NULL then no intervals are calculated. For example to get the intervals for 80% and 95% use conf.lvl=c(0.8,0.95).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xreg</code></td>
<td>

<p>Vector or matrix of exogenous variables to be included in the MAPA. If matrix then rows are observations and columns are variables. Must be at least as long as in-sample. Additional observations are unused. Note that including xreg will force type="es". 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pr.comp</code></td>
<td>

<p>MAPAx can use principal component analysis to preprocess xreg. When comp is -1 then the number of retained components is chosen automatically. When comp=0 then no pre-processing is performed and the original xreg is used. Any other value represents the number of principal components retained. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Pass additional arguments to es or ets.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function calls <em>mapaest</em> and <em>mapafor</em> internally.</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>infor</code></td>
<td>
<p>In-sample forecasts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outfor</code></td>
<td>
<p>Out-of-sample forecasts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PI</code></td>
<td>
<p>Prediction intervals for given confidence levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MSE</code></td>
<td>
<p>In-sample MSE error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MAE</code></td>
<td>
<p>In-sample MAE error.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The calculation of the prediction intervals is based on the empirical multiple step ahead MSE. To speed up calculations set <code>conf.lvl=NULL</code>. If very long forecast horizons are requested then once no more t+h MSE can be calculated the following approximation is used: <code class="reqn">\sqrt{MSE_{t+1}}*\sqrt{h}</code> for the error.</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>; Fotios Petropoulos.
</p>


<h3>References</h3>


<ul>
<li>
<p>Kourentzes N., Petropoulos F., Trapero J.R. (2014) Improving forecasting by estimating time 
series structural components across multiple frequencies. <em>International Journal of Forecasting</em>, <b>30</b>(<b>2</b>), 291â€“302.
</p>
</li>
<li>
<p>Kourentzes N., Petropoulos F. (2015) Forecasting with multivariate temporal aggregation: The case of promotional modelling. <em>International Journal of Production Economics</em>.
</p>
</li>
<li>
<p>You can find more information about MAPA at Nikos' <a href="https://kourentzes.com/forecasting/tag/mapa/">blog</a>.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>mapaest</code>, <code>mapafor</code>, <code>mapasimple</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">out &lt;- mapa(admissions)
</code></pre>


</div>