<div class="container">

<table style="width: 100%;"><tr>
<td>residuals.marssMLE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model and state fitted values, residuals, and residual sigma</h2>

<h3>Description</h3>

<p><code>residuals.marssMLE</code> returns a data frame with fitted values, residuals, residual standard deviation (sigma), and standardized residuals. A residual is the difference between the "value" of the model (<code class="reqn">\mathbf{y}</code>) or  state (<code class="reqn">\mathbf{x}</code>) and the fitted value.  At time <code class="reqn">t</code> (in the returned data frame), the model residuals are for time <code class="reqn">t</code>. For the the state residuals, the residual is for the transition from <code class="reqn">t</code> to <code class="reqn">t+1</code> following the convention in Harvey, Koopman and Penzer (1998). For the the state innovation residuals, this means that <code>state.residual[,t]</code> is for the transition from <code class="reqn">t</code> to <code class="reqn">t+1</code> and is conditioned on data 1 to <code class="reqn">t</code> while <code>model.residual[,t]</code> is is conditioned on data 1 to <code class="reqn">t-1</code>. State innovation residuals are not normally used while state smoothation residuals are used in trend outlier analysis. If warnings are reported, use <code>attr(residuals(fit), "msg")</code> to retrieve the messages.
</p>
<p>Because the state residuals is for the transition from <code class="reqn">t</code> to <code class="reqn">t+1</code>, this means that the state residual <code>.resids[t]</code> is <code>value[t-1]</code> minus <code>.fitted[t-1]</code> in the outputted data frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'marssMLE'
residuals(object, ..., 
           type=c("tt1", "tT", "tt"),
           standardization=c("Cholesky", "marginal", "Block.Cholesky"),
           form=attr(object[["model"]], "form")[1],
           clean=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a <code>marssMLE</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p><code>tt1</code> means innovations residuals. The fitted values are computed conditioned on the data up to <code class="reqn">t-1</code>. See <code>fitted()</code> with <code>type="ytt1"</code> or <code>type="xtt1"</code>. <code>tT</code> means smoothation residuals. the fitted values are computed conditioned on all the data. See <code>fitted()</code> with <code>type="ytT"</code> or <code>type="xtT"</code>. <code>tt</code> means contemporaneous residuals. The fitted values are computed conditioned on the data up to <code class="reqn">t</code>. In MARSS functions, estimates at time <code class="reqn">t</code> conditioned on data 1 to <code class="reqn">T</code> are denoted <code>tT</code>, conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">t-1</code> are denoted <code>tt1</code> and conditioned on data 1 to <code class="reqn">t</code> are <code>tt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardization</code></td>
<td>
<p>"Cholesky" means it is standardized by the lower triangle of the Cholesky transformation of the full variance-covariance matrix of the model and state residuals. 
"marginal" means that the residual is standardized by its standard deviation, i.e. the square root of the value on the diagonal of the variance-covariance matrix of the model and state residuals. 
"Block.Cholesky" means the model or state residuals are standardized by the lower triangle of the Cholesky transformation of only their variance-covariance matrix (not the joint model and state variance-covariance matrix). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>form</code></td>
<td>
<p> For developers. Can be ignored. If you want the function to use a different function than <code>residuals_form</code>.  This might be useful if you manually specified a DFA model and want to use <code>residuals_dfa</code> for rotating.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clean</code></td>
<td>
<p> Can be ignored. For <code>type="tt1"</code>, state residuals are not used for residuals analysis and for <code>type="tt"</code>, they don't exist (all NA). They are used only for smoothation residuals, <code>type="tT"</code>.  For <code>type="tt1"</code> and <code>type="tt"</code>, the data frame is cleaned by removing <code>name=="state"</code> when <code>clean=TRUE</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <code>MARSSresiduals</code> for a discussion of the residuals calculations for MARSS models.
</p>
<p><strong>value</strong> and <strong>.fitted</strong>
</p>
<p>See the discussion below on the meaning of these for <code class="reqn">\mathbf{y}</code> associated residuals (model residuals) or <code class="reqn">\mathbf{x}</code> associated residuals (state residuals).
</p>
<p><strong>model residuals</strong>
</p>
<p>The model residuals are in the data frame with <code>name=="model"</code>.
</p>
<p>The model residuals are the familiar type of residuals, they are the difference between the data at time <code class="reqn">t</code> and the predicted value at time <code class="reqn">t</code>, labeled <code>.fitted</code> in the data frame. For the model residuals, the "value"" is the data (or NA if data are missing). If <code>type="tT"</code>, the predicted value is the expected value of <code class="reqn">\mathbf{Y}</code> conditioned on all the data, i.e. is computed using the smoothed estimate of <code class="reqn">\mathbf{x}</code> at time <code class="reqn">t</code> (<code>xtT</code>).  If <code>type="tt1"</code>, the predicted value is the expected value of <code class="reqn">\mathbf{Y}</code> conditioned on the data up to time <code class="reqn">t-1</code>, i.e. is computed using the estimate of <code class="reqn">\mathbf{x}</code> at time <code class="reqn">t</code> conditioned on the data up to time <code class="reqn">t-1</code> (<code>xtt1</code>). These are known as the one-step-ahead predictions and the residuals are known as the innovations. 
</p>
<p>The standard errors help visualize how well the model fits to the data.  See <code>fitted</code> for a discussion of the calculation of the model predictions for the observations.  The standardized smoothation residuals can be used for outlier detection.  See the references in <code>MARSSresiduals</code> and the chapter on shock detection in the MARSS User Guide.
</p>
<p><strong>state residuals</strong>
</p>
<p>The state residuals are in the data frame with <code>name=="state"</code>.
</p>
<p>If you want the expected value of the states and an estimate of their standard errors (for confidence intervals), then <code>residuals()</code> is not what you want to use.  You want to use <code>tsSmooth(..., type="xtT")</code> to return the smoothed estimate of the state or you can find the states in the <code>states</code> element of the <code>marssMLE</code> object returned by a <code>MARSS()</code> call. For the one-step-ahead state estimates, use <code>tsSmooth(..., type="xtt1")</code>.
</p>
<p>The state residuals are only for state-space models. At time <code class="reqn">t</code>, the state residuals are the difference between the state estimate at time <code class="reqn">t+1</code> and the predicted value of the state at time <code class="reqn">t+1</code> given the estimate of the state at time <code class="reqn">t</code>. For smoothation state residuals, this is 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{w}}_{t+1} = \mathbf{x}_{t+1}^T - \mathbf{B}\mathbf{x}_{t}^T - \mathbf{u} - \mathbf{C}\mathbf{c}_{t+1}</code>
</p>

<p>For "tt1" state residuals, this is 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{w}}_{t+1} = \mathbf{x}_{t+1}^{t+1} - \mathbf{B}\mathbf{x}_{t}^t - \mathbf{u}  - \mathbf{C}\mathbf{c}_{t+1}</code>
</p>
<p>.
Note the t indexing is offset. The state residual at time t is the estimate at time t+1 minus the fitted value at t+1.
</p>
<p>Smoothation state residuals are used for outlier detection or shock detection in the state process.  See <code>MARSSresiduals</code> and read the references cited. Note that the state residual at time <code class="reqn">T</code> (the last time step) is NA since this would be the transition from <code class="reqn">T</code> to <code class="reqn">T+1</code> (past the end of the data).
</p>
<p>Note, because the state residuals are for the transition from <code class="reqn">t</code> to <code class="reqn">t+1</code>, this means that in the outputted data frame, the state residual <code>.resids[t]</code> is <code>value[t-1]</code> minus <code>.fitted[t-1]</code>.
</p>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>tT, tt1 or tt</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.rownames</code></td>
<td>
<p>The names of the observation rows or the state rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>model or state</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>time step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>The data value if <code>name</code> equals "model" or the <code class="reqn">x</code> estimate if <code>name</code> equals "state" at time <code class="reqn">t</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.fitted</code></td>
<td>
<p>Model predicted values of observations or states at time <code class="reqn">t</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.resids</code></td>
<td>
<p>Model or states residuals. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.sigma</code></td>
<td>
<p>The standard error of the model or state residuals. Intervals for the residuals can be constructed from <code>.sigma</code> using <code>qnorm(alpha/2)*.sigma + .fitted.</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.std.resids</code></td>
<td>
<p>Standardized residuals. See <code>MARSSresiduals</code> for a discussion of residual standardization.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Holmes, E. E. 2014. Computation of standardized residuals for (MARSS) models. Technical Report. arXiv:1411.0045. 
</p>
<p>See also the discussion and references in <code>MARSSresiduals.tT</code>, <code>MARSSresiduals.tt1</code> and <code>MARSSresiduals.tt</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11, 12), ]
fit &lt;- MARSS(dat, model = list(Z = factor(c("WA", "OR", "OR"))))

library(ggplot2)
theme_set(theme_bw())

## Not run: 
# Show a series of standard residuals diagnostic plots for state-space models
autoplot(fit, plot.type="residuals")

## End(Not run)

d &lt;- residuals(fit, type="tt1")
## Not run: 
# Make a series of diagnostic plots from a residuals object
autoplot(d)

## End(Not run)

# Manually make a plot of the model residuals (innovations) with intervals
d$.conf.low &lt;- d$.fitted+qnorm(0.05/2)*d$.sigma
d$.conf.up &lt;- d$.fitted-qnorm(0.05/2)*d$.sigma
ggplot(data = d) +
  geom_line(aes(t, .fitted)) +
  geom_point(aes(t, value), na.rm=TRUE) +
  geom_ribbon(aes(x = t, ymin = .conf.low, ymax = .conf.up), linetype = 2, alpha = 0.1) +
  ggtitle("Model residuals (innovations)") +
  xlab("Time Step") + ylab("Count") +
  facet_grid(~.rownames)

# NOTE state residuals are for t to t+1 while the value and fitted columns 
# are for t. So (value-fitted)[t] matches .resids[t+1] NOT .resids[t]
# This is only for state residuals. For model residuals, the time-indexing matches.
d &lt;- residuals(fit, type="tT")
dsub &lt;- subset(d, name=="state")
# note t in col 1 matches t+1 in col 2
head(cbind(.resids=dsub$.resids, valminusfitted=dsub$value-dsub$.fitted))

# Make a plot of the smoothation residuals
ggplot(data = d) +
  geom_point(aes(t, value-.fitted), na.rm=TRUE) +
  facet_grid(~.rownames+name) +
  ggtitle("Smoothation residuals (state and model)") +
  xlab("Time Step") + ylab("Count")

# Make a plot of xtT versus prediction of xt from xtT[t-1]
# This is NOT the estimate of the smoothed states with CIs. Use tsSmooth() for that.
ggplot(data = subset(d, name=="state")) +
  geom_point(aes(t, value), na.rm=TRUE) +
  geom_line(aes(x = t, .fitted), color="blue") +
  facet_grid(~.rownames) +
  xlab("Time Step") + ylab("Count") +
  ggtitle("xtT (points) and prediction (line)")

# Make a plot of y versus prediction of yt from xtT[t]
# Why doesn't the OR line go through the points?
# Because there is only one OR state line and it needs to go through
# both sets of OR data.
ggplot(data = subset(d, name=="model")) +
  geom_point(aes(t, value), na.rm=TRUE) +
  geom_line(aes(x = t, .fitted), color="blue") +
  facet_grid(~.rownames) +
  xlab("Time Step") + ylab("Count") +
  ggtitle("data (points) and prediction (line)")

</code></pre>


</div>