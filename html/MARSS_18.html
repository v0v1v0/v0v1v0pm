<div class="container">

<table style="width: 100%;"><tr>
<td>fitted.marssMLE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Return fitted values for X(t) and Y(t) in a MARSS model</h2>

<h3>Description</h3>

<p><code>fitted()</code> returns the different types of fitted values for <code class="reqn">\mathbf{x}_t</code> and <code class="reqn">\mathbf{y}_t</code> in a MARSS model. The fitted values are the expected value of the right side of the MARSS equations without the error terms, thus are the model predictions of <code class="reqn">\mathbf{y}_t</code> or <code class="reqn">\mathbf{x}_t</code>. <code>fitted.marssMLE</code> is a companion function to <code>tsSmooth()</code> which returns the expected value of the right side of the MARSS equations with the error terms (the Kalman filter and smoother output).
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{x}_{t} = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{C} \mathbf{c}_t + \mathbf{G} \mathbf{w}_t, \textrm{ where } \mathbf{W}_t \sim \textrm{MVN}(0,\mathbf{Q})</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{D} \mathbf{d}_t + \mathbf{H} \mathbf{v}_t, \textrm{ where } \mathbf{V}_t \sim \textrm{MVN}(0,\mathbf{R})</code>
</p>

<p>The data go from <code class="reqn">t=1</code> to <code class="reqn">t=T</code>. For brevity, the parameter matrices are shown without a time subscript, however all parameters can be time-varying.
</p>
<p>Note that the prediction of <code class="reqn">\mathbf{x}_t</code> conditioned on the data up to time <code class="reqn">t</code> is not provided since that would require the expected value of <code class="reqn">\mathbf{X}_{t}</code> conditioned on data from <code class="reqn">t = 1</code> to <code class="reqn">t+1</code>, which is not output from the Kalman filter or smoother.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'marssMLE'
fitted(object, ..., 
    type = c("ytt1", "ytT", "xtT", "ytt", "xtt1"),   
    interval = c("none", "confidence", "prediction"), 
    level = 0.95, 
    output = c("data.frame", "matrix"), 
    fun.kf = c("MARSSkfas", "MARSSkfss"))
  </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> A <code>marssMLE</code> object.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> If <code>type="tT"</code>, then the predictions are conditioned on all the data. If  <code>type="tt"</code>, then the predictions are conditioned on data up to time <code class="reqn">t</code>. If  <code>type="tt1"</code>, the predictions are conditioned on data up to time <code class="reqn">t-1</code>. The latter are also known as one-step-ahead estimates. For <code class="reqn">\mathbf{y}</code>, these are also known as the innovations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p> If <code>interval="confidence"</code>, then the standard error and confidence interval of the predicted value is returned. If <code>interval="prediction"</code>, then the standard deviation and prediction interval of new data or states are returned. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p> Level for the intervals if <code>interval</code> is not equal to <code>"none"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p> data frame or list of matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.kf</code></td>
<td>
<p> By default, <code>tsSmooth()</code> will use the Kalman filter/smoother function in <code>object$fun.kf</code> (either <code>MARSSkfas()</code> or <code>MARSSkfss()</code>). You can pass in <code>fun.kf</code> to force a particular Kalman filter/smoother function to be used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Not used. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the state-space literature, the two most commonly used fitted values are <code>"ytt1"</code> and 
<code>"ytT"</code>. The former is the expected value of <code class="reqn">\mathbf{Y}_t</code> conditioned on the data 1 to time <code class="reqn">t-1</code>. These are known as the innovations and they, plus their variance, are used in the calculation of the likelihood of a MARSS model via the innovations form of the likelihood. The latter, <code>"ytT"</code> are the model estimates of the <code class="reqn">\mathbf{y}</code> values using all the data; this is the expected value of <code class="reqn">\mathbf{Z}\mathbf{X}_t+\mathbf{a}+\mathbf{D}\mathbf{d}_t</code> conditioned on the data 1 to <code class="reqn">T</code>. The <code>"xtT"</code> along with <code>"ytT"</code> are used for computing smoothation residuals used in outlier and shock detection. See <code>MARSSresiduals</code>. For completeness, <code>fitted.marssMLE</code> will also return the other possible model predictions with different conditioning on the data (1 to <code class="reqn">t-1</code>, <code class="reqn">t</code>, and <code class="reqn">T</code>), however only <code>type="ytt1"</code> (innovations) and <code>"ytT"</code> and <code>"xtT"</code> (smoothations) are regularly used. Keep in mind that the fitted <code>"xtT"</code> is not the smoothed estimate of <code class="reqn">\mathbf{x}</code> (unlike <code>"ytT"</code>). If you want the smoothed estimate of <code class="reqn">\mathbf{x}</code> (i.e. the expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on all the data), you want the Kalman smoother. See <code>tsSmooth</code>.
</p>
<p>Fitted versus estimated values: The fitted states at time <code class="reqn">t</code> are predictions from the estimated state at time <code class="reqn">t-1</code> conditioned on the data: expected value of <code class="reqn">\mathbf{B}\mathbf{X}_{t-1}+\mathbf{u}+\mathbf{C}\mathbf{c}_t</code> conditioned on the data. They are distinguished from the estimated states at time <code class="reqn">t</code> which would includes the conditional expected values of the error terms: <code class="reqn">\textrm{E}[\mathbf{X}_{t}] = \mathbf{B}\mathbf{X}_{t-1}+\mathbf{u}+\mathbf{C}\mathbf{c}_t + \mathbf{w}_t</code>. The latter are returned by the Kalman filter and smoother. Analogously, the fitted observations at time <code class="reqn">t</code> are model predictions from the estimated state at time <code class="reqn">t</code> conditioned on the data: the expected value of the right side of the <code class="reqn">\mathbf{y}</code> equation without the error term. Like with the states, one can also compute the expected value of the observations at time <code class="reqn">t</code> conditioned on the data: the expected value of the right side of the <code class="reqn">\mathbf{y}</code> equation with the error term.  The latter would just be equal to the data if there are no missing data, but when there are missing data, this is what is used to estimate their values. The expected value of states and observations are provided via <code>tsSmooth</code>.
</p>
<p><strong>observation fitted values</strong>
</p>
<p>The model predicted <code class="reqn">\hat{\mathbf{y}}_t</code> is <code class="reqn">\mathbf{Z}\mathbf{x}_t^\tau+\mathbf{a} + \mathbf{D}\mathbf{d}_t</code>, where <code class="reqn">\mathbf{x}_t^\tau</code> is the expected value of the state at time <code class="reqn">t</code> conditioned on the data from 1 to <code class="reqn">\tau</code> (<code class="reqn">\tau</code> will be <code class="reqn">t-1</code>, <code class="reqn">t</code> or <code class="reqn">T</code>). Note, if you are using MARSS for estimating the values for missing data, then you want to use <code>tsSmooth()</code> with <code>type="ytT"</code> not <code>fitted(..., type="ytT")</code>.
</p>
<p><code class="reqn">\mathbf{x}_t^\tau</code> is the expected value of the states at time <code class="reqn">t</code> conditioned on the data from time 1 to <code class="reqn">\tau</code>. If <code>type="ytT"</code>, the expected value is conditioned on all the data, i.e. <code>xtT</code> returned by <code>MARSSkf()</code>.  If <code>type="ytt1"</code>, then the expected value uses only the data up to time <code class="reqn">t-1</code>, i.e. <code>xtt1</code> returned by <code>MARSSkf()</code>.  These are commonly known as the one step ahead predictions for a state-space model. If <code>type="ytt"</code>, then the expected value uses the data up to time <code class="reqn">t</code>, i.e. <code>xtt</code> returned by <code>MARSSkf()</code>. 
</p>
<p>If <code>interval="confidence"</code>, the standard error and interval is for the predicted <code class="reqn">\mathbf{y}</code>. The standard error is <code class="reqn">\mathbf{Z} \mathbf{V}_t^\tau \mathbf{Z}^\top</code>.  If <code>interval="prediction"</code>, the standard deviation of new iid <code class="reqn">\mathbf{y}</code> data sets is returned. The standard deviation of new <code class="reqn">\mathbf{y}</code> is <code class="reqn">\mathbf{Z} \mathbf{V}_t^\tau \mathbf{Z}^\top + \mathbf{R}_t</code>.  <code class="reqn">\mathbf{V}_t^\tau</code> is conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">n</code>. <code class="reqn">\tau</code> will be either <code class="reqn">t</code>, <code class="reqn">t-1</code> or <code class="reqn">T</code> depending on the value of <code>type</code>. 
</p>
<p>Intervals returned by <code>predict()</code> are not for the data used in the model but rather new data sets. To evaluate the data used to fit the model for residuals analysis or analysis or model inadequacy, you want the model residuals (and residual se's). Use <code>residuals</code> for model residuals and their intervals. The intervals for model residuals are narrower because the predictions for <code class="reqn">\mathbf{y}</code> were estimated from the model data (so is closer to the data used to estimate the predictions than new independent data will be).
</p>
<p><strong>state fitted values</strong>
</p>
<p>The model predicted <code class="reqn">\mathbf{x}_t</code> given <code class="reqn">\mathbf{x}_{t-1}</code> is <code class="reqn">\mathbf{B}\mathbf{x}_{t-1}^\tau+\mathbf{u}+\mathbf{C}\mathbf{c}_t</code>. If you want estimates of the states, rather than the model predictions based on <code class="reqn">\mathbf{x}_{t-1}</code>, go to <code>tsSmooth()</code>. Which function you want depends on your objective and application. 
</p>
<p><code class="reqn">\mathbf{x}_{t-1}^\tau</code> used in the prediction is the expected value of the states at time <code class="reqn">t-1</code> conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">t=\tau</code>. If <code>type="xtT"</code>, this is the expected value at time <code class="reqn">t-1</code> conditioned on all the data, i.e. <code>xtT[,t-1]</code> returned by <code>MARSSkf()</code>.  If <code>type="xtt1"</code>, it is the expected value conditioned on the data up to time <code class="reqn">t-1</code>, i.e. <code>xtt[,t-1]</code> returned by <code>MARSSkf()</code>. The predicted state values conditioned on data up to <code class="reqn">t</code> are not provided. This would require the expected value of states at time <code class="reqn">t</code> conditioned on data up to time <code class="reqn">t+1</code>, and this is not output by the Kalman filter. Only conditioning on data up to <code class="reqn">t-1</code> and <code class="reqn">T</code> are output.
</p>
<p>If <code>interval="confidence"</code>, the standard error of the predicted values (meaning the standard error of the expected value of <code class="reqn">\mathbf{X}_t</code> given <code class="reqn">\mathbf{X}_{t-1}</code>) is returned.  The standard error of the predicted value is <code class="reqn">\mathbf{B} \mathbf{V}_{t-1}^\tau\mathbf{B}^\top</code>. If <code>interval="prediction"</code>, the standard deviation of <code class="reqn">\mathbf{X}_t</code> given <code class="reqn">\mathbf{X}_{t-1}</code> is output. The latter is <code class="reqn">\mathbf{B} \mathbf{V}_{t-1}^\tau \mathbf{B}^\top + \mathbf{Q}</code> . <code class="reqn">\mathbf{V}_{t-1}^\tau</code> is either conditioned on data 1 to <code class="reqn">\tau=T</code> or <code class="reqn">\tau=t-1</code> depending on <code>type</code>. 
</p>
<p>The intervals returned by <code>fitted.marssMLE()</code> are for the state predictions based on the state estimate at <code class="reqn">t-1</code>. These are not typically what one uses or needsâ€“however might be useful for simulation work. If you want confidence intervals for the state estimates, those are provided in <code>tsSmooth</code>. If you want to do residuals analysis (for outliers or model inadequacy), you want the residuals intervals provided in <code>residuals()</code>.
</p>


<h3>Value</h3>

<p>If <code>output="data.frame"</code> (the default), a data frame with the following columns is returned. If <code>output="matrix"</code>, the columns are returned as matrices in a list. Information computed from the model has a leading "." in the column name.
</p>
<p>If <code>interval="none"</code>, the following are returned (colnames with <code>.</code> in front are computed values):
</p>
<table>
<tr style="vertical-align: top;">
<td><code>.rownames</code></td>
<td>
<p> Names of the data or states. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p> Time step. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p> The data if <code>type</code> is <code>"ytT"</code>, <code>"ytt"</code> or <code>"ytt1"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.x</code></td>
<td>
<p> The expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on all the data if <code>type="xtT"</code> or data up to time <code class="reqn">t</code> if <code>type="xtt1"</code>. From <code>tsSmooth()</code>. This is the expected value of the right-side of the <code class="reqn">\mathbf{x}_t</code> equation with the errors terms while <code>.fitted</code> is the expected value of the right side without the error term <code class="reqn">\mathbf{w}_t</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.fitted</code></td>
<td>
<p>Predicted values of observations (<code class="reqn">\mathbf{y}</code>) or the states (<code class="reqn">\mathbf{x}</code>). See details.</p>
</td>
</tr>
</table>
<p>If <code>interval = "confidence"</code>, the following are also returned:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>.se</code></td>
<td>
<p> Standard errors of the predictions. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.conf.low</code></td>
<td>
<p> Lower confidence level at <code>alpha = 1-level</code>. The interval is approximated using qnorm(alpha/2)*.se + .fitted </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.conf.up</code></td>
<td>
<p> Upper confidence level. The interval is approximated using qnorm(1-alpha/2)*.se + .fitted </p>
</td>
</tr>
</table>
<p>The confidence interval is for the predicted value, i.e. <code class="reqn">\mathbf{Z}\mathbf{x}_t^\tau+\mathbf{a}</code> for <code class="reqn">\mathbf{y}</code> or <code class="reqn">\mathbf{B}\mathbf{x}_{t-1}^\tau+\mathbf{u}</code> for <code class="reqn">\mathbf{x}</code> where <code class="reqn">\mathbf{x}_t^\tau</code> is the expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on the data from 1 to <code class="reqn">\tau</code>. (<code class="reqn">\tau</code> will be <code class="reqn">t-1</code>, <code class="reqn">t</code> or <code class="reqn">T</code>).
</p>
<p>If <code>interval = "prediction"</code>, the following are also returned:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>.sd</code></td>
<td>
<p> Standard deviation of new <code class="reqn">\mathbf{x}_t</code> or <code class="reqn">\mathbf{y}_t</code> iid values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.lwr</code></td>
<td>
<p> Lower range at <code>alpha = 1-level</code>. The interval is approximated using qnorm(alpha/2)*.sd + .fitted </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.upr</code></td>
<td>
<p> Upper range at <code>level</code>. The interval is approximated using qnorm(1-alpha/2)*.sd + .fitted </p>
</td>
</tr>
</table>
<p>The prediction interval is for new <code class="reqn">\mathbf{x}_t</code> or <code class="reqn">\mathbf{y}_t</code>. If you want to evaluate the observed data or the states estimates for outliers then these are not the intervals that you want. For that you need the residuals intervals provided by <code>residuals()</code>.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

<p><code>MARSSkf()</code>, <code>MARSSresiduals()</code>, <code>residuals()</code>, <code>predict()</code>, <code>tsSmooth()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11, 12), ]
fit &lt;- MARSS(dat, model = list(Z = factor(c("WA", "OR", "OR"))))
fitted(fit)

# Example of fitting a stochastic level model to the Nile River flow data
# red line is smooothed level estimate
# grey line is one-step-ahead prediction using xtt1
nile &lt;- as.vector(datasets::Nile)
mod.list &lt;- list(
  Z = matrix(1), A = matrix(0), R = matrix("r"),
  B = matrix(1), U = matrix(0), Q = matrix("q"),
  x0 = matrix("pi")
)
fit &lt;- MARSS(nile, model = mod.list, silent = TRUE)

# Plotting
# There are plot methods for marssMLE objects
library(ggplot2)
autoplot(fit)

# Below shows how to make plots manually but all of these can be made
# with autoplot(fit) or plot(fit)
plot(nile, type = "p", pch = 16, col = "blue")
lines(fitted(fit, type="ytT")$.fitted, col = "red", lwd = 2)
lines(fitted(fit, type="ytt1")$.fitted, col = "grey", lwd = 2)

# Make a plot of the model estimate of y(t), i.e., put a line through the points
# Intervals are for new data not the blue dots 
# (which were used to fit the model so are not new)
library(ggplot2)
d &lt;- fitted(fit, type = "ytT", interval="confidence", level=0.95)
d2 &lt;- fitted(fit, type = "ytT", interval="prediction", level=0.95)
d$.lwr &lt;- d2$.lwr
d$.upr &lt;- d2$.upr
ggplot(data = d) +
  geom_line(aes(t, .fitted), linewidth=1) +
  geom_point(aes(t, y), color = "blue", na.rm=TRUE) +
  geom_ribbon(aes(x = t, ymin = .conf.low, ymax = .conf.up), alpha = 0.3) +
  geom_line(aes(t, .lwr), linetype = 2) +
  geom_line(aes(t, .upr), linetype = 2) +
  facet_grid(~.rownames) +
  xlab("Time Step") + ylab("Count") +
  ggtitle("Blue=data, Black=estimate, grey=CI, dash=prediction interval") +
  geom_text(x=15, y=7, label="The intervals are for \n new data not the blue dots")

</code></pre>


</div>