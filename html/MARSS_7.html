<div class="container">

<table style="width: 100%;"><tr>
<td>plot.marssMLE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Plot MARSS MLE objects </h2>

<h3>Description</h3>

<p>Plots fitted observations and estimated states with confidence intervals using base R graphics (<code>plot</code>) and ggplot2 (<code>autoplot</code>).  Diagnostic plots also shown.  By default a subset of standard diagnostic plots are plotted.  Individual plots can be plotted by passing in <code>plot.type</code>.  If an individual plot is made using <code>autoplot()</code>, the ggplot object is returned which can be further manipulated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'marssMLE'
plot(x, plot.type = c(
    "fitted.ytT", "fitted.ytt", "fitted.ytt1", 
    "ytT", "ytt", "ytt1",
    "fitted.xtT", "fitted.xtt1", 
    "xtT", "xtt", "xtt1",
    "model.resids.ytt1", "qqplot.model.resids.ytt1", "acf.model.resids.ytt1",
    "std.model.resids.ytt1", "qqplot.std.model.resids.ytt1", "acf.std.model.resids.ytt1",
    "model.resids.ytT", "qqplot.model.resids.ytT", "acf.model.resids.ytT",
    "std.model.resids.ytT", "qqplot.std.model.resids.ytT", "acf.std.model.resids.ytT",
    "model.resids.ytt", "qqplot.model.resids.ytt", "acf.model.resids.ytt",
    "std.model.resids.ytt", "qqplot.std.model.resids.ytt", "acf.std.model.resids.ytt",
    "state.resids.xtT", "qqplot.state.resids.xtT", "acf.state.resids.xtT",
    "std.state.resids.xtT", "qqplot.std.state.resids.xtT", "acf.std.state.resids.xtT",
    "residuals", "all"),
    form=c("marxss", "marss", "dfa"),
    standardization = c("Cholesky", "marginal", "Block.Cholesky"),
    conf.int=TRUE, conf.level=0.95, decorate=TRUE, pi.int = FALSE,
    plot.par = list(), ..., silent = FALSE)
## S3 method for class 'marssMLE'
autoplot(x, plot.type = c(
    "fitted.ytT", "fitted.ytt", "fitted.ytt1", 
    "ytT", "ytt", "ytt1",
    "fitted.xtT", "fitted.xtt1", 
    "xtT", "xtt", "xtt1",
    "model.resids.ytt1", "qqplot.model.resids.ytt1", "acf.model.resids.ytt1",
    "std.model.resids.ytt1", "qqplot.std.model.resids.ytt1", "acf.std.model.resids.ytt1",
    "model.resids.ytT", "qqplot.model.resids.ytT", "acf.model.resids.ytT",
    "std.model.resids.ytT", "qqplot.std.model.resids.ytT", "acf.std.model.resids.ytT",
    "model.resids.ytt", "qqplot.model.resids.ytt", "acf.model.resids.ytt",
    "std.model.resids.ytt", "qqplot.std.model.resids.ytt", "acf.std.model.resids.ytt",
    "state.resids.xtT", "qqplot.state.resids.xtT", "acf.state.resids.xtT",
    "std.state.resids.xtT", "qqplot.std.state.resids.xtT", "acf.std.state.resids.xtT",
    "residuals", "all"),
    form=c("marxss", "marss", "dfa"),
    standardization = c("Cholesky", "marginal", "Block.Cholesky"),
    conf.int=TRUE, conf.level=0.95, decorate=TRUE, pi.int = FALSE,
    fig.notes = TRUE, plot.par = list(), ..., silent = FALSE)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> A <code>marssMLE</code> object.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.type</code></td>
<td>
<p> Type of plot.  If not passed in, a subset of the standard plots are drawn. See details for plot types.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardization</code></td>
<td>
<p> The type of standardization to be used plots, if the user wants to specify a specific standardization. Otherwise Cholesky standardization is used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>form</code></td>
<td>
<p> Optional. Form of the model.  This is normally taken from the form attribute of the MLE object (x), but the user can specify a different form. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int</code></td>
<td>
<p> TRUE/FALSE. Whether to include a confidence interval. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi.int</code></td>
<td>
<p> TRUE/FALSE. Whether to include a prediction interval on the observations plot </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p> Confidence level for CIs. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decorate</code></td>
<td>
<p> TRUE/FALSE. Add smoothing lines to residuals plots or qqline to qqplots and add data points plus residuals confidence intervals to states and observations plots. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.par</code></td>
<td>
<p> A list of plot parameters to adjust the look of the plots.  See details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fig.notes</code></td>
<td>
<p> Add notes to the bottom of the plots (only for <code>autoplot()</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p> No console interaction or output. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Other arguments, not used. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The plot types are as follows:
</p>

<dl>
<dt><code>"fitted.y"</code></dt>
<dd>
<p> This plots the fitted <code class="reqn">\mathbf{y}</code>, which is the expected value of <code class="reqn">\mathbf{Y}</code> conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">t-1</code>, <code class="reqn">t</code> or <code class="reqn">T</code>. It is <code class="reqn">\mathbf{Z}\mathbf{x}_t^T + \mathbf{a}</code>. The data are plotted for reference but note that the lines and intervals are for new data not the observed data.</p>
</dd>
<dt><code>"fitted.x"</code></dt>
<dd>
<p> This plots the fitted x, which is the expected value of <code class="reqn">\mathbf{X}</code> conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">t-1</code> or <code class="reqn">T</code>. It is <code class="reqn">B \textrm{E}[\mathbf{X}_{t-1}|\mathbf{y}] + u</code>. The <code class="reqn">\textrm{E}[\mathbf{X}_t|\mathbf{y}]</code> are plotted for reference but note that the lines and intervals are for new <code class="reqn">\mathbf{x}</code>. This is not the estimated states; these are used for residuals calculations. If you want the state estimates use <code>xtT</code> (or <code>xtt</code>).</p>
</dd>
<dt><code>"xtT"</code></dt>
<dd>
<p>  The estimated states from the Kalman smoother (conditioned on all the data). </p>
</dd>
<dt><code>"xtt1"</code></dt>
<dd>
<p>  The estimated states conditioned on the data up to <code class="reqn">t-1</code>. Kalman filter output. </p>
</dd>
<dt>
<code>"model.resids.ytT"</code>, <code>"model.resids.ytt1"</code>, <code>"model.resids.ytt"</code>
</dt>
<dd>
<p>Model residuals (data minus fitted y). <code>ytT</code> indicates smoothation residuals, <code>ytt1</code> indicates innovation residuals (the standard state-space residuals), and <code>ytt</code> are the residuals conditioned on data up to <code class="reqn">t</code>. </p>
</dd>
<dt><code>"state.resids.xtT"</code></dt>
<dd>
<p> State smoothation residuals (E(x(t) | xtT(t-1)) minus xtT(t)). The intervals are the CIs for the smoothation residuals not one-step-ahead residuals. </p>
</dd>
<dt><code>"std"</code></dt>
<dd> <p><code>std</code> in front of any of the above plot names indicates that the plots are for the standardized residuals. </p>
</dd>
<dt><code>"qqplot"</code></dt>
<dd>
<p> Visual normality test for the residuals, model or state. </p>
</dd> 
<dt><code>"acf"</code></dt>
<dd>
<p> ACF of the residuals. The only residuals that should be temporally independent are the innovation residuals: <code>acf.model.residuals.ytt1</code> and <code>acf.std.model.residuals.ytt1</code>. This ACF is a standard residuals diagnostic for state-space models. The other ACF plots will show temporal dependence and are not used for diagnostics. </p>
</dd>
<dt><code>"ytT"</code></dt>
<dd>
<p> The expected value of <code class="reqn">\mathbf{Y}</code> conditioned on all the data. Use this for estimates of the missing data points. Note for non-missing <code class="reqn">\mathbf{y}</code> values, the expected value of <code class="reqn">\mathbf{Y}</code> is <code class="reqn">\mathbf{y}</code>. </p>
</dd> 
<dt>
<code>"ytt"</code>, <code>ytt1</code>
</dt>
<dd>
<p> The expected value of <code class="reqn">\mathbf{Y}</code> conditioned on the data from 1 to <code class="reqn">t</code> or <code class="reqn">t-1</code>. </p>
</dd> 
</dl>
<p>The plot parameters can be passed in as a list to change the look of the plots. For <code>plot.marssMLE()</code>, the default is <code>plot.par = list(point.pch = 19, point.col = "blue", point.fill = "blue", point.size = 1, line.col = "black", line.size = 1, line.linetype = "solid", ci.col = "grey70", ci.border = NA, ci.lwd = 1, ci.lty = 1)</code>. For <code>autoplot.marssMLE</code>, the default is <code>plot.par = list(point.pch = 19, point.col = "blue", point.fill = "blue", point.size = 1, line.col = "black", line.size = 1, line.linetype = "solid", ci.fill = "grey70", ci.col = "grey70", ci.linetype = "solid", ci.linesize = 0, ci.alpha = 0.6)</code>.
</p>


<h3>Value</h3>

<p><code>autoplot()</code> will invisibly return the list of ggplot2 plot objects. Use <code>plts &lt;- autoplot()</code> to obtain that list.
</p>


<h3>Author(s)</h3>

 
<p>Eric Ward and Eli Holmes
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(harborSealWA)
model.list &lt;- list( Z = as.factor(c(1, 1, 1, 1, 2)), R = "diagonal and equal")
fit &lt;- MARSS(t(harborSealWA[, -1]), model = model.list)
plot(fit, plot.type = "fitted.ytT")

require(ggplot2)
autoplot(fit, plot.type = "fitted.ytT")

## Not run: 
# DFA example
dfa &lt;- MARSS(t(harborSealWA[, -1]), model = list(m = 2), form = "dfa")
plot(dfa, plot.type = "xtT")

## End(Not run)
</code></pre>


</div>