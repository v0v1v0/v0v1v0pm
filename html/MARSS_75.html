<div class="container">

<table style="width: 100%;"><tr>
<td>MARSShatyt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Compute Expected Value of Y, YY, and YX</h2>

<h3>Description</h3>

<p>Computes the expected value of random variables involving <code class="reqn">\mathbf{Y}</code>.  Users can use <code>tsSmooth()</code> or <code>print( MLEobj, what="Ey")</code> to access this output.  See <code>print.marssMLE</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MARSShatyt(MLEobj, only.kem = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code> MLEobj </code></td>
<td>
<p> A <code>marssMLE</code> object with the <code>par</code> element of estimated parameters, <code>model</code> element with the model description and data. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> only.kem </code></td>
<td>
<p> If TRUE, return only <code>ytT</code>, <code>OtT</code>, <code>yxtT</code>, and <code>yxttpT</code> (values conditioned on the data from <code class="reqn">1:T</code>) needed for the EM algorithm.  If <code>only.kem=FALSE</code>, then also return values conditioned on data from 1 to <code class="reqn">t-1</code> (<code>Ott1</code> and <code>ytt1</code>) and 1 to <code class="reqn">t</code> (<code>Ott</code> and <code>ytt</code>), <code>yxtt1T</code> (<code class="reqn">\textrm{var}[\mathbf{Y}_t, \mathbf{X}_{t-1}|\mathbf{y}_{1:T}]</code>), var.ytT (<code class="reqn">\textrm{var}[\mathbf{Y}_t|\mathbf{y}_{1:T}]</code>), and var.EytT (<code class="reqn">\textrm{var}_X[E_{Y|x}[\mathbf{Y}_t|\mathbf{y}_{1:T},\mathbf{x}_t]]</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For state space models, <code>MARSShatyt()</code> computes the expectations involving <code class="reqn">\mathbf{Y}</code>.  If <code class="reqn">\mathbf{Y}</code> is completely observed, this entails simply replacing <code class="reqn">\mathbf{Y}</code> with the observed <code class="reqn">\mathbf{y}</code>.  When <code class="reqn">\mathbf{Y}</code> is only partially observed, the expectation involves the conditional expectation of a multivariate normal. 
</p>


<h3>Value</h3>

 
<p>A list with the following components (n is the number of state processes). Following the notation in Holmes (2012), <code class="reqn">\mathbf{y}(1)</code> is the observed data (for <code class="reqn">t=1:T</code>) while <code class="reqn">\mathbf{y}(2)</code> is the unobserved data.  <code class="reqn">\mathbf{y}(1,1:t-1)</code> is the observed data from time 1 to <code class="reqn">t-1</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>ytT</code></td>
<td>
<p> E[Y(t) | Y(1,1:T)=y(1,1:T)] (n x T matrix). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ytt1</code></td>
<td>
<p> E[Y(t) | Y(1,1:t-1)=y(1,1:t-1)] (n x T matrix). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ytt</code></td>
<td>
<p> E[Y(t) | Y(1,1:t)=y(1,1:t)] (n x T matrix). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OtT</code></td>
<td>
<p> E[Y(t) t(Y(t)) | Y(1,1:T)=y(1,1:T)] (n x n x T array). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.ytT</code></td>
<td>
<p> var[Y(t) | Y(1,1:T)=y(1,1:T)] (n x n x T array). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.EytT</code></td>
<td>
<p> var_X[E_Y[Y(t) | Y(1,1:T)=y(1,1:T), X(t)=x(t)]] (n x n x T array). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ott1</code></td>
<td>
<p>  E[Y(t) t(Y(t)) | Y(1,1:t-1)=y(1,1:t-1)] (n x n x T array). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.ytt1</code></td>
<td>
<p> var[Y(t) | Y(1,1:t-1)=y(1,1:t-1)] (n x n x T array). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.Eytt1</code></td>
<td>
<p> var_X[E_Y[Y(t) | Y(1,1:t-1)=y(1,1:t-1), X(t)=x(t)]] (n x n x T array). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ott</code></td>
<td>
<p> E[Y(t) t(Y(t)) | Y(1,1:t)=y(1,1:t)] (n x n x T array). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yxtT</code></td>
<td>
<p> E[Y(t) t(X(t)) | Y(1,1:T)=y(1,1:T)] (n x m x T array). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yxtt1T</code></td>
<td>
<p> E[Y(t) t(X(t-1)) | Y(1,1:T)=y(1,1:T)] (n x m x T array). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yxttpT</code></td>
<td>
<p> E[Y(t) t(X(t+1)) | Y(1,1:T)=y(1,1:T)] (n x m x T array). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errors</code></td>
<td>
<p> Any error messages due to ill-conditioned matrices. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ok</code></td>
<td>
<p> (TRUE/FALSE) Whether errors were generated. </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

<p>Holmes, E. E. (2012) Derivation of the EM algorithm for constrained and unconstrained multivariate autoregressive state-space (MARSS) models. Technical report. arXiv:1302.3919 [stat.ME] Type <code>RShowDoc("EMDerivation",package="MARSS")</code> to open a copy. See the section on 'Computing the expectations in the update equations' and the subsections on expectations involving Y. 
</p>


<h3>See Also</h3>

 
<p><code>MARSS()</code>, <code>marssMODEL</code>, <code>MARSSkem()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">dat &lt;- t(harborSeal)
dat &lt;- dat[2:3, ]
fit &lt;- MARSS(dat)
EyList &lt;- MARSShatyt(fit)
</code></pre>


</div>