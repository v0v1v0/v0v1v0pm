<div class="container">

<table style="width: 100%;"><tr>
<td>MARSShessian</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Parameter Variance-Covariance Matrix from the Hessian Matrix</h2>

<h3>Description</h3>

<p>Calculates an approximate parameter variance-covariance matrix for the parameters using an inverse of the Hessian of the negative log-likelihood function at the MLEs (the observed Fisher Information matrix).   It appends <code>$Hessian</code>, <code>$parMean</code>, <code>$parSigma</code> to the <code>marssMLE</code> object. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">MARSShessian(MLEobj, method=c("Harvey1989", "fdHess", "optim"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>MLEobj</code></td>
<td>
<p> An object of class <code>marssMLE</code>. 
This object must have a <code>$par</code> element containing MLE parameter estimates from e.g. <code>MARSSkem</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> The method to use for computing the Hessian. Options are <code>Harvey1989</code> to use the Harvey (1989) recursion, which is an analytical solution, <code>fdHess</code> or <code>optim</code> which are two numerical methods.  Although <code>optim</code> can be passed to this function, in the internal functions which call this function, <code>fdHess</code> will be used if a numerical estimate is requested.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <code>MARSSFisherI</code> for a discussion of the observed Fisher Information matrix and references.
</p>
<p>Method <code>fdHess</code> uses <code>fdHess</code> from package nlme to numerically estimate the Hessian matrix (the matrix of partial 2nd derivatives of the negative log-likelihood function at the MLE).     Method <code>optim</code> uses <code>optim</code> with <code>hessian=TRUE</code> and <code>list(maxit=0)</code> to ensure that the Hessian is computed at the values in the <code>par</code> element of the MLE object. Method <code>Harvey1989</code> (the default) uses the recursion in Harvey (1989) to compute the observed Fisher Information of a MARSS model analytically.
</p>
<p>Note that the parameter confidence intervals computed with the observed Fisher Information matrix are based on the asymptotic normality of maximum-likelihood estimates under a large-sample approximation. 
</p>


<h3>Value</h3>

<p><code>MARSShessian()</code> attaches 
<code>Hessian</code>, <code>parMean</code> and <code>parSigma</code> to the <code>marssMLE</code> object that is passed into the function.
</p>


<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

 
<p>Harvey, A. C. (1989) Section 3.4.5 (Information matrix) in Forecasting, structural time series models and the Kalman filter. Cambridge University Press, Cambridge, UK.
</p>
<p>See also J. E. Cavanaugh and R. H. Shumway (1996) On computing the expected Fisher information matrix for state-space model parameters. Statistics &amp; Probability Letters 26: 347-355.  This paper discusses the Harvey (1989) recursion (and proposes an alternative).
</p>


<h3>See Also</h3>

 <p><code>MARSSFisherI()</code>, <code>MARSSharveyobsFI()</code>, <code>MARSShessian.numerical()</code>, <code>MARSSparamCIs()</code>, <code>marssMLE</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">dat &lt;- t(harborSeal)
dat &lt;- dat[c(2, 11), ]
MLEobj &lt;- MARSS(dat)
MLEobj.hessian &lt;- MARSShessian(MLEobj)

# show the approx Hessian
MLEobj.hessian$Hessian

# generate a parameter sample using the Hessian
# this uses the rmvnorm function in the mvtnorm package
hess.params &lt;- mvtnorm::rmvnorm(1,
  mean = MLEobj.hessian$parMean,
  sigma = MLEobj.hessian$parSigma
)
</code></pre>


</div>