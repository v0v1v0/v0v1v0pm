<div class="container">

<table style="width: 100%;"><tr>
<td>MARSSoptim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parameter estimation for MARSS models using optim</h2>

<h3>Description</h3>

<p>Parameter estimation for MARSS models using R's <code>optim()</code> function.   This allows access to R's quasi-Newton algorithms available in that function.  The <code>MARSSoptim()</code> function is called when <code>MARSS()</code> is called with <code>method="BFGS"</code>.  This is an internal function in the <code>MARSS-package</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">MARSSoptim(MLEobj)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>MLEobj</code></td>
<td>
<p>An object of class <code>marssMLE</code>.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Objects of class <code>marssMLE</code> may be built from scratch but are easier to construct using <code>MARSS()</code> called with <code>MARSS(..., fit=FALSE, method="BFGS")</code>.
</p>
<p>Options for <code>optim()</code> are passed in using <code>MLEobj$control</code>.  See <code>optim()</code> for a list of that function's control options.  If <code>lower</code> and <code>upper</code> for <code>optim()</code> need to be passed in, they should be passed in as part of <code>control</code> as <code>control$lower</code> and <code>control$upper</code>. Additional <code>control</code> arguments affect printing and initial conditions.
</p>

<dl>
<dt><code>MLEobj$control$kf.x0</code></dt>
<dd>
<p> The initial condition is at $t=0$ if kf.x0="x00".  The initial condition is at $t=1$ if kf.x0="x10". </p>
</dd>    
<dt><code>MLEobj$marss$diffuse</code></dt>
<dd>
<p> If diffuse=TRUE, a diffuse initial condition is used. MLEobj$par$V0 is then the scaling function for the diffuse part of the prior.  Thus the prior is V0*kappa where kappaâ€“&gt;Inf.  Note that setting a diffuse prior does not change the correlation structure within the prior. If diffuse=FALSE, a non-diffuse prior is used and MLEobj$par$V0 is the non-diffuse prior variance on the initial states. The the prior is V0.</p>
</dd>      <dt><code>MLEobj$control$silent</code></dt>
<dd>
<p> Suppresses printing of progress bars, error messages, warnings and convergence information. </p>
</dd>    
</dl>
<h3>Value</h3>

<p>The <code>marssMLE</code> object which was passed in, with additional components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>String "BFGS".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kf</code></td>
<td>
<p>Kalman filter output. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.record</code></td>
<td>
<p>If <code>MLEobj$control$trace = TRUE</code>, then this is the <code>$message</code> value from <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numIter</code></td>
<td>
<p>Number of iterations needed for convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p> Did estimation converge successfully? 
</p>

<dl>
<dt>convergence=0</dt>
<dd>
<p> Converged in less than <code>MLEobj$control$maxit</code> iterations and no evidence of degenerate solution. </p>
</dd> 
<dt>convergence=3</dt>
<dd>
<p> No convergence diagnostics were computed because all parameters were fixed thus no fitting required. </p>
</dd>   
<dt>convergence=-1</dt>
<dd>
<p> No convergence diagnostics were computed because the MLE object was not fit (called with fit=FALSE). This isn't a convergence error just information. There is not par element so no functions can be run with the object. </p>
</dd>  
<dt>convergence=1</dt>
<dd>
<p> Maximum number of iterations <code>MLEobj$control$maxit</code> was reached before <code>MLEobj$control$abstol</code> condition was satisfied. </p>
</dd> 
<dt>convergence=10</dt>
<dd>
<p> Some of the variance elements appear to be degenerate. </p>
</dd> 
<dt>convergence=52</dt>
<dd>
<p> The algorithm was abandoned due to errors from the "L-BFGS-B" method.  </p>
</dd> 
<dt>convergence=53</dt>
<dd>
<p> The algorithm was abandoned due to numerical errors in the likelihood calculation from <code>MARSSkf</code>.  If this happens with "BFGS", it can sometimes be helped with a better initial condition.  Try using the EM algorithm first (<code>method="kem"</code>), and then using the parameter estimates from that to as initial conditions for <code>method="BFGS"</code>.  </p>
</dd> 
<dt>convergence=54</dt>
<dd>
<p> The algorithm successfully fit the model but the Kalman filter/smoother could not be run on the model. Consult <code>MARSSinfo('optimerror54')</code> for insight.  </p>
</dd> 
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logLik</code></td>
<td>
<p>Log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>states</code></td>
<td>
<p>State estimates from the Kalman smoother.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>states.se</code></td>
<td>
<p>Confidence intervals based on state standard errors, see caption of Fig 6.3 (p. 337) in Shumway &amp; Stoffer (2006).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errors</code></td>
<td>
<p>Any error messages.</p>
</td>
</tr>
</table>
<h3>Discussion</h3>

<p>The function only returns parameter estimates.  To compute CIs, use <code>MARSSparamCIs</code> but if you use parametric or non-parametric bootstrapping with this function, it will use the EM algorithm to compute the bootstrap parameter estimates!  The quasi-Newton estimates are too fragile for the bootstrap routine since one often needs to search to find a set of initial conditions that work (i.e. don't lead to numerical errors).
</p>
<p>Estimates from <code>MARSSoptim</code> (which come from <code>optim</code>) should be checked against estimates from the EM algorithm.  If the quasi-Newton algorithm works, it will tend to find parameters with higher likelihood faster than the EM algorithm.  However, the MARSS likelihood surface can be multimodal with sharp peaks at degenerate solutions where a <code class="reqn">\mathbf{Q}</code> or <code class="reqn">\mathbf{R}</code> diagonal element equals 0.  The quasi-Newton algorithm sometimes gets stuck on these peaks even when they are not the maximum.  Neither an initial conditions search nor starting near the known maximum (or from the parameters estimates after the EM algorithm) will necessarily solve this problem.   Thus it is wise to check against EM estimates to ensure that the BFGS estimates are close to the MLE estimates (and vis-a-versa, it's wise to rerun with method="BFGS" after using method="kem").  Conversely, if there is a strong flat ridge in your likelihood, the EM algorithm can report early convergence while the BFGS may continue much further along the ridge and find very different parameter values.  Of course a likelihood surface with strong flat ridges makes the MLEs less informative...
</p>
<p>Note this is mainly a problem if the time series are short or very gappy.  If the time series are long, then the likelihood surface should be nice with a single interior peak.  In this case, the quasi-Newton algorithm works well but it can still be sensitive (and slow) if not started with a good initial condition.  Thus starting it with the estimates from the EM algorithm is often desirable.
</p>
<p>One should be aware that the prior set on the variance of the initial states at t=0  or t=1 can have catastrophic effects on one's estimates if the presumed prior covariance structure conflicts with the structure implied by the MARSS model.  For example, if you use a diagonal variance-covariance matrix for the prior but the model implies a variance-covariance matrix with non-zero covariances, your MLE estimates can be strongly influenced by the prior variance-covariance matrix.  Setting a diffuse prior does not help because the diffuse prior still has the correlation structure specified by V0.  One way to detect priors effects is to compare the BFGS estimates to the EM estimates.  Persistent differences typically signify a problem with the correlation structure in the prior conflicting with the implied correlation structure in the MARSS model. 
</p>


<h3>Author(s)</h3>

<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>See Also</h3>

  <p><code>MARSS()</code>, <code>MARSSkem()</code>,  <code>marssMLE()</code>,  <code>optim()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">dat &lt;- t(harborSealWA)
dat &lt;- dat[2:4, ] # remove the year row

# fit a model with EM and then use that fit as the start for BFGS
# fit a model with 1 hidden state where obs errors are iid
# R="diagonal and equal" is the default so not specified
# Q is fixed
kemfit &lt;- MARSS(dat, model = list(Z = matrix(1, 3, 1), Q = matrix(.01)))
bfgsfit &lt;- MARSS(dat,
  model = list(Z = matrix(1, 3, 1), Q = matrix(.01)),
  inits = coef(kemfit, form = "marss"), method = "BFGS"
)
</code></pre>


</div>