<div class="container">

<table style="width: 100%;"><tr>
<td>MARSSresiduals</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> MARSS Residuals </h2>

<h3>Description</h3>

<p>The normal residuals function is <code>residuals()</code>. <code>MARSSresiduals()</code> returns residuals as a list of matrices while <code>residuals()</code> returns the same information in a data frame.  This function calculates the residuals, residuals variance, and standardized residuals for the one-step-ahead (conditioned on data up to <code class="reqn">t-1</code>), the smoothed (conditioned on all the data), and contemporaneous (conditioned on data up to <code class="reqn">t</code>) residuals.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MARSSresiduals(object, ..., type = c("tT", "tt1", "tt"), 
    normalize = FALSE, silent = FALSE, 
    fun.kf = c("MARSSkfas", "MARSSkfss"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> An object of class <code>marssMLE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Additional arguments to be passed to the residuals functions. For type="tT", <code>Harvey=TRUE</code> can be passed into to use the Harvey et al (1998) algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
 <p><code>"tT"</code> for smoothed residuals conditioned on all the data <code class="reqn">t=1</code> to <code class="reqn">T</code>, aka smoothation residuals. <code>"tt1"</code> for one-step-ahead residuals, aka innovations residuals. <code>"tt"</code> for contemporaneous residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p> TRUE/FALSE See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p> If TRUE, do not print inversion warnings. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.kf</code></td>
<td>
<p> Kalman filter function to use. Can be ignored. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For smoothed residuals, see <code>MARSSresiduals.tT()</code>.
</p>
<p>For one-step-ahead residuals, see <code>MARSSresiduals.tt1()</code>.
</p>
<p>For contemporaneous residuals, see <code>MARSSresiduals.tt()</code>.
</p>
<p><strong>Standardized residuals</strong>
</p>
<p>Standardized residuals have been adjusted by the variance of the residuals at time <code class="reqn">t</code> such that the variance of the residuals at time <code class="reqn">t</code> equals 1. Given the normality assumption, this means that one typically sees +/- 2 confidence interval lines on standardized residuals plots. 
</p>
<p><code>std.residuals</code> are Cholesky standardized residuals. These are the residuals multiplied by the inverse of the lower triangle of the Cholesky decomposition of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Sigma}_t^{-1/2} \hat{\mathbf{v}}_t.</code>
</p>

<p>These residuals are uncorrelated with each other, although they are not necessarily temporally uncorrelated (innovations residuals are temporally uncorrelated). 
</p>
<p>The interpretation of the Cholesky standardized residuals is not straight-forward when the <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code> variance-covariance matrices are non-diagonal.  The residuals which were generated by a non-diagonal variance-covariance matrices are transformed into orthogonal residuals in <code class="reqn">\textrm{MVN}(0,\mathbf{I})</code> space.  For example, if v is 2x2 correlated errors with variance-covariance matrix <code class="reqn">\mathbf{R}</code>. The transformed residuals (from this function) for the i-th row of v is a combination of the row 1 effect and the row 1 effect plus the row 2 effect.  So in this case, row 2 of the transformed residuals would not be regarded as solely the row 2 residual but rather how different row 2 is from row 1, relative to expected.  If the errors are highly correlated, then the Cholesky standardized residuals can look rather non-intuitive.
</p>
<p><code>mar.residuals</code> are the marginal standardized residuals. These are the residuals multiplied by the inverse of the diagonal matrix formed from the square-root of the diagonal of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \textrm{dg}(\hat{\Sigma}_t)^{-1/2} \hat{\mathbf{v}}_t,</code>
</p>
<p> where <code class="reqn">dg(A)</code> is the square matrix formed from the diagonal of <code class="reqn">A</code>, aka <code>diag(diag(A))</code>. These residuals will be correlated if the variance matrix is non-diagonal. 
</p>
<p>The Block Cholesky standardized residuals are like the Cholesky standardized residuals except that the full variance-covariance matrix is not used, only the variance-covariance matrix for the model or state residuals (respectively) is used for standardization. For the model residuals, the Block Cholesky standardized residuals will be the same as the Cholesky standardized residuals because the upper triangle of the lower triangle of the Cholesky decomposition (which is what we standardize by) is all zero. For <code>type="tt1"</code> and <code>type="tt"</code>, the Block Cholesky standardized state residuals will be the same as the Cholesky standardized state residuals because in the former, the model and state residuals are uncorrelated and in the latter, the state residuals do not exist. For <code>type="tT"</code>, the model and state residuals are correlated and the Block Cholesky standardized residuals will be different than the Cholesky standardized residuals.
</p>
<p><strong>Normalized residuals</strong>
</p>
<p>If <code>normalize=FALSE</code>, the unconditional variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> are <code class="reqn">\mathbf{R}</code> and <code class="reqn">\mathbf{Q}</code> and the model is assumed to be written as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{w}_t</code>
</p>

<p>If <code>normalize=TRUE</code>, the model is assumed to be written as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{H}\mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{G}\mathbf{w}_t</code>
</p>

<p>with the variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> equal to <code class="reqn">\mathbf{I}</code> (identity).
</p>
<p><strong>Missing or left-out data</strong>
</p>
<p>See the discussion of residuals for missing and left-out data in <code>MARSSresiduals.tT()</code>.
</p>


<h3>Value</h3>

<p>A list of the following components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>model.residuals</code></td>
<td>
<p> The model residuals (data minus model predicted values) as a n x T matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state.residuals</code></td>
<td>
<p> The  state residuals. This is the state residual for the transition from <code class="reqn">t=t</code> to <code class="reqn">t+1</code> thus the last time step will be NA (since <code class="reqn">T+1</code> is past the data). State residuals do not exist for the <code>type="tt"</code> case (since this would required the expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on data to <code class="reqn">t+1</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p> The residuals as a (n+m) x T matrix with <code>model.residuals</code> on top and <code>state.residuals</code> below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.residuals</code></td>
<td>
<p> The variance of the model residuals and state residuals as a (n+m) x (n+m) x T matrix with the model residuals variance in rows/columns 1 to n and state residuals variances in rows/columns n+1 to n+m. The last time step will be all NA since the state residual is for <code class="reqn">t=t </code> to <code class="reqn">t+1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.residuals</code></td>
<td>
<p> The Cholesky standardized residuals as a (n+m) x T matrix. This is <code>residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mar.residuals</code></td>
<td>
<p> The marginal standardized residuals as a (n+m) x T matrix. This is <code>residuals</code> multiplied by the inverse of the diagonal matrix formed by the square-root of the diagonal of <code>var.residuals</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bchol.residuals</code></td>
<td>
<p> The Block Cholesky standardized residuals as a (n+m) x T matrix. This is <code>model.residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals[1:n,1:n,]</code> and <code>state.residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals[(n+1):(n+m),(n+1):(n+m),]</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E.obs.residuals</code></td>
<td>
<p> The expected value of the model residuals conditioned on the observed data. Returned as a n x T matrix.  For observed data, this will be the observed model residuals. For unobserved data, this will be 0 if <code class="reqn">\mathbf{R}</code> is diagonal but non-zero if <code class="reqn">\mathbf{R}</code> is non-diagonal. See <code>MARSSresiduals.tT()</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.obs.residuals</code></td>
<td>
<p> The variance of the model residuals conditioned on the observed data. Returned as a n x n x T matrix.  For observed data, this will be 0. See <code>MARSSresiduals.tT()</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msg</code></td>
<td>
<p> Any warning messages. This will be printed unless Object$control$trace = -1 (suppress all error messages). </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

<p>Holmes, E. E. 2014. Computation of standardized residuals for (MARSS) models. Technical Report. arXiv:1411.0045.
</p>
<p>See also the discussion and references in <code>MARSSresiduals.tT()</code>,  <code>MARSSresiduals.tt1()</code> and <code>MARSSresiduals.tt()</code>.
</p>


<h3>See Also</h3>

 <p><code>residuals.marssMLE()</code>, <code>MARSSresiduals.tT()</code>, <code>MARSSresiduals.tt1()</code>, <code>plot.marssMLE()</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">  dat &lt;- t(harborSeal)
  dat &lt;- dat[c(2,11),]
  fit &lt;- MARSS(dat)
  
  #state smoothed residuals
  state.resids1 &lt;- MARSSresiduals(fit, type="tT")$state.residuals
  #this is the same as
  states &lt;- fit$states
  Q &lt;- coef(fit, type="matrix")$Q
  state.resids2 &lt;- states[,2:30]-states[,1:29]-matrix(coef(fit,type="matrix")$U,2,29)
  #compare the two
  cbind(t(state.resids1[,-30]), t(state.resids2))

  #normalize to variance of 1
  state.resids1 &lt;- MARSSresiduals(fit, type="tT", normalize=TRUE)$state.residuals
  state.resids2 &lt;- (solve(t(chol(Q))) %*% state.resids2)
  cbind(t(state.resids1[,-30]), t(state.resids2))

  #one-step-ahead standardized residuals
  MARSSresiduals(fit, type="tt1")$std.residuals
</code></pre>


</div>