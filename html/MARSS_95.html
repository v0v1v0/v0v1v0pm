<div class="container">

<table style="width: 100%;"><tr>
<td>MARSSresiduals.tt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> MARSS Contemporaneous Residuals </h2>

<h3>Description</h3>

<p>Calculates the standardized (or auxiliary) contemporaneous residuals, aka the residuals and their variance conditioned on the data up to time <code class="reqn">t</code>.  Contemporaneous residuals are only for the observations. Not exported. Access this function with <code>MARSSresiduals(object, type="tt")</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MARSSresiduals.tt(object, method = c("SS"), normalize = FALSE, 
    silent = FALSE, fun.kf = c("MARSSkfas", "MARSSkfss"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> An object of class <code>marssMLE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> Algorithm to use. Currently only "SS". </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p> TRUE/FALSE See details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p> If TRUE, don't print inversion warnings. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.kf</code></td>
<td>
<p> Can be ignored. This will change the Kalman filter/smoother function from the value in object$fun.kf if desired. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function returns the conditional expected value (mean) and variance of the model contemporaneous residuals.  'conditional' means in this context, conditioned on the observed data up to time <code class="reqn">t</code> and a set of parameters.  
</p>
<p><strong>Model residuals</strong>
</p>
<p><code class="reqn">\mathbf{v}_t</code> is the difference between the data and the predicted data at time <code class="reqn">t</code> given <code class="reqn">\mathbf{x}_t</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{v}_t = \mathbf{y}_t - \mathbf{Z} \mathbf{x}_t - \mathbf{a} - \mathbf{d}\mathbf{d}_{t}</code>
</p>

<p>The observed model residuals <code class="reqn">\hat{\mathbf{v}}_t</code> are the difference between the observed data and the predicted data at time <code class="reqn">t</code> using the fitted model. <code>MARSSresiduals.tt</code> fits the model using the data up to time <code class="reqn">t</code>. So
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{v}}_t = \mathbf{y}_t - \mathbf{Z}\mathbf{x}_t^{t} - \mathbf{a} - \mathbf{D}\mathbf{d}_{t}</code>
</p>

<p>where <code class="reqn">\mathbf{x}_t^{t}</code> is the expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on the data from 1 to <code class="reqn">t</code> from the Kalman filter. <code class="reqn">\mathbf{y}_t</code> are your data and missing values will appear as NA. These will be returned in <code>residuals</code>.
</p>
<p><code>var.residuals</code> returned by the function is the conditional variance of the residuals conditioned on the data up to <code class="reqn">t</code> and the parameter set <code class="reqn">\Theta</code>.  The conditional variance is 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Sigma}_t = \mathbf{R}+\mathbf{Z} \mathbf{V}_t^{t} \mathbf{Z}^\top </code>
</p>

<p>where <code class="reqn">\mathbf{V}_t^{t}</code> is the variance of <code class="reqn">\mathbf{X}_t</code> conditioned on the data up to time <code class="reqn">t</code>. This is returned by <code>MARSSkfss</code> in <code>Vtt</code>.
</p>
<p><strong>Standardized residuals</strong>
</p>
<p><code>std.residuals</code> are Cholesky standardized residuals. These are the residuals multiplied by the inverse of the lower triangle of the Cholesky decomposition of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Sigma}_t^{-1/2} \hat{\mathbf{v}}_t</code>
</p>
<p>.
These residuals are uncorrelated unlike marginal residuals. 
</p>
<p>The interpretation of the Cholesky standardized residuals is not straight-forward when the <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code> variance-covariance matrices are non-diagonal.  The residuals which were generated by a non-diagonal variance-covariance matrices are transformed into orthogonal residuals in <code class="reqn">\textrm{MVN}(0,\mathbf{I})</code> space.  For example, if v is 2x2 correlated errors with variance-covariance matrix R. The transformed residuals (from this function) for the i-th row of v is a combination of the row 1 effect and the row 1 effect plus the row 2 effect.  So in this case, row 2 of the transformed residuals would not be regarded as solely the row 2 residual but rather how different row 2 is from row 1, relative to expected.  If the errors are highly correlated, then the Cholesky standardized residuals can look rather non-intuitive.
</p>
<p><code>mar.residuals</code> are the marginal standardized residuals. These are the residuals multiplied by the inverse of the diagonal matrix formed from the square-root of the diagonal of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \textrm{dg}(\hat{\Sigma}_t)^{-1/2} \hat{\mathbf{v}}_t</code>
</p>
<p>, where 'dg(A)' is the square matrix formed from the diagonal of A, aka <code>diag(diag(A))</code>. These residuals will be correlated if the variance matrix is non-diagonal. 
</p>
<p><strong>Normalized residuals</strong>
</p>
<p>If <code>normalize=FALSE</code>, the unconditional variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> are <code class="reqn">\mathbf{R}</code> and <code class="reqn">\mathbf{Q}</code> and the model is assumed to be written as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{w}_t</code>
</p>

<p>If normalize=TRUE, the model is assumed to be written
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{H}\mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{G}\mathbf{w}_t</code>
</p>

<p>with the variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> equal to <code class="reqn">\mathbf{I}</code> (identity).
</p>
<p><code>MARSSresiduals()</code> returns the residuals defined as in the first equations. To get normalized residuals (second equation) as used in Harvey et al. (1998), then use <code>normalize=TRUE</code>.  In that case the unconditional variance of residuals will be <code class="reqn">\mathbf{I}</code> instead of <code class="reqn">\mathbf{R}</code> and <code class="reqn">\mathbf{Q}</code>.  Note, that the normalized residuals are not the same as the standardized residuals.  In former, the unconditional residuals have a variance of <code class="reqn">\mathbf{I}</code> while in the latter it is the conditional residuals that have a variance of <code class="reqn">\mathbf{I}</code>.
</p>


<h3>Value</h3>

<p>A list with the following components  
</p>
<table>
<tr style="vertical-align: top;">
<td><code>model.residuals</code></td>
<td>
<p> The observed contemporaneous model residuals: data minus the model predictions conditioned on the data 1 to t. A n x T matrix. NAs will appear where the data are missing. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state.residuals</code></td>
<td>
<p> All NA. There are no contemporaneous residuals for the states. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p> The residuals. <code>model.residuals</code> are in rows 1:n and <code>state.residuals</code> are in rows n+1:n+m. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.residuals</code></td>
<td>
<p> The joint variance of the residuals conditioned on observed data from 1 to t-. This only has values in the 1:n,1:n upper block for the model residuals. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.residuals</code></td>
<td>
<p> The Cholesky standardized residuals as a n+m x T matrix. This is <code>residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals</code>. The model standardized residuals associated with the missing data are replaced with NA. Note because the contemporaneous state residuals do not exist, rows n+1:n+m are all NA. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mar.residuals</code></td>
<td>
<p> The marginal standardized residuals as a n+m x T matrix. This is <code>residuals</code> multiplied by the inverse of the diagonal matrix formed by the square-root of the diagonal of <code>var.residuals</code>.  The model marginal residuals associated with the missing data are replaced with NA. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bchol.residuals</code></td>
<td>
<p> Because state residuals do not exist, this will be equivalent to the Cholesky standardized residuals, <code>std.residuals</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E.obs.residuals</code></td>
<td>
<p> The expected value of the model residuals conditioned on the observed data 1 to t. Returned as a n x T matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.obs.residuals</code></td>
<td>
<p> The variance of the model residuals conditioned on the observed data. Returned as a n x n x T matrix.  For observed data, this will be 0. See  <code>MARSSresiduals.tT()</code> for a discussion of these residuals and where they might be used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msg</code></td>
<td>
<p> Any warning messages. This will be printed unless Object$control$trace = -1 (suppress all error messages). </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

<p>Holmes, E. E. 2014. Computation of standardized residuals for (MARSS) models. Technical Report. arXiv:1411.0045. 
</p>


<h3>See Also</h3>

 <p><code>MARSSresiduals.tT()</code>, <code>MARSSresiduals.tt1()</code>, <code>fitted.marssMLE()</code>, <code>plot.marssMLE()</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">  dat &lt;- t(harborSeal)
  dat &lt;- dat[c(2,11),]
  fit &lt;- MARSS(dat)
  
  # Returns a matrix
  MARSSresiduals(fit, type="tt")$std.residuals
  # Returns a data frame in long form
  residuals(fit, type="tt")
</code></pre>


</div>