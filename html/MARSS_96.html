<div class="container">

<table style="width: 100%;"><tr>
<td>MARSSresiduals.tt1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> MARSS One-Step-Ahead Residuals </h2>

<h3>Description</h3>

<p>Calculates the standardized (or auxiliary) one-step-ahead residuals, aka the innovations residuals and their variance.  Not exported. Access this function with <code>MARSSresiduals(object, type="tt1")</code>. To get the residuals as a data frame in long-form, use <code>residuals(object, type="tt1")</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MARSSresiduals.tt1(object, method = c("SS"), normalize = FALSE, 
    silent = FALSE, fun.kf = c("MARSSkfas", "MARSSkfss"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> An object of class <code>marssMLE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> Algorithm to use. Currently only "SS". </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p> TRUE/FALSE See details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p> If TRUE, don't print inversion warnings. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.kf</code></td>
<td>
<p> Can be ignored. This will change the Kalman filter/smoother function from the value in object$fun.kf if desired. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function returns the conditional expected value (mean) and variance of the one-step-ahead residuals.  'conditional' means in this context, conditioned on the observed data up to time <code class="reqn">t-1</code> and a set of parameters.  
</p>
<p><strong>Model residuals</strong>
</p>
<p><code class="reqn">\mathbf{v}_t</code> is the difference between the data and the predicted data at time <code class="reqn">t</code> given <code class="reqn">\mathbf{x}_t</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{v}_t = \mathbf{y}_t - \mathbf{Z} \mathbf{x}_t - \mathbf{a} - \mathbf{D}\mathbf{d}_t</code>
</p>

<p>The observed model residuals <code class="reqn">\hat{\mathbf{v}}_t</code> are the difference between the observed data and the predicted data at time <code class="reqn">t</code> using the fitted model. <code>MARSSresiduals.tt1</code> fits the model using the data up to time <code class="reqn">t-1</code>. So
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{v}}_t = \mathbf{y}_t - \mathbf{Z}\mathbf{x}_t^{t-1} - \mathbf{a}  - \mathbf{D}\mathbf{d}_t</code>
</p>

<p>where <code class="reqn">\mathbf{x}_t^{t-1}</code> is the expected value of <code class="reqn">\mathbf{X}_t</code> conditioned on the data from $t=1$ to <code class="reqn">t-1</code> from the Kalman filter. <code class="reqn">\mathbf{y}_t</code> are your data and missing values will appear as NA. 
</p>
<p><strong>State residuals</strong>
</p>
<p><code class="reqn">\mathbf{w}_{t+1}</code> are the difference between the state at time <code class="reqn">t+1</code> and the expected value of the state at time <code class="reqn">t+1</code> given the state at time <code class="reqn">t</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{w}_{t+1} = \mathbf{x}_{t+1} - \mathbf{B} \mathbf{x}_{t} - \mathbf{u}  - \mathbf{C}\mathbf{c}_{t+1}</code>
</p>

<p>The estimated state residuals <code class="reqn">\hat{\mathbf{w}}_{t+1}</code> are the difference between estimate of <code class="reqn">\mathbf{x}_{t+1}</code> minus the estimate using <code class="reqn">\mathbf{x}_{t}</code>. 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\mathbf{w}}_{t+1} = \mathbf{x}_{t+1}^{t+1} - \mathbf{B}\mathbf{x}_{t}^t - \mathbf{u} - \mathbf{C}\mathbf{c}_{t+1}</code>
</p>

<p>where <code class="reqn">\mathbf{x}_{t+1}^{t+1}</code> is the Kalman filter estimate of the states at time <code class="reqn">t+1</code> conditioned on the data up to time <code class="reqn">t+1</code> and <code class="reqn">\mathbf{x}_{t}^t</code> is the Kalman filter estimate of the states at time <code class="reqn">t</code> conditioned on the data up to time <code class="reqn">t</code>.
The estimated state residuals <code class="reqn">\mathbf{w}_{t+1}</code> are returned in <code>state.residuals</code> and rows <code class="reqn">n+1</code> to <code class="reqn">n+m</code> of <code>residuals</code>. <code>state.residuals[,t]</code> is <code class="reqn">\mathbf{w}_{t+1}</code> (notice time subscript difference). There are no NAs in the estimated state residuals (except for the last time step) as an estimate of the state exists whether or not there are associated data.
</p>
<p><code>res1</code> and <code>res2</code> in the code below will be the same.
</p>
<pre>dat &lt;- t(harborSeal)[2:3,]
TT &lt;- ncol(dat)
fit &lt;- MARSS(dat)
B &lt;- coef(fit, type="matrix")$B
U &lt;- coef(fit, type="matrix")$U
xt &lt;- MARSSkfss(fit)$xtt[,1:(TT-1)] # t 1 to TT-1
xtp1 &lt;- MARSSkfss(fit)$xtt[,2:TT] # t 2 to TT
res1 &lt;- xtp1 - B %*% xt - U %*% matrix(1,1,TT-1)
res2 &lt;- MARSSresiduals(fit, type="tt1")$state.residuals
</pre>
<p><strong>Joint residual variance</strong>
</p>
<p>In a state-space model, <code class="reqn">\mathbf{X}</code> and <code class="reqn">\mathbf{Y}</code> are stochastic, and the model and state residuals are random variables <code class="reqn">\hat{\mathbf{V}}_t</code> and <code class="reqn">\hat{\mathbf{W}}_{t+1}</code>. The joint distribution of <code class="reqn">\hat{\mathbf{V}}_{t}, \hat{\mathbf{W}}_{t+1}</code> is the distribution across all the different possible data sets that our MARSS equations with parameters <code class="reqn">\Theta</code> might generate. Denote the matrix of <code class="reqn">\hat{\mathbf{V}}_{t}, \hat{\mathbf{W}}_{t+1}</code>, as <code class="reqn">\widehat{\mathcal{E}}_{t}</code>. That distribution has an expected value (mean) and variance:
</p>
<p style="text-align: center;"><code class="reqn"> \textrm{E}[\widehat{\mathcal{E}}_t] = 0; \textrm{var}[\widehat{\mathcal{E}}_t] = \hat{\Sigma}_t </code>
</p>

<p>Our observed residuals <code>residuals</code> are one sample from this distribution.
To standardize the observed residuals, we will use <code class="reqn"> \hat{\Sigma}_t </code>. <code class="reqn"> \hat{\Sigma}_t </code> is returned in <code>var.residuals</code>. Rows/columns 1 to <code class="reqn">n</code> are the conditional variances of the model residuals and rows/columns <code class="reqn">n+1</code> to <code class="reqn">n+m</code> are the conditional variances of the state residuals. The off-diagonal blocks are the covariances between the two types of residuals. For one-step-ahead residuals (unlike smoothation residuals MARSSresiduals.tT), the covariance is zero.
</p>
<p><code>var.residuals</code> returned by this function is the conditional variance of the residuals conditioned on the data up to <code class="reqn">t-1</code> and the parameter set <code class="reqn">\Theta</code>.  The conditional variance for the model residuals is 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Sigma}_t = \mathbf{R}+\mathbf{Z}_t \mathbf{V}_t^{t-1} \mathbf{Z}_t^\top </code>
</p>

<p>where <code class="reqn">\mathbf{V}_t^{t-1}</code> is the variance of <code class="reqn">\mathbf{X}_t</code> conditioned on the data up to time <code class="reqn">t-1</code>. This is returned by <code>MARSSkf</code> in <code>Vtt1</code>. The innovations variance is also returned in <code>Sigma</code> from <code>MARSSkf</code> and are used in the innovations form of the likelihood calculation.
</p>
<p><strong>Standardized residuals</strong>
</p>
<p><code>std.residuals</code> are Cholesky standardized residuals. These are the residuals multiplied by the inverse of the lower triangle of the Cholesky decomposition of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\Sigma}_t^{-1/2} \hat{\mathbf{v}}_t</code>
</p>

<p>These residuals are uncorrelated unlike marginal residuals. 
</p>
<p>The interpretation of the Cholesky standardized residuals is not straight-forward when the <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code> variance-covariance matrices are non-diagonal.  The residuals which were generated by a non-diagonal variance-covariance matrices are transformed into orthogonal residuals in <code class="reqn">\textrm{MVN}(0,\mathbf{I})</code> space.  For example, if v is 2x2 correlated errors with variance-covariance matrix R. The transformed residuals (from this function) for the i-th row of v is a combination of the row 1 effect and the row 1 effect plus the row 2 effect.  So in this case, row 2 of the transformed residuals would not be regarded as solely the row 2 residual but rather how different row 2 is from row 1, relative to expected.  If the errors are highly correlated, then the Cholesky standardized residuals can look rather non-intuitive.
</p>
<p><code>mar.residuals</code> are the marginal standardized residuals. These are the residuals multiplied by the inverse of the diagonal matrix formed from the square-root of the diagonal of the variance matrix of the residuals: 
</p>
<p style="text-align: center;"><code class="reqn"> \textrm{dg}(\hat{\Sigma}_t)^{-1/2} \hat{\mathbf{v}}_t</code>
</p>
<p>, where 'dg(A)' is the square matrix formed from the diagonal of A, aka <code>diag(diag(A))</code>. These residuals will be correlated if the variance matrix is non-diagonal. 
</p>
<p>The Block Cholesky standardized residuals are like the Cholesky standardized residuals except that the full variance-covariance matrix is not used, only the variance-covariance matrix for the model or state residuals (respectively) is used for standardization. For the one-step-ahead case, the model and state residuals are independent (unlike in the smoothations case) thus the Cholesky and Block Cholesky standardized residuals will be identical (unlike in the smoothations case). 
</p>
<p><strong>Normalized residuals</strong>
</p>
<p>If <code>normalize=FALSE</code>, the unconditional variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> are <code class="reqn">\mathbf{R}</code> and <code class="reqn">\mathbf{Q}</code> and the model is assumed to be written as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{w}_t</code>
</p>

<p>If normalize=TRUE, the model is assumed to be written
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_t = \mathbf{Z} \mathbf{x}_t + \mathbf{a} + \mathbf{H}\mathbf{v}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{x}_t = \mathbf{B} \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{G}\mathbf{w}_t</code>
</p>

<p>with the variance of <code class="reqn">\mathbf{V}_t</code> and <code class="reqn">\mathbf{W}_t</code> equal to <code class="reqn">\mathbf{I}</code> (identity).
</p>
<p><code>MARSSresiduals</code> returns the residuals defined as in the first equations. To get the residuals defined as Harvey et al. (1998) define them (second equations), then use <code>normalize=TRUE</code>.  In that case the unconditional variance of residuals will be <code class="reqn">\mathbf{I}</code> instead of <code class="reqn">\mathbf{Q}</code> and <code class="reqn">\mathbf{R}</code>.  Note, that the normalized residuals are not the same as the standardized residuals.  In former, the unconditional residuals have a variance of <code class="reqn">\mathbf{I}</code> while in the latter it is the conditional residuals that have a variance of <code class="reqn">\mathbf{I}</code>.
</p>


<h3>Value</h3>

<p>A list with the following components  
</p>
<table>
<tr style="vertical-align: top;">
<td><code>model.residuals</code></td>
<td>
<p> The the observed one-step-ahead model residuals: data minus the model predictions conditioned on the data <code class="reqn">t=1</code> to <code class="reqn">t-1</code>. These are termed innovations. A n x T matrix. NAs will appear where the data are missing. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state.residuals</code></td>
<td>
<p> The one-step-ahead state residuals <code class="reqn"> \mathbf{x}_{t+1}^{t+1} - \mathbf{B}\mathbf{x}_{t}^t - \mathbf{u} </code>
. Note, state residual at time <code class="reqn">t</code> is the transition from time <code class="reqn">t=t</code> to <code class="reqn">t+1</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p> The residuals conditioned on the observed data up to time <code class="reqn">t-1</code>. Returned as a (n+m) x T matrix with <code>model.residuals</code> in rows 1 to n and <code>state.residuals</code> in rows n+1 to n+m.  NAs will appear in rows 1 to n in the places where data are missing. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.residuals</code></td>
<td>
<p> The joint variance of the one-step-ahead residuals. Returned as a n+m x n+m x T matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.residuals</code></td>
<td>
<p> The Cholesky standardized residuals as a n+m x T matrix. This is <code>residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals</code>. The model standardized residuals associated with the missing data are replaced with NA. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mar.residuals</code></td>
<td>
<p> The marginal standardized residuals as a n+m x T matrix. This is <code>residuals</code> multiplied by the inverse of the diagonal matrix formed by the square-root of the diagonal of <code>var.residuals</code>.  The model marginal residuals associated with the missing data are replaced with NA. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bchol.residuals</code></td>
<td>
<p> The Block Cholesky standardized residuals as a (n+m) x T matrix. This is <code>model.residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals[1:n,1:n,]</code> and <code>state.residuals</code> multiplied by the inverse of the lower triangle of the Cholesky decomposition of <code>var.residuals[(n+1):(n+m),(n+1):(n+m),]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E.obs.residuals</code></td>
<td>
<p> The expected value of the model residuals conditioned on the observed data <code class="reqn">t=1</code> to <code class="reqn">t-1</code>. Returned as a n x T matrix. Because all the data at time <code class="reqn">t</code> are unobserved for the purpose of estimation (since conditioning is from <code class="reqn">t=1</code> to <code class="reqn">t-1</code>), this will be all 0s (unlike the case where we condition on the data from <code class="reqn">t=1</code> to <code class="reqn">T</code> or to <code class="reqn">t</code>). This and <code>var.obs.residuals</code> are included for completeness since they are returned for <code>MARSSresiduals.tT()</code>, but they are not relevant for one-step-ahead residuals. See the discussion there. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.obs.residuals</code></td>
<td>
<p> For one-step-ahead residuals, this will be the same as the 1:n, 1:n upper diagonal block in <code>var.residuals</code> since none of the <code class="reqn">t</code> data affect the residuals at time <code class="reqn">t</code> (the model residuals are conditioned only on the data up to <code class="reqn">t-1</code>). This is different for smoothation residuals which are conditioned on the data from <code class="reqn">t=1</code> to <code class="reqn">T</code>. This and <code>E.obs.residuals</code> are included for completeness since they are returned for <code>MARSSresiduals.tT()</code>, but they are not relevant for one-step-ahead residuals. See the discussion there. Note, also included as a code check. They are computed differently, but <code>var.obs.residuals</code> and <code>var.residuals</code> should always be the same.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msg</code></td>
<td>
<p> Any warning messages. This will be printed unless <code>object$control$trace = -1</code> (suppress all error messages). </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

 
<p>Eli Holmes, NOAA, Seattle, USA.  
</p>


<h3>References</h3>

<p>R. H. Shumway and D. S. Stoffer (2006).  Section on the calculation of the likelihood of state-space models in Time series analysis and its applications.  Springer-Verlag, New York.
</p>
<p>Holmes, E. E. 2014. Computation of standardized residuals for (MARSS) models. Technical Report. arXiv:1411.0045. 
</p>


<h3>See Also</h3>

 <p><code>MARSSresiduals.tT()</code>, <code>MARSSresiduals.tt()</code>,  <code>fitted.marssMLE()</code>, <code>plot.marssMLE()</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">  dat &lt;- t(harborSeal)
  dat &lt;- dat[c(2,11),]
  fit &lt;- MARSS(dat)
  
  MARSSresiduals(fit, type="tt1")$std.residuals
  residuals(fit, type="tt1")
</code></pre>


</div>