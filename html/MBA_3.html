<div class="container">

<table style="width: 100%;"><tr>
<td>mba.surf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Surface approximation from bivariate scattered data using multilevel B-splines</h2>

<h3>Description</h3>

<p>The function <code>mba.surf</code> returns a surface approximated from a
bivariate scatter of data points using multilevel B-splines.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mba.surf(xyz, no.X, no.Y, n = 1, m = 1, h = 8, extend=FALSE,
         sp=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xyz</code></td>
<td>
<p>a <code class="reqn">n \times 3</code> matrix or data frame, where <code class="reqn">n</code> is
the number of observed points.  The three columns correspond to point x, y, and z
coordinates.  The z value is the response at the given x, y
coordinates.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.X</code></td>
<td>
<p>resolution of the approximated surface along the x axis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.Y</code></td>
<td>
<p>resolution of the approximated surface along the y axis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>initial size of the spline space in the hierarchical
construction along the x axis. If the rectangular domain is a
square, n = m = 1 is recommended. If the x axis is k times the length
of the y axis, n = 1, m = k is recommended. The default is n = 1. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>initial size of the spline space in the hierarchical
construction along the y axis. If the y axis is k times the length
of the x axis, m = 1, n = k is recommended. The default is m = 1.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Number of levels in the hierarchical construction. If, e.g.,
n = m = 1 and h = 8, the resulting spline surface has a coefficient
grid of size <code class="reqn">2^h</code> + 3 = 259 in each direction of the
spline surface. See references for additional information. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend</code></td>
<td>
<p>if FALSE, a convex hull is computed for the input points
and all matrix elements in z that have centers outside of this
polygon are set to <code>NA</code>; otherwise, all elements in z are given an
estimated z value. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sp</code></td>
<td>
<p>if TRUE, the resulting surface is returned as a
<code>SpatialPixelsDataFrame</code> object; otherwise, the surface is in
<code>image</code> format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><code>b.box</code> is an optional vector to sets the bounding
box. The vector's elements are minimum x, maximum x, minimum y, and maximum
y, respectively.  </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List with 8 component:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>xyz.est</code></td>
<td>
<p>a list that contains vectors x, y and the <code class="reqn">no.X
      \times no.Y</code> matrix z of estimated z-values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.X</code></td>
<td>
<p><code>no.X</code> from arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.Y</code></td>
<td>
<p><code>no.Y</code> from arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p><code>n</code> from arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p><code>m</code> from arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p><code>h</code> from arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend</code></td>
<td>
<p><code>extend</code> from arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sp</code></td>
<td>
<p><code>sp</code> from arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.box</code></td>
<td>
<p><code>b.box</code> defines the bounding box over which z is estimated.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>If <code>no.X != no.Y</code> then use <code>sp=TRUE</code> for compatibility with
the <code>image</code> function.
</p>
<p>The function <code>mba.surf</code> relies on the Multilevel B-spline
Approximation (MBA) algorithm.  The underlying code was developed at
SINTEF Applied Mathematics by Dr. Øyvind Hjelle.  Dr. Øyvind Hjelle
based the algorithm on the paper by the originators of Multilevel B-splines:
</p>
<p>S. Lee, G. Wolberg, and S. Y. Shin. (1997) Scattered data interpolation with
multilevel B-splines. IEEE Transactions on Visualization and Computer
Graphics, 3(3):229–244.
</p>
<p>For additional documentation and references see:
</p>
<p><a href="https://www.sintef.no/upload/IKT/9011/geometri/MBA/mba_doc/index.html">https://www.sintef.no/upload/IKT/9011/geometri/MBA/mba_doc/index.html</a>.
</p>


<h3>See Also</h3>

<p><code>mba.points</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(LIDAR)

mba.int &lt;- mba.surf(LIDAR, 300, 300, extend=TRUE)$xyz.est

# Image plot of the surface.
image(mba.int, xaxs = "r", yaxs = "r")

# Perspective plot of the surface.
persp(mba.int, theta = 135, phi = 30, col = "green3", scale = FALSE,
      ltheta = -120, shade = 0.75, expand = 10, border = NA, box = FALSE)

# For a good time, I recommend using rgl.
library(rgl)

# Exaggerate z a bit for effect.
mba.int$z &lt;- 10*mba.int$z

# Make nice colors for the rgl surface.
zlim &lt;- range(mba.int$z)
zlen &lt;- zlim[2] - zlim[1] + 1

colorlut &lt;- terrain.colors(zlen) # Height color lookup table.

col &lt;- colorlut[mba.int$z - zlim[1] + 1 ] # Assign colors to heights for each point.

open3d()
surface3d(mba.int$x, mba.int$y, mba.int$z, color = col)


## End(Not run)
</code></pre>


</div>