<div class="container">

<table style="width: 100%;"><tr>
<td>LPDMRSortInferenceExact</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Identification of profiles, weights, majority threshold and veto and
dictator thresholds for the MRSort sorting approach extended to handle large
performance differences.</h2>

<h3>Description</h3>

<p>MRSort is a simplified ElectreTRI method that uses the pessimistic
assignment rule, without indifference or preference thresholds attached to
criteria.  LPDMRSort considers both a binary discordance and a binary
concordance conditions including several interactions between them.  The
identification of the profiles, weights, majority threshold and veto and
dictator thresholds are done by taking into account assignment examples.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LPDMRSortInferenceExact(
  performanceTable,
  assignments,
  categoriesRanks,
  criteriaMinMax,
  majorityRule = "M",
  readableWeights = FALSE,
  readableProfiles = FALSE,
  minmaxLPD = FALSE,
  alternativesIDs = NULL,
  criteriaIDs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>performanceTable</code></td>
<td>
<p>Matrix or data frame containing the performance
table.  Each row corresponds to an alternative, and each column to a
criterion.  Rows (resp. columns) must be named according to the IDs of the
alternatives (resp. criteria).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assignments</code></td>
<td>
<p>Vector containing the assignments (IDs of the categories)
of the alternatives to the categories.  The elements are named according to
the alternatives.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>categoriesRanks</code></td>
<td>
<p>Vector containing the ranks of the categories.  The
elements are named according to the IDs of the categories.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteriaMinMax</code></td>
<td>
<p>Vector containing the preference direction on each of
the criteria.  "min" (resp. "max") indicates that the criterion has to be
minimized (maximized).  The elements are named according to the IDs of the
criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>majorityRule</code></td>
<td>
<p>String denoting how the vetoes and dictators are
combined in order to form the assignment rule.  The values to choose from
are "M", "V", "D", "v", "d", "dV", "Dv", "dv".  "M" corresponds to using
only the majority rule without vetoes or dictators, "V" considers only the
vetoes, "D" only the dictators, "v" is like "V" only that a dictator may
invalidate a veto, "d" is like "D" only that a veto may invalidate a
dictator, "dV" is like "V" only that if there is no veto we may then
consider the dictator, "Dv" is like "D" only that when there is no dictator
we may consider the vetoes, while finally "dv" is identical to using both
dictator and vetoes only that when both are active they invalidate each
other, so the majority rule is considered in that case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>readableWeights</code></td>
<td>
<p>Boolean parameter indicating whether the weights are
to be spaced more evenly or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>readableProfiles</code></td>
<td>
<p>Boolean parameter indicating whether the profiles
are to be spaced more evenly or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minmaxLPD</code></td>
<td>
<p>Boolean parameter indicating whether the veto thresholds
are to be minimized (or maximized if lower criteria values are preferred)
while the dictator thresholds are to be maximized (or minimized if lower
criteria values are preferred).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternativesIDs</code></td>
<td>
<p>Vector containing IDs of alternatives, according to
which the data should be filtered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteriaIDs</code></td>
<td>
<p>Vector containing IDs of criteria, according to which the
data should be filtered.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function returns a list structured as follows :
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The majority threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>A vector containing
the weights of the criteria.  The elements are named according to the
criteria IDs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>profilesPerformances</code></td>
<td>
<p>A matrix containing the lower
profiles of the categories.  The columns are named according to the
criteria, whereas the rows are named according to the categories. The lower
profile of the lower category can be considered as a dummy profile.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vetoPerformances</code></td>
<td>
<p>A matrix containing the veto profiles of the
categories.  The columns are named according to the criteria, whereas the
rows are named according to the categories. The veto profile of the lower
category can be considered as a dummy profile.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solverStatus</code></td>
<td>
<p>The
solver status as given by glpk.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Bouyssou, D. and Marchant, T. An axiomatic approach to
noncompen- satory sorting methods in MCDM, II: more than two categories.
European Journal of Operational Research, 178(1): 246â€“276, 2007.
</p>
<p>Meyer, P. and Olteanu, A-L. Integrating large positive and negative
performance differences in majority-rule sorting models.  European Journal
of Operational Research, submitted, 2015.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# the performance table

performanceTable &lt;- rbind(c(10,10,9), c(10,9,10), c(9,10,10), c(9,9,10), 
                          c(9,10,9), c(10,9,9), c(10,10,7), c(10,7,10), 
                          c(7,10,10), c(9,9,17), c(9,17,9), c(17,9,9), 
                          c(7,10,17), c(10,17,7), c(17,7,10), c(7,17,10), 
                          c(17,10,7), c(10,7,17), c(7,9,17), c(9,17,7), 
                          c(17,7,9), c(7,17,9), c(17,9,7), c(9,7,17))

rownames(performanceTable) &lt;- c("a1", "a2", "a3", "a4", "a5", "a6", "a7", 
                                "a8", "a9", "a10", "a11", "a12", "a13", 
                                "a14", "a15", "a16", "a17", "a18", "a19", 
                                "a20", "a21", "a22", "a23", "a24")

colnames(performanceTable) &lt;- c("c1","c2","c3")

categoriesRanks &lt;-c(1,2)

names(categoriesRanks) &lt;- c("P","F")

criteriaMinMax &lt;- c("max","max","max")

names(criteriaMinMax) &lt;- colnames(performanceTable)

assignments &lt;-rbind(c("P","P","P","F","F","F","F","F","F","F","F","F",
                    "F","F","F","F","F","F","F","F","F","F","F","F"), 
                    c("P","P","P","F","F","F","P","P","P","P","P","P",
                    "P","P","P","P","P","P","P","P","P","P","P","P"), 
                    c("P","P","P","F","F","F","F","F","F","F","F","F",
                    "P","P","P","P","P","P","F","F","F","F","F","F"), 
                    c("P","P","P","F","F","F","P","P","P","P","P","P",
                    "P","P","P","P","P","P","F","F","F","F","F","F"), 
                    c("P","P","P","F","F","F","F","F","F","P","P","P",
                    "F","F","F","F","F","F","F","F","F","F","F","F"), 
                    c("P","P","P","F","F","F","F","F","F","P","P","P",
                    "P","P","P","P","P","P","P","P","P","P","P","P"), 
                    c("P","P","P","F","F","F","F","F","F","P","P","P",
                    "P","P","P","P","P","P","F","F","F","F","F","F"))

colnames(assignments) &lt;- rownames(performanceTable)

majorityRules &lt;- c("V","D","v","d","dV","Dv","dv")

for(i in 1:1)# change to 7 in order to perform all tests
{
  x&lt;-LPDMRSortInferenceExact(performanceTable, assignments[i,],
                             categoriesRanks, criteriaMinMax, 
                             majorityRule = majorityRules[i], 
                             readableWeights = TRUE,
                             readableProfiles = TRUE,
                             minmaxLPD = TRUE)
  
  ElectreAssignments&lt;-LPDMRSort(performanceTable, x$profilesPerformances, 
                                categoriesRanks,
                                x$weights, criteriaMinMax, x$lambda, 
                                criteriaVetos=x$vetoPerformances, 
                                criteriaDictators=x$dictatorPerformances, 
                                majorityRule = majorityRules[i])
  
  print(x)
  
  print(all(ElectreAssignments == assignments[i,]))
}

</code></pre>


</div>