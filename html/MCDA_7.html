<div class="container">

<table style="width: 100%;"><tr>
<td>LPDMRSort</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MRSort that takes into account large performance differences.</h2>

<h3>Description</h3>

<p>MRSort is a simplified ElectreTRI method that uses the pessimistic
assignment rule, without indifference or preference thresholds attached to
criteria. LPDMRSort considers both a binary discordance and a binary
concordance conditions including several interactions between them.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LPDMRSort(
  performanceTable,
  categoriesLowerProfiles,
  categoriesRanks,
  criteriaWeights,
  criteriaMinMax,
  majorityThreshold,
  criteriaVetos = NULL,
  criteriaDictators = NULL,
  majorityRule = "M",
  alternativesIDs = NULL,
  criteriaIDs = NULL,
  categoriesIDs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>performanceTable</code></td>
<td>
<p>Matrix or data frame containing the performance
table. Each row corresponds to an alternative, and each column to a
criterion. Rows (resp. columns) must be named according to the IDs of the
alternatives (resp. criteria).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>categoriesLowerProfiles</code></td>
<td>
<p>Matrix containing, in each row, the lower
profiles of the categories. The columns are named according to the criteria,
and the rows are named according to the categories. The index of the row in
the matrix corresponds to the rank of the category.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>categoriesRanks</code></td>
<td>
<p>A vector containing the ranks of the categories (1
for the best, with higher values for increasingly less preferred
categories). The vector needs to be named with the categories names, whereas
the ranks need to be a range of values from 1 to the number of categories.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteriaWeights</code></td>
<td>
<p>Vector containing the weights of the criteria. The
elements are named according to the IDs of the criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteriaMinMax</code></td>
<td>
<p>Vector containing the preference direction on each of
the criteria.  "min" (resp. "max") indicates that the criterion has to be
minimized (maximized).  The elements are named according to the IDs of the
criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>majorityThreshold</code></td>
<td>
<p>The cut threshold for the concordance condition.
Should be at least half of the sum of the weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteriaVetos</code></td>
<td>
<p>Matrix containing in each row a vector defining the
veto values for the lower profile of the category. NA values mean that no
veto is defined. A veto threshold for criterion i and category k represents
the performance below which an alternative is forbidden to outrank the lower
profile of category k, and thus is forbidden to be assigned to the category
k. The rows are named according to the categories, whereas the columns are
named according to the criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteriaDictators</code></td>
<td>
<p>Matrix containing in each row a vector defining the
dictator values for the lower profile of the category. NA values mean that
no veto is defined.  A dictator threshold for criterion i and category k
represents the performance above which an alternative is guaranteed to
outrank the lower profile of category k, and thus may no be assigned below
category k. The rows are named according to the categories, whereas the
columns are named according to the criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>majorityRule</code></td>
<td>
<p>String denoting how the vetoes and dictators are
combined in order to form the assignment rule.  The values to choose from
are "M", "V", "D", "v", "d", "dV", "Dv", "dv".  "M" corresponds to using
only the majority rule without vetoes or dictators, "V" considers only the
vetoes, "D" only the dictators, "v" is like "V" only that a dictator may
invalidate a veto, "d" is like "D" only that a veto may invalidate a
dictator, "dV" is like "V" only that if there is no veto we may then
consider the dictator, "Dv" is like "D" only that when there is no dictator
we may consider the vetoes, while finally "dv" is identical to using both
dictator and vetoes only that when both are active they invalidate each
other, so the majority rule is considered in that case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternativesIDs</code></td>
<td>
<p>Vector containing IDs of alternatives, according to
which the datashould be filtered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteriaIDs</code></td>
<td>
<p>Vector containing IDs of criteria, according to which the
data should be filtered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>categoriesIDs</code></td>
<td>
<p>Vector containing IDs of categories, according to which
the data should be filtered.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function returns a vector containing the assignments of the
alternatives to the categories.
</p>


<h3>References</h3>

<p>Bouyssou, D. and Marchant, T. An axiomatic approach to
noncompensatory sorting methods in MCDM, II: more than two categories.
European Journal of Operational Research, 178(1): 246â€“276, 2007.
</p>
<p>Meyer, P. and Olteanu, A-L. Integrating large positive and negative
performance differences in majority-rule sorting models. European Journal of
Operational Research, submitted, 2015.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# the performance table

performanceTable &lt;- rbind(c(10,10,9), c(10,9,10), c(9,10,10), c(9,9,10), 
                          c(9,10,9), c(10,9,9), c(10,10,7), c(10,7,10), 
                          c(7,10,10), c(9,9,17), c(9,17,9), c(17,9,9), 
                          c(7,10,17), c(10,17,7), c(17,7,10), c(7,17,10), 
                          c(17,10,7), c(10,7,17), c(7,9,17), c(9,17,7), 
                          c(17,7,9), c(7,17,9), c(17,9,7), c(9,7,17))

profilesPerformances &lt;- rbind(c(10,10,10),c(0,0,0))

vetoPerformances &lt;- rbind(c(7,7,7),c(0,0,0))

dictatorPerformances &lt;- rbind(c(17,17,17),c(0,0,0))

rownames(performanceTable) &lt;- c("a1", "a2", "a3", "a4", "a5", "a6", "a7", 
                                "a8", "a9", "a10", "a11", "a12",  "a13", 
                                "a14", "a15", "a16", "a17", "a18", "a19", 
                                "a20", "a21", "a22", "a23", "a24")

rownames(profilesPerformances) &lt;- c("P","F")

rownames(vetoPerformances) &lt;- c("P","F")

rownames(dictatorPerformances) &lt;- c("P","F")

colnames(performanceTable) &lt;- c("c1","c2","c3")

colnames(profilesPerformances) &lt;- c("c1","c2","c3")

colnames(vetoPerformances) &lt;- c("c1","c2","c3")

colnames(dictatorPerformances) &lt;- c("c1","c2","c3")

lambda &lt;- 0.5

weights &lt;- c(1/3,1/3,1/3)

names(weights) &lt;- c("c1","c2","c3")

categoriesRanks &lt;-c(1,2)

names(categoriesRanks) &lt;- c("P","F")

criteriaMinMax &lt;- c("max","max","max")

names(criteriaMinMax) &lt;- colnames(performanceTable)

assignments &lt;-rbind(c("P","P","P","F","F","F","F","F","F","F","F","F",
                    "F","F","F","F","F","F","F","F","F","F","F","F"), 
                    c("P","P","P","F","F","F","P","P","P","P","P","P",
                    "P","P","P","P","P","P","P","P","P","P","P","P"), 
                    c("P","P","P","F","F","F","F","F","F","F","F","F",
                    "P","P","P","P","P","P","F","F","F","F","F","F"), 
                    c("P","P","P","F","F","F","P","P","P","P","P","P",
                    "P","P","P","P","P","P","F","F","F","F","F","F"), 
                    c("P","P","P","F","F","F","F","F","F","P","P","P",
                    "F","F","F","F","F","F","F","F","F","F","F","F"), 
                    c("P","P","P","F","F","F","F","F","F","P","P","P",
                    "P","P","P","P","P","P","P","P","P","P","P","P"), 
                    c("P","P","P","F","F","F","F","F","F","P","P","P",
                    "P","P","P","P","P","P","F","F","F","F","F","F"))

colnames(assignments) &lt;- rownames(performanceTable)

majorityRules &lt;- c("V","D","v","d","dV","Dv","dv")

for(i in 1:7)
{
  ElectreAssignments&lt;-LPDMRSort(performanceTable, profilesPerformances, 
                                categoriesRanks,
                                weights, criteriaMinMax, lambda, 
                                criteriaVetos=vetoPerformances,
                                criteriaDictators=dictatorPerformances,
                                majorityRule = majorityRules[i])

  print(all(ElectreAssignments == assignments[i,]))
}

</code></pre>


</div>