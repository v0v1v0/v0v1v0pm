<div class="container">

<table style="width: 100%;"><tr>
<td>LPDMRSortIdentifyUsedDictatorProfiles</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Identify dictator profiles evaluations that have an impact on the final
assignments of MRSort with large performance differences</h2>

<h3>Description</h3>

<p>MRSort is a simplified ELECTRE-TRI approach which assigns alternatives to a
set of ordered categories using delimiting profiles evaluations. In this
case, we also take into account large performance differences. This method
is used to identify which dictator profiles evaluations have an impact on
the final assignment of at least one of the input alternatives.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LPDMRSortIdentifyUsedDictatorProfiles(
  performanceTable,
  assignments,
  categoriesRanks,
  criteriaMinMax,
  majorityThreshold,
  criteriaWeights,
  profilesPerformances,
  dictatorPerformances,
  vetoPerformances = NULL,
  majorityRule = "D",
  alternativesIDs = NULL,
  criteriaIDs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>performanceTable</code></td>
<td>
<p>Matrix or data frame containing the performance
table.  Each row corresponds to an alternative, and each column to a
criterion.  Rows (resp. columns) must be named according to the IDs of the
alternatives (resp. criteria).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assignments</code></td>
<td>
<p>A vector containing the category to which each
alternative is assigned. The vector needs to be named using the alternatives
IDs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>categoriesRanks</code></td>
<td>
<p>A vector containing the ranks of the categories (1
for the best, with higher values for increasingly less preferred
categories). The vector needs to be named with the categories names, whereas
the ranks need to be a range of values from 1 to the number of categories.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteriaMinMax</code></td>
<td>
<p>Vector containing the preference direction on each of
the criteria.  "min" (resp. "max") indicates that the criterion has to be
minimized (maximized).  The elements are named according to the IDs of the
criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>majorityThreshold</code></td>
<td>
<p>The majority threshold needed to determine when a
coalition of criteria is sufficient in order to validate an outranking
relation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteriaWeights</code></td>
<td>
<p>Vector containing the weights of the criteria.  The
elements are named according to the IDs of the criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>profilesPerformances</code></td>
<td>
<p>Matrix containing, in each row, the lower
profiles of the categories. The columns are named according to the criteria,
and the rows are named according to the categories. The index of the row in
the matrix corresponds to the rank of the category.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dictatorPerformances</code></td>
<td>
<p>Matrix containing in each row a vector defining
the dictator values for the lower profile of the category. NA values mean
that no dictator is defined.  A dictator threshold for criterion i and
category k represents the performance above which an alternative outranks
the lower profile of category k regardless of the size of the coalition of
criteria in favor of this statement.  The rows are named according to the
categories, whereas the columns are named according to the criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vetoPerformances</code></td>
<td>
<p>Matrix containing in each row a vector defining the
veto values for the lower profile of the category. NA values mean that no
veto is defined.  A veto threshold for criterion i and category k represents
the performance below which an alternative is forbidden to outrank the lower
profile of category k, and thus is forbidden to be assigned to the category
k.  The rows are named according to the categories, whereas the columns are
named according to the criteria. By default no veto profiles are needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>majorityRule</code></td>
<td>
<p>String denoting how the vetoes and dictators are
combined in order to form the assignment rule.  The values to choose from
are "D", "v", "d", "dV", "Dv", "dv".  "D" considers only the dictators, "v"
is like "V" only that a dictator may invalidate a veto, "d" is like "D" only
that a veto may invalidate a dictator, "dV" is like "V" only that if there
is no veto we may then consider the dictator, "Dv" is like "D" only that
when there is no dictator we may consider the vetoes, while finally "dv" is
identical to using both dictator and vetoes only that when both are active
they invalidate each other, so the majority rule is considered in that case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternativesIDs</code></td>
<td>
<p>Vector containing IDs of alternatives, according to
which the datashould be filtered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteriaIDs</code></td>
<td>
<p>Vector containing IDs of criteria, according to which the
data should be filtered.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function returns a matrix containing TRUE/FALSE inficators for
each evaluation of the veto profiles.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# the performance table

performanceTable &lt;- rbind(
  c(1,27,1),
  c(6,20,1),
  c(2,20,0),
  c(6,40,0),
  c(30,10,3))

rownames(performanceTable) &lt;- c("RER","METRO1","METRO2","BUS","TAXI")

colnames(performanceTable) &lt;- c("Price","Time","Comfort")

# lower profiles of the categories (best category in the first position of the list)

categoriesLowerProfiles &lt;- rbind(c(3, 11, 3),c(7, 25, 2),c(NA,NA,NA))

colnames(categoriesLowerProfiles) &lt;- colnames(performanceTable)

rownames(categoriesLowerProfiles)&lt;-c("Good","Medium","Bad")

# the order of the categories, 1 being the best

categoriesRanks &lt;-c(1,2,3)

names(categoriesRanks) &lt;- c("Good","Medium","Bad")

# criteria to minimize or maximize

criteriaMinMax &lt;- c("min","min","max")

names(criteriaMinMax) &lt;- colnames(performanceTable)

# dictators

criteriaDictators &lt;- rbind(c(1, 1, -1),c(1, 20, 0),c(NA,NA,NA))

colnames(criteriaDictators) &lt;- colnames(performanceTable)
rownames(criteriaDictators) &lt;- c("Good","Medium","Bad")

# vetos

criteriaVetos &lt;- rbind(c(9, 50, 5),c(50, 50, 5),c(NA,NA,NA))

colnames(criteriaVetos) &lt;- colnames(performanceTable)
rownames(criteriaVetos) &lt;- c("Good","Medium","Bad")

# weights

criteriaWeights &lt;- c(1/6,3/6,2/6)

names(criteriaWeights) &lt;- colnames(performanceTable)

# assignments

assignments &lt;- c("Good","Medium","Bad","Bad","Bad")


# LPDMRSortIndetifyUsedVetoProfiles

used&lt;-LPDMRSortIdentifyUsedDictatorProfiles(performanceTable, assignments,
                                        categoriesRanks, criteriaMinMax,
                                        0.5, criteriaWeights,
                                        categoriesLowerProfiles,
                                        criteriaDictators,
                                        criteriaVetos,
                                        "dv")

</code></pre>


</div>