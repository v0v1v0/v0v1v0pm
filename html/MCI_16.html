<div class="container">

<table style="width: 100%;"><tr>
<td>ijmatrix.create</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Interaction matrix with market shares
</h2>

<h3>Description</h3>

<p>Creation of an interaction matrix with market shares (<code class="reqn">p_{ij}</code>) of every supplier (<code class="reqn">j</code>) in every submarket (<code class="reqn">i</code>) based on the frequencies in the raw data (e.g. household or POS survey). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">ijmatrix.create(rawdataset, submarkets, suppliers, ..., remNA = TRUE, 
remSing = FALSE, remSing.val = 1, remSingSupp.val = 1, 
correctVar = FALSE, correctVar.val = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rawdataset</code></td>
<td>

<p>a <code>data.frame</code> containing the raw data
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>submarkets</code></td>
<td>

<p>the column in the dataset containing the submarkets (e.g. ZIP codes)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suppliers</code></td>
<td>

<p>the column in the dataset containing the suppliers (e.g. store codes) 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>other numeric variables in the raw data which were observed and shall be used to calculate market shares (e.g. expenditures)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remNA</code></td>
<td>

<p>logical argument that indicates if <code>NA</code> values of the submarkets and suppliers are removed or not (default: <code>remNA = TRUE</code>, otherwise: <code>remNA = FALSE</code>, which means that <code>NA</code> are considered in the interaction matrix, recoded as factor <code>99999</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remSing</code></td>
<td>

<p>logical argument that indicates if singular instances of the submarkets and suppliers are removed or not (default: <code>remSing = FALSE</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remSing.val</code></td>
<td>

<p>if <code>remSing = TRUE</code>: numeric value that indicates the limit value of singular instances in the submarket set to be removed from the data
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remSingSupp.val</code></td>
<td>

<p>if <code>remSing = TRUE</code>: numeric value that indicates the limit value of singular instances in the supplier set to be removed from the data
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correctVar</code></td>
<td>

<p>logical argument that indicates if the calculated market shares shall be corrected when they do not match the MCI standards (<code class="reqn">p_{ij} = 0</code>) (default: <code>correctVar = FALSE</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correctVar.val</code></td>
<td>

<p>if <code>correctVar = TRUE</code>: numeric value which is added to the absolute values before calculating market shares (default: 1)
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function creates an interaction matrix for all <code class="reqn">i</code> submarkets (e.g. geographical regions) and all <code class="reqn">j</code> suppliers (e.g. store locations). The function calculates <code class="reqn">p_{ij}</code> based on the frequencies and, optionally, further market shares calculated from other observed variables in the given raw dataset (e.g. expenditures from submarket <code class="reqn">i</code> at supplier <code class="reqn">j</code>). 
</p>
<p>Single observations with missing submarket or supplier (<code>NA</code>) are removed from the data automatically (unless <code>remNA = FALSE</code>). Optionally, singular instances (e.g. some submarkets or suppliers are only represented once or twice in the whole dataset) can also be removed (<code>remSing = TRUE</code>), where the limit values for extraction can be set by <code>remSing.val</code> and <code>remSingSupp.val</code> (e.g. <code>remSing.val = 2</code> and <code>remSingSupp.val = 1</code> removes every submarket from the interaction matrix which was observed <code class="reqn">\le 2</code> and every supplier observed <code class="reqn">\le 1</code>).
</p>


<h3>Value</h3>

<p>An interaction matrix which is a <code>data.frame</code> containing the <code class="reqn">i</code> x <code class="reqn">j</code> combinations (<code>'interaction'</code>), the submarkets (column is named as in raw data), the suppliers (column is named as in raw data), the observed absolute frequencies of every <code class="reqn">j</code> in every <code class="reqn">i</code> (<code>'freq_ij_abs'</code>), the observed absolute frequencies in every <code class="reqn">i</code> (<code>'freq_i_total'</code>) and the observed market shares of every <code class="reqn">j</code> in every <code class="reqn">i</code> (<code>'p_ij_obs'</code>). If additional variables are stated (e.g. expenditures) which shall be turned into (local) market shares, the output interaction matrix contains absolute values for every interaction, total values for every <code class="reqn">i</code> submarket and market shares (<code class="reqn">p_{ij}</code>) for these variables, too, which are automatically named based on the given variable name (e.g. the market shares based on a raw data variable called <code>expen</code> is named <code>p_ij_obs_expen</code>). The first three variables of the output matrix are factors, the calculated values are numeric.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Cooper, L. G./Nakanishi, M. (2010): “Market-Share Analysis: Evaluating competitive marketing effectiveness”. Boston, Dordrecht, London : Kluwer (first published 1988). E-book version from 2010: <a href="http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf">http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf</a>
</p>
<p>Huff, D. L./McCallum, D. (2008): “Calibrating the Huff Model Using ArcGIS Business Analyst”. <em>ESRI White Paper</em>, September 2008. <a href="https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf">https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf</a>
</p>
<p>Wieland, T. (2015): “Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens”. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>See Also</h3>

<p><code>ijmatrix.shares</code>, <code>ijmatrix.crosstab</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Creating an interaction matrix based on the POS survey in grocery1 #

data(grocery1)
# Loads the data
ijmatrix.create (grocery1, "plz_submarket", "store_code")
# Creates an interaction matrix with local market shares based on frequencies

mynewmcidata &lt;- ijmatrix.create (grocery1, "plz_submarket", "store_code")
# Save results directly in a new dataset

ijmatrix.create (grocery1, "plz_submarket", "store_code", "trip_expen")
# Creates an interaction matrix with local market shares based on frequencies
# and expenditures (Variable "trip_expen")



# MCI analysis for the grocery store market areas based on the POS survey in shopping1 #

data(shopping1)
# Loading the survey dataset
data(shopping2)
# Loading the distance/travel time dataset
data(shopping3)
# Loading the dataset containing information about the city districts
data(shopping4)
# Loading the grocery store data

shopping1_KAeast &lt;- shopping1[shopping1$resid_code %in% 
shopping3$resid_code[shopping3$KA_east == 1],]
# Extracting only inhabitants of the eastern districts of Karlsruhe

ijmatrix_gro_adj &lt;- ijmatrix.create(shopping1_KAeast, "resid_code",
"gro_purchase_code", "gro_purchase_expen", remSing = TRUE, remSing.val = 1,
remSingSupp.val = 2, correctVar = TRUE, correctVar.val = 0.1)
# Removing singular instances/outliers (remSing = TRUE) incorporating
# only suppliers which are at least obtained three times (remSingSupp.val = 2)
# Correcting the values (correctVar = TRUE)
# by adding 0.1 to the absolute values (correctVar.val = 0.1)

ijmatrix_gro_adj &lt;- ijmatrix_gro_adj[(ijmatrix_gro_adj$gro_purchase_code !=
"REFORMHAUSBOESER") &amp; (ijmatrix_gro_adj$gro_purchase_code != "WMARKT_DURLACH")
&amp; (ijmatrix_gro_adj$gro_purchase_code != "X_INCOMPLETE_STORE"),]
# Remove non-regarded observations

ijmatrix_gro_adj_dist &lt;- merge (ijmatrix_gro_adj, shopping2, by.x="interaction",
by.y="route")
# Include the distances and travel times (shopping2)
ijmatrix_gro_adj_dist_stores &lt;- merge (ijmatrix_gro_adj_dist, shopping4,
by.x = "gro_purchase_code", by.y = "location_code")
# Adding the store information (shopping4)

mci.transvar(ijmatrix_gro_adj_dist_stores, "resid_code", "gro_purchase_code", 
"p_ij_obs")
# Log-centering transformation of one variable (p_ij_obs)

ijmatrix_gro_transf &lt;- mci.transmat(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# Log-centering transformation of the interaction matrix

mcimodel_gro_trips &lt;- mci.fit(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# MCI model for the grocery store market areas
# shares: "p_ij_obs", explanatory variables: "d_time", "salesarea_qm"

summary(mcimodel_gro_trips)
# Use like lm
</code></pre>


</div>