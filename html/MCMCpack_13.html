<div class="container">

<table style="width: 100%;"><tr>
<td>HDPHSMMnegbin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov Chain Monte Carlo for HDP-HSMM with a Negative
Binomial outcome distribution</h2>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a Hidden Semi-Markov Model with a Heirarchical Dirichlet Process
and a Negative Binomial outcome distribution
(Johnson and Willsky, 2013).  The user supplies data and priors, and a
sample from the posterior distribution is returned as an mcmc
object, which can be subsequently analyzed with functions provided
in the coda package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">HDPHSMMnegbin(
  formula,
  data = parent.frame(),
  K = 10,
  b0 = 0,
  B0 = 1,
  a.alpha = 1,
  b.alpha = 0.1,
  a.gamma = 1,
  b.gamma = 0.1,
  a.omega,
  b.omega,
  e = 2,
  f = 2,
  g = 10,
  r = 1,
  burnin = 1000,
  mcmc = 1000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  P.start = NA,
  rho.start = NA,
  rho.step,
  nu.start = NA,
  omega.start = NA,
  gamma.start = 0.5,
  alpha.start = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Model formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>The number of regimes under consideration. This should be
larger than the hypothesized number of regimes in the data. Note
that the sampler will likely visit fewer than <code>K</code> regimes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.alpha, b.alpha</code></td>
<td>
<p>Shape and scale parameters for the Gamma
distribution on <code class="reqn">\alpha</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.gamma, b.gamma</code></td>
<td>
<p>Shape and scale parameters for the Gamma
distribution on <code class="reqn">\gamma</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.omega, b.omega</code></td>
<td>
<p>Paramaters for the Beta prior on
<code class="reqn">\omega</code>, which determines the regime length distribution,
which is Negative Binomial, with parameters <code>r</code> and <code>omega</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code> See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>The hyperprior for the distribution <code class="reqn">\rho</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Parameter of the Negative Binomial prior for regime
durations. It is the target number of successful trials. Must be
strictly positive. Higher values increase the variance of the
duration distributions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>The number of Metropolis iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
mcmc iterations must be divisible by this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the current beta vector, and the Metropolis acceptance
rate are printed to the screen every <code>verbose</code>th iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\beta</code> vector.  This
can either be a scalar or a column vector with dimension equal to the number
of betas. If this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA will use the
maximum likelihood estimate of <code class="reqn">\beta</code> as the starting value
for all regimes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P.start</code></td>
<td>
<p>Initial transition matrix between regimes. Should be
a <code>K</code> by <code>K</code> matrix. If not provided, the default value
will be uniform transition distributions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho.start</code></td>
<td>
<p>The starting value for the <code class="reqn">\rho</code> variable.
This can either be a scalar or a column vector with dimension
equal to the number of regimes. If the value is scalar, it will
be used for all regimes. The default value is a vector of ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho.step</code></td>
<td>
<p>Tuning parameter for the slice sampling approach to
sampling <code class="reqn">rho</code>. Determines the size of the step-out used to
find the correct slice to draw from. Lower values are more
accurate, but will take longer (up to a fixed searching limit).
Default is 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.start</code></td>
<td>
<p>The starting values for the random effect,
<code class="reqn">\nu</code>. The default value is a vector of ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega.start</code></td>
<td>
<p>A vector of starting values for the probability
of success parameter in the Negative Binomial distribution that
governs the duration distributions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.start, gamma.start</code></td>
<td>
<p>Scalar starting values for the
<code class="reqn">\alpha</code>, and <code class="reqn">\gamma</code> parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>HDPHSMMnegbin</code> simulates from the posterior distribution of a
HDP-HSMM with a Negative Binomial outcome distribution,
allowing for multiple, arbitrary changepoints in the model. The details of the
model are discussed in Johnson &amp; Willsky (2013). The implementation here is
based on a weak-limit approximation, where there is a large, though
finite number of regimes that can be switched between. Unlike other
changepoint models in <code>MCMCpack</code>, the HDP-HSMM approach allows
for the state sequence to return to previous visited states.
</p>
<p>The model takes the following form, where we show the fixed-limit version:
</p>
<p style="text-align: center;"><code class="reqn">y_t \sim \mathcal{P}oisson(\nu_t\mu_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_t = x_t ' \beta_k,\;\; k = 1, \ldots, K</code>
</p>

<p style="text-align: center;"><code class="reqn">\nu_t \sim \mathcal{G}amma(\rho_k, \rho_k)</code>
</p>

<p>Where <code class="reqn">K</code> is an upper bound on the number of states and
<code class="reqn">\beta_k</code> and <code class="reqn">\rho_k</code> are parameters when a state is
<code class="reqn">k</code> at <code class="reqn">t</code>.
</p>
<p>In the HDP-HSMM, there is a super-state sequence that, for a given
observation, is drawn from the transition distribution and then a
duration is drawn from a duration distribution to determin how long
that state will stay active. After that duration, a new super-state
is drawn from the transition distribution, where self-transitions
are  disallowed. The transition probabilities between states are
assumed to follow a heirarchical Dirichlet process:
</p>
<p style="text-align: center;"><code class="reqn">\pi_k \sim \mathcal{D}irichlet(\alpha\delta_1, \ldots ,
\alpha\delta_K)</code>
</p>

<p style="text-align: center;"><code class="reqn">\delta \sim \mathcal{D}irichlet(\gamma/K, \ldots, \gamma/K)</code>
</p>

<p>In the algorithm itself, these <code class="reqn">\pi</code> vectors are modified to
remove self-transitions as discussed above. There is a unique
duration distribution for each regime with the following
parameters:
</p>
<p style="text-align: center;"><code class="reqn">D_k \sim \mathcal{N}egBin(r, \omega_k)</code>
</p>

<p style="text-align: center;"><code class="reqn">\omega_k \sim \mathcal{B}eta(a_{\omega,k}, b_{\omega, k})</code>
</p>

<p>We assume Gaussian distribution for prior of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_k \sim \mathcal{N}(b_0,B_0^{-1}),\;\; m = 1, \ldots, K</code>
</p>

<p>The overdispersion parameters have a prior with the following form:
</p>
<p style="text-align: center;"><code class="reqn">f(\rho_k|e,f,g) \propto \rho^{e-1}(\rho + g)^{-(e+f)}</code>
</p>

<p>The model is simulated via blocked Gibbs conditonal on the states.
The <code class="reqn">\beta</code> being simulated via the auxiliary mixture sampling
method of Fuerhwirth-Schanetter et al. (2009). The <code class="reqn">\rho</code> is
updated via slice sampling. The <code class="reqn">\nu_t</code> are updated their
(conjugate) full conditional, which is also Gamma. The states and
their durations are drawn as in Johnson &amp; Willsky (2013).
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
“MCMCpack: Markov Chain Monte Carlo in R.”, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/">http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/</a>.
</p>
<p>Sylvia Fruehwirth-Schnatter, Rudolf Fruehwirth, Leonhard Held, and
Havard Rue. 2009. “Improved auxiliary mixture sampling for
hierarchical models of non-Gaussian data”, <em>Statistics
and Computing</em> 19(4): 479-492.
&lt;doi:10.1007/s11222-008-9109-4&gt;
</p>
<p>Matthew Blackwell. 2017. “Game Changers: Detecting Shifts in
Overdispersed Count Data,” <em>Political Analysis</em>
26(2), 230-239. &lt;doi:10.1017/pan.2017.42&gt;
</p>
<p>Matthew J. Johnson and Alan S. Willsky. 2013. “Bayesian Nonparametric Hidden Semi-Markov Models.” <em>Journal of Machine Learning Research</em>, 14(Feb), 673-701.
</p>


<h3>See Also</h3>

<p><code>MCMCnegbinChange</code>,
<code>HDPHMMnegbin</code>,
</p>


<h3>Examples</h3>

<pre><code class="language-R">
 ## Not run: 
   n &lt;- 150
   reg &lt;- 3
   true.s &lt;- gl(reg, n/reg, n)
   rho.true &lt;- c(1.5, 0.5, 3)
   b1.true &lt;- c(1, -2, 2)
   x1 &lt;- runif(n, 0, 2)
   nu.true &lt;- rgamma(n, rho.true[true.s], rho.true[true.s])
   mu &lt;- nu.true * exp(1 + x1 * b1.true[true.s])
   y &lt;- rpois(n, mu)

   posterior &lt;- HDPHSMMnegbin(y ~ x1, K = 10, verbose = 1000,
                          e = 2, f = 2, g = 10,
                          b0 = 0, B0 = 1/9,
                          a.omega = 1, b.omega = 100, r = 1,
                          rho.step = rep(0.75, times = 10),
                          seed = list(NA, 2),
                          omega.start = 0.05, gamma.start = 10,
                          alpha.start = 5)

   plotHDPChangepoint(posterior, ylab="Density", start=1)
   
## End(Not run)

</code></pre>


</div>