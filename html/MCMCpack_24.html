<div class="container">

<table style="width: 100%;"><tr>
<td>MCMCdynamicIRT1d_b</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov Chain Monte Carlo for Dynamic One Dimensional Item Response
Theory Model</h2>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a dynamic one dimensional item response theory (IRT) model, with
Normal random walk priors on the subject abilities (ideal points),
and multivariate Normal priors on the item parameters. The user
supplies data and priors, and a sample from the posterior
distribution is returned as an mcmc object, which can be
subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMCdynamicIRT1d_b(
  datamatrix,
  item.time.map,
  theta.constraints = list(),
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  theta.start = NA,
  alpha.start = NA,
  beta.start = NA,
  tau2.start = 1,
  a0 = 0,
  A0 = 0.1,
  b0 = 0,
  B0 = 0.1,
  c0 = -1,
  d0 = -1,
  e0 = 0,
  E0 = 1,
  store.ability = TRUE,
  store.item = TRUE,
  ...
)

MCMCdynamicIRT1d(
  datamatrix,
  item.time.map,
  theta.constraints = list(),
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  theta.start = NA,
  alpha.start = NA,
  beta.start = NA,
  tau2.start = 1,
  a0 = 0,
  A0 = 0.1,
  b0 = 0,
  B0 = 0.1,
  c0 = -1,
  d0 = -1,
  e0 = 0,
  E0 = 1,
  store.ability = TRUE,
  store.item = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>datamatrix</code></td>
<td>
<p>The matrix of data.  Must be 0, 1, or missing
values.  The rows of <code>datamatrix</code> correspond to subjects and
the columns correspond to items.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item.time.map</code></td>
<td>
<p>A vector that relates each item to a time
period.  Each element of <code>item.time.map</code> gives the time
period of the corresponding column of <code>datamatrix</code>. It is
assumed that the minimum value of <code>item.time.map</code> is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.constraints</code></td>
<td>
<p>A list specifying possible simple equality
or inequality constraints on the ability parameters. A typical
entry in the list has one of three forms: <code>varname=c</code> which
will constrain the ability parameter for the subject named
<code>varname</code> to be equal to c, <code>varname="+"</code> which will
constrain the ability parameter for the subject named
<code>varname</code> to be positive, and <code>varname="-"</code> which will
constrain the ability parameter for the subject named
<code>varname</code> to be negative. If x is a matrix without row names
defaults names of “V1",“V2", ... , etc will be used. See Rivers
(2003) for a thorough discussion of identification of IRT models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The
number of Gibbs iterations must be divisible by this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A switch which determines whether or not the
progress of the sampler is printed to the screen.  If
<code>verbose</code> is greater than 0 then every <code>verbose</code>th
iteration will be printed to the screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the
Mersenne Twister generator is used with default seed 12345; if an
integer is passed it is used to seed the Mersenne twister.  The
user can also pass a list of length two to use the L'Ecuyer
random number generator, which is suitable for parallel
computation.  The first element of the list is the L'Ecuyer seed,
which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a
positive substream number. See the MCMCpack specification for
more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.start</code></td>
<td>
<p>The starting values for the subject abilities
(ideal points). This can either be a scalar or a column vector
with dimension equal to the number of voters.  If this takes a
scalar value, then that value will serve as the starting value
for all of the thetas.  The default value of NA will choose the
starting values based on an eigenvalue-eigenvector decomposition
of the aggreement score matrix formed from the <code>datamatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\alpha</code>
difficulty parameters. This can either be a scalar or a column
vector with dimension equal to the number of items.  If this
takes a scalar value, then that value will serve as the starting
value for all of the alphas.  The default value of NA will set
the starting values based on a series of probit regressions that
condition on the starting values of theta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code>
discrimination parameters. This can either be a scalar or a
column vector with dimension equal to the number of items.  If
this takes a scalar value, then that value will serve as the
starting value for all of the betas.  The default value of NA
will set the starting values based on a series of probit
regressions that condition on the starting values of theta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2.start</code></td>
<td>
<p>The starting values for the evolution variances
(the variance of the random walk increments for the ability
parameters / ideal points. Order corresponds to the rows of
<code>datamatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>A vector containing the prior mean of each of the
difficulty parameters <code class="reqn">\alpha</code>. Should have as many
elements as items / roll calls. Order corresponds to the columns
of <code>datamatrix</code>. If a scalar is passed it is assumed that
all elements of <code>a0</code> are equal to the scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A0</code></td>
<td>
<p>A vector containing the prior precision (inverse
variance) of each of the difficulty parameters <code class="reqn">\alpha</code>.
Should have as many elements as items / roll calls. Order
corresponds to the columns of <code>datamatrix</code>. If a scalar is
passed it is assumed that all elements of <code>A0</code> are equal to
the scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>A vector containing the prior mean of each of the
discrimination parameters <code class="reqn">\beta</code>. Should have as many
elements as items / roll calls. Order corresponds to the columns
of <code>datamatrix</code>. If a scalar is passed it is assumed that
all elements of <code>b0</code> are equal to the scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B0</code></td>
<td>
<p>A vector containing the prior precision (inverse
variance) of each of the discrimination parameters
<code class="reqn">\beta</code>. Should have as many elements as items / roll
calls. Order corresponds to the columns of <code>datamatrix</code>. If
a scalar is passed it is assumed that all elements of <code>B0</code>
are equal to the scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c0</code></td>
<td>
<p><code class="reqn">c_{0/2}</code> is the shape parameter for the inverse
Gamma prior on <code class="reqn">\tau^2</code> (the variance of the random walk
increments).  The amount of information in the inverse Gamma
prior is something like that from <code class="reqn">c_0</code>
pseudo-observations. <code>c0</code> can be either a vector with an
element for each subject or a scalar. If <code>c0</code> is negative
then <code class="reqn">\tau^2</code> is not estimated– the values in
<code>tau2.start</code> are used throughout the sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d0</code></td>
<td>
<p><code class="reqn">d_{0/2}</code> is the scale parameter for the inverse
Gamma prior on <code class="reqn">\tau^2</code> (the variance of the random walk
increments).  In constructing the inverse Gamma prior, <code class="reqn">d_0</code>
acts like the sum of squared errors from the <code class="reqn">c_0</code>
pseudo-observations. <code>d0</code> can be either a vector with an
element for each subject or a scalar. If <code>d0</code> is negative
then <code class="reqn">\tau^2</code> is not estimated– the values in
<code>tau2.start</code> are used throughout the sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e0</code></td>
<td>
<p>A vector containing the prior mean of the initial ability
parameter / ideal point for each subject. Should have as many
elements as subjects. Order corresponds to the rows of
<code>datamatrix</code>. If a scalar is passed it is assumed that all
elements of <code>e0</code> are equal to the scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E0</code></td>
<td>
<p>A vector containing the prior variance of the initial
ability parameter / ideal point for each subject. Should have as
many elements as subjects. Order corresponds to the rows of
<code>datamatrix</code>. If a scalar is passed it is assumed that all
elements of <code>E0</code> are equal to the scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.ability</code></td>
<td>
<p>A switch that determines whether or not to
store the ability parameters for posterior analysis.
<em>NOTE</em>: In situations with many individuals storing the
ability parameters takes an enormous amount of memory, so
<code>store.ability</code> should only be <code>TRUE</code> if the chain is
thinned heavily, or for applications with a small number of
individuals.  By default, the item parameters are stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.item</code></td>
<td>
<p>A switch that determines whether or not to store
the item parameters for posterior analysis.  <em>NOTE</em>: In
situations with many items storing the item parameters takes an
enormous amount of memory, so <code>store.item</code> should only be
<code>FALSE</code> if the chain is thinned heavily, or for applications
with a small number of items.  By default, the item parameters
are not stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>MCMCdynamicIRT1d</code> simulates from the posterior distribution
using the algorithm of Martin and Quinn (2002). The simulation
proper is done in compiled C++ code to maximize efficiency.  Please
consult the coda documentation for a comprehensive list of
functions that can be used to analyze the posterior sample.
</p>
<p>The model takes the following form. We assume that each subject has
an subject ability (ideal point) denoted <code class="reqn">\theta_{j,t}</code> (where
<code class="reqn">j</code> indexes subjects and <code class="reqn">t</code> indexes time periods) and that
each item has a difficulty parameter <code class="reqn">\alpha_i</code> and
discrimination parameter <code class="reqn">\beta_i</code>. The observed choice by
subject <code class="reqn">j</code> on item <code class="reqn">i</code> is the observed data matrix which
is <code class="reqn">(I \times J)</code>. We assume that the choice is dictated by an
unobserved utility:
</p>
<p style="text-align: center;"><code class="reqn">z_{i,j,t} = -\alpha_i + \beta_i \theta_{j,t} +
\varepsilon_{i,j,t}</code>
</p>

<p>Where the disturbances are assumed to be distributed standard
Normal. The parameters of interest are the subject abilities (ideal
points) and the item parameters.
</p>
<p>We assume the following priors.  For the subject abilities (ideal
points):
</p>
<p style="text-align: center;"><code class="reqn">\theta_{j,t} \sim \mathcal{N}(\theta_{j,t-1}, \tau^2_j)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">\theta_{j,0} \sim \mathcal{N}(e0, E0)</code>
</p>
<p>.
</p>
<p>The evolution variance has the following prior:
</p>
<p style="text-align: center;"><code class="reqn">\tau^2_j \sim \mathcal{IG}(c0/2, d0/2)</code>
</p>
<p>.
</p>
<p>For the item parameters in the standard model, the prior is:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_i \sim \mathcal{N}(a0, A0^{-1})</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\beta_i \sim \mathcal{N}(b0, B0^{-1})</code>
</p>
<p>.
</p>
<p>The model is identified by the proper priors on the item parameters
and constraints placed on the ability parameters.
</p>
<p>As is the case with all measurement models, make sure that you have
plenty of free memory, especially when storing the item parameters.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample. This
object can be summarized by functions provided by the coda
package.
</p>


<h3>Author(s)</h3>

<p>Kevin M. Quinn
</p>


<h3>References</h3>

<p>Andrew D. Martin and Kevin M. Quinn. 2002. "Dynamic Ideal Point
Estimation via Markov Chain Monte Carlo for the U.S. Supreme Court,
1953-1999." <em>Political Analysis.</em> 10: 134-153. &lt;doi:10.1093/pan/10.2.134&gt;
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  “MCMCpack:
Markov Chain Monte Carlo in R.”, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>


<h3>See Also</h3>

<p><code>plot.mcmc</code>,<code>summary.mcmc</code>,
<code>MCMCirt1d</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  ## Not run: 
	data(Rehnquist)

	## assign starting values
	theta.start &lt;- rep(0, 9)
	theta.start[2] &lt;- -3 ## Stevens
	theta.start[7] &lt;- 2  ## Thomas

	out &lt;- MCMCdynamicIRT1d(t(Rehnquist[,1:9]),
	                        item.time.map=Rehnquist$time,
	                        theta.start=theta.start,
	                        mcmc=50000, burnin=20000, thin=5,
	                        verbose=500, tau2.start=rep(0.1, 9),
	                        e0=0, E0=1,
	                        a0=0, A0=1,
	                        b0=0, B0=1, c0=-1, d0=-1,
	                        store.item=FALSE,
	                        theta.constraints=list(Stevens="-", Thomas="+"))

	summary(out)
  
## End(Not run)

</code></pre>


</div>