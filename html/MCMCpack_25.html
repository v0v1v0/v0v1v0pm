<div class="container">

<table style="width: 100%;"><tr>
<td>MCMCfactanal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov Chain Monte Carlo for Normal Theory Factor Analysis Model</h2>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of
a normal theory factor analysis model. Normal priors are assumed on
the factor loadings and factor scores while inverse Gamma priors
are assumed for the uniquenesses. The user supplies data and
parameters for the prior distributions, and a sample from the
posterior distribution is returned as an mcmc object, which can be
subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMCfactanal(
  x,
  factors,
  lambda.constraints = list(),
  data = NULL,
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  lambda.start = NA,
  psi.start = NA,
  l0 = 0,
  L0 = 0,
  a0 = 0.001,
  b0 = 0.001,
  store.scores = FALSE,
  std.var = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either a formula or a numeric matrix containing the
manifest variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factors</code></td>
<td>
<p>The number of factors to be fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.constraints</code></td>
<td>
<p>List of lists specifying possible simple
equality or inequality constraints on the factor loadings. A
typical entry in the list has one of three forms:
<code>varname=list(d,c)</code> which will constrain the dth loading for
the variable named <code>varname</code> to be equal to c,
<code>varname=list(d,"+")</code> which will constrain the dth loading
for the variable named <code>varname</code> to be positive, and
<code>varname=list(d, "-")</code> which will constrain the dth loading
for the variable named <code>varname</code> to be negative. If x is a
matrix without column names defaults names of “V1",“V2", ... ,
etc will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>The number of iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The
number of iterations must be divisible by this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A switch which determines whether or not the
progress of the sampler is printed to the screen.  If
<code>verbose</code> is greater than 0 the iteration number and the
factor loadings and uniquenesses are printed to the screen every
<code>verbose</code>th iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the
Mersenne Twister generator is used with default seed 12345; if an
integer is passed it is used to seed the Mersenne twister.  The
user can also pass a list of length two to use the L'Ecuyer
random number generator, which is suitable for parallel
computation.  The first element of the list is the L'Ecuyer seed,
which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a
positive substream number. See the MCMCpack specification for
more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.start</code></td>
<td>
<p>Starting values for the factor loading matrix
Lambda. If <code>lambda.start</code> is set to a scalar the starting
value for all unconstrained loadings will be set to that
scalar. If <code>lambda.start</code> is a matrix of the same dimensions
as Lambda then the <code>lambda.start</code> matrix is used as the
starting values (except for equality-constrained elements). If
<code>lambda.start</code> is set to <code>NA</code> (the default) then
starting values for unconstrained elements are set to 0, and
starting values for inequality constrained elements are set to
either 0.5 or -0.5 depending on the nature of the constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi.start</code></td>
<td>
<p>Starting values for the uniquenesses. If
<code>psi.start</code> is set to a scalar then the starting value for
all diagonal elements of <code>Psi</code> are set to this value. If
<code>psi.start</code> is a <code class="reqn">k</code>-vector (where <code class="reqn">k</code> is the number
of manifest variables) then the staring value of <code>Psi</code> has
<code>psi.start</code> on the main diagonal. If <code>psi.start</code> is set
to <code>NA</code> (the default) the starting values of all the
uniquenesses are set to 0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l0</code></td>
<td>
<p>The means of the independent Normal prior on the factor loadings.
Can be either a scalar or a matrix with the same dimensions as
<code>Lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L0</code></td>
<td>
<p>The precisions (inverse variances) of the independent Normal prior
on the factor loadings. Can be either a scalar or a matrix with the same
dimensions as <code>Lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>Controls the shape of the inverse Gamma prior on the uniqueness.
The actual shape parameter is set to <code>a0/2</code>. Can be either a scalar or
a <code class="reqn">k</code>-vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Controls the scale of the inverse Gamma prior on the uniquenesses.
The actual scale parameter is set to <code>b0/2</code>. Can be either a scalar or
a <code class="reqn">k</code>-vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.scores</code></td>
<td>
<p>A switch that determines whether or not to store the
factor scores for posterior analysis.  <em>NOTE: This takes an enormous
amount of memory, so should only be used if the chain is thinned heavily, or
for applications with a small number of observations</em>.  By default, the
factor scores are not stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.var</code></td>
<td>
<p>If <code>TRUE</code> (the default) the manifest variables are
rescaled to have zero mean and unit variance. Otherwise, the manifest
variables are rescaled to have zero mean but retain their observed
variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">x_i = \Lambda \phi_i + \epsilon_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon_i \sim \mathcal{N}(0,\Psi)</code>
</p>

<p>where <code class="reqn">x_i</code> is the <code class="reqn">k</code>-vector of observed variables
specific to observation <code class="reqn">i</code>, <code class="reqn">\Lambda</code> is the <code class="reqn">k \times
d</code> matrix of factor loadings, <code class="reqn">\phi_i</code> is the <code class="reqn">d</code>-vector of
latent factor scores, and <code class="reqn">\Psi</code> is a diagonal, positive
definite matrix. Traditional factor analysis texts refer to the
diagonal elements of <code class="reqn">\Psi</code> as uniquenesses.
</p>
<p>The implementation used here assumes independent conjugate priors
for each element of <code class="reqn">\Lambda</code> each <code class="reqn">\phi_i</code>, and each
diagonal element of <code class="reqn">\Psi</code>. More specifically we assume:
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_{ij} \sim \mathcal{N}(l_{0_{ij}}, L_{0_{ij}}^{-1}),
i=1,\ldots,k, j=1,\ldots,d</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi_i \sim \mathcal{N}(0, I), i=1,\dots,n</code>
</p>

<p style="text-align: center;"><code class="reqn">\Psi_{ii} \sim \mathcal{IG}(a_{0_i}/2, b_{0_i}/2),
i=1,\ldots,k</code>
</p>

<p><code>MCMCfactanal</code> simulates from the posterior distribution using
standard Gibbs sampling. The simulation proper is done in compiled
C++ code to maximize efficiency.  Please consult the coda
documentation for a comprehensive list of functions that can be
used to analyze the posterior sample.
</p>
<p>As is the case with all measurement models, make sure that you have
plenty of free memory, especially when storing the scores.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the sample from the posterior
distribution. This object can be summarized by functions provided by the
coda package.
</p>


<h3>References</h3>

<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.
“MCMCpack: Markov Chain Monte Carlo in R.”, <em>Journal of Statistical
Software</em>. 42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/">http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  “Output
Analysis and Diagnostics for MCMC (CODA)”, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code>plot.mcmc</code>,<code>summary.mcmc</code>,<code>factanal</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
   ## Not run: 
   ### An example using the formula interface
   data(swiss)
   posterior &lt;- MCMCfactanal(~Agriculture+Examination+Education+Catholic
                    +Infant.Mortality, factors=2,
                    lambda.constraints=list(Examination=list(1,"+"),
                       Examination=list(2,"-"), Education=c(2,0),
                       Infant.Mortality=c(1,0)),
                    verbose=0, store.scores=FALSE, a0=1, b0=0.15,
                    data=swiss, burnin=5000, mcmc=50000, thin=20)
   plot(posterior)
   summary(posterior)

   ### An example using the matrix interface
   Y &lt;- cbind(swiss$Agriculture, swiss$Examination,
              swiss$Education, swiss$Catholic,
              swiss$Infant.Mortality)
   colnames(Y) &lt;- c("Agriculture", "Examination", "Education", "Catholic",
                    "Infant.Mortality")
   post &lt;- MCMCfactanal(Y, factors=2,
                        lambda.constraints=list(Examination=list(1,"+"),
                          Examination=list(2,"-"), Education=c(2,0),
                          Infant.Mortality=c(1,0)),
                        verbose=0, store.scores=FALSE, a0=1, b0=0.15,
                        burnin=5000, mcmc=50000, thin=20)
   
## End(Not run)

</code></pre>


</div>