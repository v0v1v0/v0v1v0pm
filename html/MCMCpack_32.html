<div class="container">

<table style="width: 100%;"><tr>
<td>MCMCirtKd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov Chain Monte Carlo for K-Dimensional Item Response Theory Model</h2>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
K-dimensional item response theory (IRT) model, with standard normal priors
on the subject abilities (ideal points), and normal priors on the item
parameters.  The user supplies data and priors, and a sample from the
posterior distribution is returned as an mcmc object, which can be
subsequently analyzed with functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMCirtKd(
  datamatrix,
  dimensions,
  item.constraints = list(),
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = NA,
  alphabeta.start = NA,
  b0 = 0,
  B0 = 0,
  store.item = FALSE,
  store.ability = TRUE,
  drop.constant.items = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>datamatrix</code></td>
<td>
<p>The matrix of data.  Must be 0, 1, or missing values.  It
is of dimensionality subjects by items.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimensions</code></td>
<td>
<p>The number of dimensions in the latent space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>item.constraints</code></td>
<td>
<p>List of lists specifying possible equality
or simple inequality constraints on the item parameters. A
typical entry in the list has one of three forms:
<code>rowname=list(d,c)</code> which will constrain the dth item
parameter for the item named rowname to be equal to c,
<code>rowname=list(d,"+")</code> which will constrain the dth item
parameter for the item named rowname to be positive,
and<code>rowname=list(d, "-")</code> which will constrain the dth item
parameter for the item named rowname to be negative. If x is a
matrix without row names defaults names of “V1", “V2", ... ,
etc will be used. In a K dimensional model, the first item
parameter for item <code class="reqn">i</code> is the difficulty parameter
(<code class="reqn">\alpha_i</code>), the second item parameter is the discrimation
parameter on dimension 1 (<code class="reqn">\beta_{i,1}</code>), the third item
parameter is the discrimation parameter on dimension 2
(<code class="reqn">\beta_{i,2}</code>), ..., and the (K+1)th item parameter is the
discrimation parameter on dimension K (<code class="reqn">\beta_{i,1}</code>).  The
item difficulty parameters (<code class="reqn">\alpha</code>) should generally not be
constrained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>The number of iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
iterations must be divisible by this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 then
every <code>verbose</code>th iteration will be printed to the screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphabeta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\alpha</code> and
<code class="reqn">\beta</code> difficulty and discrimination parameters. If
<code>alphabeta.start</code> is set to a scalar the starting value for all
unconstrained item parameters will be set to that scalar. If
<code>alphabeta.start</code> is a matrix of dimension <code class="reqn">(K+1) \times
items</code> then the <code>alphabeta.start</code> matrix is used as the
starting values (except for equality-constrained elements). If
<code>alphabeta.start</code> is set to <code>NA</code> (the default) then starting
values for unconstrained elements are set to values generated from a series
of proportional odds logistic regression fits, and starting values for
inequality constrained elements are set to either 1.0 or -1.0 depending on
the nature of the constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>The prior means of the <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
difficulty and discrimination parameters, stacked for all items.  If a
scalar is passed, it is used as the prior mean for all items.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B0</code></td>
<td>
<p>The prior precisions (inverse variances) of the independent normal
prior on the item parameters.  Can be either a scalar or a matrix of
dimension <code class="reqn">(K+1) \times items</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.item</code></td>
<td>
<p>A switch that determines whether or not to store the item
parameters for posterior analysis.  <em>NOTE: In applications with many
items this takes an enormous amount of memory. If you have many items and
want to want to store the item parameters you may want to thin the chain
heavily</em>.  By default, the item parameters are not stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.ability</code></td>
<td>
<p>A switch that determines whether or not to store the
subject abilities for posterior analysis. <em>NOTE: In applications with
many subjects this takes an enormous amount of memory. If you have many
subjects and want to want to store the ability parameters you may want to
thin the chain heavily</em>. By default, the ability parameters are all stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.constant.items</code></td>
<td>
<p>A switch that determines whether or not items
that have no variation should be deleted before fitting the model. Default =
TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>MCMCirtKd</code> simulates from the posterior distribution using standard
Gibbs sampling using data augmentation (a normal draw for the subject
abilities, a multivariate normal draw for the item parameters, and a
truncated normal draw for the latent utilities). The simulation proper is
done in compiled C++ code to maximize efficiency.  Please consult the coda
documentation for a comprehensive list of functions that can be used to
analyze the posterior sample.
</p>
<p>The default number of burnin and mcmc iterations is much smaller than the
typical default values in MCMCpack.  This is because fitting this model is
extremely computationally expensive.  It does not mean that this small of a
number of scans will yield good estimates.  The priors of this model need to
be proper for identification purposes.  The user is asked to provide prior
means and precisions <em>(not variances)</em> for the item parameters and the
subject parameters.
</p>
<p>The model takes the following form.  We assume that each subject
has an ability (ideal point) denoted <code class="reqn">\theta_j</code> <code class="reqn">(K \times
1)</code>, and that each item has a difficulty parameter <code class="reqn">\alpha_i</code>
and discrimination parameter <code class="reqn">\beta_i</code> <code class="reqn">(K \times 1)</code>.  The
observed choice by subject <code class="reqn">j</code> on item <code class="reqn">i</code> is the observed
data matrix which is <code class="reqn">(I \times J)</code>.  We assume that the choice
is dictated by an unobserved utility:
</p>
<p style="text-align: center;"><code class="reqn">z_{i,j} = - \alpha_i + \beta_i'\theta_j + \varepsilon_{i,j}</code>
</p>

<p>Where the <code class="reqn">\varepsilon_{i,j}</code>s are assumed to be distributed
standard normal.  The parameters of interest are the subject
abilities (ideal points) and the item parameters.
</p>
<p>We assume the following priors.  For the subject abilities (ideal points) we
assume independent standard normal priors:
</p>
<p style="text-align: center;"><code class="reqn">\theta_{j,k} \sim \mathcal{N}(0,1)</code>
</p>

<p>These cannot be changed by the user.
For each item parameter, we assume independent normal priors:
</p>
<p style="text-align: center;"><code class="reqn">\left[\alpha_i, \beta_i \right]' \sim \mathcal{N}_{(K+1)} (b_{0,i},B_{0,i})</code>
</p>

<p>Where <code class="reqn">B_{0,i}</code> is a diagonal matrix.  One can specify a
separate prior mean and precision for each item parameter.
</p>
<p>The model is identified by the constraints on the item parameters (see
Jackman 2001).  The user cannot place constraints on the subject abilities.
This identification scheme differs from that in <code>MCMCirt1d</code>, which uses
constraints on the subject abilities to identify the model.  In our
experience, using subject ability constraints for models in greater than one
dimension does not work particularly well.
</p>
<p>As is the case with all measurement models, make sure that you have plenty
of free memory, especially when storing the item parameters.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>James H. Albert. 1992. “Bayesian Estimation of Normal Ogive
Item Response Curves Using Gibbs Sampling." <em>Journal of Educational
Statistics</em>.  17: 251-269.
</p>
<p>Joshua Clinton, Simon Jackman, and Douglas Rivers. 2004. “The Statistical
Analysis of Roll Call Data."  <em>American Political Science Review</em>.  98:
355-370.
</p>
<p>Simon Jackman. 2001. “Multidimensional Analysis of Roll Call Data via
Bayesian Simulation.” <em>Political Analysis.</em> 9: 227-241.
</p>
<p>Valen E. Johnson and James H. Albert. 1999. <em>Ordinal Data Modeling</em>.
Springer: New York.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  “MCMCpack:
Markov Chain Monte Carlo in R.”, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/">http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  “Output
Analysis and Diagnostics for MCMC (CODA)”, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>
<p>Douglas Rivers.  2004.  “Identification of Multidimensional Item-Response
Models."  Stanford University, typescript.
</p>


<h3>See Also</h3>

<p><code>plot.mcmc</code>,<code>summary.mcmc</code>,
<code>MCMCirt1d</code>, <code>MCMCordfactanal</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
   ## Not run: 
   data(SupremeCourt)
   # note that the rownames (the item names) are "1", "2", etc
   posterior1 &lt;- MCMCirtKd(t(SupremeCourt), dimensions=1,
                   burnin=5000, mcmc=50000, thin=10,
                   B0=.25, store.item=TRUE,
                   item.constraints=list("1"=list(2,"-")))
   plot(posterior1)
   summary(posterior1)


   data(Senate)
   Sen.rollcalls &lt;- Senate[,6:677]
   posterior2 &lt;- MCMCirtKd(Sen.rollcalls, dimensions=2,
                   burnin=5000, mcmc=50000, thin=10,
                   item.constraints=list(rc2=list(2,"-"), rc2=c(3,0),
                                         rc3=list(3,"-")),
                   B0=.25)
   plot(posterior2)
   summary(posterior2)
   
## End(Not run)

</code></pre>


</div>