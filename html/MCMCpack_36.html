<div class="container">

<table style="width: 100%;"><tr>
<td>MCMCmixfactanal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov Chain Monte Carlo for Mixed Data Factor Analysis Model</h2>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a mixed
data (both continuous and ordinal) factor analysis model. Normal priors are
assumed on the factor loadings and factor scores, improper uniform priors
are assumed on the cutpoints, and inverse gamma priors are assumed for the
error variances (uniquenesses). The user supplies data and parameters for
the prior distributions, and a sample from the posterior distribution is
returned as an mcmc object, which can be subsequently analyzed with
functions provided in the coda package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMCmixfactanal(
  x,
  factors,
  lambda.constraints = list(),
  data = parent.frame(),
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  tune = NA,
  verbose = 0,
  seed = NA,
  lambda.start = NA,
  psi.start = NA,
  l0 = 0,
  L0 = 0,
  a0 = 0.001,
  b0 = 0.001,
  store.lambda = TRUE,
  store.scores = FALSE,
  std.mean = TRUE,
  std.var = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A one-sided formula containing the manifest variables. Ordinal
(including dichotomous) variables must be coded as ordered factors. Each
level of these ordered factors must be present in the data passed to the
function.  NOTE: data input is different in <code>MCMCmixfactanal</code> than in
either <code>MCMCfactanal</code> or <code>MCMCordfactanal</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factors</code></td>
<td>
<p>The number of factors to be fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.constraints</code></td>
<td>
<p>List of lists specifying possible equality or
simple inequality constraints on the factor loadings. A typical entry in the
list has one of three forms: <code>varname=list(d,c)</code> which will constrain
the dth loading for the variable named varname to be equal to c,
<code>varname=list(d,"+")</code> which will constrain the dth loading for the
variable named varname to be positive, and <code>varname=list(d, "-")</code> which
will constrain the dth loading for the variable named varname to be
negative. If x is a matrix without column names defaults names of “V1",
“V2", ... , etc will be used. Note that, unlike <code>MCMCfactanal</code>, the
<code class="reqn">\Lambda</code> matrix used here has <code>factors</code>+1 columns. The
first column of <code class="reqn">\Lambda</code> corresponds to negative item
difficulty parameters for ordinal manifest variables and mean parameters for
continuous manifest variables and should generally not be constrained
directly by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>The number of iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
iterations must be divisible by this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune</code></td>
<td>
<p>The tuning parameter for the Metropolis-Hastings sampling. Can
be either a scalar or a <code class="reqn">k</code>-vector (where <code class="reqn">k</code> is the number of
manifest variables). <code>tune</code> must be strictly positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is great than 0 the
iteration number and the Metropolis-Hastings acceptance rate are printed to
the screen every <code>verbose</code>th iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.start</code></td>
<td>
<p>Starting values for the factor loading matrix Lambda. If
<code>lambda.start</code> is set to a scalar the starting value for all
unconstrained loadings will be set to that scalar. If <code>lambda.start</code> is
a matrix of the same dimensions as Lambda then the <code>lambda.start</code>
matrix is used as the starting values (except for equality-constrained
elements). If <code>lambda.start</code> is set to <code>NA</code> (the default) then
starting values for unconstrained elements in the first column of Lambda are
based on the observed response pattern, the remaining unconstrained elements
of Lambda are set to 0, and starting values for inequality constrained
elements are set to either 1.0 or -1.0 depending on the nature of the
constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi.start</code></td>
<td>
<p>Starting values for the error variance (uniqueness) matrix.
If <code>psi.start</code> is set to a scalar then the starting value for all
diagonal elements of <code>Psi</code> that represent error variances for
continuous variables are set to this value. If <code>psi.start</code> is a
<code class="reqn">k</code>-vector (where <code class="reqn">k</code> is the number of manifest variables)
then the staring value of <code>Psi</code> has <code>psi.start</code> on the main
diagonal with the exception that entries corresponding to error variances
for ordinal variables are set to 1.. If <code>psi.start</code> is set to <code>NA</code>
(the default) the starting values of all the continuous variable
uniquenesses are set to 0.5. Error variances for ordinal response variables
are always constrained (regardless of the value of <code>psi.start</code> to have
an error variance of 1 in order to achieve identification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l0</code></td>
<td>
<p>The means of the independent Normal prior on the factor loadings.
Can be either a scalar or a matrix with the same dimensions as
<code>Lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L0</code></td>
<td>
<p>The precisions (inverse variances) of the independent Normal prior
on the factor loadings. Can be either a scalar or a matrix with the same
dimensions as <code>Lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>Controls the shape of the inverse Gamma prior on the uniqueness.
The actual shape parameter is set to <code>a0/2</code>. Can be either a scalar or
a <code class="reqn">k</code>-vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Controls the scale of the inverse Gamma prior on the uniquenesses.
The actual scale parameter is set to <code>b0/2</code>. Can be either a scalar or
a <code class="reqn">k</code>-vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.lambda</code></td>
<td>
<p>A switch that determines whether or not to store the
factor loadings for posterior analysis. By default, the factor loadings are
all stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.scores</code></td>
<td>
<p>A switch that determines whether or not to store the
factor scores for posterior analysis.  <em>NOTE: This takes an enormous
amount of memory, so should only be used if the chain is thinned heavily, or
for applications with a small number of observations</em>.  By default, the
factor scores are not stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.mean</code></td>
<td>
<p>If <code>TRUE</code> (the default) the continuous manifest
variables are rescaled to have zero mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.var</code></td>
<td>
<p>If <code>TRUE</code> (the default) the continuous manifest
variables are rescaled to have unit variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model takes the following form:
</p>
<p>Let <code class="reqn">i=1,\ldots,N</code> index observations and <code class="reqn">j=1,\ldots,K</code>
index response variables within an observation. An observed
variable <code class="reqn">x_{ij}</code> can be either ordinal with a total of
<code class="reqn">C_j</code> categories or continuous.  The distribution of <code class="reqn">X</code> is
governed by a <code class="reqn">N \times K</code> matrix of latent variables <code class="reqn">X^*</code>
and a series of cutpoints <code class="reqn">\gamma</code>. <code class="reqn">X^*</code> is assumed to be
generated according to:
</p>
<p style="text-align: center;"><code class="reqn">x^*_i = \Lambda \phi_i + \epsilon_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon_i \sim \mathcal{N}(0,\Psi)</code>
</p>

<p>where <code class="reqn">x^*_i</code> is the <code class="reqn">k</code>-vector of latent variables
specific to observation <code class="reqn">i</code>, <code class="reqn">\Lambda</code> is the <code class="reqn">k \times
d</code> matrix of factor loadings, and <code class="reqn">\phi_i</code> is the
<code class="reqn">d</code>-vector of latent factor scores. It is assumed that the
first element of <code class="reqn">\phi_i</code> is equal to 1 for all <code class="reqn">i</code>.
</p>
<p>If the <code class="reqn">j</code>th variable is ordinal, the probability that it takes the
value <code class="reqn">c</code> in observation <code class="reqn">i</code> is:
</p>
<p style="text-align: center;"><code class="reqn">\pi_{ijc} = \Phi(\gamma_{jc} - \Lambda'_j\phi_i) -
\Phi(\gamma_{j(c-1)} - \Lambda'_j\phi_i)</code>
</p>

<p>If the <code class="reqn">j</code>th variable is continuous, it is assumed that <code class="reqn">x^*_{ij}
= x_{ij}</code> for all <code class="reqn">i</code>.
</p>
<p>The implementation used here assumes independent conjugate priors for each
element of <code class="reqn">\Lambda</code> and each <code class="reqn">\phi_i</code>. More
specifically we assume:
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_{ij} \sim \mathcal{N}(l_{0_{ij}}, L_{0_{ij}}^{-1}),
i=1,\ldots,k, j=1,\ldots,d</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi_{i(2:d)} \sim \mathcal{N}(0, I), i=1,\dots,n</code>
</p>

<p><code>MCMCmixfactanal</code> simulates from the posterior distribution using a
Metropolis-Hastings within Gibbs sampling algorithm. The algorithm employed
is based on work by Cowles (1996).  Note that the first element of
<code class="reqn">\phi_i</code> is a 1. As a result, the first column of
<code class="reqn">\Lambda</code> can be interpretated as negative item difficulty
parameters.  Further, the first element <code class="reqn">\gamma_1</code> is
normalized to zero, and thus not returned in the mcmc object.  The
simulation proper is done in compiled C++ code to maximize efficiency.
Please consult the coda documentation for a comprehensive list of functions
that can be used to analyze the posterior sample.
</p>
<p>As is the case with all measurement models, make sure that you have plenty
of free memory, especially when storing the scores.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Kevin M. Quinn. 2004. “Bayesian Factor Analysis for Mixed
Ordinal and Continuous Responses.” <em>Political Analysis</em>. 12: 338-353.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  “MCMCpack:
Markov Chain Monte Carlo in R.”, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>M. K. Cowles. 1996. “Accelerating Monte Carlo Markov Chain Convergence for
Cumulative-link Generalized Linear Models." <em>Statistics and Computing.</em>
6: 101-110.
</p>
<p>Valen E. Johnson and James H. Albert. 1999. “Ordinal Data Modeling."
Springer: New York.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/">http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  “Output
Analysis and Diagnostics for MCMC (CODA)”, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code>plot.mcmc</code>, <code>summary.mcmc</code>,
<code>factanal</code>, <code>MCMCfactanal</code>,
<code>MCMCordfactanal</code>, <code>MCMCirt1d</code>,
<code>MCMCirtKd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
data(PErisk)

post &lt;- MCMCmixfactanal(~courts+barb2+prsexp2+prscorr2+gdpw2,
                        factors=1, data=PErisk,
                        lambda.constraints = list(courts=list(2,"-")),
                        burnin=5000, mcmc=1000000, thin=50,
                        verbose=500, L0=.25, store.lambda=TRUE,
                        store.scores=TRUE, tune=1.2)
plot(post)
summary(post)




library(MASS)
data(Cars93)
attach(Cars93)
new.cars &lt;- data.frame(Price, MPG.city, MPG.highway,
                 Cylinders, EngineSize, Horsepower,
                 RPM, Length, Wheelbase, Width, Weight, Origin)
rownames(new.cars) &lt;- paste(Manufacturer, Model)
detach(Cars93)

# drop obs 57 (Mazda RX 7) b/c it has a rotary engine
new.cars &lt;- new.cars[-57,]
# drop 3 cylinder cars
new.cars &lt;- new.cars[new.cars$Cylinders!=3,]
# drop 5 cylinder cars
new.cars &lt;- new.cars[new.cars$Cylinders!=5,]

new.cars$log.Price &lt;- log(new.cars$Price)
new.cars$log.MPG.city &lt;- log(new.cars$MPG.city)
new.cars$log.MPG.highway &lt;- log(new.cars$MPG.highway)
new.cars$log.EngineSize &lt;- log(new.cars$EngineSize)
new.cars$log.Horsepower &lt;- log(new.cars$Horsepower)

new.cars$Cylinders &lt;- ordered(new.cars$Cylinders)
new.cars$Origin    &lt;- ordered(new.cars$Origin)



post &lt;- MCMCmixfactanal(~log.Price+log.MPG.city+
                 log.MPG.highway+Cylinders+log.EngineSize+
                 log.Horsepower+RPM+Length+
                 Wheelbase+Width+Weight+Origin, data=new.cars,
                 lambda.constraints=list(log.Horsepower=list(2,"+"),
                 log.Horsepower=c(3,0), weight=list(3,"+")),
                 factors=2,
                 burnin=5000, mcmc=500000, thin=100, verbose=500,
                 L0=.25, tune=3.0)
plot(post)
summary(post)


## End(Not run)

</code></pre>


</div>