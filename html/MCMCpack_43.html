<div class="container">

<table style="width: 100%;"><tr>
<td>MCMCpaircompare</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov Chain Monte Carlo for a Pairwise Comparisons Model with Probit Link</h2>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a
model for pairwise comparisons data with a probit link. Thurstone's model
is a special case of this model when the <code class="reqn">\alpha</code> parameter is fixed at
1.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMCpaircompare(
  pwc.data,
  theta.constraints = list(),
  alpha.fixed = FALSE,
  burnin = 1000,
  mcmc = 20000,
  thin = 1,
  verbose = 0,
  seed = NA,
  alpha.start = NA,
  a = 0,
  A = 0.25,
  store.theta = TRUE,
  store.alpha = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pwc.data</code></td>
<td>
<p>A data.frame containing the pairwise comparisons data.
Each row of <code>pwc.data</code> corresponds to a single pairwise comparison.
<code>pwc.data</code> needs to have exactly four columns. The first column
contains a unique identifier for the rater. Column two contains the unique
identifier for the first item being compared. Column three contains the
unique identifier for the second item being compared. Column four contains
the unique identifier of the item selected from the two items being
compared. If a tie occurred, the entry in the fourth column should be NA.
For applications without raters (such as sports competitions) all entries
in the first column should be set to a single value and <code>alpha.fixed</code>
(see below) should be set to <code>TRUE</code>. <strong>The identifiers in
columns 2 through 4 must start with a letter. Examples are provided below.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.constraints</code></td>
<td>
<p>A list specifying possible simple equality or
inequality constraints on the item parameters. A typical entry in the
list has one of three forms: <code>itemname=c</code> which will constrain the
item parameter for the item named <code>itemname</code> to be equal to c,
<code>itemname="+"</code> which will constrain the item parameter for the
item named <code>itemname</code> to be positive, and <code>itemname="-"</code> which
will constrain the item parameter for the item named <code>itemname</code> to
be negative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.fixed</code></td>
<td>
<p>Should alpha be fixed to a constant value of 1 for all
raters? Default is FALSE. If set to FALSE, an alpha value is estimated for
each rater.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>The number of Gibbs iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
Gibbs iterations must be divisible by this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0
output is printed to the screen every
<code>verbose</code>th iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.start</code></td>
<td>
<p>The starting value for the alpha vector.  This
can either be a scalar or a column vector with dimension equal to the number
of alphas.  If this takes a scalar value, then that value will serve as the
starting value for all of the alphas. The default value of NA will set the
starting value of each alpha parameter to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>The prior mean of alpha. Must be a scalar. Default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>The prior precision of alpha. Must be a positive scalar.
Default is 0.25 (prior variance is 4).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.theta</code></td>
<td>
<p>Should the theta draws be returned? Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.alpha</code></td>
<td>
<p>Should the alpha draws be returned? Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>MCMCpaircompare</code> uses the data augmentation approach of Albert and
Chib (1993). The user supplies data and priors, and a sample from the
posterior is returned as an <code>mcmc</code> object, which can be subsequently
analyzed in the <code>coda</code> package.
</p>
<p>The simulation is done in compiled C++ code to maximize efficiency.
</p>
<p>Please consult the <code>coda</code> package documentation for a comprehensive
list of functions that can be used to analyze the posterior sample.
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">i = 1,...,I \ \ \ \   (raters) </code>
</p>

<p style="text-align: center;"><code class="reqn">j = 1,...,J \ \ \ \   (items)  </code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = 1 \ \  if  \ \  i \ \  chooses \ \  j \ \ over \ \ j'</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = 0 \ \ if \ \ i \ \ chooses \ \ j' \ \ over \ \ j</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{ijj'} = NA \ \  if \ \ i \ \ chooses \ \ neither</code>
</p>

<p style="text-align: center;"><code class="reqn">Pr(Y_{ijj'} = 1) = \Phi( \alpha_{i} [\theta_{j} - \theta_{ j'} ] ) </code>
</p>

<p>The following Gaussian priors are assumed:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_i \sim \mathcal{N}(a, A^{-1})</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_j \sim \mathcal{N}(0, 1)</code>
</p>

<p>For identification, some <code class="reqn">\theta_j</code>s are truncated above or below 0,
or fixed to constants.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.
</p>


<h3>References</h3>

<p>Albert, J. H. and S. Chib. 1993. “Bayesian Analysis of Binary
and Polychotomous Response Data.” <em>J. Amer. Statist. Assoc.</em> 88,
669-679
</p>
<p>Yu, Qiushi and Kevin M. Quinn. 2021. “A Multidimensional Pairwise
Comparison Model for Heterogeneous Perception with an Application to
Modeling the Perceived Truthfulness of Public Statements on COVID-19.”
University of Michigan Working Paper.
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  “MCMCpack:
Markov Chain Monte Carlo in R.”, <em>Journal of Statistical Software</em>.
42(9): 1-21. <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.  <em>Scythe
Statistical Library 1.0.</em> <a href="http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/">http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/</a>.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  “Output
Analysis and Diagnostics for MCMC (CODA)”, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code>plot.mcmc</code>,<code>summary.mcmc</code>,
<code>MCMCpaircompare2d</code>,
<code>MCMCpaircompare2dDP</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  ## Not run: 
  ## Euro 2016 example
  data(Euro2016)

posterior1 &lt;- MCMCpaircompare(pwc.data=Euro2016,
                              theta.constraints=list(Ukraine="-",
                                                     Portugal="+"),
                              alpha.fixed=TRUE,
                              verbose=10000,
                              burnin=10000, mcmc=500000, thin=100,
                              store.theta=TRUE, store.alpha=FALSE)

## alternative identification constraints
posterior2 &lt;- MCMCpaircompare(pwc.data=Euro2016,
                              theta.constraints=list(Ukraine="-",
                                                     Portugal=1),
                              alpha.fixed=TRUE,
                              verbose=10000,
                              burnin=10000, mcmc=500000, thin=100,
                              store.theta=TRUE, store.alpha=FALSE)








## a synthetic data example with estimated rater-specific parameters
set.seed(123)

I &lt;- 65  ## number of raters
J &lt;- 50 ## number of items to be compared


## raters 1 to 5 have less sensitivity to stimuli than raters 6 through I
alpha.true &lt;- c(rnorm(5, m=0.2, s=0.05), rnorm(I - 5, m=1, s=0.1))
theta.true &lt;- sort(rnorm(J, m=0, s=1))

n.comparisons &lt;- 125 ## number of pairwise comparisons for each rater

## generate synthetic data according to the assumed model
rater.id &lt;- NULL
item.1.id &lt;- NULL
item.2.id &lt;- NULL
choice.id &lt;- NULL
for (i in 1:I){
    for (c in 1:n.comparisons){
        rater.id &lt;- c(rater.id, i+100)
        item.numbers &lt;- sample(1:J, size=2, replace=FALSE)
        item.1 &lt;- item.numbers[1]
        item.2 &lt;- item.numbers[2]
        item.1.id &lt;- c(item.1.id, item.1)
        item.2.id &lt;- c(item.2.id, item.2)
        eta &lt;- alpha.true[i] * (theta.true[item.1] - theta.true[item.2])
        prob.item.1.chosen &lt;- pnorm(eta)
        u &lt;- runif(1)
        if (u &lt;= prob.item.1.chosen){
            choice.id &lt;- c(choice.id, item.1)
        }
        else{
            choice.id &lt;- c(choice.id, item.2)
        }
    }
}
item.1.id &lt;- paste("item", item.1.id+100, sep=".")
item.2.id &lt;- paste("item", item.2.id+100, sep=".")
choice.id &lt;- paste("item", choice.id+100, sep=".")

sim.data &lt;- data.frame(rater.id, item.1.id, item.2.id, choice.id)


## fit the model
posterior &lt;- MCMCpaircompare(pwc.data=sim.data,
                             theta.constraints=list(item.101=-2,
                                                    item.150=2),
                             alpha.fixed=FALSE,
                             verbose=10000,
                             a=0, A=0.5,
                             burnin=10000, mcmc=200000, thin=100,
                             store.theta=TRUE, store.alpha=TRUE)

theta.draws &lt;- posterior[, grep("theta", colnames(posterior))]
alpha.draws &lt;- posterior[, grep("alpha", colnames(posterior))]

theta.post.med &lt;- apply(theta.draws, 2, median)
alpha.post.med &lt;- apply(alpha.draws, 2, median)

theta.post.025 &lt;- apply(theta.draws, 2, quantile, prob=0.025)
theta.post.975 &lt;- apply(theta.draws, 2, quantile, prob=0.975)
alpha.post.025 &lt;- apply(alpha.draws, 2, quantile, prob=0.025)
alpha.post.975 &lt;- apply(alpha.draws, 2, quantile, prob=0.975)

## compare estimates to truth
par(mfrow=c(1,2))
plot(theta.true, theta.post.med, xlim=c(-2.5, 2.5), ylim=c(-2.5, 2.5),
     col=rgb(0,0,0,0.3))
segments(x0=theta.true, x1=theta.true,
         y0=theta.post.025, y1=theta.post.975,
         col=rgb(0,0,0,0.3)) 
abline(0, 1, col=rgb(1,0,0,0.5))

plot(alpha.true, alpha.post.med, xlim=c(0, 1.2), ylim=c(0, 3),
     col=rgb(0,0,0,0.3))
segments(x0=alpha.true, x1=alpha.true,
         y0=alpha.post.025, y1=alpha.post.975,
         col=rgb(0,0,0,0.3)) 
abline(0, 1, col=rgb(1,0,0,0.5))


## End(Not run)

</code></pre>


</div>