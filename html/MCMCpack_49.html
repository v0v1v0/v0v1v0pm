<div class="container">

<table style="width: 100%;"><tr>
<td>MCMCprobitChange</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov Chain Monte Carlo for a linear Gaussian Multiple Changepoint Model</h2>

<h3>Description</h3>

<p>This function generates a sample from the posterior distribution of a linear
Gaussian model with multiple changepoints. The function uses the Markov
chain Monte Carlo method of Chib (1998).  The user supplies data and priors,
and a sample from the posterior distribution is returned as an mcmc object,
which can be subsequently analyzed with functions provided in the coda
package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMCprobitChange(
  formula,
  data = parent.frame(),
  m = 1,
  burnin = 10000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = NA,
  beta.start = NA,
  P.start = NA,
  b0 = NULL,
  B0 = NULL,
  a = NULL,
  b = NULL,
  marginal.likelihood = c("none", "Chib95"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Model formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The number of changepoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance are
printed to the screen every <code>verbose</code>th iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The seed for the random number generator.  If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister.  The user can also pass a list of
length two to use the L'Ecuyer random number generator, which is suitable
for parallel computation.  The first element of the list is the L'Ecuyer
seed, which is a vector of length six or NA (if NA a default seed of
<code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.start</code></td>
<td>
<p>The starting values for the <code class="reqn">\beta</code> vector.
This can either be a scalar or a column vector with dimension equal to the
number of betas.  The default value of of NA will use the MLE estimate of
<code class="reqn">\beta</code> as the starting value.  If this is a scalar, that value
will serve as the starting value mean for all of the betas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P.start</code></td>
<td>
<p>The starting values for the transition matrix.  A user should
provide a square matrix with dimension equal to the number of states.  By
default, draws from the <code>Beta(0.9, 0.1)</code> are used to construct a proper
transition matrix for each raw except the last raw.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the number of betas. If this
takes a scalar value, then that value will serve as the prior mean for all
of the betas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of beta. Default value of 0 is equivalent to an
improper uniform prior for beta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities.
By default, the expected duration is computed and corresponding a and b
values are assigned. The expected duration is the sample period divided by
the number of states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marginal.likelihood</code></td>
<td>
<p>How should the marginal likelihood be calculated?
Options are: <code>none</code> in which case the marginal likelihood will not be
calculated, and <code>Chib95</code> in which case the method of Chib (1995) is
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>MCMCprobitChange</code> simulates from the posterior distribution of a
probit regression model with multiple parameter breaks. The simulation is
based on Chib (1998) and Park (2011).
</p>
<p>The model takes the following form:
</p>
<p style="text-align: center;"><code class="reqn">\Pr(y_t = 1) = \Phi(x_i'\beta_m) \;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states, and <code class="reqn">\beta_m</code>
is a parameter when a state is <code class="reqn">m</code> at <code class="reqn">t</code>.
</p>
<p>We assume Gaussian distribution for prior of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_m \sim \mathcal{N}(b_0,B_0^{-1}),\;\; m = 1, \ldots, M</code>
</p>

<p>And:
</p>
<p style="text-align: center;"><code class="reqn">p_{mm} \sim \mathcal{B}eta(a, b),\;\; m = 1, \ldots, M</code>
</p>

<p>Where <code class="reqn">M</code> is the number of states.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarized by functions provided by the coda package.  The object
contains an attribute <code>prob.state</code> storage matrix that contains the
probability of <code class="reqn">state_i</code> for each period, the log-likelihood of
the model (<code>loglike</code>), and the log-marginal likelihood of the model
(<code>logmarglike</code>).
</p>


<h3>References</h3>

<p>Jong Hee Park. 2011. “Changepoint Analysis of Binary and
Ordinal Probit Models: An Application to Bank Rate Policy Under the Interwar
Gold Standard."  <em>Political Analysis</em>. 19: 188-204. &lt;doi:10.1093/pan/mpr007&gt;
</p>
<p>Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park. 2011.  “MCMCpack:
Markov Chain Monte Carlo in R.”, <em>Journal of Statistical Software</em>.
42(9): 1-21.  <a href="https://doi.org/10.18637/jss.v042.i09">doi:10.18637/jss.v042.i09</a>.
</p>
<p>Siddhartha Chib. 1998. “Estimation and comparison of multiple change-point
models.” <em>Journal of Econometrics</em>. 86: 221-241.
</p>
<p>Albert, J. H. and S. Chib. 1993. “Bayesian Analysis of Binary and
Polychotomous Response Data.” <em>J. Amer. Statist. Assoc.</em> 88, 669-679
</p>


<h3>See Also</h3>

<p><code>plotState</code>, <code>plotChangepoint</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
set.seed(1973)
x1 &lt;- rnorm(300, 0, 1)
true.beta &lt;- c(-.5, .2, 1)
true.alpha &lt;- c(.1, -1., .2)
X &lt;- cbind(1, x1)

## set two true breaks at 100 and 200
true.phi1 &lt;- pnorm(true.alpha[1] + x1[1:100]*true.beta[1])
true.phi2 &lt;- pnorm(true.alpha[2] + x1[101:200]*true.beta[2])
true.phi3 &lt;-  pnorm(true.alpha[3] + x1[201:300]*true.beta[3])

## generate y
y1 &lt;- rbinom(100, 1, true.phi1)
y2 &lt;- rbinom(100, 1, true.phi2)
y3 &lt;- rbinom(100, 1, true.phi3)
Y &lt;- as.ts(c(y1, y2, y3))

## fit multiple models with a varying number of breaks
out0 &lt;- MCMCprobitChange(formula=Y~X-1, data=parent.frame(), m=0,
                         mcmc=1000, burnin=1000, thin=1, verbose=1000,
                         b0 = 0, B0 = 0.1, a = 1, b = 1,  marginal.likelihood = c("Chib95"))
out1 &lt;- MCMCprobitChange(formula=Y~X-1, data=parent.frame(), m=1,
                         mcmc=1000, burnin=1000, thin=1, verbose=1000,
                         b0 = 0, B0 = 0.1, a = 1, b = 1,  marginal.likelihood = c("Chib95"))
out2 &lt;- MCMCprobitChange(formula=Y~X-1, data=parent.frame(), m=2,
                         mcmc=1000, burnin=1000, thin=1, verbose=1000,
                         b0 = 0, B0 = 0.1, a = 1, b = 1,  marginal.likelihood = c("Chib95"))
out3 &lt;- MCMCprobitChange(formula=Y~X-1, data=parent.frame(), m=3,
                         mcmc=1000, burnin=1000, thin=1, verbose=1000,
                         b0 = 0, B0 = 0.1, a = 1, b = 1,  marginal.likelihood = c("Chib95"))

## find the most reasonable one
BayesFactor(out0, out1, out2, out3)

## draw plots using the "right" model
plotState(out2)
plotChangepoint(out2)

## End(Not run)

</code></pre>


</div>