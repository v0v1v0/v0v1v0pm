<div class="container">

<table style="width: 100%;"><tr>
<td>MCMCquantreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian quantile regression using Gibbs sampling</h2>

<h3>Description</h3>

<p>This function fits quantile regression models under Bayesian inference.  The
function samples from the posterior distribution using Gibbs sampling with
data augmentation.  A multivariate normal prior is assumed for
<code class="reqn">\beta</code>. The user supplies the prior parameters.  A sample of the
posterior distribution is returned as an mcmc object, which can then be
analysed by functions in the coda package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMCquantreg(
  formula,
  data = NULL,
  tau = 0.5,
  burnin = 1000,
  mcmc = 10000,
  thin = 1,
  verbose = 0,
  seed = sample(1:1e+06, 1),
  beta.start = NA,
  b0 = 0,
  B0 = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Model formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>The quantile of interest. Must be between 0 and 1. The default
value of 0.5 corresponds to median regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number and the most recently sampled values of <code class="reqn">\beta</code>
and <code class="reqn">\sigma</code> are printed to the screen every <code>verbose</code>th
iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The seed for the random number generator. If NA, the Mersenne
Twister generator is used with default seed 12345; if an integer is passed
it is used to seed the Mersenne twister. The default value for this argument
is a random integer between 1 and 1,000,000. This default value ensures that
if the function is used again with a different value of <code class="reqn">\tau</code>, it
is extremely unlikely that the seed will be identical. The user can also
pass a list of length two to use the L'Ecuyer random number generator, which
is suitable for parallel computation.  The first element of the list is the
L'Ecuyer seed, which is a vector of length six or NA (if NA a default seed
of <code>rep(12345,6)</code> is used).  The second element of list is a positive
substream number. See the MCMCpack specification for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.start</code></td>
<td>
<p>The starting values for <code class="reqn">\beta</code>.  This can
either be a scalar or a column vector with dimension equal to the dimension
of <code class="reqn">\beta</code>.  The default value of NA will use the OLS estimate
<code class="reqn">\hat{\beta}</code> with
<code class="reqn">\hat{\sigma}\Phi^{-1}(\tau)</code> added on to the
first element of <code class="reqn">\hat{\beta}</code> as the starting value.
(<code class="reqn">\hat{\sigma}^2</code> denotes the usual unbiased estimator of
<code class="reqn">\sigma^2</code> under ordinary mean regression and
<code class="reqn">\Phi^{-1}(\tau)</code> denotes the inverse of the cumulative
density function of the standard normal distribution.)  Note that the
default value assume that an intercept is included in the model.  If a
scalar is given, that value will serve as the starting value for all
<code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>.  This can either be a scalar
or a column vector with dimension equal to the dimension of
</p>
<p><code class="reqn">\beta</code>. If this takes a scalar value, then that value will serve
as the prior mean for all <code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B0</code></td>
<td>
<p>The prior precision of <code class="reqn">\beta</code>.  This can either be a
scalar or a square matrix with dimensions equal to the number of betas.  If
this takes a scalar value, then that value times an identity matrix serves
as the prior precision of <code class="reqn">\beta</code>. Default value of 0 is
equivalent to an improper uniform prior for <code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>MCMCquantreg</code> simulates from the posterior distribution using Gibbs
sampling with data augmentation (see
<a href="http://people.brunel.ac.uk/~mastkky/">http://people.brunel.ac.uk/~mastkky/</a>).  <code class="reqn">\beta</code> are drawn
from a multivariate normal distribution. The augmented data are drawn
conditionally from the inverse Gaussian distribution. The simulation is
carried out in compiled C++ code to maximise efficiency.  Please consult the
coda documentation for a comprehensive list of functions that can be used to
analyse the posterior sample.
</p>
<p>We assume the model
</p>
<p style="text-align: center;"><code class="reqn">Q_{\tau}(y_i|x_i) = x_i'\beta</code>
</p>

<p>where <code class="reqn">Q_{\tau}(y_i|x_i)</code> denotes the
conditional <code class="reqn">\tau</code>th quantile of <code class="reqn">y_i</code> given
<code class="reqn">x_i</code>, and <code class="reqn">\beta=\beta(\tau)</code> are the
regression parameters possibly dependent on <code class="reqn">\tau</code>. The likelihood
is formed based on assuming independent Asymmetric Laplace distributions on
the <code class="reqn">y_i</code> with skewness parameter <code class="reqn">\tau</code> and location
parameters <code class="reqn">x_i'\beta</code>. This assumption ensures that the
likelihood function is maximised by the <code class="reqn">\tau</code>th conditional
quantile of the response variable.  We assume standard, semi-conjugate
priors on <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim \mathcal{N}(b_0,B_0^{-1})</code>
</p>

<p>Only starting values for
<code class="reqn">\beta</code> are allowed for this sampler.
</p>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample.  This object can
be summarised by functions provided by the coda package.
</p>


<h3>Author(s)</h3>

<p>Craig Reed
</p>


<h3>References</h3>

<p>Daniel Pemstein, Kevin M. Quinn, and Andrew D. Martin.  2007.
<em>Scythe Statistical Library 1.2.</em> <a href="http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/">http://scythe.wustl.edu.s3-website-us-east-1.amazonaws.com/</a>.
</p>
<p>Craig Reed and Keming Yu. 2009. “An Efficient Gibbs Sampler for Bayesian
Quantile Regression.” Technical Report.
</p>
<p>Keming Yu and Jin Zhang. 2005. “A Three Parameter Asymmetric Laplace
Distribution and it's extensions.” <em>Communications in Statistics -
Theory and Methods</em>, 34, 1867-1879.
</p>
<p>Martyn Plummer, Nicky Best, Kate Cowles, and Karen Vines. 2006.  “Output
Analysis and Diagnostics for MCMC (CODA)”, <em>R News</em>. 6(1): 7-11.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf</a>.
</p>


<h3>See Also</h3>

<p><code>MCMCregress</code>, <code>plot.mcmc</code>,
<code>summary.mcmc</code>, <code>lm</code>,
<code>rq</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

x&lt;-rep(1:10,5)
y&lt;-rnorm(50,mean=x)
posterior_50 &lt;- MCMCquantreg(y~x)
posterior_95 &lt;- MCMCquantreg(y~x, tau=0.95, verbose=10000,
    mcmc=50000, thin=10, seed=2)
plot(posterior_50)
plot(posterior_95)
raftery.diag(posterior_50)
autocorr.plot(posterior_95)
summary(posterior_50)
summary(posterior_95)

## End(Not run)

</code></pre>


</div>