<div class="container">

<table style="width: 100%;"><tr>
<td>sampSizeMCTGen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sample Size Calculations (General Case)</h2>

<h3>Description</h3>

<p>This function build on the <code>sampSizeMCT</code> function in the
<code>DoseFinding</code> package, allowing the procedure to work with the
<code>powMCTGen</code> function for the general case.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sampSizeMCTGen(
  family = c("negative binomial", "binomial", "poisson"),
  link = c("log", "logit", "probit", "cauchit", "cloglog", "log risk ratio",
    "risk ratio"),
  modelPar = NULL,
  theoResp = NULL,
  doses = NULL,
  upperN,
  lowerN = floor(upperN/2),
  Ntype = c("arm", "total"),
  alRatio = NULL,
  altModels,
  alpha = 0.025,
  power = 0.8,
  sumFct = c("min", "mean", "max"),
  verbose = FALSE,
  tol = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A character string containing the error distribution to be used
in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>A character string for the model link function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelPar</code></td>
<td>
<p>A numeric vector containing the additional parameters for the
family argument. If the family is negative binomial, the dispersion
parameter should be supplied. If the family is binomial, no model parameter
should be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theoResp</code></td>
<td>
<p>A numerical vector of theoretical response values, on the
transformed scale (e.g. on the log-scale for the negative binomial family).
This should be the same length as the doses argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doses</code></td>
<td>
<p>A numerical vector of doses, corresponding to the theoretical
response values provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upperN, lowerN</code></td>
<td>
<p>Upper and lower bound for the power sample size.
<code>lowerN</code> defaults to <code>floor(upperN/2)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ntype</code></td>
<td>
<p>One of "arm", "total", or 'actual". See documentation for
<code>Ntype</code> in <code>powMCT</code> for descriptions
of "arm" and 'total". For "actual", the nSample should be a numerical
vector containing the actual patient allocation for each dose provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alRatio</code></td>
<td>
<p>A numeric vector specifying the ratios between the patient
allocation for the specified doses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>altModels</code></td>
<td>
<p>An object of class <code>Mods</code>, defining the mean vectors
under which the power should be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A numeric value specifying the significance level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p>A numeric value specifying the power power of <code>sumFct</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sumFct</code></td>
<td>
<p>Either an included character vector or a function that combines
the power values under the different alternative into one value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical specifying whether the patient allocation should be
printed, in addition to the results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>A positive numeric value specifying the tolerance level for the
bisection search algorithm. Bisection is stopped if the <code>targFunc</code>
value is within <code>tol</code> of power.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Numeric containing the calculated power values
</p>


<h3>Examples</h3>

<pre><code class="language-R">
dose.vec = c(0, 5, 10, 20, 30, 40)
models.full = Mods(doses = dose.vec, linear = NULL,
      sigEmax = rbind(c(9, 2), c(6, 3)),
      emax = 0.8,
      quadratic = -0.02,
      placEff = 0, maxEff = 2)
## Now we can calculate the sample sizes needed in order to achieve a certain power
sampSizeMCTGen("negative binomial", "log", modelPar = 0.1, upperN = 50, Ntype = "arm",
      altModels = models.full, alpha = 0.05, sumFct = "min", power = 0.8)

</code></pre>


</div>