<div class="container">

<table style="width: 100%;"><tr>
<td>sampSize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Sample size calculations for MCPMod </h2>

<h3>Description</h3>

<p>Given a candidate set, the baseline effect, the maximum effect and
the standard deviation, the <code>sampSize</code> function returns the smallest sample size
achieving a certain combined power value. See Pinheiro et al. (2006) for details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sampSize(models, doses, base, maxEff, sigma, upperN,
         lowerN = floor(upperN/2), power = 0.8, alRatio = NULL,
         sumFct = mean, off = 0.1*max(doses), scal = 1.2 * max(doses),
         alpha = 0.025, twoSide = FALSE, tol = 0.001, verbose = FALSE,
         control = mvtnorm.control(), muMat = NULL,
         typeN = c("arm", "total"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p> A list specifying the candidate models. This
can also be a fullMod object, then the arguments <code>base</code>, 
<code>maxEff</code>, <code>off</code> and <code>scal</code> are ignored </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doses</code></td>
<td>
<p> Dose levels to be administered </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p> Expected baseline effect </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxEff</code></td>
<td>
<p> Expected maximum change from baseline </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p> Expected standard deviation </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upperN, lowerN</code></td>
<td>
<p> Upper and lower bound for the target sample size. <code>lowerN</code> defaults to
<code>floor(upperN/2)</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p> Desired combined power value, defaults to 0.8. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alRatio</code></td>
<td>
<p> Vector describing the relative patient allocations to the dose
groups. See Examples below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sumFct</code></td>
<td>
<p> A function to combine the power values under the
different models into one value. By default the
arthmetic mean is used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>off</code></td>
<td>
<p> Offset parameter for the linear in log model (default 10 perc. of maximum dose). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scal</code></td>
<td>
<p> Scale parameter for the beta model (default 20 perc. larger than maximum dose).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p> Level of significance (default: 0.025)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>twoSide</code></td>
<td>
<p> Logical indicating whether a two sided or a one-sided
test is performed. By default FALSE, so one-sided testing. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> A positive numeric value specifying the tolerance level for the bisection search algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> Logical value indicating if a trace of the iteration progress of
the bisection search algorithm should be displayed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p> A list of options for the <code>pmvt</code> and <code>qmvt</code> functions
as produced by <code>mvtnorm.control</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muMat</code></td>
<td>
<p> An optional matrix with means as columns and given dimnames 
(dose levels and names of contrasts). If specified the
the <code>models</code> argument should not be specified, see examples
below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typeN</code></td>
<td>
<p> One of "arm" or "total". Determines, whether the sample size in the
smallest arm or the total sample size is iterated in bisection
search algorithm. See examples below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Possible additional arguments for <code>sumFct</code>  </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculates the sample size necessary to achieve a desired combined power value 
for the multiple contrast test. A summary function is used to combine 
the individual power values. The allocation ratios for the dose groups need to be
predefined and fixed (by default balanced allocations are assumed).<br></p>
<p>The function implements a simple bisection search algorithm to determine the target sample size. In case the upper and
lower bound (<code>upperN</code>, <code>lowerN</code>) do not contain the target sample size the algorithm automatically
adjusts these boundaries, but outputs a warning message. 
</p>


<h3>Value</h3>

<p>An object of class sampSize, with the following components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>samp.size</code></td>
<td>
<p>Vector of target sample size(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx.power</code></td>
<td>
<p>Combined Power achieved under the assumed scenario and sample size.</p>
</td>
</tr>
</table>
<h3>References</h3>

 
<p>Bornkamp B., Pinheiro J. C., and Bretz, F. (2009). MCPMod: An            
R Package for the Design and Analysis of Dose-Finding        
Studies, <em>Journal of Statistical Software</em>, <b>29</b>(7), 1–23
</p>
<p>Pinheiro, J. C., Bornkamp, B., and Bretz, F. (2006). Design and analysis of dose finding studies
combining multiple comparisons and modeling procedures, <em>Journal of Biopharmaceutical
Statistics</em>, <b>16</b>, 639–656
</p>


<h3>See Also</h3>

 <p><code>powCalc</code>, <code>powerMM</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# example from JBS paper p.651
doses &lt;- c(0,10,25,50,100,150)                                         
models &lt;- list(linear = NULL, emax = c(25),                            
               logistic = c(50, 10.88111), exponential=c(85),          
               betaMod=matrix(c(0.33,2.31,1.39,1.39), byrow=TRUE, nrow=2))
sampSize(models, doses, base = 0, maxEff = 0.4, sigma = 1,             
         upperN = 80, scal = 200, alpha = 0.05)
# with different summary function

sampSize(models, doses, base = 0, maxEff = 0.4, sigma = 1,             
         upperN = 90, scal = 200, sumFct = median, alpha = 0.05)

# with unbalanced allocations (twice as many patients in placebo group
# than in active dose groups)
sampSize(models, doses, base = 0, maxEff = 0.4, sigma = 1,            
       alpha = 0.05, upperN = 80, scal = 200, alRatio=c(2,1,1,1,1,1))
# iterates total sample size instead of sample size in smallest arm
# in this case no big difference
sampSize(models, doses, base = 0, maxEff = 0.4, sigma = 1,
         alpha = 0.05, upperN = 500, scal = 200, typeN = "total",
         alRatio=c(2,1,1,1,1,1))


# sample size calculation for general matrix of means
dvec &lt;- c(0, 10, 50, 100)                             
mu1 &lt;- c(1, 2, 2, 2)                                  
mu2 &lt;- c(1, 1, 2, 2)                                  
mu3 &lt;- c(1, 1, 1, 2)                                  
mMat &lt;- cbind(mu1, mu2, mu3)                          
dimnames(mMat)[[1]] &lt;- dvec                           
sampSize(muMat = mMat, doses = dvec, sigma = 1,       
       alpha = 0.05, upperN = 10, alRatio=c(2,2,1,1))

## End(Not run)
</code></pre>


</div>