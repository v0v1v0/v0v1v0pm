<div class="container">

<table style="width: 100%;"><tr>
<td>normn MA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multi-dimensional MA normalization for plate effect</h2>

<h3>Description</h3>

<p>Normalize data to minimize the difference among the subgroups of the samples generated by experimental factor such as multiple plates (batch effects)<br>
- the primary method is Multi-MA, but other fitting function, <em>f</em> in manuscript (e.g. loess) is available, too.<br>
This method is based on the assumptions stated below<br></p>

<ol>
<li>
<p> The geometric mean value of the samples in each subgroup (or plate) for a single target is ideally same as those from the other subgroups.
</p>
</li>
<li>
<p> The subgroup (or plate) effects that influence those mean values for multiple observed targets are dependent on the values themselves. (intensity dependent effects)
</p>
</li>
</ol>
<h3>Usage</h3>

<pre><code class="language-R">normn_MA(mD, expGroup, represent_FUN= function(x) mean(x, na.rm= T), 
        fitting_FUN= NULL, isLog= TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mD</code></td>
<td>
<p> a <code>matrix</code> of measured values in which columns are the measured molecules and rows are samples </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expGroup</code></td>
<td>
<p> a <code>vector</code> of experimental grouping variable such as plate. The length of codeexpGroup must be same as the number of rows of <code>mD</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>represent_FUN</code></td>
<td>
<p> a <code>function</code> that computes representative values for each experimental group (e.g. plate). The default is mean ignoring any NA </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitting_FUN</code></td>
<td>
 <p><code>NULL</code> or a <code>function</code> that fits to data in MA-coordinates. 
If it is <code>NULL</code> as the default, 'Multi-MA' method is employed. 
If a <code>function</code> is used, two arguments of <code>m_j</code> and <code>A</code> are required, which are <code class="reqn">\mathbf{m}_j</code> coordinate in <code class="reqn">M_d</code> and <code class="reqn">A</code> coordinate, respectively. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isLog</code></td>
<td>
<p> TRUE or FALSE, if the normalization should be conducted after log-transformation. The affinity proteomics data from suspension bead arrays is recommended to be normalized using the default, <code>isLog = TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The data after normalization in a <code>matrix</code>
</p>


<h3>Author(s)</h3>

<p>Mun-Gwan Hong &lt;<a href="mailto:mun-gwan.hong@scilifelab.se">mun-gwan.hong@scilifelab.se</a>&gt;</p>


<h3>References</h3>

<p>Hong M-G, Lee W, Pawitan Y, Schwenk JM (201?) 
Multi-dimensional normalization of plate effects for multiplexed applications
<em>unpublished</em>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(sba)
B &lt;- normn_MA(sba$X, sba$plate)		# Multi-MA normalization

# MA-loess normalization
B &lt;- normn_MA(sba$X, sba$plate, fitting_FUN= function(m_j, A) loess(m_j ~ A)$fitted)

# weighted linear regression normalization
B &lt;- normn_MA(sba$X, sba$plate, fitting_FUN= function(m_j, A) {
	beta &lt;- lm(m_j ~ A, weights= 1/A)$coefficients
	beta[1] + beta[2] * A
})

# robust linear regression normalization
if(any(search() == "package:MASS")) {	# excutable only when MASS package was loaded.
	B &lt;- normn_MA(sba$X, sba$plate, fitting_FUN= function(m_j, A) {
		beta &lt;- rlm(m_j ~ A, maxit= 100)$coefficients
		beta[1] + beta[2] * A
	})
}
</code></pre>


</div>