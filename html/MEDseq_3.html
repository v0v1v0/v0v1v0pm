<div class="container">

<table style="width: 100%;"><tr>
<td>dbs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the Density-based Silhouette</h2>

<h3>Description</h3>

<p>Computes the Density-based Silhouette for a 'soft' clustering assignment matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dbs(z,
    ztol = 1E-100,
    weights = NULL,
    summ = c("mean", "median"),
    clusters = NULL,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>A numeric matrix such that rows correspond to observations, columns correspond to clusters, and rows sum to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ztol</code></td>
<td>
<p>A small (single, numeric, non-negative) tolerance parameter governing whether small assignment probabilities are treated instead as crisp assignments. Defaults to <code>1E-100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>An optional numeric vector giving observation-specific weights for computing the (weighted) mean/median DBS (see <code>summ</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summ</code></td>
<td>
<p>A single character string indicating whether the (possibly weighted) <code>"mean"</code> (the default) or <code>"median"</code> DBS should be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusters</code></td>
<td>
<p>Optional/experimental argument for giving the indicator labels of the cluster assignments. Defaults to the MAP assignment derived from <code>z</code> when not supplied. Note that actually supplying the MAP assignment here is slightly less efficient than the <code>NULL</code> default and <strong>not</strong> advised.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Catches unused arguments.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following elements:
</p>

<dl>
<dt><code>silvals</code></dt>
<dd>
<p>A matrix where each row contains the cluster to which each observation belongs in the first column and the observation-specific DBS width in the second column.</p>
</dd>
<dt><code>msw</code></dt>
<dd>
<p>Depending on the value of <code>summ</code>, either the mean or median DBS width.</p>
</dd>
<dt><code>wmsw</code></dt>
<dd>
<p>Depending on the value of <code>summ</code>, either the weighted mean or weighted median DBS width.</p>
</dd>
</dl>
<h3>Note</h3>

<p>When calling <code>MEDseq_fit</code>, the <code>summ</code> argument can be passed via the <code>...</code> construct, in which case it governs both the <code>dbs</code> and <code>asw</code> criteria.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Menardi, G. (2011). Density-based silhouette diagnostics for clustering methods. <em>Statistics and Computing</em>, 21(3): 295-308.
</p>


<h3>See Also</h3>

<p><code>MEDseq_fit</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate a toy z matrix
z &lt;- abs(matrix(rnorm(50), ncol=2))
z &lt;- z/rowSums(z)

# Return the median DBS width
dbs(z, summ="median")$msw

# For real sequence data
data(mvad)

mod &lt;- MEDseq_fit(seqdef(mvad[,17:86]), G=11, modtype="UUN", weights=mvad$weight)

dbs(mod$z, weights=mvad$weight)
</code></pre>


</div>