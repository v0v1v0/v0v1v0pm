<div class="container">

<table style="width: 100%;"><tr>
<td>MFPCA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multivariate functional principal component analysis for functions on
different (dimensional) domains</h2>

<h3>Description</h3>

<p>This function calculates a multivariate functional principal component
analysis (MFPCA) based on i.i.d. observations <code class="reqn">x_1, \ldots, x_N</code> of a
multivariate functional data-generating process <code class="reqn">X = (X^{(1)}, \ldots
X^{(p)})</code> with elements <code class="reqn">X^{(j)} \in
L^2(\mathcal{T}_j)</code> defined on a domain
<code class="reqn">\mathcal{T}_j \subset IR^{d_j}</code>. In particular, the
elements can be defined on different (dimensional) domains. The results
contain the mean function, the estimated multivariate functional principal
components <code class="reqn">\hat \psi_1, \ldots, \hat \psi_M</code> (having the same structure
as <code class="reqn">x_i</code>), the associated eigenvalues <code class="reqn">\hat \nu_1 \geq \ldots \geq
\hat \nu_M &gt; 0</code> and the individual scores <code class="reqn">\hat \rho_{im} =
\widehat{&lt;x_i, \psi_m&gt;}</code>. Moreover,
estimated trajectories for each observation based on the truncated
Karhunen-Loeve representation </p>
<p style="text-align: center;"><code class="reqn">\hat x_i = \sum_{m = 1}^M \hat \rho_{im}
\hat \psi_m</code>
</p>
<p> are given
if desired (<code>fit = TRUE</code>). The implementation of the observations
<code class="reqn">x_i = (x_i^{(1)}, \ldots , x_i^{(p)}),~ i = 1 , \ldots, N</code>, the mean function and
multivariate functional principal components <code class="reqn">\hat \psi_1, \ldots, \hat
\psi_M</code> uses the <code>multiFunData</code> class, which is defined
in the package <span class="pkg">funData</span>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MFPCA(
  mFData,
  M,
  uniExpansions,
  weights = rep(1, length(mFData)),
  fit = FALSE,
  approx.eigen = FALSE,
  bootstrap = FALSE,
  nBootstrap = NULL,
  bootstrapAlpha = 0.05,
  bootstrapStrat = NULL,
  verbose = options()$verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mFData</code></td>
<td>
<p>A  <code>multiFunData</code> object containing the
<code>N</code> observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>The number of multivariate functional principal components to
calculate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uniExpansions</code></td>
<td>
<p>A list characterizing the (univariate) expansion that is
calculated for each element. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>An optional vector of weights, defaults to <code>1</code> for each
element. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a truncated multivariate Karhunen-Loeve
representation for the data is calculated based on the estimated scores and
eigenfunctions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx.eigen</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the eigenanalysis problem for
the estimated covariance matrix is solved approximately using the
<span class="pkg">irlba</span> package, which is much faster. If the number <code>M</code> of
eigenvalues to calculate is high with respect to the number of observations
in <code>mFData</code> or the number of estimated univariate eigenfunctions, the
approximation may be inappropriate. In this case, approx.eigen is set to
<code>FALSE</code> and the function throws a warning. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap</code></td>
<td>
<p>Logical. If <code>TRUE</code>, pointwise bootstrap confidence
bands are calculated for the multivariate functional principal components.
Defaults to <code>FALSE</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nBootstrap</code></td>
<td>
<p>The number of bootstrap iterations to use. Defaults to
<code>NULL</code>, which leads to an error, if <code>bootstrap = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrapAlpha</code></td>
<td>
<p>A vector of numerics (or a single number) giving the
significance level for bootstrap intervals. Defaults to <code>0.05</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrapStrat</code></td>
<td>
<p>A stratification variable for bootstrap. Must be a
factor of length <code>nObs(mFData)</code> or <code>NULL</code> (default). If
<code>NULL</code>, no stratification is made in the bootstrap resampling, i.e.
the curves are sampled with replacement. If <code>bootstrapStrat</code> is not
<code>NULL</code>, the curves are resampled with replacement within the groups
defined by <code>bootstrapStrat</code>, hence keeping the group proportions
fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function reports
extra-information about the progress (incl. timestamps). Defaults to
<code>options()$verbose</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Weighted MFPCA</h4>

<p>If the elements vary considerably in domain,
range or variation, a weight vector <code class="reqn">w_1 , \ldots, w_p</code> can be supplied
and the MFPCA is based on the weighted scalar product </p>
<p style="text-align: center;"><code class="reqn">&lt;&lt;f,g&gt;&gt;_w =
\sum_{j = 1}^p w_j \int_{\mathcal{T}_j} f^{(j)}(t) g^{(j)}(t) \mathrm{d}
t</code>
</p>
<p> and the
corresponding weighted covariance operator <code class="reqn">\Gamma_w</code>.</p>



<h4>Bootstrap</h4>

<p>If <code>bootstrap = TRUE</code>, pointwise bootstrap
confidence bands are generated for the multivariate eigenvalues <code class="reqn">\hat
\nu_1, \ldots, \hat \nu_M </code> as well as for multivariate functional principal
components <code class="reqn">\hat \psi_1, \ldots, \hat \psi_M</code>. The parameter <code>nBootstrap</code> gives the number of bootstrap
iterations. In each iteration, the observations are resampled on the level of
(multivariate) functions and the whole MFPCA is recalculated. In particular,
if the univariate basis depends on the data (FPCA approaches), basis
functions and scores are both re-estimated. If the basis functions are fixed
(e.g. splines), the scores from the original estimate are used to speed up
the calculations. The confidence bands for the eigenfunctions are calculated
separately for each element as pointwise percentile bootstrap confidence
intervals. Analogously, the confidence bands for the eigenvalues are also
percentile bootstrap confidence bands. The significance level(s) can be
defined by the <code>bootstrapAlpha</code> parameter, which defaults to 5%. As a
result, the <code>MFPCA</code> function returns a list <code>CI</code> of the same length
as <code>bootstrapAlpha</code>, containing the lower and upper bounds of the
confidence bands for the principal components as <code>multiFunData</code> objects
of the same structure as <code>mFData</code>. The confidence bands for the
eigenvalues are returned in a list <code>CIvalues</code>, containing the upper and
lower bounds for each significance level.</p>



<h4>Univariate Expansions</h4>

<p>The multivariate functional principal
component analysis relies on a univariate basis expansion for each element
<code class="reqn">X^{(j)}</code>. The univariate basis representation is calculated using
the <code>univDecomp</code> function, that passes the univariate functional
observations and optional parameters to the specific function. The univariate
decompositions are specified via the <code>uniExpansions</code> argument in the
<code>MFPCA</code> function. It is a list of the same length as the <code>mFData</code>
object, i.e. having one entry for each element of the multivariate functional
data. For each element, <code>uniExpansion</code> must specify at least the type of
basis functions to use. Additionally, one may add further parameters. The
following basis representations are supported: </p>
<ul>
<li>
<p> Given basis
functions. Then <code>uniExpansions[[j]] = list(type = "given", functions,
scores, ortho)</code>, where <code>functions</code> is a <code>funData</code> object on the
same domain as <code>mFData</code>, containing the given basis functions. The
parameters <code>scores</code> and <code>ortho</code> are optional. <code>scores</code> is an
<code>N x K</code> matrix containing the scores (or coefficients) of the observed
functions for the given basis functions, where <code>N</code> is the number of
observed functions and <code>K</code> is the number of basis functions. Note that
the scores need to be demeaned to give meaningful results. If scores are not
supplied, they are calculated using the given basis functions. The parameter
<code>ortho</code> specifies whether the given basis functions are orthonormal
<code>orhto = TRUE</code> or not <code>ortho = FALSE</code>. If <code>ortho</code> is not
supplied, the functions are treated as non-orthogonal. <code>scores</code> and
<code>ortho</code> are not checked for plausibility, use them at your own risk!
</p>
</li>
<li>
<p> Univariate functional principal component analysis. Then
<code>uniExpansions[[j]] = list(type = "uFPCA", nbasis, pve, npc, makePD)</code>,
where <code>nbasis,pve,npc,makePD</code> are parameters passed to the
<code>PACE</code> function for calculating the univariate functional
principal component analysis. </p>
</li>
<li>
<p> Basis functions expansions from the
package <span class="pkg">fda</span>. Then <code>uniExpansions[[j]] = list(type = "fda", ...)</code>,
where <code>...</code> are passed to <code>funData2fd</code>, which
heavily builds on <code>eval.fd</code>. If <span class="pkg">fda</span> is not available,
a warning is thrown. </p>
</li>
<li>
<p> Spline basis functions (not penalized). Then
<code>uniExpansions[[j]] = list(type = "splines1D", bs, m, k)</code>, where
<code>bs,m,k</code> are passed to the functions <code>univDecomp</code> and
<code>univExpansion</code>. For two-dimensional tensor product splines, use
<code>type = "splines2D"</code>. </p>
</li>
<li>
<p> Spline basis functions (with smoothness
penalty). Then <code>uniExpansions[[j]] = list(type = "splines1Dpen", bs, m,
k)</code>, where <code>bs,m,k</code> are passed to the functions <code>univDecomp</code>
and <code>univExpansion</code>. Analogously to the unpenalized case, use
<code>type = "splines2Dpen"</code> for 2D penalized tensor product splines. </p>
</li>
<li>
<p>Cosine basis functions. Use <code>uniExpansions[[j]] = list(type = "DCT2D",
qThresh, parallel)</code> for functions one two-dimensional domains (images) and
<code>type = "DCT3D"</code> for 3D images. The calculation is based on the discrete
cosine transform (DCT) implemented in the C-library <code>fftw3</code>. If this
library is not available, the function will throw  a warning. <code>qThresh</code>
gives the quantile for hard thresholding the basis coefficients based on
their absolute value. If <code>parallel = TRUE</code>, the coefficients for
different images are calculated in parallel.</p>
</li>
</ul>
<p> See <code>univDecomp</code>
and <code>univExpansion</code> for details.</p>



<h3>Value</h3>

<p>An object of class <code>MFPCAfit</code> containing the following
components: </p>
<table>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>A vector of estimated eigenvalues <code class="reqn">\hat \nu_1
  , \ldots , \hat \nu_M</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>functions</code></td>
<td>
<p>A
<code>multiFunData</code> object containing the estimated
multivariate functional principal components <code class="reqn">\hat \psi_1, \ldots, \hat
  \psi_M</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p> A matrix of dimension <code>N x M</code> containing the
estimated scores <code class="reqn">\hat \rho_{im}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vectors</code></td>
<td>
<p>A matrix
representing the eigenvectors associated with the combined univariate score
vectors. This might be helpful for calculating predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normFactors</code></td>
<td>
<p>The normalizing factors used for calculating the
multivariate eigenfunctions and scores. This might be helpful when
calculation predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanFunction</code></td>
<td>
<p>A multivariate functional
data object, corresponding to the mean function. The MFPCA is applied to
the de-meaned functions in <code>mFData</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>A
<code>multiFunData</code> object containing estimated
trajectories for each observation based on the truncated Karhunen-Loeve
representation and the estimated scores and eigenfunctions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CI</code></td>
<td>
<p>A
list of the same length as <code>bootstrapAlpha</code>, containing the pointwise
lower and upper bootstrap confidence bands for each eigenfunction and each
significance level in form of <code>multiFunData</code> objects
(only if <code>bootstrap = TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CIvalues</code></td>
<td>
<p>A list of the same
length as <code>bootstrapAlpha</code>, containing the lower and upper bootstrap
confidence bands for each eigenvalue and each significance level (only if
<code>bootstrap = TRUE</code>).</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>C. Happ, S. Greven (2018): Multivariate Functional Principal
Component Analysis for Data Observed on Different (Dimensional) Domains.
Journal of the American Statistical Association, 113(522): 649-659. DOI:
<a href="https://doi.org/10.1080/01621459.2016.1273115">doi:10.1080/01621459.2016.1273115</a>
</p>
<p>C. Happ-Kurz (2020): Object-Oriented Software for Functional
Data. Journal of Statistical Software, 93(5): 1-38. DOI:
<a href="https://doi.org/10.18637/jss.v093.i05">doi:10.18637/jss.v093.i05</a>
</p>


<h3>See Also</h3>

<p>See Happ-Kurz (2020. <a href="https://doi.org/10.18637/jss.v093.i05">doi:10.18637/jss.v093.i05</a>) for a general
introduction to the <span class="pkg">funData</span> package and it's interplay with
<span class="pkg">MFPCA</span>. This file also includes a case study on how to use
<code>MFPCA</code>. Useful functions: <code>multiFunData</code>,
<code>PACE</code>, <code>univDecomp</code>, <code>univExpansion</code>,
<code>summary</code>,
<code>plot</code>,
<code>scoreplot</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">oldPar &lt;- par(no.readonly = TRUE)

set.seed(1)

### simulate data (one-dimensional domains)
sim &lt;-  simMultiFunData(type = "split", argvals = list(seq(0,1,0.01), seq(-0.5,0.5,0.02)),
                        M = 5, eFunType = "Poly", eValType = "linear", N = 100)

# MFPCA based on univariate FPCA
uFPCA &lt;- MFPCA(sim$simData, M = 5, uniExpansions = list(list(type = "uFPCA"),
                                                                  list(type = "uFPCA")))
summary(uFPCA)
plot(uFPCA) # plot the eigenfunctions as perturbations of the mean
scoreplot(uFPCA) # plot the scores

# MFPCA based on univariate spline expansions
splines &lt;- MFPCA(sim$simData, M = 5, uniExpansions = list(list(type = "splines1D", k = 10),
                                                          list(type = "splines1D", k = 10)),
                 fit = TRUE) # calculate reconstruction, too
summary(splines)
plot(splines) # plot the eigenfunctions as perturbations of the mean
scoreplot(splines) # plot the scores

### Compare estimates to true eigenfunctions
# flip to make results more clear
uFPCA$functions &lt;- flipFuns(sim$trueFuns, uFPCA$functions)
splines$functions &lt;- flipFuns(sim$trueFuns, splines$functions)

par(mfrow = c(1,2))
plot(sim$trueFuns[[1]], main = "Eigenfunctions\n1st Element", lwd = 2)
plot(uFPCA$functions[[1]], lty = 2, add = TRUE)
plot(splines$functions[[1]], lty = 3, add = TRUE)

plot(sim$trueFuns[[2]], main = "Eigenfunctions\n2nd Element", lwd = 2)
plot(uFPCA$functions[[2]], lty = 2, add = TRUE)
plot(splines$functions[[2]], lty = 3, add = TRUE)
legend("bottomleft", c("True", "uFPCA", "splines"), lty = 1:3, lwd = c(2,1,1))

# Test reconstruction for the first 10 observations
plot(sim$simData[[1]], obs = 1:10, main = "Reconstruction\n1st Element", lwd = 2)
plot(splines$fit[[1]], obs = 1:10, lty = 2, col = 1, add = TRUE)

plot(sim$simData[[2]], obs = 1:10, main = "Reconstruction\n2nd Element", lwd = 2)
plot(splines$fit[[2]], obs = 1:10, lty = 2, col = 1, add = TRUE)
legend("bottomleft", c("True", "Reconstruction"), lty = c(1,2), lwd = c(2,1))

# MFPCA with Bootstrap-CI for the first 2 eigenfunctions
### ATTENTION: Takes long

splinesBoot &lt;- MFPCA(sim$simData, M = 2, uniExpansions = list(list(type = "splines1D", k = 10),
                                                          list(type = "splines1D", k = 10)),
                 bootstrap = TRUE, nBootstrap = 100, bootstrapAlpha = c(0.05, 0.1), verbose = TRUE)
summary(splinesBoot)
                                 
plot(splinesBoot$functions[[1]], ylim = c(-2,1.5))
plot(splinesBoot$CI$alpha_0.05$lower[[1]], lty = 2, add = TRUE)
plot(splinesBoot$CI$alpha_0.05$upper[[1]], lty = 2, add = TRUE)
plot(splinesBoot$CI$alpha_0.1$lower[[1]], lty = 3, add = TRUE)
plot(splinesBoot$CI$alpha_0.1$upper[[1]], lty = 3, add = TRUE)
abline(h = 0, col = "gray")
 
plot(splinesBoot$functions[[2]], ylim = c(-1,2.5))
plot(splinesBoot$CI$alpha_0.05$lower[[2]], lty = 2, add = TRUE)
plot(splinesBoot$CI$alpha_0.05$upper[[2]], lty = 2, add = TRUE)
plot(splinesBoot$CI$alpha_0.1$lower[[2]], lty = 3, add = TRUE)
plot(splinesBoot$CI$alpha_0.1$upper[[2]], lty = 3, add = TRUE)
abline(h = 0, col = "gray")
legend("topleft", c("Estimate", "95% CI", "90% CI"), lty = 1:3, lwd = c(2,1,1))

# Plot 95% confidence bands for eigenvalues
plot(1:2, splinesBoot$values, pch = 20, ylim = c(0, 1.5), 
     main = "Estimated eigenvalues with 95% CI",
     xlab = "Eigenvalue no.", ylab = "")
arrows(1:2, splinesBoot$CIvalues$alpha_0.05$lower,
       1:2, splinesBoot$CIvalues$alpha_0.05$upper,
       length = 0.05, angle = 90, code = 3)
points(1:2, sim$trueVals[1:2], pch = 20, col = 4)
legend("topright", c("Estimate", "True value"), pch = 20, col = c(1,4))


### simulate data (two- and one-dimensional domains)
### ATTENTION: Takes long

set.seed(2)
sim &lt;-  simMultiFunData(type = "weighted",
                 argvals = list(list(seq(0,1,0.01), seq(-1,1,0.02)), list(seq(-0.5,0.5,0.01))),
                 M = list(c(4,5), 20), eFunType = list(c("Fourier", "Fourier"), "Poly"),
                 eValType = "exponential", N = 150)

# MFPCA based on univariate spline expansions (for images) and univariate FPCA (for functions)
pca &lt;- MFPCA(sim$simData, M = 10,
             uniExpansions = list(list(type = "splines2D", k = c(10,12)),
                             list(type = "uFPCA")))
summary(pca)
plot(pca) # plot the eigenfunctions as perturbations of the mean
scoreplot(pca) # plot the scores

### Compare to true eigenfunctions
# flip to make results more clear
pca$functions &lt;- flipFuns(sim$trueFuns[1:10], pca$functions)

par(mfrow = c(5,2), mar = rep(2,4))
for(m in 2:6) # for m = 1, image.plot (used in plot(funData)) produces an error...
{
  plot(sim$trueFuns[[1]], main = paste("True, m = ", m), obs = m)
  plot(pca$functions[[1]], main = paste("Estimate, m = ", m), obs = m)
}

par(mfrow = c(1,1))
plot(sim$trueFuns[[2]], main = "Eigenfunctions (2nd element)", lwd = 2, obs=  1:5)
plot(pca$functions[[2]], lty = 2, add = TRUE, obs=  1:5)
legend("bottomleft", c("True", "MFPCA"), lty = 1:2, lwd = c(2,1))

par(oldPar)
</code></pre>


</div>