<div class="container">

<table style="width: 100%;"><tr>
<td>univDecomp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Univariate basis decomposition</h2>

<h3>Description</h3>

<p>This function calculates a univariate basis decomposition for a
(univariate) functional data object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">univDecomp(type, funDataObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A character string, specifying the basis for which the
decomposition is to be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>funDataObject</code></td>
<td>
<p>A <code>funData</code> object, representing the
(univariate) functional data samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further parameters, passed to the function for the
particular basis to use.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Functional data <code class="reqn">X_i(t)</code> can often be approximated by a linear
combination of basis functions <code class="reqn">b_k(t)</code> </p>
<p style="text-align: center;"><code class="reqn">X_i(t) = \sum_{k =
1}^K \theta_{ik} b_k(t), i = 1, \ldots, N.</code>
</p>
<p> The basis functions may be
prespecified (such as spline basis functions or Fourier bases) or can
be estimated from the data (e.g. by functional principal component
analysis) and are the same for all observations <code class="reqn">X_1(t), \ldots,
X_n(t)</code>. The coefficients (or scores) <code class="reqn">\theta_{ik}</code> reflect the
weight of each basis function <code class="reqn">b_k(t)</code> for the observed function
<code class="reqn">X_i(t)</code> and can be used to characterize the individual
observations.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>A matrix of scores (coefficients) for each
observation based on the prespecified basis functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>A
matrix containing the scalar products of the basis functions. Can be
<code>NULL</code> if the basis functions are orthonormal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ortho</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the basis functions are all
orthonormal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>functions</code></td>
<td>
<p>A functional data object, representing
the basis functions. Can be <code>NULL</code> if the basis functions are
not estimated from the data, but have a predefined form. See
Details.</p>
</td>
</tr>
</table>
<h3>Warning</h3>

<p>The options <code>type = "DCT2D"</code> and <code>type =
  "DCT3D"</code> have not been tested with ATLAS/MKL/OpenBLAS.
</p>


<h3>See Also</h3>

<p><code>MFPCA</code>, <code>univExpansion</code>,
<code>fpcaBasis</code>, <code>splineBasis1D</code>,
<code>splineBasis1Dpen</code>, <code>splineBasis2D</code>,
<code>splineBasis2Dpen</code>, <code>umpcaBasis</code>,
<code>fcptpaBasis</code>, <code>fdaBasis</code>,
<code>dctBasis2D</code>, <code>dctBasis3D</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># generate some data
dat &lt;- simFunData(argvals = seq(0,1,0.01), M = 5,
                  eFunType = "Poly", eValType = "linear", N = 100)$simData

# decompose the data in univariate functional principal components...
decFPCA &lt;- univDecomp(type = "uFPCA", funDataObject = dat, npc = 5)
str(decFPCA)

# or in splines (penalized)
decSplines &lt;- univDecomp(type = "splines1Dpen", funDataObject = dat) # use mgcv's default params
str(decSplines)
</code></pre>


</div>