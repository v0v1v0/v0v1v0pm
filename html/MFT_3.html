<div class="container">

<table style="width: 100%;"><tr>
<td>MFT.m_est</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MFT.m_est</h2>

<h3>Description</h3>

<p>Naive routine for the estimation of the order of serial correlation (m-dependence) in point processes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MFT.m_est(Phi, n = 200, maxlag = 10, alpha = 0.05, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>point process, vector of time stamps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>positive integer, number of life times used in segments for estimation of serial correlation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxlag</code></td>
<td>
<p>non-negative integer, maximal lag up to which serial correlations are calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>numeric, in (0,1), significance level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>logical, if TRUE, estimation procedure is plotted</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table><tr style="vertical-align: top;">
<td><code>m_est</code></td>
<td>
<p>non-negative integer, estimated order of serial correlation (m-dependence)</p>
</td>
</tr></table>
<h3>Author(s)</h3>

<p>Michael Messer, Stefan Albert, Solveig Plomer and Gaby Schneider
</p>


<h3>References</h3>

<p>Michael Messer, Kaue M. Costa, Jochen Roeper and Gaby Schneider (2017).
Multi-scale detection of rate changes in spike trains with weak dependencies. Journal of Computational Neuroscience, 42 (2), 187-201.
&lt;doi:10.1007/s10827-016-0635-3&gt;
</p>


<h3>See Also</h3>

<p><code>MFT.rate, plot.MFT, summary.MFT, MFT.variance, MFT.mean, MFT.peaks</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># 1. Independent life times (m=0)
set.seed(117)
n &lt;- 5000
Phi1 &lt;- cumsum(rexp(n,3.5))
Phi2 &lt;- cumsum(rexp(n,5))
Phi3 &lt;- cumsum(rexp(n,2))
Phi  &lt;- c(Phi1[Phi1&lt;=200],Phi2[Phi2&gt;200 &amp; Phi2&lt;400],Phi3[Phi3&gt;400 &amp; Phi3&lt;700])
MFT.m_est(Phi)

# 2. Point process simulated according to model
# X_i = a_0 X_i + a_1 X_{i-1} + ... a_m X_{i-m}
# with life times X_i gamma-distributed, 2 change points and true m = 3.
set.seed(210)
Tt &lt;- 3000
m &lt;- 3
a &lt;- c(1,0.5,0.25,0.125)
mu &lt;- c(0.5,1,2)/(sum(a))
sigmaX &lt;- sqrt(0.225/(sum(a^2)))
shape &lt;- mu^2/sigmaX^2; rate &lt;- mu/sigmaX^2
len &lt;- 10000
# build auxiliary processes
X1 &lt;- rgamma(len,rate=rate[1],shape=shape[1]); M1 &lt;- embed(X1,m+1)
v1 &lt;- cumsum(as.vector(M1 %*% a)); v1 &lt;- v1[v1&lt;Tt]
X2 &lt;- rgamma(len,rate=rate[2],shape=shape[2]); M2 &lt;- embed(X2,m+1)
v2 &lt;- cumsum(as.vector(M2 %*% a)); v2 &lt;- v2[v2&lt;Tt]
X3 &lt;- rgamma(len,rate=rate[3],shape=shape[3]); M3 &lt;- embed(X3,m+1)
v3 &lt;- cumsum(as.vector(M3 %*% a)); v3 &lt;- v3[v3&lt;Tt]
# build final point process with cps at 100 and 200
Phi &lt;- c(v1[v1&lt;Tt/3],v2[v2&gt;Tt/3 &amp; v2&lt;(2/3)*Tt],v3[v3&gt;(2/3)*Tt])
# estimate m
MFT.m_est(Phi)

</code></pre>


</div>