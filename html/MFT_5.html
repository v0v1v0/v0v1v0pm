<div class="container">

<table style="width: 100%;"><tr>
<td>MFT.rate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MFT.rate</h2>

<h3>Description</h3>

<p>The multiple filter test for rate change detection in point processes on the line.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MFT.rate(Phi, m = 0, cutout = TRUE, autoset.d_H = TRUE, S = NULL,
  E = NULL, d = NULL, H = NULL, alpha = 0.05,
  method = "asymptotic", sim = 10000, rescale = FALSE, Q = NA,
  blocksize = NA, perform.CPD = TRUE, print.output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>numeric vector of increasing events, input point process</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>non-negative integer, dependence parameter: serial corellation rho up to order m estimated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutout</code></td>
<td>
<p>logical, if TRUE for every point, for which the estimated rho becomes negative, the h-neighborhood of G (resp. R) is set to zero. This might only occur, if m &gt; 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autoset.d_H</code></td>
<td>
<p>logical, automatic choice of window size H and step size d</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>numeric, start of time interval, default: Smallest multiple of d that lies beyond min(Phi)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>numeric, end of time interval, default: Smallest multiple of d that lies beyond max(Phi), needs E &gt; S.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>numeric, &gt; 0, step size delta at which processes are evaluated. d is automatically set if autoset.d_H = TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>vector, window set H, all elements must be increasing ordered multiples of d, the smallest element must be &gt;= d and the largest =&lt; (T/2). H is automatically set if autoset.d_H = TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>numeric, in (0,1), significance level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>either "asymptotic", "bootstrap" or "fixed", defines how threshold Q is derived, default: "asymptotic", If "asymptotic": Q is derived by simulation of limit process L (Brownian motion); possible set number of simulations (sim), If "bootstrap": Q is derived by (Block)-Bootstrapping; possibly set number of simulations (sim) and blocksize (blocksize), If "fixed": Q may be set manually (Q)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>integer, &gt; 0, No of simulations of limit process (for approximation of Q), default = 10000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>
<p>logical, if TRUE statistic G is rescaled to statistic R, default = FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>numeric, rejection threshold, default: Q is simulated according to sim and alpha.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blocksize</code></td>
<td>
<p>NA or integer &gt;= 1, if method == 'bootstrap', blocksize determines the size of blocks (number of life times) for bootstrapping</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perform.CPD</code></td>
<td>
<p>logical, if TRUE change point detection algorithm is performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.output</code></td>
<td>
<p>logical, if TRUE results are printed to the console</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>invisible
</p>
<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>test statistic</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>rejection threshold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>how threshold Q was derived, see 'Arguments' for detailed description</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>number of simulations of the limit process (approximation of Q)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blocksize</code></td>
<td>
<p>size of blocks (number of life times) for bootstrapping (approximation of Q)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>
<p>states whether statistic G is rescaled to R</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>order of respected serial correlation (m-dependence)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CP</code></td>
<td>
<p>set of change points estmated by the multiple filter algorithm, increasingly ordered in time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rate</code></td>
<td>
<p>estimated mean rates between adjacent change points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>start of time interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>end of time interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tt</code></td>
<td>
<p>length of time interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>window set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>step size delta at which processes were evaluated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>significance level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutout</code></td>
<td>
<p>states whether cutout was used (see 'Arguments')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perform.CPD</code></td>
<td>
<p>logical, if TRUE change point detection algorithm was performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tech.var</code></td>
<td>
<p>list of technical variables with processes Phi and G_ht or R_ht</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of MFT which was performed: "rate"</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Michael Messer, Stefan Albert, Solveig Plomer and Gaby Schneider
</p>


<h3>References</h3>

<p>Michael Messer, Marietta Kirchner, Julia Schiemann, Jochen Roeper, Ralph Neininger and Gaby Schneider (2014).
A multiple filter test for the detection of rate changes in renewal processes with varying variance. The Annals of Applied Statistics 8(4): 2027-67
&lt;doi:10.1214/14-AOAS782&gt;
</p>
<p>Michael Messer, Kaue M. Costa, Jochen Roeper and Gaby Schneider (2017).
Multi-scale detection of rate changes in spike trains with weak dependencies. Journal of Computational Neuroscience, 42 (2), 187-201.
&lt;doi:10.1007/s10827-016-0635-3&gt;
</p>


<h3>See Also</h3>

<p><code>MFT.variance, MFT.m_est, plot.MFT, summary.MFT, MFT.mean, MFT.peaks</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Rate change detection in Poisson process 
# with three change points (at t = 250, 600 and 680)
set.seed(0)
Phi1 &lt;- runif(rpois(1,lambda=390),0,250)
Phi2 &lt;- runif(rpois(1,lambda=380),250,600)
Phi3 &lt;- runif(rpois(1,lambda=200),600,680)
Phi4 &lt;- runif(rpois(1,lambda=400),680,1000)
Phi  &lt;- sort(c(Phi1,Phi2,Phi3,Phi4)) 
mft  &lt;- MFT.rate(Phi)
plot(mft)


</code></pre>


</div>