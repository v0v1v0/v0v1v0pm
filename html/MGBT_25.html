<div class="container">

<table style="width: 100%;"><tr>
<td>RthOrderPValueOrthoT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> P-value for the Rth Order Statistic </h2>

<h3>Description</h3>

<p>Compute the p-value for the <code class="reqn">r</code>th order statistic
</p>
<p style="text-align: center;"><code class="reqn">\eta(r,n) = \frac{x_{[r:n]} - \mathrm{mean}\{x_{[(r+1)\rightarrow n:n]}\}}
                 {\sqrt{\mathrm{var}\{x_{[(r+1)\rightarrow n:n]}\}}}\mbox{.}</code>
</p>

<p>This function is the cumulative distribution function of the Grubbs–Beck statistic (<code>eta</code> = <code class="reqn">GB_r(p)</code>). In distribution notation, this is equivalent to saying <code class="reqn">F(GB_r)</code> for nonexceedance probability <br><code class="reqn">F \in (0,1)</code>. The inverse or quantile function <code class="reqn">GB_r(F)</code> is <code>CritK</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">RthOrderPValueOrthoT(n, r, eta, n.sim=10000, silent=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of observations;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The number of truncated observations; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>The pseudo-studentized magnitude of <code class="reqn">r</code>th smallest observation;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.sim</code></td>
<td>
<p>The sample size to attempt a Monte Carlo integration in case the numerical integration via <code>integrate()</code> encounters a divergent integral; and</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>A logical controlling the silence of <code>try</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The value a two-column <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>matrix</code>.
</p>


<h3>Note</h3>

<p>The extension to Monte Carlo integration in event of failure of the numerical integration an extension is by WHA. The <b>Note</b> for <code>MGBT</code> provides extensive details in the context of a practical application.
</p>
<p>Note that in conjunction with <code>RthOrderPValueOrthoT</code>, TAC provided an enhanced numerical integration interface (<code>integrateV()</code>) to <code>integrate()</code> built-in to <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>. In fact, all that TAC did was wrap a vectorization scheme using <code>sapply()</code> on top of <code>peta</code>. The issue is that <code>peta</code> was not designed to be vectorized. WHA has simply inserted the <code>sapply</code> <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> idiom inside <code>peta</code> and hence vectorizing it and removed the need in the <span class="pkg">MGBT</span> package for the <code>integrateV()</code> function in the TAC sources.
</p>
<p>TAC named this function with the <code>Kth</code> order. In code, however, TAC uses the variable <code>r</code>. WHA has migrated all references to <code>Kth</code> to <code>Rth</code> for systematic consistency. Hence, this function has been renamed to <code>RthOrderPValueOrthoT</code>.
</p>
<p>TAC also provides a <code>KthOrderPValueOrthoTb</code> function and notes that it employs simple Gaussian quadrature to compute the integral much more quickly. However, it is slightly less accurate for tail probabilities. The Gaussian quadrature is from a function <code>gauss.quad.prob()</code>, which seems to not be found in the TAC sources given to WHA.
</p>


<h3>Author(s)</h3>

<p> W.H. Asquith consulting T.A. Cohn sources </p>


<h3>Source</h3>

<p><code>LowOutliers_jfe(R).txt</code>, <code>LowOutliers_wha(R).txt</code>, <code>P3_089(R).txt</code>—<br>
Named <code>KthOrderPValueOrthoT</code> + <code>KthOrderPValueOrthoTb</code>
</p>


<h3>References</h3>

<p>Cohn, T.A., 2013–2016, Personal communication of original R source code: U.S. Geological Survey, Reston, Va.
</p>


<h3>See Also</h3>

<p><code>MGBT</code>, <code>CritK</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Running next line without the $value will show:
#0.001000002 with absolute error &lt; 1.7e-05 # This is output from the integrate()
# function, which means that the numerical integration worked.
RthOrderPValueOrthoT(58, 2, -3.561143)$value


# Long CPU time
CritK(58, 2, RthOrderPValueOrthoT(58, 2, -3.561143)$value)
#[1] -3.561143  # Therefore CritK() is the inverse of this function.


# Long CPU time
# Monte Carlo distribution of rth pseudo-studentized order statistic (TAC note)
testRthOrderPValueOrthoT &lt;- function(nrep=1E4, r=2, n=100,
               test_quants = c(0.05,0.1,0.5,0.9,0.95),  ndigits=3, seed=1) {
   set.seed(seed)
   z &lt;- replicate(nrep, { x &lt;- sort(rnorm(n)); xr &lt;- x[r]; x2 &lt;- x[(r+1):n]
                         (xr - mean(x2))/sqrt(var(x2)) })
     res &lt;- sapply(quantile(z, test_quants), function(q) {
                 c(q, RthOrderPValueOrthoT(n,r,q)$value) })
   round(res,ndigits)
}

nsim &lt;- 1E4
for(n in 50) {   # original TAC sources had c(10,15,25,50,100,500)
   for(r in 5) { # original TAC sources had 1:min(10,floor(n/2))
      message("n=",n, " and r=",r)
      print(testRthOrderPValueOrthoT(nrep=nsim, n=n, r=r))
   }
}
# Output like this will be seen
# n=50 and r=5
#         5%    10%    50%    90%    95%
#[1,] -2.244 -2.127 -1.788 -1.523 -1.460
#[2,]  0.046  0.096  0.499  0.897  0.946
# that shows simulated percentages near the theoretical

# To get the MSE of the results (TAC note). See WHA note on a change below and
# it is suspected that TAC's "tests" might have been fluid in the sense that
# he would modify as needed and did not fully design as Examples for end users.
rr &lt;- rep(0,10)
for(n in 50) {   # original TAC sources had c(10,15,25,50,100,500)
   for(r in 5) { # original TAC sources had 1:min(10,floor(n/2))
      message("n=",n, " and r=",r)
      for(i in 1:10) { # The [1,1] is WHA addition to get function to run.
         # extract the score for the 5% level
         rr[i] &lt;- testRthOrderPValueOrthoT(nrep=nsim, n=n, r=r, seed=i)[1,1]
      }
      message("var (MSE):", sqrt(var(rr/100)))
   }
}
# Output like this will be seen
# n=50 and r=5
# var (MSE):6.915361322608e-05 


#  Long CPU time
#  Monte Carlo computation of critical values for special cases (TAC note)
CritValuesMC &lt;-
function(nrep=50, kvs=c(1,3,0.25,0.5), n=100, ndigits=3, seed=1,
         test_quants=c(0.01,0.10,0.50)) {
   set.seed(seed)
   k_values &lt;- ifelse(kvs &gt;= 1, kvs, ceiling(n*kvs))
   z  &lt;- replicate(nrep, {
      x &lt;- sort(rnorm(n))
      sapply(k_values, function(r) {
          xr &lt;- x[r]; x2 &lt;- x[(r+1):n]
         (xr-mean(x2)) / sqrt(var(x2)) })  })
   res &lt;- round(apply(z, MARGIN=1, quantile, test_quants), ndigits)
   colnames(res) &lt;- k_values; return(res)
}

# TAC example. Note that z acquires its square dimension from test_quants
# but Vr is used in the sapply(). WHA has reset Vr to
n=100; nrep=10000; test_quants=c(.05,.5,1); Vr=1:10 # This Vr by TAC
z &lt;- CritValuesMC(n=n, nrep=nrep, test_quants=test_quants)
Vr &lt;- 1:length(z[,1]) # WHA reset of Vr to use TAC code below. TAC Vr bug?
HH &lt;- sapply(Vr, function(r) RthOrderPValueOrthoT(n, r, z[1,r])$value)
TT &lt;- sapply(Vr, function(r) RthOrderPValueOrthoT(n, r, z[2,r])$value) #
</code></pre>


</div>