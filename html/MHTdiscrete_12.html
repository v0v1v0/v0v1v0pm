<div class="container">

<table style="width: 100%;"><tr>
<td>MixBonf.p.adjust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The adjusted p-values for Mixed Bonferroni single-step FWER controlling procedure.</h2>

<h3>Description</h3>

<p>The function for calculating the adjusted p-values based on original available p-values and the attaianble p-values for the discrete test statistics.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MixBonf.p.adjust(pc, pd, pd.set, alpha, make.decision)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pc</code></td>
<td>
<p>numeric vector of the available p-values (possibly with <code>NA</code>s) for the continuous test statistics. Any other R is coerced by <code>as.numeric</code>. Same as in <code>p.adjust</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pd</code></td>
<td>
<p>numeric vector of the available p-values (possibly with <code>NA</code>s) for the discrete test statistics. Any other R is coerced by <code>as.numeric</code>. Same as in <code>p.adjust</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pd.set</code></td>
<td>
<p>a list of numeric vectors, where each vector is the vector of all attainable p-values containing the available p-value for the corresponding hypothesis for discrete data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>significant level used to compare with adjusted p-values to make decisions, the default value is 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.decision</code></td>
<td>
<p>logical; if  <code>TRUE</code>, then the output include the decision rules compared adjusted p-values with significant level <code class="reqn">\alpha</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector of the adjusted p-values (of the same length as <code>p</code>) if  <code>make.decision = FALSE</code>, or a list including original p-values, adjusted p-values and decision rules if <code>make.decision = TRUE</code>.
</p>


<h3>Note</h3>

<p>The arguments include three parts, the available p-values need to be reorganized in advance. Gather all available p-values for continuous data as <code>pc</code>, and all available p-values for discrete data as <code>pd</code>. The attainable p-value refers to the element of domain set of p-value for the corresponding hypothesis for discrete test statistics, the p-value can only take finite values bewtween 0 and 1, that is, the attainable p-values for discrete case are finite and countable, so we can assign them in a finite list <code>pd.set</code>. The function returns the  adjusted p-values with the first part for continuous data of the same length as <code>pc</code>, and second part for discrete data of the same length as <code>pd</code>
</p>


<h3>Author(s)</h3>

<p>Yalin Zhu
</p>


<h3>References</h3>

<p>Zhu, Y., &amp; Guo, W. (2017).
Familywise error rate controlling procedures for discrete data
<em>arXiv preprint</em> arXiv:1711.08147.
</p>


<h3>See Also</h3>

<p><code>Tarone.p.adjust</code>,  <code>MBonf.p.adjust</code>,  <code>p.adjust</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">pd &lt;- c(pbinom(1,8,0.5),pbinom(1,5,0.75)); pc &lt;- c(0.04, 0.1)
pd.set &lt;-list(pbinom(0:8,8,0.5),pbinom(0:5,5,0.75))
MixBonf.p.adjust(pc,pd,pd.set)
## Compare with the traditional Bonferroni adjustment
p.adjust(c(pc,pd),method = "bonferroni")
</code></pre>


</div>