<div class="container">

<table style="width: 100%;"><tr>
<td>aggregate_for_mims</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate over epoch to get numerically integrated values.</h2>

<h3>Description</h3>

<p><code>aggregate_for_mims</code> returns a dataframe with integrated values by
trapzoidal method over each epoch for each column. The epoch start time will
be used as timestamp in the first column.
</p>


<h3>Usage</h3>

<pre><code class="language-R">aggregate_for_mims(df, epoch, method = "trapz", rectify = TRUE, st = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>dataframe of accelerometer data in mhealth format. First column
should be timestamps in POSIXt format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epoch</code></td>
<td>
<p>string. Any format that is acceptable by argument <code>breaks</code>
in method <code>cut.POSIXt</code>.For example, "1 sec", "1 min", "5
secs", "10 mins".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>string. Integration methods. Supported strings include:
"trapz", "power", "sum", "meanBySecond", "meanBySize". Default is "trapz".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rectify</code></td>
<td>
<p>logical. If TRUE, input data will be rectified before
integration. Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the epochs generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate epochs. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function accepts a dataframe (in mhealth accelerometer data format) and
computes its aggregated values over each fixed epoch using different
integration methods (default is trapzoidal method, other methods are not used
by mims unit algorithm) for each value columns. The returned dataframe will
have the same number of columns as input dataframe, and have the same
datetime format as input dataframe in the timestamp column. The trapzoidal
method used in the function is based on <code>trapz</code>.
</p>


<h3>Value</h3>

<p>dataframe. The returned dataframe will have the same format as input
dataframe.
</p>


<h3>How is it used in mims-unit algorithm?</h3>

<p>This function is used in
mims-unit algorithm after filtering (<code>iir</code>). The filtered
signal will be rectified and integrated to get mims unit values for each
axis using this function.
</p>


<h3>Note</h3>

<p>If <code>epoch</code> argument is not provided or is <code>NULL</code>, the
function will treat the input dataframe as a single epoch.
</p>
<p>If the number of samples in one segment is less than 90
samples, the aggregation result will be -1 (marker of invalid value).
</p>


<h3>See Also</h3>

<p><code>aggregate_for_orientation</code> for aggregating to get
accelerometer orientation estimation for each epoch.
</p>
<p>Other aggregate functions: 
<code>aggregate_for_orientation()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # sample data
  df = sample_raw_accel_data
  head(df)

  # epoch set to 5 seconds, and method set to "trapz"
  aggregate_for_mims(df, epoch = '5 sec', method='trapz')

  # epoch set to 1 second, method set to "sum"
  aggregate_for_mims(df, epoch = '1 sec', method='sum')

  # epoch set to 1 second, and st set to be 1 second before the start time of the data
  # so the first segment will only include data for 1 second, therefore the resulted
  # aggregated value for the first segment will be -1 (invalid) because the
  # samples are not enough. And the second segment starts from 11:00:01, instead
  # of 11:00:02 as shown in prior example,
  aggregate_for_mims(df, epoch = '1 sec', method='sum', st=df[1,1] - 1)
</code></pre>


</div>