<div class="container">

<table style="width: 100%;"><tr>
<td>aggregate_for_orientation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate over epoch to get estimated accelerometer orientation.</h2>

<h3>Description</h3>

<p><code>aggregate_for_orientation</code> returns a dataframe with accelerometer
orientations estimated by
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1241424">Mizell,
2003</a> over each epoch (see <code>compute_orientation</code>). The epoch
start time will be used as timestamp in the first column.
</p>


<h3>Usage</h3>

<pre><code class="language-R">aggregate_for_orientation(
  df,
  epoch,
  estimation_window = 2,
  unit = "deg",
  st = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>dataframe. Input accelerometer data in mhealth format. First column
should be timestamps in POSIXt format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epoch</code></td>
<td>
<p>string. Any format that is acceptable by argument <code>breaks</code>
in method <code>cut.POSIXt</code>.For example, "1 sec", "1 min", "5
secs", "10 mins".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimation_window</code></td>
<td>
<p>number. Duration in seconds to be used to estimate
orientation within each epoch. Default is 2 (seconds), as suggested by
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1241424">Mizell,
2003</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit</code></td>
<td>
<p>string. The unit of orientation angles. Can be "deg" (degree) or
"rad" (radian). Default is "deg".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the epochs generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate epochs. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function accepts a dataframe (in mhealth accelerometer data format) and
computes the estimated acclerometer orientations (in x, y, and z angles) over
each fixed epoch. The returned dataframe will have the same format as input
dataframe, including four columns, and have the same datetime format as input
dataframe in the timestamp column. The orientation estimation method used in
the function is based on
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1241424">Mizell,
2003</a>.
</p>


<h3>Value</h3>

<p>dataframe. The returned dataframe will have the same format as input
dataframe.
</p>


<h3>How is it used in mims-unit algorithm?</h3>

<p>This function is used in
mims-unit algorithm after extrapolation (<code>extrapolate</code>). The
extrapolated signal will be estimated to get orientation angles using this
function.
</p>


<h3>Note</h3>

<p>If <code>epoch</code> argument is not provided or is <code>NULL</code>, the
function will treat the input dataframe as a single epoch.
</p>
<p>If the number of samples in an epoch is less than 90
would be NaN (invalid) for this epoch.
</p>


<h3>See Also</h3>

<p><code>aggregate_for_mims</code> for aggregating to get integrated
values for each axis for each epoch.
</p>
<p>Other aggregate functions: 
<code>aggregate_for_mims()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Use sample input data
  df = sample_raw_accel_data
  head(df)

  # set epoch to 1 second and unit to degree
  # last epoch does not have enough samples to estimate orientation angles.
  aggregate_for_orientation(df, epoch='1 sec', unit='deg')

  # set epoch to 2 seconds and unit to radian
  # last epoch does not have enough samples to estimate orientation angles.
  aggregate_for_orientation(df, epoch='2 sec', unit='rad')

  # epoch set to 2 seconds, and st set to be 1 second before the start time of the data
  # so the first segment will only include data for 1 second, therefore the resulted
  # aggregated value for the first segment will be -1 (invalid) because the
  # samples are not enough. And the second segment starts from 11:00:01, instead
  # of 11:00:01 as shown in prior example,
  aggregate_for_orientation(df, epoch = '1 sec', unit='rad', st=df[1,1] - 1)

</code></pre>


</div>