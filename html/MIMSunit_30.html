<div class="container">

<table style="width: 100%;"><tr>
<td>mims_unit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Monitor Independent Motion Summary unit (MIMS-unit)</h2>

<h3>Description</h3>

<p><code>mims_unit</code> computes the Monitor Independent Motion Summary unit for the
input multi-channel accelerometer signal. The input signal can be from
devices of any sampling rate and dynamic range. Please refer to the
manuscript for detailed description of the algorithm. Please refer to
functions for the intermediate steps: <code>extrapolate</code> for
extrapolation, <code>iir</code> for filtering,
<code>aggregate_for_mims</code> for aggregation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mims_unit(
  df,
  before_df = NULL,
  after_df = NULL,
  epoch = "5 sec",
  dynamic_range,
  output_mims_per_axis = FALSE,
  use_gui_progress = FALSE,
  st = NULL,
  use_snapshot_to_check = FALSE
)

mims_unit_from_files(
  files,
  epoch = "5 sec",
  dynamic_range,
  output_mims_per_axis = FALSE,
  use_gui_progress = FALSE,
  use_snapshot_to_check = FALSE,
  file_type = "mhealth",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>dataframe. Input multi-channel accelerometer signal. The
first column should be the time component. The accelerometer data values
(typically starting from the second column) should be in <code class="reqn">g</code> (per <code class="reqn">9.81m/s^2</code>) unit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>before_df</code></td>
<td>
<p>dataframe. The multi-channel accelerometer signal comes
before the input signal to be prepended to the input signal during
computation. This is used to eliminate the edge effect during extrapolation
and filtering. If it is <code>NULL</code>, algorithm will run directly on the
input signal. Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>after_df</code></td>
<td>
<p>dataframe. The multi-channel accelerometer signal comes after
the input signal to be append to the input signal. This is used to
eliminate the edge effect during extrapolation and filtering. If it is
<code>NULL</code>, algorithm will run directly on the input signal. Default is
NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epoch</code></td>
<td>
<p>string. Any format that is acceptable by argument <code>breaks</code>
in method <code>cut.POSIXt</code>.For example, "1 sec", "1 min", "5
sec", "10 min". Default is "5 sec".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dynamic_range</code></td>
<td>
<p>numerical vector. The dynamic ranges of the input
signal. Should be a 2-element numerical vector. <code>c(low, high)</code>, where
<code>low</code> is the negative max value the device can reach and <code>high</code>
is the positive max value the device can reach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_mims_per_axis</code></td>
<td>
<p>logical. If it is TRUE, the output MIMS-unit
dataframe will have MIMS-unit values for each axis from the third column.
Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_gui_progress</code></td>
<td>
<p>logical. If it is TRUE, show GUI progress bar on
windows platform. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the epochs generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate epochs. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_snapshot_to_check</code></td>
<td>
<p>logical. If TRUE, the function will use the first
100 rows or 10
the algorithm will use all data to check timestamp duplications. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>files</code></td>
<td>
<p>character vector. A list of csv filepaths for raw accelerometer
data organized in order to be processed. The data should be consecutive in
timestamps. A typical case is a set of hourly or daily files for
continuous accelerometer sampling. For a single file, please wrap the filepath
in a vector 'c(filepath)'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file_type</code></td>
<td>
<p>character. "mhealth" or "actigraph". The type of the csv files
that store the raw accelerometer data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed to the import function when reading
in the data from the files.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>dataframe. The MIMS-unit dataframe. The first column is the start
time of each epoch in POSIXct format. The second column is the MIMS-unit
value for the input signal. If <code>output_mims_per_axis</code> is TRUE, the
third column and then are the MIMS-unit values for each axis of the input
signal.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This is the main entry of
MIMS-unit algorithm.
</p>


<h3>Note</h3>

<p>This function is a wrapper function for the low-level
<code>custom_mims_unit</code> function. It has set internal parameters as
described in the manuscript. If you want to run customized algorithm for
MIMSunit or if you want to develop better algorithms based on MIMS-unit
algorithm, please use function <code>custom_mims_unit</code> where all
parameters are tunable.
</p>
<p><code>before_df</code> and <code>after_df</code> are often set when the accelerometer
data are divided into files of smaller chunk.
</p>
<p>Please make sure the input data do not contain duplicated timestamps. See
more information about this <a href="https://github.com/mHealthGroup/MIMSunit/issues/32">issue</a>.
Otherwise the computation will stop.
</p>


<h3>See Also</h3>

<p>Other Top level API functions: 
<code>custom_mims_unit()</code>,
<code>sensor_orientations()</code>,
<code>shiny_app()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Use sample data for testing
  df = sample_raw_accel_data

  # compute mims unit values and output axial values
  output = mims_unit(df, epoch = '1 sec', dynamic_range=c(-8, 8), output_mims_per_axis=TRUE)
  head(output)
  # Use sample mhealth file for testing
  filepaths = c(
    system.file('extdata', 'mhealth.csv', package='MIMSunit')
  )

  # Test with multiple files
  output = mims_unit_from_files(filepaths, epoch = "1 sec", dynamic_range = c(-8, 8))
  head(output)
</code></pre>


</div>