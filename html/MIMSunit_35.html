<div class="container">

<table style="width: 100%;"><tr>
<td>segment_data</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Segment input dataframe into windows as specified by breaks.
<code>segment_data</code> segments the input sensor dataframe into
epoch windows with length specified in breaks.</h2>

<h3>Description</h3>

<p>This function accepts a dataframe of multi-channel signal, segments it
into epoch windows with length specified in breaks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">segment_data(df, breaks, st = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>dataframe. Input dataframe of the multi-channel signal. The first
column is the timestamps in POSXlct format and the following columns are
accelerometer values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>character. An epoch length character that can be accepted by
cut.breaks function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the breaks generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate breaks. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>dataframe. The same format as the input dataframe, but with an extra
column "SEGMENT" in the end specifies the epoch window a sample belongs to.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a utility
function that was used in various part in the algorithm whenever we need to
segment a dataframe, e.g., before aggregating values over epoch windows.
</p>


<h3>See Also</h3>

<p>Other utility functions: 
<code>clip_data()</code>,
<code>cut_off_signal()</code>,
<code>interpolate_signal()</code>,
<code>parse_epoch_string()</code>,
<code>sampling_rate()</code>,
<code>simulate_new_data()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Use sample data
  df = sample_raw_accel_data

  # segment data into 1 minute segments
  output = segment_data(df, "1 min")

  # check the 3rd segment, each segment would have 1 minute data
  summary(output[output['SEGMENT'] == 3,])

  # segment data into 15 second segments
  output = segment_data(df, "15 sec")

  # check the 1st segment, each segment would have 15 second data
  summary(output[output['SEGMENT'] == 1,])

  # segment data into 1 hour segments
  output = segment_data(df, "1 hour")

  # because the input data has only 15 minute data
  # there will be only 1 segment in the output
  unique(output['SEGMENT'])
  summary(output)

  # use manually set start time
  output = segment_data(df, "15 sec", st='2016-01-15 10:59:50.000')

  # check the 1st segment, because the start time is 10 seconds before the
  # start time of the actual data, the first segment will only include 5 second
  # data.
  summary(output[output['SEGMENT'] == 1,])
</code></pre>


</div>