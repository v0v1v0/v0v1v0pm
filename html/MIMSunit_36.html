<div class="container">

<table style="width: 100%;"><tr>
<td>sensor_orientations</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimates sensor orientation</h2>

<h3>Description</h3>

<p><code>sensor_orientations</code> estimates the orientation angles for the input
multi-channel accelerometer signal. The input signal can be from devices of
any sampling rate and dynamic range. Please refer to function
<code>compute_orientation</code> for the implementation of the estimation
algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sensor_orientations(
  df,
  before_df = NULL,
  after_df = NULL,
  epoch = "5 sec",
  dynamic_range,
  st = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>dataframe. Input multi-channel accelerometer signal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>before_df</code></td>
<td>
<p>dataframe. The multi-channel accelerometer signal comes
before the input signal to be prepended to the input signal during
computation. This is used to eliminate the edge effect during extrapolation
and filtering. If it is <code>NULL</code>, algorithm will run directly on the
input signal. Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>after_df</code></td>
<td>
<p>dataframe. The multi-channel accelerometer signal comes after
the input signal to be append to the input signal. This is used to
eliminate the edge effect during extrapolation and filtering. If it is
<code>NULL</code>, algorithm will run directly on the input signal. Default is
NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epoch</code></td>
<td>
<p>string. Any format that is acceptable by argument <code>breaks</code>
in method <code>cut.POSIXt</code>.For example, "1 sec", "1 min", "5
sec", "10 min". Default is "5 sec".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dynamic_range</code></td>
<td>
<p>numerical vector. The dynamic ranges of the input
signal. Should be a 2-element numerical vector. <code>c(low, high)</code>, where
<code>low</code> is the negative max value the device can reach and <code>high</code>
is the positive max value the device can reach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the epochs generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate epochs. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>dataframe. The orientation dataframe. The first column is the start
time of each epoch in POSIXct format. The second to fourth columns are the
orientation angles.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This is not included in the
official MIMS-unit algorithm nor the manuscript, but we found it is useful
to know the sensor orientations in addition to the summary of movement.
</p>


<h3>Note</h3>

<p>This function interpolates and extrapolates the signal before
estimating the orientation angles.
</p>
<p><code>before_df</code> and <code>after_df</code> are often set when the accelerometer
data are divided into files of smaller chunk.
</p>


<h3>See Also</h3>

<p>Other Top level API functions: 
<code>custom_mims_unit()</code>,
<code>mims_unit()</code>,
<code>shiny_app()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Use sample data for testing
  df = sample_raw_accel_data

  # compute sensor orientation angles
  sensor_orientations(df, epoch = '2 sec', dynamic_range=c(-8, 8))

  # compute sensor orientation angles with different epoch length
  output = sensor_orientations(df, epoch = '1 sec', dynamic_range=c(-8, 8))
  head(output)
</code></pre>


</div>