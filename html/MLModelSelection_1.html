<div class="container">

<table style="width: 100%;"><tr>
<td>MLModelSelectionMCMC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model estimation for multivariate longitudinal models.</h2>

<h3>Description</h3>

<p>Using MCMC procedure to generate posterior samples and provide AIC, BIC, DIC, MPL, MSPE, and predicted values.</p>


<h3>Usage</h3>

<pre><code class="language-R">MLModelSelectionMCMC(Num.of.iterations, list.Data, list.InitialValues, list.HyperPara, 
	list.UpdatePara, list.TuningPara)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Num.of.iterations</code></td>
<td>
<p>Number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.Data</code></td>
<td>
<p><em>List</em> of data set containing response <code class="reqn">Y</code>, design matrix <code class="reqn">X</code>, avialable time points for each subject, GARP model, and ISD model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.InitialValues</code></td>
<td>
<p><em>List</em> of initial values for parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.HyperPara</code></td>
<td>
<p><em>List</em> of given hyperparameters in priors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.UpdatePara</code></td>
<td>
<p>Determine which parameter will be updated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.TuningPara</code></td>
<td>
<p>Provide turning parameters in proposal distributions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We set the subject <code class="reqn">i</code> (<code class="reqn">i=1, \ldots, N</code>) has <code class="reqn">K</code> continuous responses at each time point <code class="reqn">t</code> (<code class="reqn">t=1, \ldots, n_i</code>). Assume that the measurement times are common across subjects, but not necessarily equally-spaced. Let <code class="reqn">{y}_{it} = (y_{it1}, \ldots, y_{itK})</code> denote the response vector containing <code class="reqn">K</code> continuous responses for <code class="reqn">i</code>th subject at time <code class="reqn">t</code> along with a <code class="reqn">p\times 1</code> vectof of covariates, <code class="reqn">{x}_{it} = (x_{it1}, \ldots, x_{itp})</code>. An efficient Gibbs sampling algorithm is developed for model estimation in the multivariate longitudinal model given by
</p>
<p style="text-align: center;"><code class="reqn">
y_{i1k}  = {x}'_{it}{\beta}_k + e_{i1k}, t=1;
</code>
</p>

<p style="text-align: center;"><code class="reqn">
y_{itk}  = {x}'_{it}{\beta}_k + \sum_{g=1}^K\sum_{j=1}^{t-1} \phi_{itj, kg} (y_{ijg}-x'_{ij}{\beta}_g)+ e_{itk},  t\geq 2,
</code>
</p>

<p>where <code class="reqn">{\beta}_k = (\beta_{k1}, \ldots, \beta_{kp})'</code> is a vector of regression coefficients of length <code class="reqn">p</code>, <code class="reqn">\phi_{itj, kg}</code> is a generalized autoregressive parameter (GARP) to explain the serial dependence of responses across time. Moreover, 
</p>
<p style="text-align: center;"><code class="reqn">
\phi_{itj, kg} = \alpha_{kg} \mathbf{1}\{|t-j|=1\} ,\;  \log(\sigma_{itk}) = \lambda_{k0} + \lambda_{k1} h_{it}, \; \log\left(\frac{\omega_{ilm}}{\pi-\omega_{ilm}}\right) = \nu_l + \nu_m.
</code>
</p>

<p>The priors for the parameters in the model given by
</p>
<p style="text-align: center;"><code class="reqn">
{\beta} \sim \mathcal{N}(0, \sigma_\beta^2 I);
</code>
</p>

<p style="text-align: center;"><code class="reqn">
{\lambda}_k \sim \mathcal{N}(0, \sigma_\lambda^2 I);
</code>
</p>

<p style="text-align: center;"><code class="reqn">
{\nu}_k \sim \mathcal{N}(0, \sigma_\nu^2 I),  \quad k=1, \ldots, K,
</code>
</p>

<p>where <code class="reqn">\sigma_\beta^2</code>, <code class="reqn">\sigma_\lambda^2</code>, and <code class="reqn">\sigma_\nu^2</code> are prespecified values. For <code class="reqn">k, g = 1, \ldots, K</code> and <code class="reqn">m=1, \ldots, a</code>, we further assume
</p>
<p style="text-align: center;"><code class="reqn">
\alpha_{kgm} \sim \delta_{kgm} \mathcal{N}(0, \sigma^2_\delta) + (1-\delta_{kgm})\eta_0,
</code>
</p>

<p>where <code class="reqn">\sigma^2_\delta</code> is prespecified value and <code class="reqn">\eta_0</code> is the point mass at 0.
</p>


<h3>Value</h3>

<p>Lists of posterior samples, parameters estimates, AIC, BIC, DIC, MPL, MSPE, and predicted values are returned</p>


<h3>Note</h3>

<p>We'll provide the reference for details of the model and the algorithm for performing model estimation whenever the manuscript is accepted. 
</p>


<h3>Author(s)</h3>

<p>Kuo-Jung Lee
</p>


<h3>References</h3>

<p>Keunbaik Lee et al. (2015) Estimation of covariance matrix of multivariate longitudinal data using modified Choleksky and hypersphere decompositions. <em>Biometrics</em>. <b>75-86, 2020</b>. doi: <a href="https://doi.org/10.1111/biom.13113">10.1111/biom.13113</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(MASS)
library(MLModelSelection)


AR.Order = 6 #denote \phi_{itj, kg} = \alpha_{kg} \mathbf{1}{|t-j|=1} 
ISD.Model = 1 #denote \log(\sigma_{itk}) = \lambda_{k0} + \lambda_{k1} h_{it}

data(SimulatedData)

N = dim(SimulatedData$Y)[1] # the number of subjects
T = dim(SimulatedData$Y)[2] # time points
K = dim(SimulatedData$Y)[3] # the number of attributes
P = dim(SimulatedData$X)[3] # the number of covariates
M = AR.Order  # the demension of alpha
nlamb = ISD.Model + 1 # the dimension of lambda

Data = list(Y = SimulatedData$Y, X = SimulatedData$X, 
	TimePointsAvailable = SimulatedData$TimePointsAvailable, 
	AR.Order = AR.Order, ISD.Model = ISD.Model)

beta.ini = matrix(rnorm(P*K), P, K)
delta.ini = array(rbinom(K*K*M, 1, 0.1), c(K, K, M)) 
alpha.ini = array(runif(K*K*M, -1, 1), c(K, K, M))
lambda.ini = matrix(rnorm(nlamb*K), K, nlamb, byrow=T)
nu.ini = rnorm(K)


InitialValues = list(beta = beta.ini, delta = delta.ini, alpha = alpha.ini, 
	lambda = lambda.ini, nu = nu.ini)

# Hyperparameters in priors
sigma2.beta = 1
sigma2.alpha = 10
sigma2.lambda = 0.01
sigma2.nu = 0.01

# Whehter the parameter will be updated
UpdateBeta = TRUE
UpdateDelta = TRUE
UpdateAlpha = TRUE
UpdateLambda = TRUE	
UpdateNu = TRUE


HyperPara = list(sigma2.beta = sigma2.beta, sigma2.alpha=sigma2.alpha, 
	sigma2.lambda=sigma2.lambda, sigma2.nu=sigma2.nu)


UpdatePara = list(UpdateBeta = UpdateBeta, UpdateAlpha = UpdateAlpha, UpdateDelta = UpdateDelta, 
	              UpdateLambda = UpdateLambda, UpdateNu = UpdateNu)

# Tuning parameters in proposal distribution within MCMC
TuningPara = list(TuningAlpha = 0.01, TuningLambda = 0.005, TuningNu = 0.005)

num.of.iter = 100

start.time &lt;- Sys.time()

PosteriorSamplesEstimation = MLModelSelectionMCMC(num.of.iter, Data, InitialValues, 
	HyperPara, UpdatePara, TuningPara)

end.time &lt;- Sys.time()

cat("Estimate of beta\n")
print(PosteriorSamplesEstimation$PosteriorEstimates$beta.mean)


</code></pre>


</div>