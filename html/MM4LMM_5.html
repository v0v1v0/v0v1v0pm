<div class="container">

<table style="width: 100%;"><tr>
<td>MMEst</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
MM inference method for variance component mixed models 

</h2>

<h3>Description</h3>

<p>This is the main function of the <cite>MM4LMM</cite> package. It performs inference  in  a variance component mixed model using a Min-Max algorithm. Inference in multiple models (e.g. for GWAS analysis) can also be performed.

</p>


<h3>Usage</h3>

<pre><code class="language-R">MMEst(Y, Cofactor = NULL, X = NULL, formula=NULL, VarList, ZList = NULL, Method = "Reml",
	Henderson=NULL, Init = NULL, CritVar = 0.001, CritLogLik = 0.001,
	MaxIter = 100, NbCores = 1, Verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>

<p>A vector of response values.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cofactor</code></td>
<td>

<p>An incidence matrix corresponding to fixed effects common to all models to be adjusted. If <code>NULL</code>, a single intercept is used as cofactor.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>An incidence matrix or a list of incidence matrices corresponding to fixed effects specific to each model. If <code>X</code> is a matrix, one model per column will be fitted. If <code>X</code> is a list, one model per element of the list will be fitted (default is <code>NULL</code>).

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>A formula object specifying the fixed effect part of all models separated by + operators. To specify an interaction between <code>Cofactor</code> and <code>X</code> use the colnames of <code>X</code> when it is a list or use "Xeffect" when <code>X</code> is a matrix.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VarList</code></td>
<td>

<p>A list of covariance matrices associated with random and residual effects.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ZList</code></td>
<td>

<p>A list of incidence matrices associated with random and residual effects (default is <code>NULL</code>).

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Method</code></td>
<td>

<p>The method used for inference. Available methods are "Reml" (Restricted Maximum Likelihood) and "ML" (Maximum Likelihood).

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Henderson</code></td>
<td>

<p>If <code>TRUE</code> the Henderson trick is applied. If <code>FALSE</code> the Henderson trick is not applied. If <code>NULL</code> the algorithm chooses wether to use the trick or not.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Init</code></td>
<td>

<p>A vector of initial values for variance parameters (default is <code>NULL</code>)

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CritVar</code></td>
<td>

<p>Value of the criterion for the variance components to stop iteration. (see Details)

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CritLogLik</code></td>
<td>

<p>Value of the criterion for the log-likelihood to stop iteration. (see Details)

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxIter</code></td>
<td>

<p>Maximum number of iterations per model.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NbCores</code></td>
<td>

<p>Number of cores to be used. 

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Verbose</code></td>
<td>

<p>A boolean describing if messages have to be printed (TRUE) or not (FALSE). Default is TRUE.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>X</code> is <code>NULL</code>, the following model is fitted:
</p>
<p style="text-align: center;"><code class="reqn">Y = X_C \beta_C + \sum_{k=1}^K Z_k u_k</code>
</p>

<p>with <code class="reqn">X_C</code> the matrix provided in <code>Cofactor</code>, <code class="reqn">\beta_C</code> the unknown fixed effects, <code class="reqn">Z_k</code> the incidence matrix provided for the kth component of <code>ZList</code> and <code class="reqn">u_k</code> the kth vector of random effects. If <code>ZList</code> is unspecified, all incidence matrices are assumed to be the Identity matrix. Random effects are assumed to follow a Gaussian distribution with mean 0 and covariance matrix <code class="reqn">R_k \sigma_k^2</code>, where <code class="reqn">R_k</code> is the kth correlation matrix provided in <code>VarList</code>.
</p>
<p>If <code>X</code> is not <code>NULL</code>, the following model is fitted for each i:
</p>
<p style="text-align: center;"><code class="reqn">Y = X_C \beta_C + X_{[i]} \beta_{[i]} + \sum_{k=1}^K Z_k u_k</code>
</p>

<p>where <code class="reqn">X_{[i]}</code> is the incidence matrix corresponding to the ith component (i.e. column if <code class="reqn">X</code> is a matrix, element otherwise) of <code class="reqn">X</code>, and <code class="reqn">\beta_{[i]}</code> is the (unknow) fixed effect associated to <code class="reqn">X_{[i]}</code>.
</p>
<p>All models are fitted using the MM algorithm. If <code>Henderson</code>=<code>TRUE</code>, at each step the quantities required for updating the variance components are computed using the Mixed Model Equation (MME) trick. See Johnson et al. (1995) for details. 
</p>



<h3>Value</h3>

<p>The result is a list where each element corresponds to a fitted model. Each element displays the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Beta </code></td>
<td>
<p>Estimated values of <code class="reqn">\beta_C</code> and <code class="reqn">\beta_{i}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma2 </code></td>
<td>
<p>Estimated values of <code class="reqn">\sigma_1^2,...,\sigma_K^2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VarBeta </code></td>
<td>
<p>Variance matrix of <code>Beta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LogLik (Method) </code></td>
<td>
<p>The value of the (restricted, if <code>Method</code> is "Reml") log-likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NbIt </code></td>
<td>
<p>The number of iterations required to reach the optimum</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Method </code></td>
<td>
<p>The method used for the inference</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr </code></td>
<td>
<p>An integer vector with an entry for each element of <code>Beta</code> giving the term in <code>Factors</code> which gave rise to this element (for internal use in the function <code>AnovaTest</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Factors </code></td>
<td>
<p>Names of each term in the formula</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>F. Laporte and T. Mary-Huard

</p>


<h3>References</h3>

<p>Laporte, F., Charcosset, A., &amp; Mary-Huard, T. (2022). Efficient ReML inference in variance component mixed models using a Min-Max algorithm. PLOS Computational Biology, 18(1), e1009659.
</p>
<p>Johnson, D. L., &amp; Thompson, R. (1995). Restricted maximum likelihood estimation of variance components for univariate animal models using sparse matrix techniques and average information. Journal of dairy science, 78(2), 449-456.
</p>
<p>Hunter, D. R., &amp; Lange, K. (2004). A tutorial on MM algorithms. The American Statistician, 58(1), 30-37.
</p>
<p>Zhou, H., Hu, L., Zhou, J., &amp; Lange, K. (2015). MM algorithms for variance components models. arXiv preprint arXiv:1509.07426.

</p>


<h3>Examples</h3>

<pre><code class="language-R">require('MM4LMM')

#### Example 1: variance component analysis, 1 model
data(VarianceComponentExample)
DataHybrid &lt;- VarianceComponentExample$Data
KinF &lt;- VarianceComponentExample$KinshipF
KinD &lt;- VarianceComponentExample$KinshipD

##Build incidence matrix for each random effect
Zf &lt;- t(sapply(as.character(DataHybrid$CodeFlint), function(x)
  as.numeric(rownames(KinF)==x)))
Zd &lt;- t(sapply(as.character(DataHybrid$CodeDent), function(x)
  as.numeric(rownames(KinD)==x)))

##Build the VarList and ZList objects
VL = list(Flint=KinF , Dent=KinD , Error = diag(1,nrow(DataHybrid)))
ZL &lt;- list(Flint=Zf , Dent=Zd , Error = diag(1,nrow(DataHybrid)))

##Perform inference
#A first way to call MMEst
ResultVA &lt;- MMEst(Y=DataHybrid$Trait  , Cofactor = matrix(DataHybrid$Trial)
                  , ZList = ZL  ,  VarList = VL)
length(ResultVA)
print(ResultVA)

#A second way to call MMEst (same result)
Formula &lt;- as.formula('~ Trial')
ResultVA2 &lt;- MMEst(Y=DataHybrid$Trait  , Cofactor = DataHybrid,
                   formula = Formula
                  , ZList = ZL  ,  VarList = VL)
length(ResultVA2)
print(ResultVA2)



#### Example 2: Marker Selection with interaction between Cofactor and X matrix
Formula &lt;- as.formula('~ Trial+Xeffect+Xeffect:Trial')
ResultVA3 &lt;- MMEst(Y=DataHybrid$Trait  , Cofactor = DataHybrid,
                  X = VarianceComponentExample$Markers,
                   formula = Formula
                  , ZList = ZL  ,  VarList = VL)
length(ResultVA3)
print(ResultVA3[[1]])


#### Example 3: QTL detection with two variance components
data(QTLDetectionExample)
Pheno &lt;- QTLDetectionExample$Phenotype
Geno &lt;- QTLDetectionExample$Genotype
Kinship &lt;- QTLDetectionExample$Kinship

##Build the VarList object
VLgd &lt;- list(Additive=Kinship , Error=diag(1,length(Pheno)))

##Perform inference
ResultGD &lt;- MMEst(Y=Pheno , X=Geno
                  , VarList=VLgd , CritVar = 10e-5)

length(ResultGD)
print(ResultGD[[1]])
</code></pre>


</div>