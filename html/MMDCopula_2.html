<div class="container">

<table style="width: 100%;"><tr>
<td>BiCopEst.MO</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of Marshall-Olkin copulas</h2>

<h3>Description</h3>

<p>Estimation of Marshall-Olkin copulas
</p>


<h3>Usage</h3>

<pre><code class="language-R">BiCopEst.MO(
  u1,
  u2,
  method,
  par.start = 0.5,
  kernel = "gaussian.Phi",
  gamma = 0.95,
  alpha = 1,
  niter = 100,
  C_eta = 1,
  ndrawings = 10,
  naveraging = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u1</code></td>
<td>
<p>vector of observations of the first coordinate, in <code class="reqn">[0,1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u2</code></td>
<td>
<p>vector of observations of the second coordinate, in <code class="reqn">[0,1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character giving the name of the estimation method, among:
</p>

<ul>
<li> <p><code>curve</code>: <code class="reqn">\alpha</code> is estimated by inversion of
the probability measure of the diagonal
<code class="reqn">\{(u,v): u = v\}</code>
</p>
</li>
<li> <p><code>itau</code>: <code class="reqn">\alpha</code> is estimated by inversion of Kendall's tau
</p>
</li>
<li> <p><code>MMD</code>: <code class="reqn">\alpha</code> is estimated by MMD optimization
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.start</code></td>
<td>
<p>starting parameter of the gradient descent.
(only used for <code>method = "MMD"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>the kernel used in the MMD distance
(only used for <code>method = "MMD"</code>) :
it can be a function taking in parameter <code>(u1, u2, v1, v2, gamma, alpha)</code>
or a name giving the kernel to use in the list:
</p>

<ul>
<li> <p><code>"gaussian"</code>: Gaussian kernel <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_2^2)
    </code>
</p>
</li>
<li> <p><code>"exp-l2"</code>: <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_2)
    </code>
</p>
</li>
<li> <p><code>"exp-l1"</code>: <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_1)
    </code>
</p>
</li>
<li> <p><code>"inv-l2"</code>: <code class="reqn">k(x,y) = 1/(1+\|\frac{x-y}{\gamma}\|_2)^\alpha
    </code>
</p>
</li>
<li> <p><code>"inv-l1"</code>: <code class="reqn">k(x,y) = 1/(1+\|\frac{x-y}{\gamma}\|_1)^\alpha
    </code>
</p>
</li>
</ul>
<p>Each of these names can receive the suffix <code>".Phi"</code>, such as <code>"gaussian.Phi"</code>
to indicates that the kernel <code class="reqn">k(x,y)</code> is replaced by
<code class="reqn">k(\Phi^{-1}(x) , \Phi^{-1}(y))</code> where <code class="reqn">\Phi^{-1}</code> denotes the quantile
function of the standard Normal distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>parameter <code class="reqn">\gamma</code> to be used in the kernel.
(only used for <code>method = "MMD"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>parameter <code class="reqn">\alpha</code> to be used in the kernel, if any.
(only used for <code>method = "MMD"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>the stochastic gradient algorithm is composed of two phases:
a first "burn-in" phase and a second "averaging" phase.
If <code>niter</code> is of size <code>1</code>, the same number of iterations is used for
both phases of the stochastic gradient algorithm. If <code>niter</code> is of size <code>2</code>,
then <code>niter[1]</code> iterations are done for the burn-in phase and <code>niter[2]</code>
for the averaging phase.
(only used for <code>method = "MMD"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C_eta</code></td>
<td>
<p>a multiplicative constant controlling for the size of the gradient descent step.
The step size is then computed as <code>C_eta / sqrt(i_iter)</code>
where <code>i_iter</code> is the index of the current iteration of the stochastic gradient algorithm.
(only used for <code>method = "MMD"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndrawings</code></td>
<td>
<p>number of replicas of the stochastic estimate of the gradient
drawn at each step. The gradient is computed using the average of these replicas.
(only used for <code>method = "MMD"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>naveraging</code></td>
<td>
<p>number of full run of the stochastic gradient algorithm
that are averaged at the end to give the final estimated parameter.
(only used for <code>method = "MMD"</code>)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>the estimated parameter (<code>alpha</code>) of the Marshall-Olkin copula.
</p>


<h3>References</h3>

<p>Alquier, P., Ch√©rief-Abdellatif, B.-E., Derumigny, A., and Fermanian, J.D. (2022).
Estimation of copulas via Maximum Mean Discrepancy.
Journal of the American Statistical Association, <a href="https://doi.org/10.1080/01621459.2021.2024836">doi:10.1080/01621459.2021.2024836</a>.
</p>


<h3>See Also</h3>

<p><code>BiCopSim.MO</code> for the estimation of
Marshall-Olkin copulas.
<code>BiCopEstMMD</code> for the estimation of other parametric copula families by MMD.
</p>


<h3>Examples</h3>

<pre><code class="language-R">U &lt;- BiCopSim.MO(n = 1000, alpha = 0.2)
estimatedPar &lt;- BiCopEst.MO(u1 = U[,1], u2 = U[,2], method = "MMD", niter = 1, ndrawings = 1)

estimatedPar &lt;- BiCopEst.MO(u1 = U[,1], u2 = U[,2], method = "MMD")


</code></pre>


</div>