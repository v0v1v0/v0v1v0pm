<div class="container">

<table style="width: 100%;"><tr>
<td>MB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multivariate multiplicative binomial distribution</h2>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p>Various utilities to coerce and manipulate <code>MB</code> objects
</p>


<h3>Usage</h3>

<pre><code class="language-R">MB(dep, m, pnames=character(0))
## S3 method for class 'MB'
as.array(x, ...)
## S4 method for signature 'MB'
getM(x)
## S3 method for class 'gunter_MB'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dep</code></td>
<td>

<p>Primary argument to <code>MB()</code>.  Typically a matrix with each row
being an observation (see ‘details’ section below for an
example).  If an object of class <code>Oarray</code>, function <code>MB()</code>
coerces to an <code>MB</code> object
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>

<p>Vector containing the relative sizes of the various marginal
binomial distributions
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Object of class <code>MB</code> to be converted to an <code>Oarray</code> object
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to <code>as.array()</code>, currently ignored
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pnames</code></td>
<td>
<p>In function <code>MB()</code>, a character vector of
names for the entries
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>MB()</code> returns an object of class <code>MB</code>.  This is
essentially a matrix with one row corresponding to a single
observation; repeated rows indicate identical observations as shown
below.  Observational data is typically in this form.  The idea is
that the user can coerce to a <code>gunter_MB</code> object, which is then
analyzable by <code>Lindsey()</code>.
</p>
<p>The multivariate multiplicative binomial distribution is defined by
\[
    \prod_{i=1}^t
    {m_i\choose x_i\, z_i}p_i^{x_i}q_i^{z_i}\theta_i^{x_iz_i}
    \prod_{i &lt; j}\phi_{ij}^{x_ix_j}
  \]
</p>
<p>Thus if \(\theta=\phi=1\) the system reduces to a product of
independent binomial distributions with probability \(p_i\) and size
\(m_i\) for \(i=1,\ldots,t\).
</p>
<p>There follows a short <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> transcript showing the <code>MB</code> class in use,
with annotation.
</p>
<p>The first step is to define an <code>m</code> vector:
</p>
<pre>
R&gt; m &lt;- c(2,3,1)
 </pre>
<p>This means that \(m_1=2,m_2=3,m_3=1\).  So
\(m_1=2\) means that \(i=1\) corresponds to a binomial
distribution with size 2 [that is, the observation is in the set
\({0,1,2}\)]; and \(m_2=3\) means that \(i=2\)
corresponds to a binomial with size 3 [ie the set
\({0,1,2,3}\)].
</p>
<p>Now we need some observations:
</p>
<pre>
R&gt; a &lt;- matrix(c(1,0,0, 1,0,0, 1,1,1, 2,3,1, 2,0,1),5,3,byrow=T)
R&gt; a
     [,1] [,2] [,3]
[1,]    1    0    0
[2,]    1    0    0
[3,]    1    1    1
[4,]    2    3    1
[5,]    2    0    1 
</pre>
<p>In matrix <code>a</code>, the first observation, viz <code>c(1,0,0)</code> is
interpreted as \(x_1=1,x_2=0,x_3=0\).  Thus, because
\(x_i+z_i=m_i\), we have \(z_1=1,z_2=3,z_3=1\).  Now
we can create an object of class <code>MB</code>, using function <code>MB()</code>:
</p>
<pre>
R&gt;  mx &lt;- MB(a, m, letters[1:3])   
</pre>
<p>The third argument gives names to the observations corresponding to the
columns of <code>a</code>.   The values of \(m_1, m_2, m_3\) may
be extracted using <code>getM()</code>:
</p>
<pre>
R&gt; getM(mx)
a b c 
2 3 1 
R&gt; 
</pre>
<p>The <code>getM()</code> function returns a named vector, with names
given as the third argument to <code>MB()</code>.
</p>
<p>Now we illustrate the print method:
</p>
<pre>
R&gt; mx
     a na     b nb     c nc    
[1,] 1 1      0 3      0 1     
[2,] 1 1      0 3      0 1     
[3,] 1 1      1 2      1 0     
[4,] 2 0      3 0      1 0     
[5,] 2 0      0 3      1 0     
R&gt; 
</pre>
<p>See how the columns are in pairs: the first pair total 2 (because
\(m_1=2\)), the second pair total 3 (because \(m_2=3\)),
and the third pair total 1 (because \(m_3=1\)).  Each pair of
columns has only a single degree of freedom, because \(m_i\) is known.
</p>
<p>Also observe how the column names are in pairs.  The print method puts
these in place.  Take the first two columns.  These are named
‘<code>a</code>’ and ‘<code>na</code>’: this is intented to mean
‘<code>a</code>’ and ‘not <code>a</code>’.
</p>
<p>We can now coerce to a <code>gunter_MB</code>:
</p>
<pre>
R&gt; (gx &lt;- gunter(mx))
$tbl
   a b c
1  0 0 0
2  1 0 0
3  2 0 0
[snip]
24 2 3 1

$d
 [1] 0 2 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1

$m
a b c 
2 3 1 
</pre>
<p>Take the second line of the element <code>tbl</code> of <code>gx</code>, as an
example.  This reads <code>c(1,0,0)</code> corresponding to the observations
of <code>a,b,c</code> respectively, and the second line of element <code>d</code>
[“<code>d</code>” for “data”], viz 2, shows that this
observation occurred twice (and in fact these were the first two lines
of <code>a</code>).
</p>
<p>Now we can coerce object <code>mx</code> to an array:
</p>
<pre>
R&gt; (ax &lt;- as.array(mx))
, , c = 0

   b
a   0 1 2 3
  0 0 0 0 0
  1 0 0 2 0
  2 0 0 0 0

, , c = 1

   b
a   0 1 2 3
  0 0 1 0 0
  1 0 0 0 0
  2 1 1 0 0
&gt;
</pre>
<p>(actually, <code>ax</code> is an <code>Oarray</code> object).  The location of an
element in <code>ax</code> corresponds to an observation of <code>abc</code>, and
the entry corresponds to the number of times that observation was made.
For example, <code>ax[1,2,0]=2</code> shows that <code>c(1,2,0)</code> occurred
twice (the first two lines of <code>a</code>).
</p>
<p>The Lindsey Poisson device is applicable: see <code>help(danaher)</code> for
an application to the bivariate case and <code>help(Lindsey)</code> for an
example where a table is created from scratch.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code>MM</code>, <code>Lindsey</code>, <code>danaher</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
a &lt;- matrix(c(1,0,0, 1,0,0, 1,1,1, 2,3,1, 2,0,1),5,3,byrow=TRUE)
m &lt;- c(2,3,1)
mx &lt;- MB(a, m, letters[1:3])   # mx is of class 'MB'; column headings
                   #  mean "a" and "not a".
ax &lt;- as.array(mx)
gx &lt;- gunter(ax)
ax2 &lt;- as.array(gx)

data(danaher)
summary(Lindsey_MB(danaher))

</code></pre>


</div>