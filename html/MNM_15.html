<div class="container">

<table style="width: 100%;"><tr>
<td>mv.l1lm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Linear Regression Based on Identity, Spatial Sign or Spatial Rank Scores
</h2>

<h3>Description</h3>

<p>This function fits a multivariate linear regression model based on identity, spatial sign or spatial rank scores. Both inner and outer standardization are possible.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mv.l1lm(formula, scores = "identity", stand = "outer", 
        maxiter = 1000, eps = 1e-06, eps.S = 1e-06, 
        x = TRUE, y = TRUE, data, subset, na.action)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>an object of class "formula" (or one that can be coerced to
that class): a symbolic description of the model to be
fitted. The left part of the formula (the response) must be a  n x p matrix with at least two columns.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>

<p>score to be used. Can be either <code>"identity"</code>, <code>"sign"</code> or <code>"rank"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stand</code></td>
<td>

<p>can be <code>"outer"</code> or <code>"inner"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>

<p>maximum number of iterations. Used only for <code>score = "sign"</code> and  <code>score = "rank"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>convergence tolerance. Used only for <code>score = "sign"</code> or  <code>score = "rank"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.S</code></td>
<td>

<p>lower limit for the residual norms. Used only for <code>score = "sign"</code>  or  <code>score = "rank"</code> in the iteration procedure to avoid to divide by a zero norm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>logical. Indicating whether the design matrix 'x' returned from the model matrix should be stored. Default is <code>TRUE</code>. Might be needed for example 
in the <code>anova</code> function.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>logical. Indicating whether the response matrix 'y' should be stored. Default is <code>TRUE</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an optional data frame, list or environment (or object
coercible by 'as.data.frame' to a data frame) containing the
variables in the model.  If not found in 'data', the
variables are taken from 'environment(formula)', typically
the environment from which 'mv.l1lm' is called.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>a function which indicates what should happen when the data
contain 'NA's. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The theory behind this function is described in detail in Chapter 13 of the MNM book. 
</p>
<p>For regular multivariate L2-regression the function <code>lm</code> might be more efficient and offers more methods. Note however that
the results given by <code>lm</code> and <code>mv.l1lm</code> may differ slightly due to different divisors of the covariance matrix.
</p>
<p>The algorithms for the sign and rank scores are still in an early phase and therefore any feedback is very welcome. 
For example if p+1 residuals are 0, then the algorithms may not return correct values. Note also that the computations for rank scores 
might be slow. 
</p>
<p>Rank regression does not provide an estimate for the intercept parameter is not considered a parameter, a Hodges-Lehmann estimator of the residuals is then an estimate when an interecept term is in the formula.
For the one sample case however the function cannot be used for rank scores. We recommend that the regression function should not be used for the one or two sample case. There are
distinct functions designed for that purpose. Note furthermore that in the two sample case the covariance matrix returned from the regression function differs
slightly from the one returned by the function <code>mv.2sample.est</code> since there matrix A is computed in a different way. 
</p>
<p>In general it is recommended to use the <code>data</code> argument and specify there the data frame that contains the variables and matrices. For having a matrix Y in a data frame 
for example the following methods work:
</p>

<dl>
<dt>a)</dt>
<dd>
<p><code>MyData &lt;- data.frame(I(Y),...)</code>
</p>
<p>or
</p>
</dd>
<dt>b)</dt>
<dd>
<p><code>MyData &lt;- data.frame(...)</code> <br><code>MyData$Y &lt;- Y</code>
</p>
</dd>
</dl>
<p>Otherwise also the function <code>cbind</code> can be used on the left side of the formula to combine numeric vectors on the fly.
</p>


<h3>Value</h3>

<p><code>mv.l1ml</code> returns an object of 'class' <code>mvl1lm</code>.
</p>
<p>The functions <code>summary</code> is the best choice to view the results.  The
generic accessor functions <code>coefficients</code>, <code>fitted</code>, <code>residuals</code>
and <code>vcov</code> extract various useful features of
the value returned by <code>mv.l1ml</code>.
</p>
<p>An object of class <code>mv.l1ml</code> is a list wich contains different information depending on the scores and standardization used.
To see its content use the function <code>str</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Oja, H. (2010), <em>Multivariate Nonparametric Methods with R</em>, Springer.</cite> 
</p>
<p><cite>Nordhausen, K. and Oja, H. (2011), Multivariate L1 Methods: The Package MNM, <em>Journal of Statistical Software</em>, <b>43</b>, 1-28.</cite>
</p>


<h3>See Also</h3>

<p><code>lm</code>, <code>mv.1sample.est</code>, <code>mv.1sample.test</code>, <code>mv.2sample.est</code>, <code>mv.Csample.test</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># creating simple data

X &lt;- cbind(rep(1,100),rmvnorm(100,c(0,0,0)) )
B &lt;- matrix(c(4,1,1,0.5,-3,2,2,2),ncol=4, byrow=TRUE)
Y &lt;- X %*% t(B)+ rmvnorm(100,c(0,0), diag(0.2,2))
DAT &lt;- data.frame(x1=X[,2],x2=X[,3], x3=X[,4], Y=I(Y))

# true B
t(B)

# example using identity scores
test1 &lt;- mv.l1lm(Y ~ x1 + x2 + x3, data=DAT)

print(test1)
summary(test1)
coef(test1)
vcov(test1)
head(fitted(test1))
head(residuals(test1))

# example using outer sign scores
test2 &lt;- mv.l1lm(Y ~ x1 + x2 + x3, scores= "s", data=DAT)

print(test2)
summary(test2)
coef(test2)
vcov(test2)
head(fitted(test2))
head(residuals(test2))

# example using inner sign scores
test3 &lt;- mv.l1lm(Y ~ x1 + x2 + x3, scores= "s", stand="i", 
data=DAT)

print(test3)
summary(test3)
coef(test3)
vcov(test3)
head(fitted(test3))
head(residuals(test3))

# example using outer rank scores
test4 &lt;- mv.l1lm(Y ~ x1 + x2 + x3, scores= "r", stand="o", 
data=DAT)

print(test4)
summary(test4)
coef(test4)
vcov(test4)
head(fitted(test4))
head(residuals(test4))

# example using inner rank scores
test5 &lt;- mv.l1lm(Y ~ x1 + x2 + x3, scores= "r", stand="i", 
data=DAT)

print(test5)
summary(test5)
coef(test5)
vcov(test5)
head(fitted(test5))
head(residuals(test5))

# prediction

newData &lt;- data.frame(x1=c(1,-2),x2=c(0.5,0.7), x3=c(-1,-1))
newData
predict(test1,newData)
predict(test2,newData)
predict(test3,newData)
predict(test4,newData)
predict(test5,newData)

</code></pre>


</div>