<div class="container">

<table style="width: 100%;"><tr>
<td>moead</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MOEA/D</h2>

<h3>Description</h3>

<p>MOEA/D implementation in R
</p>


<h3>Usage</h3>

<pre><code class="language-R">moead(
  preset = NULL,
  problem = NULL,
  decomp = NULL,
  aggfun = NULL,
  neighbors = NULL,
  variation = NULL,
  update = NULL,
  constraint = NULL,
  scaling = NULL,
  stopcrit = NULL,
  showpars = NULL,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>preset</code></td>
<td>
<p>List object containing preset values for one or more
of the other parameters of the <code>moead</code> function. Values provided in
the <code>preset</code> list will override any other value provided. Presets should be
generated by the <code>preset_moead()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>problem</code></td>
<td>
<p>List containing the problem parameters.
See <code>Problem Description</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decomp</code></td>
<td>
<p>List containing the decomposition method parameters
See <code>Decomposition methods</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggfun</code></td>
<td>
<p>List containing the aggregation function parameters
See <code>Scalarization methods</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbors</code></td>
<td>
<p>List containing the decomposition method parameters
See <code>Neighborhood strategies</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variation</code></td>
<td>
<p>List containing the variation operator parameters
See <code>Variation operators</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update</code></td>
<td>
<p>List containing the population update parameters
See <code>Update strategies</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraint</code></td>
<td>
<p>List containing the constraint handing parameters
See <code>Constraint operators</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>List containing the objective scaling parameters
See <code>Objective scaling</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stopcrit</code></td>
<td>
<p>list containing the stop criteria parameters.
See <code>Stop criteria</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showpars</code></td>
<td>
<p>list containing the echoing behavior parameters.
See <code>print_progress()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>seed for the pseudorandom number generator. Defaults to NULL,
in which case <code>as.integer(Sys.time())</code> is used for the definition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other parameters (useful for development and debugging, not
necessary in regular use)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Component-wise implementation of the Multiobjective Evolutionary Algorithm
based on decomposition - MOEA/D.
</p>


<h3>Value</h3>

<p>List object of class <em>moead</em> containing:
</p>

<ul>
<li>
<p> information on the final population (<code>X</code>), its objective values (<code>Y</code>) and
constraint information list (<code>V</code>) (see <code>evaluate_population()</code> for details);
</p>
</li>
<li>
<p> Archive population list containing its corresponding <code>X</code>, <code>Y</code> and <code>V</code>
fields (only if <code>update$UseArchive = TRUE</code>).
</p>
</li>
<li>
<p> Estimates of the <em>ideal</em> and <em>nadir</em> points, calculated for the final
population;
</p>
</li>
<li>
<p> Number of function evaluations, iterations, and total execution time;
</p>
</li>
<li>
<p> Random seed employed in the run, for reproducibility
</p>
</li>
</ul>
<h3>Problem Description</h3>

<p>The <code>problem</code> parameter consists of a list with all necessary
definitions for the multiobjective optimization problem to be solved.
<code>problem</code> must contain at least the following fields:
</p>

<ul>
<li> <p><code>problem$name</code>: name of the problem instance function, that is, a
routine that calculates <strong>Y</strong> = <strong>f</strong>(<strong>X</strong>);
</p>
</li>
<li> <p><code>problem$xmin</code>: vector of lower bounds of each variable
</p>
</li>
<li> <p><code>problem$xmax</code>: vector of upper bounds of each variable
</p>
</li>
<li> <p><code>problem$m</code>:  integer indicating the number of objectives
</p>
</li>
</ul>
<p>Besides these fields, <code>problem</code> should contain any other relevant inputs
for the routine listed in <code style="white-space: pre;">⁠$name⁠</code>. <code>problem</code> may also contain the
(optional) field <code>problem$constraints</code>, which is a list object
containing information about the problem constraints. If present, this list
must have the following fields:
</p>

<ul>
<li> <p><code>problem$constraints$name</code> - (required) name of the function that
calculates the constraint values (see below for details)
</p>
</li>
<li> <p><code>problem$constraints$epsilon</code> - (optional) a small non-negative value
indicating the tolerance to be considered for equality constraints.
Defaults to zero.
</p>
</li>
</ul>
<p>Besides these fields, <code>problem$constraint</code> should contain any other
relevant inputs for the routine listed in <code>problem$constraint$name</code>.
</p>
<p>Detailed instructions for defining the routines for calculating the
objective and constraint functions are provided in the vignette
<em>Defining Problems in the MOEADr Package</em>. Check that documentation for
details.
</p>


<h3>Decomposition Methods</h3>

<p>The <code>decomp</code> parameter is a list that defines the method to be used for the
generation of the weight vectors. <code>decomp</code> must have
at least the <code style="white-space: pre;">⁠$name⁠</code> parameter. Currently available methods can be
verified using <code>get_decomposition_methods()</code>. Check
<code>generate_weights()</code> and the information provided by
<code>get_decomposition_methods()</code> for more details.
</p>


<h3>Neighborhood Strategies</h3>

<p>The <code>neighbors</code> parameter is a list that defines the method for defining the
neighborhood relations among subproblems. <code>neighbors</code> must have
at least three parameters:
</p>

<ul>
<li> <p><code>neighbors$name</code>, name of the strategy used to define the neighborhoods.
Currently available methods are:
- <code style="white-space: pre;">⁠$name = "lambda"⁠</code>: uses the distances between weight vectors.
The calculation is performed only once for the entire run,
since the weight vectors are assumed static.
- <code style="white-space: pre;">⁠$name = "x"⁠</code>: uses the distances between the incumbent solutions
associated with each subproblem. In this case the calculation is
performed at each iteration, since incumbent solutions may change.
</p>
</li>
<li> <p><code>neighbors$T</code>: defines the neighborhood size. This parameter must receive
a value smaller than the number of subproblems defined for the MOEA/D.
</p>
</li>
<li> <p><code>neighbors$delta.p</code>: parameter that defines the probability of sampling
from the neighborhood when performing variation.
</p>
</li>
</ul>
<p>Check <code>define_neighborhood()</code> for more details.
</p>


<h3>Variation Operators</h3>

<p>The <code>variation</code> parameter consists of a list vector, in which each
sublist defines a variation operator to be used as part of the variation
block. Each sublist must have at least a field <code style="white-space: pre;">⁠$name⁠</code>, containing the name
of the <code>i</code>-th variation operator to be applied. Use
<code>get_variation_operators()</code> to generate a list of available operators, and
consult the vignette <code style="white-space: pre;">⁠Variation Stack in the MOEADr Package⁠</code> for more
details.
</p>


<h3>Scalar Aggregation Functions</h3>

<p>The <code>aggfun</code> parameter is a list that defines the scalar aggregation function
to be used. <code>aggfun</code> must have at least the <code style="white-space: pre;">⁠$name⁠</code> parameter. Currently
available methods can be verified using <code>get_scalarization_methods()</code>. Check
<code>scalarize_values()</code> and the information provided by
<code>get_scalarization_methods()</code> for more details.
</p>


<h3>Update Methods</h3>

<p>The <code>update</code> parameter is a list that defines the population update strategy
to be used. <code>update</code> must have at least the <code style="white-space: pre;">⁠$name⁠</code> parameter. Currently
available methods can be verified using <code>get_update_methods()</code>. Check
<code>update_population()</code> and the information provided by
<code>get_update_methods()</code> for more details.
</p>
<p>Another (optional) field of the <code>update</code> parameter is <code>update$UseArchive</code>,
which is a binary flag defining whether the algorithm should keep an
external solution archive (<code>TRUE</code>) or not (<code>FALSE</code>). Since it adds to the
computational burden and memory requirements of the algorithm, the use of an
archive population is recommended only in the case of constrained problems
with constraint handling method that can occasionally accept unfeasible
solutions, leading to the potential loss of feasible efficient solutions for
certain subproblems (e.g., <code>constraint_vbr()</code> with <code>type</code> = "sr" or "vt").
</p>


<h3>Constraint Handling Methods</h3>

<p>The <code>constraint</code> parameter is a list that defines the constraint-handling
technique to be used. <code>constraint</code> must have at least the <code style="white-space: pre;">⁠$name⁠</code> parameter.
Currently available methods can be verified using <code>get_constraint_methods()</code>.
Check <code>update_population()</code> and the information provided by
<code>get_constraint_methods()</code> for more details.
</p>


<h3>Objective Scaling</h3>

<p>Objective scaling refers to the re-scaling of the objective values at each
iteration, which is generally considered to prevent problems arising from
differently-scaled objective functions. <code>scaling</code> is a list that must have
at least the <code style="white-space: pre;">⁠$name⁠</code> parameter. Currently available options are
<code style="white-space: pre;">⁠$name = "none"⁠</code>, which does not perform any scaling, and <code style="white-space: pre;">⁠$name = "simple"⁠</code>,
which performs a simple linear scaling of the objectives to the interval
<code style="white-space: pre;">⁠[0, 1]⁠</code>.
</p>


<h3>Stop Criteria</h3>

<p>The <code>stopcrit</code> parameter consists of a list vector, in which each
sublist defines a termination criterion to be used for the MOEA/D. Each
sublist must have at least a field <code style="white-space: pre;">⁠$name⁠</code>, containing the name of the
<code>i</code>-th criterion to be verified. The iterative cycle of the MOEA/D is
terminated whenever any criterion is met. Use <code>get_stop_criteria()</code> to
generate a list of available criteria, and check the information provided by
that function for more details.
</p>


<h3>Echoing Options</h3>

<p>The <code>showpars</code> parameter is a list that defines the echoing options of the
MOEA/D. <code>showpars</code> must contain two fields:
</p>

<ul>
<li> <p><code>showpars$show.iters</code>, defining the type of echoing output. <code style="white-space: pre;">⁠$show.iters⁠</code>
can be set as <code>"none"</code>, <code>"numbers"</code>, or <code>"dots"</code>.
</p>
</li>
<li> <p><code>showpars$showevery</code>, defining the period of echoing (in iterations).
<code style="white-space: pre;">⁠$showevery⁠</code> must be a positive integer.
</p>
</li>
</ul>
<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br></p>


<h3>Examples</h3>

<pre><code class="language-R">## Prepare a test problem composed of minimization of the (shifted)
## sphere and Rastrigin functions
sphere     &lt;- function(x){sum((x + seq_along(x) * 0.1) ^ 2)}
rastringin &lt;- function(x){
                x.shift &lt;- x - seq_along(x) * 0.1
                sum((x.shift) ^ 2 - 10 * cos(2 * pi * x.shift) + 10)}
problem.sr &lt;- function(X){
                t(apply(X, MARGIN = 1,
                FUN = function(X){c(sphere(X), rastringin(X))}))}


## Set the input parameters for the moead() routine
## This reproduces the Original MOEA/D of Zhang and Li (2007)
## (with a few changes in the computational budget, to make it run faster)
problem   &lt;- list(name       = "problem.sr",
                  xmin       = rep(-1, 30),
                  xmax       = rep(1, 30),
                  m          = 2)
decomp    &lt;- list(name       = "SLD", H = 49) # &lt;-- H = 99 in the original
neighbors &lt;- list(name       = "lambda",
                  T          = 20,
                  delta.p    = 1)
aggfun    &lt;- list(name       = "wt")
variation &lt;- list(list(name  = "sbx",
                       etax  = 20, pc = 1),
                  list(name  = "polymut",
                       etam  = 20, pm = 0.1),
                  list(name  = "truncate"))
update    &lt;- list(name       = "standard", UseArchive = FALSE)
scaling   &lt;- list(name       = "none")
constraint&lt;- list(name       = "none")
stopcrit  &lt;- list(list(name  = "maxiter",
                    maxiter  = 50))      # &lt;-- maxiter = 200 in the original
showpars  &lt;- list(show.iters = "dots",
                  showevery  = 10)
seed      &lt;- 42

## Run MOEA/D
out1 &lt;- moead(preset = NULL,
              problem, decomp, aggfun, neighbors, variation, update,
              constraint, scaling, stopcrit, showpars, seed)

## Examine the output:
summary(out1)

## Alternatively, the standard MOEA/D could also be set up using the
## preset_moead() function. The code below runs the original MOEA/D with
## exactly the same configurations as in Zhang and Li (2007).
## Not run: 
  out2 &lt;- moead(preset   = preset_moead("original"),
                problem  = problem,
                showpars = showpars,
                seed     = 42)

  ## Examine the output:
  summary(out2)
  plot(out2, suppress.pause = TRUE)

## End(Not run)

# Rerun with MOEA/D-DE configuration and AWT scalarization
out3 &lt;- moead(preset   = preset_moead("moead.de"),
              problem  = problem,
              aggfun   = list(name = "awt"),
              stopcrit = list(list(name    = "maxiter",
                                   maxiter = 50)),
              seed    = seed)
plot(out3, suppress.pause = TRUE)
</code></pre>


</div>