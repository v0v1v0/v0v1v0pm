<div class="container">

<table style="width: 100%;"><tr>
<td>constraint_penalty</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>"Penalty" constraint handling method for MOEA/D</h2>

<h3>Description</h3>

<p>Uses the Penalty Function constraint handling method to generate a
preference index for the MOEADr framework.
</p>


<h3>Usage</h3>

<pre><code class="language-R">constraint_penalty(B, bigZ, bigV, beta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Matrix of neighborhoods (generated by <code>define_neighborhood()</code><code style="white-space: pre;">⁠$B⁠</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bigZ</code></td>
<td>
<p>Matrix of scalarized objective values for each neighborhood and
the incumbent solution (generated by <code>scalarize_values()</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bigV</code></td>
<td>
<p>Matrix of violation values for each neighborhood and the
incumbent solution (generated in <code>order_neighborhood()</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Penalization constant (non-negative value)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other parameters (unused, included for compatibility with
generic call)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function calculates the preference index of a set of neighborhoods
based on the "penalty" constraint handling method. Please
see <code>order_neighborhood()</code> for more information on the preference index
matrix.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">⁠[ N x (T+1) ]⁠</code> matrix of preference indices. Each row <code>i</code> contains
a permutation of <code style="white-space: pre;">⁠{1, 2, ..., (T+1)}⁠</code>, where <code style="white-space: pre;">⁠1,...,T⁠</code> correspond
to the solutions contained in the neighborhood of the i-th subproblem,
<code>B[i, ]</code>, and <code>T+1</code> corresponds to the incumbent solution for that
subproblem. The order of the permutation is defined by the increasing values
of <code>f(xk) + beta * v(xk)</code>, where <code>f(xk)</code> is the aggregation function value of
the k-th solution being compared, and v(xk) is its total constraint violation
(calculated in <code>evaluate_population()</code><code style="white-space: pre;">⁠$V$v⁠</code>).
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br></p>


</div>