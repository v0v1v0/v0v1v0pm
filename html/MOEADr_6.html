<div class="container">

<table style="width: 100%;"><tr>
<td>constraint_vbr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>"Violation-based Ranking" constraint handling method for MOEA/D</h2>

<h3>Description</h3>

<p>Uses the Violation-based Ranking handling method to generate a
preference index for the MOEADr framework.
</p>


<h3>Usage</h3>

<pre><code class="language-R">constraint_vbr(bigZ, bigV, type = c("ts", "sr", "vt"), pf = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bigZ</code></td>
<td>
<p>Matrix of scalarized objective values for each neighborhood and
the incumbent solution (generated by <code>scalarize_values()</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bigV</code></td>
<td>
<p>Matrix of violation values for each neighborhood and the
incumbent solution (generated in <code>order_neighborhood()</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of <code>c(x)</code> function to use (see <code style="white-space: pre;">⁠c(x) Criteria⁠</code> for details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf</code></td>
<td>
<p>probability parameter for type = "sr" (ignored in other modes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other parameters (unused, included for compatibility with
generic call)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function calculates the preference index of a set of neighborhoods
based on the "violation-based ranking" (VBR) constraint handling method. Please
see <code>order_neighborhood()</code> for more information on the preference index
matrix.
</p>
<p>The VBR strategy generalizes some well-known methods for handling constraints
in population-based metaheuristics (see Section <code style="white-space: pre;">⁠c(x) Criteria⁠</code>).
This strategy essentially ranks points within for a given subproblem based on
their aggregated function value (<code>f^{agg}(x|w_i)</code>) or their total constraint
violation (<code>v(x)</code>). Specific variations of this strategy differ on the
criteria for using one or the other.
</p>
<p>The value used for ranking a given point <code>x</code> can be summarized as:
</p>

<table>
<tr>
<td style="text-align: left;">
Violation  </td>
<td style="text-align: left;"> | c(x) criterion </td>
<td style="text-align: left;"> | Rank using: </td>
</tr>
<tr>
<td style="text-align: left;">
<code>v(x) = 0</code> </td>
<td style="text-align: left;"> | <code style="white-space: pre;">⁠c(x) = *⁠</code>     </td>
<td style="text-align: left;"> | <code>f^{agg}(x|w_i)</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
<code>v(x) &gt; 0</code> </td>
<td style="text-align: left;"> | <code>c(x) == TRUE</code> </td>
<td style="text-align: left;"> | <code>f^{agg}(x|w_i)</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
<code>v(x) &gt; 0</code> </td>
<td style="text-align: left;"> | <code>c(x) == FALSE</code>
</td>
<td style="text-align: left;"> | <code>v(x)</code>      </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Points compared according to their <code>f^{agg}(x|w_i)</code> values (i.e., feasible
points and those for which <code>c(x) = TRUE</code>) are ranked first (i.e., receive
ranks between <code>1</code> and <code style="white-space: pre;">⁠n_{feas}⁠</code>, where <code style="white-space: pre;">⁠n_{feas}⁠</code> is the
number of feasible points in the i-th neighborhood), with points that are
compared according to their <code>v(x)</code> values receiving ranks between
<code style="white-space: pre;">⁠(n_{feas} + 1)⁠</code> and <code>T + 1</code> (<code>T</code> being the size of the neighborhood. The <code>+1</code>
comes from including the incumbent solution in the comparison).
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">⁠[ N x (T+1) ]⁠</code> matrix of preference indices. Each row <code>i</code> contains
a permutation of <code style="white-space: pre;">⁠{1, 2, ..., (T+1)}⁠</code>, where <code style="white-space: pre;">⁠1,...,T⁠</code> correspond
to the solutions contained in the neighborhood of the i-th subproblem,
<code>B[i, ]</code>, and <code>T+1</code> corresponds to the incumbent solution for that
subproblem. The order of the permutation is defined by the specific strategy
defined by the input variable <code>type</code>).
</p>


<h3>c(x) Criteria</h3>

<p>Specific variations of the VBR differ on how the criterion c(x) is
implemented. Three variants are currently implemented in the MOEADr package:
</p>

<table>
<tr>
<td style="text-align: left;">
Method                                 </td>
<td style="text-align: left;"> | ID            </td>
<td style="text-align: left;"> | <code>c(x)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
Tournament Selection <code style="white-space: pre;">⁠[Deb2000]⁠</code>       </td>
<td style="text-align: left;"> | <code style="white-space: pre;">⁠$type = "ts"⁠</code>
</td>
<td style="text-align: left;"> | <code>FALSE</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
Stochastic Ranking <code style="white-space: pre;">⁠[Runarsson2000]⁠</code>   </td>
<td style="text-align: left;"> | <code style="white-space: pre;">⁠$type = "sr"⁠</code>
</td>
<td style="text-align: left;"> | <code>runif() &lt; pf</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
Violation Threshold <code style="white-space: pre;">⁠[Asafuddoula2014]⁠</code>
</td>
<td style="text-align: left;"> | <code style="white-space: pre;">⁠$type = "vt"⁠</code>
</td>
<td style="text-align: left;"> | <code>v(x) &lt; eps_v^i</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>where <code class="reqn">pf \in [0,1]</code> is a user-defined parameter for the "sr" method, and
<code>eps_v^i</code> is subproblem-dependent, adaptive quantity calculated internally
in the routine (see <code style="white-space: pre;">⁠[Asafuddoula2014]⁠</code> and <code style="white-space: pre;">⁠[Campelo2017]⁠</code> for details).
</p>


<h3>Using an External Archive</h3>

<p>For types "sr" and "vt", it is possible for the algorithm to lose feasible
solutions during its update step, since there is a non-zero probability of
unfeasible solutions replacing feasible ones. In these cases, it is
recommended to set the <code>moead()</code> parameter <code>update$UseArchive = TRUE</code>, so
that an external archive is built with the best feasible solutions found for
each subproblem.
</p>


<h3>References</h3>

<p><code style="white-space: pre;">⁠[Deb2000]⁠</code> K. Deb,
"An efficient constraint handling method for genetic algorithm",
Computer Methods in Applied Mechanics and Engineering 186(2–4):311–338, 2000.
</p>
<p><code style="white-space: pre;">⁠[Runarsson2000]⁠</code> T. Runarsson, X. Yao,
"Stochastic ranking for constrained evolutionary optimization",
IEEE Transactions on Evolutionary Computation4(3):284–294, 2000.<br></p>
<p><code style="white-space: pre;">⁠[Asafuddoula2014]⁠</code> M. Asafuddoula, T. Ray, R. Sarker, K. Alam,
"An adaptive constraint handling approach embedded MOEA/D,”
2012 IEEE Congress on Evolutionary Computation (CEC).<br></p>
<p><code style="white-space: pre;">⁠[Campelo2017]⁠</code>  F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr
Package: A Component-Based Framework for Multiobjective Evolutionary
Algorithms Based on Decomposition. Journal of Statistical Software
<a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br></p>


</div>