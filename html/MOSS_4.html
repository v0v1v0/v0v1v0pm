<div class="container">

<table style="width: 100%;"><tr>
<td>moss</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multi-Omic integration via Sparse Singular value decomposition.</h2>

<h3>Description</h3>

<p>This function integrates omic blocks to perform sparse singular
value decomposition (SVD), non-linear embedding, and/or cluster
analysis. Both supervised and unsupervised methods are supported.
In both cases, if multiple omic blocks are used as predictors, they
are concatenated and normalized to form an 'extended' omic matrix 'X' 
(Gonzalez-Reymundez and Vazquez, 2020). Supervised analysis can be
obtained by indicating which omic block defines a multivariate 
response 'Y'. Each method within MOSS returns a matrix 'B', 
which form depends on the technique used
(e.g. B = X in pca; B = X'Y, for pls; B = (X'X)^-X'Y, for lrr).
A sparse SVD of matrix B is then obtained to summarize the variability
among samples and features in terms of latent factors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">moss(
  data.blocks,
  scale.arg = TRUE,
  norm.arg = TRUE,
  method = "pca",
  resp.block = NULL,
  covs = NULL,
  K.X = 5,
  K.Y = K.X,
  verbose = TRUE,
  nu.parallel = FALSE,
  nu.u = NULL,
  nu.v = NULL,
  alpha.u = 1,
  alpha.v = 1,
  plot = FALSE,
  cluster = FALSE,
  clus.lab = NULL,
  tSNE = FALSE,
  axes.pos = seq_len(K.Y),
  approx.arg = FALSE,
  exact.dg = FALSE,
  use.fbm = FALSE,
  lib.thresh = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data.blocks</code></td>
<td>
<p>List containing omic blocks of class 'matrix' or
'FBM'. In
each block, rows represent subjects and columns features.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.arg</code></td>
<td>
<p>Should the omic blocks be centered and
scaled? Logical. Defaults to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm.arg</code></td>
<td>
<p>Should omic blocks be
normalized? Logical. Defaults to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Multivariate method. Character.
Defaults to 'pca'. Possible options are pca, mbpca, pca-lda,
mbpca-lda, pls,
mbpls, pls-lda, mbpls-lda, lrr, mblrr, lrr-lda, mblrr-lda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resp.block</code></td>
<td>
<p>What block should be used as response? Integer.
Only used when the specified
method is supervised.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covs</code></td>
<td>
<p>Covariates which effect we wish to adjust for. Accepts matrix,
data.frame, numeric, or character vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K.X</code></td>
<td>
<p>Number of principal components for predictors.
Integer. Defaults to 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K.Y</code></td>
<td>
<p>Number of responses PC index when method is
supervised. Defaults to K.X.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Should we print messages? Logical.
Defaults to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.parallel</code></td>
<td>
<p>Tuning degrees of sparsity in parallel. Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.u</code></td>
<td>
<p>A grid with
increasing integers representing degrees of sparsity for
left Eigenvectors.
Defaults to NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.v</code></td>
<td>
<p>Same but for right Eigenvectors. Defaults to NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.u</code></td>
<td>
<p>Elastic Net parameter for left Eigenvectors.
Numeric between 0
and 1. Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.v</code></td>
<td>
<p>Elastic Net parameter for right
Eigenvectors. Numeric between 0 and 1. Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>Should results be plotted?
Logical. Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Arguments
passed to the function tsne2clus as a list. Defaults to FALSE.
If cluster=TRUE,
default parameters are used (eps_range=c(0,4), eps_res=100).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clus.lab</code></td>
<td>
<p>A
vector of same length than number of subjects with labels used to
visualize clusters. Factor.
Defaults to NULL.
When sparsity is imposed on the left
Eigenvectors, the association between non-zero loadings and
labels' groups is shown by a Chi-2 statistics for each pc.
When sparsity is not imposed, the association between
labels and PC
is addressed by a Kruskal-Wallis statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tSNE</code></td>
<td>
<p>Arguments passed to the function pca2tsne as a list.
Defaults to
FALSE. If tSNE=T, default parameters are used
(perp=50,n.samples=1,n.iter=1e3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes.pos</code></td>
<td>
<p>PC index used for tSNE.
Defaults to 1 : K.Y. Used only when tSNE
is different than NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx.arg</code></td>
<td>
<p>Should we use standard SVD or
random approximations? Defaults to FALSE.
If TRUE and at least one block is of
class 'matrix', irlba is called. If TRUE &amp; is(O,'FBM')==TRUE,
big_randomSVD is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact.dg</code></td>
<td>
<p>Should we compute exact degrees of sparsity? Logical.
Defaults to FALSE. Only relevant When alpha.s or alpha.f are in
the (0,1)
interval and exact.dg = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.fbm</code></td>
<td>
<p>Should we treat omic blocks as
Filed Backed Matrix (FBM)? Logical. Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lib.thresh</code></td>
<td>
<p>Should we use a liberal or conservative
threshold to tune degrees of sparsity? Logical. Defaults to TRUE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Once 'dense' solutions are found (the result of SVD on a matrix B),
the function ssvdEN_sol_path is called to perform sparse SVD (sSVD)
on a grid of possible degrees of sparsity (nu),
for a possible value of the elastic net parameter (alpha).
The sSVD is performed using the algorithm of Shen and Huang (2008),
extended to include Elastic Net type of regularization.
For one latent factor (rank 1 case), the algorithm finds vectors u
and v' and scalar d that minimize:
</p>

<table><tr>
<td style="text-align: right;">
||B-d* uv'||^2 +
lambda(nu_v)(alpha_v||v'||_1 +
(1-alpha_v)||v'||^2) + lambda(nu_u)(alpha_u||u||_1 +
(1-alpha_u)||u||^2)
</td>
</tr></table>
<p>such that ||u|| = 1.
The right Eigenvector is obtained from v / ||v|| and the
corresponding d from u'Bv.
The element lambda(nu_.) is a monotonically decreasing function of
nu_. (the number of desired element different from zero)
onto positive real numbers, and alpha_. is any number between
zero and one
balancing shrinking and variable selection.
Selecting degree of sparsity: The function allows to tune the
degree of sparsity using an ad-hoc method based on
the one presented in Shen &amp; Huang (2008, see reference) and
generalized for tuning both nu_v and nu_u.
This is done by exploring the proportion of
explained variance (PEV) on a grid of possible values.
Drastic and/or steep
changes in the PEV trajectory across degrees of sparsity are
used for automatic selection
(see help for the function ssvdEN_sol_path).
By imposing the additional assumption of omic blocks
being conditionally independent, each multivariate technique can
be extended using a 'multi-block' approach, where the
contribution of each omic block to the total (co)variance is
addressed.
When response Y is a character column matrix,
with classes or categories by subject,
each multivariate technique can be extended to perform
linear discriminant analysis.
</p>


<h3>Value</h3>

<p>Returns a list with the results of the sparse SVD.
If <em>plot</em>=TRUE, a series of plots is generated as well.
</p>

<ul>
<li> <p><em><strong>B:</strong></em>  The object of the (sparse) SVD.
Depending of the method used,
B can be a extended matrix of normalized omic blocks,
a variance-covariance matrix,
or a matrix of regression coefficients.
If at least one of the blocks in 'data.blocks' is of class FBM,
is(B,'FBM') is TRUE.
Otherwise, is(B,'matrix') is TRUE.
</p>
</li>
<li> <p><em><strong>Q:</strong></em> Matrix with the SVD projections at the 
level of subjects.
</p>
</li>
<li> <p><em><strong>selected_items:</strong></em> List containing the position, name, and loadings
of selected features and subjects by latent dimension.
if 'plot=TRUE', a scatterplot is displayed, where the x-axis
represents the latent dimensions, the y-axis the total number 
of features selected in log scale, and each point is a pie chart
showing the relative contribution of each omic to the number of
features selected. The radio of the pie-chart represents the 
coefficient of variation among squared loadings 
(mean squared loadings divided by their standard deviation)
</p>
</li>
<li> <p><em><strong>dense:</strong></em> A list containing the results of the
dense SVD.</p>

<ul>
<li> <p><strong>u:</strong> Matrix with left Eigenvectors.
</p>
</li>
<li> <p><strong>v:</strong> Matrix with right Eigenvectors.
</p>
</li>
<li> <p><strong>d:</strong> Matrix with singular values.
</p>
</li>
</ul>
</li>
<li> <p><em><strong>sparse:</strong></em> A list containing the results of the
sparse SVD.
</p>

<ul>
<li> <p><strong>u:</strong> Matrix with left Eigenvectors.
</p>
</li>
<li> <p><strong>v:</strong> Matrix with right Eigenvectors.
</p>
</li>
<li> <p><strong>d:</strong> Matrix with singular values.
</p>
</li>
<li> <p><strong>opt_dg_v</strong> Selected degrees of sparsity for
right Eigenvectors.
</p>
</li>
<li> <p><strong>opt_dg_u:</strong> Selected degrees of sparsity for
left Eigenvectors.
</p>
</li>
</ul>
</li>
<li>
<p> Graphical displays: Depending on the values in 'plot',
'tSNE','cluster',
and 'clus.lab' arguments, the following ggplot objects can be
obtained.
They contain:</p>

<ul>
<li> <p><strong>scree_plot:</strong> Plots of Eigenvalues and their
first and
second order empirical derivatives along PC indexes.
</p>
</li>
<li> <p><strong>tun_dgSpar_plot:</strong> Plots with the PEV trajectory,
as well as
its first and second empirical derivatives along the degrees of
sparsity path.
</p>
</li>
<li> <p><strong>PC_plot:</strong> Plot of the first principal
components according to axes.pos. By default the first two
are plotted.
</p>
</li>
<li> <p><strong>tSNE_plot:</strong> Plot with the tSNE mapping onto
two dimensions.
</p>
</li>
<li> <p><strong>clus_plot:</strong> The output of function tsne2clus.
</p>
</li>
<li> <p><strong>subLabels_vs_PCs:</strong> Plot of the Kruskal-Wallis
(or Chi-square)
statistics of the association test between PC
(or selected subjects) and
pre-established subjects groups.
</p>
</li>
<li> <p><strong>clusters_vs_PCs:</strong> Plot of the Kruskal-Wallis
(or Chi-square)
statistics of the association test between PC
(or selected subjects) and
detected clusters.
</p>
</li>
</ul>
</li>
</ul>
<h3>Note</h3>


<ol>
<li>
<p> The function does not return PEV for EN parameter
(alpha_v and/or alpha_u), the user needs to provide
a single value for each.
</p>
</li>
<li>
<p> When number of PC index &gt; 1,
columns of T might not be orthogonal.
</p>
</li>
<li>
<p> Although the user is encouraged to
perform data projection and
cluster separately, MOSS allows to do this automatically.
However, both tasks might require further tuning than the
provided by default, and computations could become cumbersome.
</p>
</li>
<li>
<p> Tuning of degrees of sparsity is done heuristically
on training set. In our experience, this results in
high specificity, but rather low sensitivity.
(i.e. too liberal cutoffs, as compared with
extensive cross-validation on testing set).
</p>
</li>
<li>
<p> When 'method' is an unsupervised technique,
'K.X' is the number of
latent factors returned and used in further analysis.
When 'method' is a supervised technique,
'K.X' is used to perform a SVD
to facilitate the product of large matrices and inverses.
</p>
</li>
<li>
<p> If 'K.X' (or 'K.Y') equal 1, no plots are returned.
</p>
</li>
<li>
<p> Although the degree of sparsity maps onto number of
features/subjects for Lasso, the user needs to be aware that this
conceptual correspondence
is lost for full EN (alpha belonging to (0, 1);
e.g. the number of features selected with alpha &lt; 1 will
be eventually larger than the optimal degree of sparsity).
This allows to rapidly increase the number of
non-zero elements
when tuning the degrees of sparsity.
In order to get exact values for the degrees of sparsity
at subjects
or features levels, the user needs to
set the value of 'exact.dg' parameter from 'FALSE'
(the default) to 'TRUE'.
</p>
</li>
</ol>
<h3>References</h3>


<ul>
<li>
<p> Gonzalez-Reymundez, and Vazquez. 2020. Multi-omic Signatures
identify pan-cancer classes of tumors beyond tissue of origin.
Scientific Reports 10 (1):8341  
</p>
</li>
<li>
<p> Shen, Haipeng, and Jianhua Z. Huang. 2008.
Sparse Principal Component
Analysis via Regularized Low Rank Matrix approximation.
Journal of Multivariate Analysis 99 (6). Academic Press: 1015_34.
</p>
</li>
<li>
<p> Baglama, Jim, Lothar Reichel, and B W Lewis. 2018.
Irlba: Fast Truncated Singular Value Decomposition and
Principal Components Analysis for Large Dense and
Sparse Matrices.
</p>
</li>
<li>
<p> Taskesen, Erdogan, Sjoerd M. H. Huisman, Ahmed Mahfouz,
Jesse H. Krijthe, Jeroen de Ridder, Anja van de Stolpe,
Erik van den Akker, Wim Verheagh, and Marcel J. T. Reinders. 2016.
Pan-Cancer Subtyping in a 2D-Map Shows Substructures
That Are Driven by Specific Combinations of Molecular
Characteristics. Scientific Reports 6 (1):24949.
</p>
</li>
<li>
<p> van der Maaten L, Hinton G. Visualizing Data using t-SNE.
J Mach Learn Res. 2008;9: 2579–2605
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Example1: sparse PCA of a list of omic blocks.
library("MOSS")
sim_data &lt;- simulate_data()
set.seed(43)

# Extracting simulated omic blocks.
sim_blocks &lt;- sim_data$sim_blocks

# Extracting subjects and features labels.
lab.sub &lt;- sim_data$labels$lab.sub
lab.feat &lt;- sim_data$labels$lab.feat
out &lt;- moss(sim_blocks[-4],
  method = "pca",
  nu.v = seq(1, 200, by = 100),
  nu.u = seq(1, 100, by = 50),
  alpha.v = 0.5,
  alpha.u = 1
)

library(ggplot2)
library(ggthemes)
library(viridis)
library(cluster)
library(fpc)

set.seed(43)

# Example2: sparse PCA with t-SNE, clustering, and association with
# predefined groups of subjects.
out &lt;- moss(sim_blocks[-4],axes.pos=c(1:5),
  method = "pca",
  nu.v = seq(1, 200, by = 10),
  nu.u = seq(1, 100, by = 2),
  alpha.v = 0.5,
  alpha.u = 1,
  tSNE = TRUE,
  cluster = TRUE,
  clus.lab = lab.sub,
  plot = TRUE
)

# This shows clusters obtained with labels from pre-defined groups
# of subjects.
out$clus_plot

# This shows the statistical overlap between PCs and the pre-defined
# groups of subjects.
out$subLabels_vs_PCs

# This shows the contribution of each omic to the features 
# selected by PC index.
out$selected_items

# This shows features forming signatures across clusters.
out$feat_signatures

# Example3: Multi-block PCA with sparsity.
out &lt;- moss(sim_blocks[-4],axes.pos=1:5,
  method = "mbpca",
  nu.v = seq(1, 200, by = 10),
  nu.u = seq(1, 100, by = 2),
  alpha.v = 0.5,
  alpha.u = 1,
  tSNE = TRUE,
  cluster = TRUE,
  clus.lab = lab.sub,
  plot = TRUE
)
out$clus_plot

# This shows the 'weight' each omic block has on the variability
# explained by each PC. Weights in each PC add up to one.
out$block_weights

# Example4: Partial least squares with sparsity (PLS).
out &lt;- moss(sim_blocks[-4],axes.pos=1:5,
  K.X = 500,
  K.Y = 5,
  method = "pls",
  nu.v = seq(1, 100, by = 2),
  nu.u = seq(1, 100, by = 2),
  alpha.v = 1,
  alpha.u = 1,
  tSNE = TRUE,
  cluster = TRUE,
  clus.lab = lab.sub,
  resp.block = 3,
  plot = TRUE
)
out$clus_plot

# Get some measurement of accuracy at detecting features with signal
# versus background noise.
table(out$sparse$u[, 1] != 0, lab.feat[1:2000])
table(out$sparse$v[, 1] != 0, lab.feat[2001:3000])

# Example5: PCA-LDA
out &lt;- moss(sim_blocks,
  method = "pca-lda",
  cluster = TRUE,
  resp.block = 4,
  clus.lab = lab.sub,
  plot = TRUE
)
out$clus_plot


</code></pre>


</div>