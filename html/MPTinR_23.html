<div class="container">

<table style="width: 100%;"><tr>
<td>gen.data</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate or bootstrap data and get predictions from a model specified in a model file (or connection).
</h2>

<h3>Description</h3>

<p><code>gen.data</code> generates random dataset(s) from given paramater values and model (specified via model file or textConnection) for paramteric bootstrap.<br><code>sample.data</code> generates random dataset(s) from given data for nonparametric bootstrap.<br><code>gen.predictions</code> generates response probabilities or predicted responses from given paramater values and model (specified via model file or textConnection). <br></p>


<h3>Usage</h3>

<pre><code class="language-R">gen.data(parameter.values, samples,
	model.filename, 
	data = NULL, n.per.item.type = NULL,
	restrictions.filename = NULL, model.type = c("easy", "eqn", "eqn2"), 
	reparam.ineq = TRUE, check.model = TRUE)

sample.data(data, samples,
	model.filename = NULL, categories.per.type = NULL,
	model.type = c("easy", "eqn", "eqn2"), check.model = TRUE)	

gen.predictions(parameter.values, 
	model.filename, 
	restrictions.filename = NULL, 
	n.per.item.type = NULL, 
	model.type = c("easy", "eqn", "eqn2"), 
	reparam.ineq = TRUE, check.model = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>parameter.values</code></td>
<td>

<p><code>vector</code> of paramater values. Either named then order is irrelevant or unnamed then must follow the alphabetical order of paramaters (<code>check.mpt</code> returns the alphabetical order of paramater names).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samples</code></td>
<td>

<p>Number of random datasets to be generated from a given set of paramater values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.per.item.type</code></td>
<td>

<p><code>vector</code> of length equal to number of item types (or trees) specifying how many item each item type has. Default is <code>NULL</code>. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>data <code>vector</code>. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>categories.per.type</code></td>
<td>

<p>numeric vector indicating how many response categories each item type has.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.filename</code></td>
<td>

<p>A character <code>vector</code> specifying the location and name of the model file, pssoble a <code>textConnection</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restrictions.filename</code></td>
<td>

<p><code>NULL</code> or a character <code>vector</code> or a <code>list</code> of characters. The default is <code>NULL</code> which corresponds to no restrictions. A character <code>vector</code> specifies the location or name of the restrictions file. A <code>list</code> of characters contains the restrictions directly. See <code>fit.mpt</code> for Details and Examples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.type</code></td>
<td>

<p>Character vector specifying whether the model file is formatted in the easy way (<code>"easy"</code>; i.e., each line represents all branches corresponding to a response category) or the traditional EQN syntax (<code>"eqn"</code> or <code>"eqn2"</code>; see Details and e.g., Stahl &amp; Klauer, 2007). If <code>model.filename</code> ends with .eqn or .EQN, <code>model.type</code> is automatically set to <code>"eqn"</code>. Default is <code>"easy"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reparam.ineq</code></td>
<td>

<p>Should inequality restrictions be applied (i.e., the model reparametrized)? Default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.model</code></td>
<td>

<p>logical. Should model be chekced with random values whether or not the expected values sum to one per tree? Default is <code>TRUE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>gen.data</code> and <code>sample.data</code> are basically wrapper for <code>rmultinom</code> (called multiple times, if there is more than one item type). The <code>prob</code> argument of <code>rmultinom</code> is obtained differently for the two functions. For <code>gen.data</code> it corresponds to the predicted response proportions as returned by <code>get.predictions</code> (which is actually called by <code>gen.data</code>). For <code>sample.data</code> it is the proprtion of responses for each item type.
</p>
<p><code>gen.data</code> needs to know how big the n for each item type is. This can either be specified via the <code>data</code> or the <code>n.per.item.type</code> argument (i.e., one of those needs to be non-<code>NULL</code>). See the examples.
</p>
<p><code>sample.data</code> needs to know which response categories correspond to each item type. This can either be specified via the <code>model.filename</code> or the <code>categories.per.type</code> argument (i.e., one of those needs to be non-<code>NULL</code>). See the examples.
</p>


<h3>Value</h3>

<p>Either a vector or matrix containing the generated data (for <code>gen.data</code> and <code>sample.data</code>) or a vector containing the predictions (for <code>gen.predictions</code>).
</p>


<h3>Author(s)</h3>

<p>Henrik Singmann and David Kellen
</p>


<h3>See Also</h3>

<p><code>fit.mpt</code> or <code>fit.model</code> for functions that will fit the generated data. Note that it is probably a very good idea to set <code>fit.aggregated = FALSE</code> when fitting larger sets of generated data.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#### using the model and data from Broeder &amp; Schuetz:
data(d.broeder, package = "MPTinR")
m.2htm &lt;- system.file("extdata", "5points.2htm.model", package = "MPTinR")
m.sdt &lt;- "pkg/MPTinR/inst/extdata/broeder.sdt.model"

m.sdt &lt;- system.file("extdata", "broeder.sdt.model", package = "MPTinR")

# fit the 2HTM
br.2htm &lt;- fit.mpt(colSums(d.broeder), m.2htm)

# fit the SDT model
br.sdt &lt;- fit.model(colSums(d.broeder), m.sdt, lower.bound = c(rep(-Inf, 5), 0, 1),
	upper.bound = Inf)

# get one random dataset using the paramater values obtained (i.e., parametric bootstrap) 
# and the data argument.
gen.data(br.2htm[["parameters"]][,1], 1, m.2htm, data = colSums(d.broeder))

gen.data(br.sdt[["parameters"]][,1], 1, m.sdt, data = colSums(d.broeder))

# get one random dataset using the paramater values obtained (i.e., parametric bootstrap) 
# and the n.per.item.type argument.
gen.data(br.2htm[["parameters"]][,1], 1, m.2htm, 
	n.per.item.type = c(240, 2160, 600, 1800, 1200, 1200, 1800, 600, 2160, 240))

gen.data(br.sdt[["parameters"]][,1], 1, m.sdt, 
	n.per.item.type = c(240, 2160, 600, 1800, 1200, 1200, 1800, 600, 2160, 240))

# sample one random dataset from the original data:
sample.data(colSums(d.broeder), 1, model.filename = m.2htm)
# above uses the model.filename argument

sample.data(colSums(d.broeder), 1, categories.per.type = rep(2,10))
# above uses the categories.per.type argument


# just get the predicted proportions:
predictions.mpt &lt;- gen.predictions(br.2htm[["parameters"]][,1], m.2htm)
predictions.sdt &lt;- gen.predictions(br.sdt[["parameters"]][,1], m.sdt)

# predicting using the proactive Inhibiton Model (Riefer &amp; Batchelder, 1988, Figure 1)

model1 &lt;- system.file("extdata", "rb.fig1.model", package = "MPTinR")

gen.predictions(c(r = 0.3, p = 1, q = 0.4944), model1)  
gen.predictions(c(r = 0.3, p = 1, q = 0.4944), model1, n.per.item.type = 180)

# the order of parameters is reordered (i.e., not alphabetically)
# but as the vector is named, it does not matter!
# Compare with:
data(rb.fig1.data, package = "MPTinR")
fit.mpt(rb.fig1.data[1,], model1, n.optim = 1)
</code></pre>


</div>