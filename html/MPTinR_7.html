<div class="container">

<table style="width: 100%;"><tr>
<td>fit.mpt.old</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function to fit MPT models (old)
</h2>

<h3>Description</h3>

<p><code>fit.mpt.old</code> function fits <em>binary</em> multinomial processing tree models (MPT models; e.g., Riefer &amp; Batchelder, 1988). However, this function is an old version  using the L-BFGS-B optimization routine. See <code>fit.mpt</code> for the new version. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit.mpt.old(
	data,
	model.filename, 
	restrictions.filename = NULL, 
	n.optim = 5,
	fia = NULL,
	ci = 95, 
	starting.values = NULL,
	output = c("standard", "fia", "full"),
	reparam.ineq = TRUE,
	sort.param = TRUE,
	model.type = c("easy", "eqn", "eqn2"),
	multicore = c("none", "individual", "n.optim"), sfInit = FALSE, nCPU = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Either a <em>numeric</em> <code>vector</code> for individual fit or a <em>numeric</em> <code>matrix</code> or <code>data.frame</code> for multi-individual fit. The data on each position (column for multi-individual fit) must correspond to the respective line in the model file. Fitting for multiple individuals can be parallelized via <code>multicore</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.filename</code></td>
<td>

<p>A character <code>vector</code> specifying the location and name of the model file. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restrictions.filename</code></td>
<td>

<p><code>NULL</code> or a character <code>vector</code> or a <code>list</code> of characters. The default is <code>NULL</code> which corresponds to no restrictions. A character <code>vector</code> specifies the location or name of the restrictions file. A <code>list</code> of characters contains the restrictions directly.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.optim</code></td>
<td>

<p>Number of optimization runs. Can be parallelized via <code>multicore</code>. Default is 5. If the number is high, fitting can take long for <em>large</em> models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fia</code></td>
<td>

<p>Number of random samples to be drawn in the Monte Carlo algorithm to estimate the Fisher Information Approximation (FIA), a minimum description length based measure of model complexity (see Wu, Myung &amp; Batchelder, 2010). The default is <code>NULL</code> which corresponds to no computation of the FIA. Reasonable values (e.g., &gt; 200000) can lead to long computation times (minutes to hours) depending on the size of the model. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>

<p>A scalar corresponding to the size of the confidence intervals for the parameter estimates. Default is 95 which corresponds to 95% confidence intervals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starting.values</code></td>
<td>

<p>A <code>vector</code> or <code>NULL</code>. If <code>NULL</code> (the default), starting values for parameters are randomly drawn from a uniform distribution with the interval <code>(0.05 - 0.95)</code>. If <code>length(starting.values)==2</code>, starting values  are randomly drawn from a uniform distribution with the interval <code>starting.values[1] - starting.values[2])</code>. If <code>length(starting.values)</code> matches the number of parameters in the model, <code>starting.values</code> will be used as the starting values for fitting and <code>n.optim</code> will be set to 1. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>

<p>If "fia", <code>fit.mpt</code> will additionally return the results from <code>get.mpt.fia</code> (if calculated <code>fia</code> not equal <code>NULL</code>). If "full" <code>fit.mpt</code> will additionally return the results from <code>get.mpt.fia</code> and the output of <code>optim</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reparam.ineq</code></td>
<td>

<p>Logical. Indicates whether or not inequality restrictions (when present in the model file) should be enforced while fitting the model. If <code>TRUE</code> (the default) inequality restricted parameters will be reparameterized, if <code>FALSE</code> not. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort.param</code></td>
<td>

<p>Logical. If TRUE, parameters are alphabetically sorted in the parameter table. If FALSE, the first parameters in the parameter table are the non-restricted ones, followed by the restricted parameters. Default is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.type</code></td>
<td>

<p>Character vector specifying whether the model file is formatted in the easy way (<code>"easy"</code>; i.e., each line represents all branches corresponding to a response category) or the traditional EQN syntax (<code>"eqn"</code> or <code>"eqn2"</code>; see Details and e.g., Stahl &amp; Klauer, 2007). If <code>model.filename</code> ends with .eqn or .EQN, <code>model.type</code> is automatically set to <code>"eqn"</code>. Default is <code>"easy"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multicore</code></td>
<td>

<p>Character vector. If not <code>"none"</code>, uses <code>snowfall</code> for parallelization (which needs to be installed separately via <code>install.packages(snowfall)</code>). If <code>"individual"</code>, parallelizes the optimization for each individual (i.e., data needs to be a <code>matrix</code> or <code>data.frame</code>). If <code>"n.optim"</code>, parallelizes the <code>n.optim</code> optimization runs. Default is <code>"none"</code> which corresponds to no parallelization. Note that you need to initialize <code>snowfall</code> in default settings. See <code>sfInit</code> and Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sfInit</code></td>
<td>

<p>Logical. Relevant if <code>multicore</code> is not <code>"none"</code>. If <code>TRUE</code>, <code>fit.mpt</code> will initialize and close the multicore support. If <code>FALSE</code>, (the default) assumes that <code>sfInit()</code> was initialized before. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nCPU</code></td>
<td>

<p>Scalar. Only relevant if <code>multicore</code> is not <code>"none"</code> and <code>sfInit</code> is TRUE. Number of CPUs used by <code>snowfall</code>. Default is 2.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There is a new version of this function using <code>nlminb</code> and the analytically derived gradient and hessian. See <code>fit.mpt</code>. We recommend using the new version <code>fit.mpt</code>, only use this version if you are sure on what to do.
</p>
<p>The model file is either of the easy format or the "classical" EQN format (see below).<br>
In the easy format (the default) the model file contains all trees of the model. Trees are separated by at least one empty line. Everything to the right of a hash (#) is ignored (this behavior is new since version 0.9.2). Lines starting with a # are treated as empty. Each line in each tree corresponds to all branches of this tree (concatenated by a +) that correspond to one of the possible response categories. The position of each line must correspond to the position of this response category in the data object (for multi-individual fit to the respective column).
</p>
<p>The difference between both types of EQN format (<code>"eqn"</code> or<code>"eqn2"</code>) is the way the first line of the model file is treated. If <code>model.file</code> is set to <code>"eqn"</code>, <code>MPTinR</code> will ignore the first line of the model file and will read the rest of the file (as does multiTree; Moshagen, 2010). If <code>model.file</code> is set to <code>"eqn2"</code> MPTinR will only read as many lines as indicated in the first line of the EQN model file (as does e.g., HMMTree; Stahl &amp; Klauer, 2007). As default <code>fit.mpt</code> expects the easy format, but if the filename ends with .eqn or .EQN and <code>model.type</code> is <code>"easy"</code>, <code>model.type</code> is set to <code>"eqn"</code><br>
For the EQN format consult one of the corresponding papers (see e.g., Moshagen, 2010; Stahl &amp; Klauer, 2007). The positions in the data object (number of column for multi-individual fit) must correspond to the category number in the EQN file.<br></p>
<p>Note that names of parameters in the model file should not start with <code>hank.</code>. Variables with these names can lead to unforeseen problems as variables starting with these letters are internally used.
</p>
<p>The restrictions file may contain (sequential) equality (i.e., =) and inequality (i.e., &lt;) restrictions and must adhere to the following rules:<br>
1. Inequalities first.<br>
2. If a variable appears in an inequality restriction, it can not be on the LHS of any further restriction.<br>
3. If a variable appears on RHS of an equality restriction, it can not appear on LHS of an equality restriction.<br>
Note that only "&lt;" is supported as inequality operator but not "&gt;"!<br>
Examples of restrictions are (the following could all appear in one restrictions file):<br><code>D1 &lt; D2 &lt; D3</code><br><code>D4 = D3</code><br><code>B1 = B3 = 0.3333</code><br><code>X4 = X5 = D3</code><br>
Restrictions file may contain comments (i.e., everything to the right of a # will be ignored; new behavior since version 0.9.2)
</p>
<p>For equality restrictions, the equality restricted parameters are simply exchanged with their restrictions before the fitting.<br>
For inequality restricted parameters, the model is reparameterized so that only the rightmost parameter of an inequality restriction remains the original parameter. Each instance of the other parameters in this restriction is replaced by the product of the rightmost parameter and dummy parameters (see Knapp &amp; Batchelder, 2004). This procedure (which is equivalent to method A described in Knapp &amp; Batchelder, 2004) leads to an equivalent model (although the binary MPT structure is not apparent in the resulting equations).<br>
To prohibit this reparameterization (i.e., if the inequality restrictions hold without reparameterization), you can set <code>reparam.ineq</code> to <code>FALSE</code>. This can be useful for obtaining the FIA (see examples in Wu, Myung, &amp; Batchelder, 2010).
</p>
<p>The fitting/optimization is achieved via <code>optim</code>'s L-BFGS-B method by Byrd et al. (1995) with random starting values. To avoid local minima it is useful to set <code>n.optim</code> &gt; 1. If <code>n.optim</code> &gt; 1, the <code>summary</code> of the vector containing the Log-Likelihood values returned by each run of <code>optim</code> is added to the output (to check whether local minima were present). If the model is rather big, <code>n.optim</code> &gt; 1 can be slow.
</p>
<p>To obtain a measure of the model's complexity beyond the number of parameters (and taking inequality restrictions into account), set <code>fia</code> to a (reasonably high) scalar integer (i.e., a number). Then, <code>fit.mpt</code> will obtain the Fisher information approximation (FIA), a minimum description based measure of model complexity, using the algorithm provided by Wu, Myung, &amp; Batchelder (2010a, 2010b) ported from Matlab to R. When performing model-selection, this measure is superior to other methods such as the Akaike information criterion (AIC) or Bayesian information criterion (BIC) which basically only take the number of parameters into account.<br>
To get the FIA, <code>fit.mpt.old</code> performs the following steps:<br>
1. The representation of the model as equations is transformed into the string representation of the model in the context-free language of MPT models (L-BMPT; Purdy &amp; Batchelder, 2009). For this step to be successful it is <em>absolutely necessary</em> that the equations representing the model perfectly map the tree structure of the MPT. That is, the model file is only allowed to contain parameters, their negations (e.g., <code>Dn</code> and <code>(1 - Dn)</code>) and the operators + and *, but nothing else. Simplifications of the equations will seriously distort this step. This step is achieved by <code>make.mpt.cf</code>.<br>
2. The context free representation of the model is then fed into the MCMC function computing the FIA (the port of BMPTFIA provided by Wu, Myung &amp; Batchelder (2010a), see <code>bmpt.fia</code>).<br>
(Actually, both steps are achieved by a call to <code>get.mpt.fia</code>)
</p>
<p>Once again: If one wants to compute the FIA, it is <em>absolutely necessary</em>, that the representation of the model via equations in the model file exactly maps on the structure of the binary MPT (see <code>make.mpt.cf</code> for more details).
</p>
<p>Confidence intervals (CI) are based on the observed Hessian matrix returned by the minimization algorithm (<code>optim</code>).<br>
For inequality restricted parameters, the CIs are computed using the parameter estimates' variance bounds (see Baldi &amp; Batchelder, 2003; especially equation 19). Note that these bounds represent the "worst case scenario" variances, and can lead to CIs outside parameter boundaries if the set of inequalities is large and/or the variances for the reparameterized model are large (Note that CIs for non-restricted parameters can be outside the parameter boundaries as well due to large variances).
</p>
<p>To set the starting values for the fitting process (e.g., to avoid local minima) one can set <code>starting.values</code> to a vector of length 2. Then, starting values are randomly drawn from a uniform distribution from <code>starting.values[1]</code> to <code>starting.values[2]</code>.<br>
Furthermore, one can specify the starting values individually by supplying a vector with the same length as the number of parameters. Starting values must be ordered according to the alphabetical order of the parameters. Use <code>check.mpt</code> for a function that returns the alphabetical order of the parameters. If one specifies the starting values like that, <code>n.optim</code> will be set to 1 as all other values would not make any sense (the optimization routine will produce identical results with identical starting values).
</p>
<p>Multicore fitting is achieved via the <code>snowfall</code> package and needs to be initialized via <code>sfInit</code>. As initialization needs some time, you can either initialize multicore facilities yourself using <code>sfInit()</code> and setting the <code>sfInit</code> argument to <code>FALSE</code> (the default) or let MPTinR initialize multicore facilities by setting the <code>sfInit</code> argument to <code>TRUE</code>. The former is recommended as initializing <code>snowfall</code> takes some time and only needs to be done once if you run <code>fit.mpt.old</code> multiple times. If there are any problems with multicore fitting, first try to initialize <code>snowfall</code> outside MPTinR (e.g., <code>sfInit( parallel=TRUE, cpus=2 )</code>). If this does not work, the problem is not related to MPTinR but to snowfall (for support and references visit: <a href="https://www.imbi.uni-freiburg.de/parallel/">https://www.imbi.uni-freiburg.de/parallel/</a>).<br>
Note that you need to <em>close</em> snowfall via <code>sfStop()</code> after using MPTinR.
</p>
<p><code>fit.model()</code> is essentially a copy of <code>fit.mpt.old</code> that allows the user to specify the upper and lower bounds of the parameters. This function can be used to fit other models than MPT models that can be described in a model file. That is, the model file can contain any type of valid R expressions including R functions (potentially self-written) visible in the global environment (i.e., not only +, *, and - as operators).  Currently <code>fit.model</code> should be viewed as experimental.
</p>
<p>Note that <code>fit.model()</code> is usually slower than <code>fit.mpt.old</code> as there are some more checks in the critical function calculating the likelihood of the model. <br></p>
<p>The <code>lower.bound</code> and <code>upper.bound</code> needs to be of length 1 or equal to the number of <code>free</code> parameters. If length &gt; 1, parameters are mapped to the bounds in alphabetic order of the parameters. Use <code>check.mpt</code> to obtain the alphabetical order of parameters for your model.
</p>
<p>While it should be possible to specify equality or fixed restrictions it will probably lead to unforeseen consequences to specify inequality restrictions for non-MPT models.
</p>


<h3>Value</h3>

<p>For individual fits (i.e., <code>data</code> is a <code>vector</code>) a <code>list</code> containing one or more of the following components from the best fitting model:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>goodness.of.fit</code></td>
<td>
<p>A <code>data.frame</code> containing the goodness of fit values for the model. <code>Log.Likelihood</code> is the Log-Likelihood value. <code>G.Squared</code>, <code>df</code>, and <code>p.value</code> are the <code class="reqn">G^2</code> goodness of fit statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>information.criteria</code></td>
<td>
<p>A <code>data.frame</code> containing model information criteria based on the G^2 value. The FIA values(s) are presented if <code>fia</code> is not <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.info</code></td>
<td>
<p>A <code>data.frame</code> containing other information about the model. If the rank of the Hessian matrix (<code>rank.hessian</code>) <em>does not</em> correspond to the number of parameters in the model (<code>n.parameters</code>) this indicates a serious issue with the identifiability of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>A data.frame containing the parameter estimates and corresponding confidence intervals. If a restriction file was present, the restricted parameters are marked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>list</code> of two matrices; the first one (<code>observed</code>) contains the entered data, the second one (<code>predicted</code>) contains the predicted values.</p>
</td>
</tr>
</table>
<p>For multi-individual fits (i.e., <code>data</code> is a <code>matrix</code> or <code>data.frame</code>) a <code>list</code> with similar elements, but the following differences.<br>
The first elements, <code>goodness.of.fit</code>, <code>information.criteria</code>, and <code>model.info</code>, contain the same information as for individual fits, but each are <code>lists</code> with three elements containing the respective values for: each individual in the list element <code>individual</code>, the sum of the individual values in the list element <code>sum</code>, and the values corresponding to the fit for the aggregated data in the list element <code>aggregated</code>.<br><code>parameters</code> is a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>individual</code></td>
<td>
<p>A 3-dimensional array containing the parameter estimates ([,1,]), confidence intervals [,2:3,], and, if restrictions not <code>NULL</code>, column 4 [,4,] is 0 for non-restricted parameters, 1 for equality restricted parameters, and 2 for inequality restricted parameters. The first dimension refers to the parameters, the second to the information on each parameter, and the third to the individuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p>A <code>data.frame</code> with the mean parameter estimates from the individual estimates. No confidence intervals can be provided for these values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregated</code></td>
<td>
<p>A data.frame containing the parameter estimates and corresponding confidence intervals for the aggregated data. If a restriction file was present, the restricted parameters are marked.</p>
</td>
</tr>
</table>
<p>The element <code>data</code> contains two matrices, one with the <code>observed</code>, and one with the <code>predicted</code> data.
</p>
<p>If <code>n.optim</code> &gt; 1, the <code>summary</code> of the vector (matrix for multi-individual fit) containing the Log-Likelihood values returned by each run of <code>optim</code> is added to the output.
</p>
<p>When using R (&gt;= 2.13.0) compiling <code>fit.mpt.old</code> using <code>compilers</code> <code>cmpfun</code> can significantly improve fitting time.
</p>


<h3>Note</h3>

<p>There may be several warnings <code>fit.mpt.old</code> throws while fitting MPT models. Most of them are not problematic and related to matrix operations needed for confidence intervals. Examples:<br><code>In sqrt(var.params) : NaNs produced</code><br><code>In sqrt(min(var.bound.tmp)) : NaNs produced</code><br>
These warnings are not critical.
</p>
<p>Other warnings may relate to the optimization routine (e.g., <code>Optimization routine [...] did not converge successfully</code>).<br>
In these cases it is recommended to rerun <code>fit.mpt.old</code> to check if the results are stable.
</p>


<h3>Note</h3>

<p>All (model or restriction) files should end with an empty line, otherwise a warning will be shown.
</p>


<h3>Author(s)</h3>

<p>Henrik Singmann and David Kellen with help from Karl Christoph Klauer and Fabian Hoelzenbein.
</p>


<h3>References</h3>

<p>Baldi, P. &amp; Batchelder, W. H. (2003). Bounds on variances of estimators for multinomial processing tree models. <em>Journal of Mathematical Psychology</em>, 47, 467-470. 
</p>
<p>Broeder, A., &amp; Schuetz, J. (2009). Recognition ROCs are curvilinear-or are they? On premature arguments against the two-high-threshold model of recognition. <em>Journal of Experimental Psychology: Learning, Memory, and Cognition</em>, 35(3), 587. doi:10.1037/a0015279
</p>
<p>Byrd, R. H., Lu, P., Nocedal, J., &amp; Zhu, C. (1995). A limited memory algorithm for bound constrained optimization. <em>SIAM J. Scientific Computing</em>, 16, 1190-1208.
</p>
<p>Knapp, B. R., &amp; Batchelder, W. H. (2004). Representing parametric order constraints in multi-trial applications of multinomial processing tree models. <em>Journal of Mathematical Psychology</em>, 48, 215-229.
</p>
<p>Moshagen, M. (2010). multiTree: A computer program for the analysis of multinomial processing tree models. <em>Behavior Research Methods</em>, 42, 42-54.
</p>
<p>Purdy, B. P., &amp; Batchelder, W. H. (2009). A context-free language for binary multinomial processing tree models. <em>Journal of Mathematical Psychology</em>, 53, 547-561.
</p>
<p>Riefer, D. M., &amp; Batchelder, W. H. (1988). Multinomial modeling and the measurement of cognitive processes. <em>Psychological Review</em>, 95, 318-339.
</p>
<p>Stahl, C. &amp; Klauer, K. C. (2007). HMMTree: A computer program for latent-class hierarchical multinomial processing tree models. <em>Behavior Research Methods</em>, 39, 267- 273.
</p>
<p>Wu, H., Myung, J.I., &amp; Batchelder, W.H. (2010a). Minimum description length model selection of multinomial processing tree models. <em>Psychonomic Bulletin &amp; Review</em>, 17, 275-286.
</p>
<p>Wu, H., Myung, J.I., &amp; Batchelder, W.H. (2010b). On the minimum description length complexity of multinomial processing trees. <em>Journal of Mathematical Psychology</em>, 54, 291-303.
</p>


<h3>See Also</h3>

<p><code>fit.mpt</code> for the current and recommended function fot fitting MPTs
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

# The first example fits the MPT model presented in Riefer and Batchelder (1988, Figure 1)
# to the data presented in Riefer and Batchelder (1988, Table 1)
# Note that Riefer and Batchelder (1988, pp. 328) did some hypotheses tests, that are not done here.
# Rather, we use each condition (i.e., row in Table 1) as a different individual.
# We try to use n.optim = 1 here, but this can lead to local minima
# In general we recommend to set n.optim &gt;= 5

# load the data
data(rb.fig1.data)

#get the character string with the position of the model:
model1 &lt;- system.file("extdata", "rb.fig1.model", package = "MPTinR")
model1.eqn &lt;- system.file("extdata", "rb.fig1.model.eqn", package = "MPTinR")

# just fit the first "individual":
fit.mpt.old(rb.fig1.data[1,], model1, n.optim = 1)

#fit all "individuals":
fit.mpt.old(rb.fig1.data, model1, n.optim = 1)

#fit all "individuals" using the .EQN model file:
fit.mpt.old(rb.fig1.data, model1.eqn, n.optim = 1)



# The second example fits the MPT model presented in Riefer and Batchelder (1988, Figure 2)
# to the data presented in Riefer and Batchelder (1988, Table 3)
# First, the model without restrictions is fitted: ref.model
# Next, the model with all r set equal is fitted: r.equal
# Then, the model with all c set equal is fitted: c.equal
# Finally, the inferential tests reported by Riefer &amp; Batchelder, (1988, p. 332) are executed.
# Note, that n.optim = 10, because of frequent local minima.

# get the data
data(rb.fig2.data)

# positions of model and restriction files:
model2 &lt;- system.file("extdata", "rb.fig2.model", package = "MPTinR")
model2r.r.eq &lt;- system.file("extdata", "rb.fig2.r.equal", package = "MPTinR")
model2r.c.eq &lt;- system.file("extdata", "rb.fig2.c.equal", package = "MPTinR")

# The full (i.e., unconstrained) model
(ref.model &lt;- fit.mpt.old(rb.fig2.data, model2, n.optim = 10))

# All r equal
(r.equal &lt;- fit.mpt.old(rb.fig2.data, model2, model2r.r.eq, n.optim = 10))

# All c equal
(c.equal &lt;- fit.mpt.old(rb.fig2.data, model2, model2r.c.eq, n.optim = 10))

# is setting all r equal a good idea?
(g.sq.r.equal &lt;- r.equal[["goodness.of.fit"]][["G.Squared"]] - 
			ref.model[["goodness.of.fit"]][["G.Squared"]])
(df.r.equal &lt;- r.equal[["goodness.of.fit"]][["df"]] - 
			ref.model[["goodness.of.fit"]][["df"]])
(p.value.r.equal &lt;- pchisq(g.sq.r.equal, df.r.equal , lower.tail = FALSE))

# is setting all c equal a good idea?
(g.sq.c.equal &lt;- c.equal[["goodness.of.fit"]][["G.Squared"]] - 
		ref.model[["goodness.of.fit"]][["G.Squared"]])
(df.c.equal &lt;- c.equal[["goodness.of.fit"]][["df"]] - 
		ref.model[["goodness.of.fit"]][["df"]])
(p.value.c.equal &lt;- pchisq(g.sq.c.equal, df.c.equal , lower.tail = FALSE))


# Example from Broeder &amp; Schuetz (2009)
# We fit the data from the 40 individuals from their Experiment 3
# We fit three different models:
# 1. Their 2HTM model: br.2htm
# 2. A restricted 2HTM model with Dn = Do: br.2htm.res
# 3. A 1HTM model (i.e., Dn = 0): br.1htm
# We fit the models with, as well as without, applied inequality restrictions (see Details)
# that is, for some models (.ineq) we impose: G1 &lt; G2 &lt; G3 &lt; G4 &lt; G5 
# As will be apparent, the inequality restrictions do not hold for all individuals.
# Finally, we compute the FIA for all models, taking inequalities into account.
# Note: The following examples will take some time (&gt; 1 hour).

data(d.broeder)
m.2htm &lt;- system.file("extdata", "5points.2htm.model", package = "MPTinR")
r.2htm &lt;- system.file("extdata", "broeder.2htm.restr", package = "MPTinR")
r.1htm &lt;- system.file("extdata", "broeder.1htm.restr", package = "MPTinR")
i.2htm &lt;- system.file("extdata", "broeder.2htm.ineq", package = "MPTinR")
ir.2htm &lt;- system.file("extdata", "broeder.2htm.restr.ineq", package = "MPTinR")
ir.1htm &lt;- system.file("extdata", "broeder.1htm.restr.ineq", package = "MPTinR")

# fit the original 2HTM
br.2htm &lt;- fit.mpt.old(d.broeder, m.2htm)
br.2htm.ineq &lt;- fit.mpt.old(d.broeder, m.2htm, i.2htm)

# do the inequalities hold for all participants?
br.2htm.ineq[["parameters"]][["individual"]][,"estimates",]
br.2htm[["parameters"]][["individual"]][,"estimates",]
# See the difference between forced and non-forced inequality restrictions:
round(br.2htm[["parameters"]][["individual"]][,"estimates",] -
		br.2htm.ineq[["parameters"]][["individual"]][,"estimates",],2)

# The same for the other two models
# The restricted 2HTM
br.2htm.res &lt;- fit.mpt(d.broeder, m.2htm, r.2htm)
br.2htm.res.ineq &lt;- fit.mpt(d.broeder, m.2htm, ir.2htm)
round(br.2htm.res[["parameters"]][["individual"]][,"estimates",] -
		br.2htm.res.ineq[["parameters"]][["individual"]][,"estimates",],2)
# The 1HTM
br.1htm &lt;- fit.mpt(d.broeder, m.2htm, r.1htm)
br.1htm.ineq &lt;- fit.mpt(d.broeder, m.2htm, ir.1htm)
round(br.2htm.res[["parameters"]][["individual"]][,"estimates",] -
		br.2htm.res.ineq[["parameters"]][["individual"]][,"estimates",],2)

# These results show that we cannot compute inequality constraints for the non inequality
#  imposed models (It would look differently if we excluded critical cases, 
# i.e., 2, 6, 7, 10, 18, 21, 25, 29, 32, 34, 35, 37, 38)
# Therefore, we get the FIA for the models as computed above 
# WARNING: The following part will take a long time!

br.2htm.fia &lt;- fit.mpt.old(d.broeder, m.2htm, fia = 200000)
br.2htm.ineq.fia &lt;- fit.mpt.old(d.broeder, m.2htm, i.2htm, fia = 200000)
br.2htm.res.fia &lt;- fit.mpt.old(d.broeder, m.2htm, r.2htm, fia = 200000 )
br.2htm.res.ineq.fia &lt;- fit.mpt.old(d.broeder, m.2htm, ir.2htm, fia = 200000)
br.1htm.fia &lt;- fit.mpt.old(d.broeder, m.2htm, r.1htm, fia = 200000)
br.1htm.ineq.fia &lt;- fit.mpt.old(d.broeder, m.2htm, ir.1htm, fia = 200000)

# Model selection using the FIA
(br.select &lt;- select.mpt(list(orig.2htm = br.2htm.fia, orig.2htm.ineq = br.2htm.ineq.fia,
		res.2htm = br.2htm.res.fia, res.2htm.ineq = br.2htm.res.ineq.fia, 
		orig.1htm = br.1htm.fia, orig.1htm.ineq = br.1htm.ineq.fia)))
# The same results, ordered by FIA
br.select[order(br.select[,"delta.FIA.sum"]),]

# Compare this with the model selection not using FIA:
select.mpt(list(orig.2htm = br.2htm, orig.2htm.ineq = br.2htm.ineq, 
		res.2htm = br.2htm.res, res.2htm.ineq = br.2htm.res.ineq, 
		orig.1htm = br.1htm, orig.1htm.ineq = br.1htm.ineq))




# compare speed of no multicore versus multicore for multiple optimization runs:

require(snowfall)
# change number of CPUs if more are available
nCPU = 2
sfInit( parallel=TRUE, cpus=nCPU, type = "SOCK" )

# NO multicore
system.time(fit.mpt.old(d.broeder, m.2htm))

# multicore:
system.time(fit.mpt.old(d.broeder, m.2htm, multicore = "n.optim"))

sfStop()

## End(Not run)

  </code></pre>


</div>