<div class="container">

<table style="width: 100%;"><tr>
<td>fit.mptinr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit cognitive models for categorical data using an objective function
</h2>

<h3>Description</h3>

<p>Fitting function for package MPTinR. Can fit any model for categorical data specified in an objective function. Fitting can be enhanced with gradient and or Hessian. Predicted values will be added when a prediction function is present.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
fit.mptinr(
	data,
	objective, 
	param.names,
	categories.per.type,
	gradient = NULL, use.gradient = TRUE,
	hessian = NULL, use.hessian = FALSE,
	prediction = NULL,
	n.optim = 5,
	fia.df = NULL,
	ci = 95, 
	starting.values = NULL,
	lower.bound = 0,
	upper.bound = 1,
	output = c("standard", "fia", "full"),
	fit.aggregated = TRUE,
	sort.param = TRUE,
	show.messages = TRUE,
	use.restrictions = FALSE,
	orig.params = NULL,
	restrictions = NULL,	
	multicore = c("none", "individual", "n.optim"), sfInit = FALSE, nCPU = 2,
	control = list(),
    numDeriv = TRUE,
	...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Either a <em>numeric</em> <code>vector</code> for individual fit or a <em>numeric</em> <code>matrix</code> or <code>data.frame</code> for multi-dataset fit. The data on each position (column for multi-dataset fit) must correspond to the respective line in the model file. Fitting for multiple datasets can be parallelized via <code>multicore</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objective</code></td>
<td>

<p>the objective function used for fitting. Needs to return a scalar likelihood value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param.names</code></td>
<td>

<p>character vector giving the parameters present in the model. The order of this vector determines the order with which the output from the fitting routine is interpreted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>categories.per.type</code></td>
<td>

<p>numeric vector indicating how many response categories each item type has.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>

<p>the gradient function used for fitting. Needs to return a vector of same length as <code>param.names</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.gradient</code></td>
<td>

<p>logical. indicating whether or not <code>gradient</code> should be used for fitting. Default is <code>TRUE</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>

<p>the Hessian function used for fitting. Needs to return a matrix with <code>dim = c(length(param.names), length(param.names)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.hessian</code></td>
<td>

<p>logical. indicating whether or not <code>hessian</code> should be used for fitting. Default is <code>FALSE</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction</code></td>
<td>

<p>the prediction function. Needs to return a vector of equal length as the response categories or data. Needs to return probabilities!
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.optim</code></td>
<td>

<p>Number of optimization runs. Can be parallelized via <code>multicore</code>. Default is 5. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fia.df</code></td>
<td>

<p>needed for handling MPTs with computation of FIA coming from <code>fit.mpt</code> or <code>fit.model</code>. Do not use.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>

<p>A scalar corresponding to the size of the confidence intervals for the parameter estimates. Default is 95 which corresponds to 95% confidence intervals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starting.values</code></td>
<td>

<p>A <code>vector</code>, a <code>list</code>, or <code>NULL</code> (the default). If <code>NULL</code> starting values for parameters are randomly drawn from a uniform distribution with the interval <code>(0.1 - 0.9)</code>. See Details for the other options.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.bound</code></td>
<td>

<p>numeric scalar or vector. Can be used in <code>fit.model</code> to set the lower bounds of the parameter space. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.bound</code></td>
<td>

<p>numeric scalar or vector. Can be used in <code>fit.model</code> to set the upper bounds of the parameter space. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>

<p>If "full" <code>fit.mpt</code> will additionally return the return values of <code>nlminb</code> and the Hessian matrices. (If "fia", <code>fit.mpt</code> will additionally return the results from <code>get.mpt.fia</code> (if <code>fia</code> not equal <code>NULL</code>).)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.aggregated</code></td>
<td>

<p>logical. Only relevant for multiple datasets (i.e., <code>matrix</code> or <code>data.frame</code>). Should the aggregated dataset (i.e., data summed over rows) be additionally fitted? Default (<code>TRUE</code>) fits the aggregated data. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort.param</code></td>
<td>

<p>Logical. If TRUE, parameters are alphabetically sorted in the parameter table. If FALSE, the first parameters in the parameter table are the non-restricted ones, followed by the restricted parameters. Default is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.messages</code></td>
<td>

<p>Logical. If TRUE the time the fitting algorithms takes is printed to the console.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.restrictions</code></td>
<td>

<p>needed for handling MPTs coming from <code>fit.mpt</code>. Do not use, unless you are sure what you are doing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orig.params</code></td>
<td>

<p>needed for handling models coming from <code>fit.mpt</code> or <code>fit.model</code>. Do not use, unless you are sure what you are doing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restrictions</code></td>
<td>

<p>needed for handling models coming from <code>fit.mpt</code> or <code>fit.model</code>. Do not use, unless you are sure what you are doing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multicore</code></td>
<td>

<p>Character vector. If not <code>"none"</code>, uses <code>snowfall</code> for parallelization (which needs to be installed separately via <code>install.packages(snowfall)</code>). If <code>"individual"</code>, parallelizes the optimization for each individual (i.e., data needs to be a <code>matrix</code> or <code>data.frame</code>). If <code>"n.optim"</code>, parallelizes the <code>n.optim</code> optimization runs. Default is <code>"none"</code> which corresponds to no parallelization. Note that you need to initialize <code>snowfall</code> in default settings. See <code>sfInit</code> and Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sfInit</code></td>
<td>

<p>Logical. Relevant if <code>multicore</code> is not <code>"none"</code>. If <code>TRUE</code>, <code>fit.mpt</code> will initialize and close the multicore support. If <code>FALSE</code>, (the default) assumes that <code>sfInit()</code> was initialized before. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nCPU</code></td>
<td>

<p>Scalar. Only relevant if <code>multicore</code> is not <code>"none"</code> and <code>sfInit</code> is TRUE. Number of CPUs used by <code>snowfall</code>. Default is 2.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>list containing control arguments passed on to <code>nlminb</code>. See there.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numDeriv</code></td>
<td>

<p>logical. Should the Hessian matrix of the maximum likelihood estimates be estimated numerically using <code>numDeriv::hessian</code> in case it cannot be estimated analytically? This can be extremely time and memory consuming for larger models. Default is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>arguments passed on to the objective function, the gradient function, the hessian function and the prediction function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This functions can be used to fit any model for categorical data that can be specified via a (objective) function (i.e., especially models that are not MPTs). For fitting MPTs or other similar models such as SDTs see <code>fit.mpt</code> or <code>fit.model</code>.
</p>
<p>The only mandatory arguments are: <code>data</code>, <code>objective</code>, <code>param.names</code>, and <code>categories.per.type</code>. Adding a function calculating the <code>gradient</code> will usually significantly speed up the fitting. However, in extreme cases (i.e., many empty cells) using the gradient can interfere with finding the global minima. Adding the function computing the <code>hessian</code> matrix is usually only useful for obtaining the accurate confidence intervals (usually the numerically estimated Hessian matrix is equivalent unless there are many empty cells or parameters at the boundary).
</p>
<p>The <code>objective</code> (and <code>gradient</code> and <code>hessian</code>) function need to take as the first argument a numerical vector of <code>length(param.names)</code> representing the parameters. The other mandatory arguments for these functions are:<br><code>data</code>: A vector containing the data for the dataset being fitted.<br><code>param.names</code>: The character vector containing the parameter names is handed over to the objective.<br><code>n.params</code>: = <code>length(param.names)</code>. To speed up computation the number of parameters is also handed over to the objective on each iteration.<br><code>tmp.env</code>: A <code>environment</code> (created with <code>new.env</code>). The objective function produced by <code>fit.mpt</code> assign the parameter values into this environment using the following statement:<br><code>for (i in seq_len(n.params))  assign(param.names[i],Q[i], envir = tmp.env)</code><br>
Furthermore, <code>fit.mptinr</code> assigns the data points before fitting each dataset into <code>tmp.env</code> with the variables names <code>hank.data.x</code> where <code>x</code> is the ordinal number of that data point (i.e., position or column). In other words, you can use <code>tmp.env</code> to <code>eval</code> you model within this environment and access both parameters and data in it. <br><code>lower.bound</code> and <code>upper.bound</code>: both <code>lower.bound</code> and <code>upper.bound</code> will be passed on to the user-supplied functions as when nlminb fits without <code>gradient</code> it can try to use parameter values outside the bounds. This can be controlled with these arguments isnide the objective function.
</p>
<p>Furthermore, note that all arguments passed via <code>...</code> will be passed to <code>objective</code>, <code>gradient</code>, and <code>hessian</code>. And that these three functions need to take the same arguments. Furthermore <code>gradient</code> must return a vector as long as <code>param.names</code> and <code>hessian</code> must return a square matrix of order <code>length(param.names</code>). See <code>nlminb</code> for (slightly) more info.
</p>
<p>Usage of <code>gradient</code> and/or <code>hessian</code> can be controlled with <code>use.gradient</code> and <code>use.hessian</code>.
</p>
<p><code>prediction</code> is a function similar to <code>objective</code> with the difference that it should return a vector of length <code>sum(categories.per.type</code> giving the probabilities for each item type. This function needs to take the same arguments as <code>objective</code> with the only exception that it does not take <code>lower.bound</code> and <code>upper.bound</code> (but <code>...</code> is passed on to it).
</p>
<p>Note that parameters names should not start with <code>hank.</code>. 
</p>
<p>To set the starting values for the fitting process (e.g., to avoid local minima) one can set <code>starting.values</code> to a vector of length 2 and <code>n.optim &gt; 1</code>. Then, starting values are randomly drawn from a uniform distribution from <code>starting.values[1]</code> to <code>starting.values[2]</code>.
</p>
<p>Alternatively, one can supply a list with two elements to <code>starting.values</code>. Both elements need to be either of length 1 or of length equal to the number of parameters (if both are of length 1, it is the same as if you supply a vector of length 2). For each parameter n (in alphabetical order), a starting value is randomly drawn from a uniform distribution <code>starting.values[[1]][n]</code> to <code>starting.values[[2]][n]</code> (if length is 1, this is the border for all parameters).
</p>
<p>The least interesting option is to specify the starting values individually by supplying a vector with the same length as the number of parameters. Starting values must be ordered according to the alphabetical order of the parameter names. Use <code>check.mpt</code> for a function that returns the alphabetical order of the parameters. If one specifies the starting values like that, <code>n.optim</code> will be set to 1 as all other values would not make any sense (the optimization routine will produce identical results with identical starting values).
</p>
<p>Multicore fitting is achieved via the <code>snowfall</code> package and needs to be initialized via <code>sfInit</code>. As initialization needs some time, you can either initialize multicore facilities yourself using <code>sfInit()</code> and setting the <code>sfInit</code> argument to <code>FALSE</code> (the default) or let MPTinR initialize multicore facilities by setting the <code>sfInit</code> argument to <code>TRUE</code>. The former is recommended as initializing <code>snowfall</code> takes some time and only needs to be done once if you run <code>fit.mpt</code> multiple times. If there are any problems with multicore fitting, first try to initialize <code>snowfall</code> outside MPTinR (e.g., <code>sfInit( parallel=TRUE, cpus=2 )</code>). If this does not work, the problem is not related to MPTinR but to snowfall (for support and references visit: <a href="https://www.imbi.uni-freiburg.de/parallel/">https://www.imbi.uni-freiburg.de/parallel/</a>).<br>
Note that you need to <em>close</em> snowfall via <code>sfStop()</code> after using MPTinR.
</p>


<h3>Value</h3>

<p>For individual fits (i.e., <code>data</code> is a <code>vector</code>) a <code>list</code> containing one or more of the following components from the best fitting model:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>goodness.of.fit</code></td>
<td>
<p>A <code>data.frame</code> containing the goodness of fit values for the model. <code>Log.Likelihood</code> is the Log-Likelihood value. <code>G.Squared</code>, <code>df</code>, and <code>p.value</code> are the <code class="reqn">G^2</code> goodness of fit statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>information.criteria</code></td>
<td>
<p>A <code>data.frame</code> containing model information criteria based on the <code class="reqn">G^2</code> value. The FIA values(s) are presented if <code>fia</code> is not <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.info</code></td>
<td>
<p>A <code>data.frame</code> containing other information about the model. If the rank of the Fisher matrix (<code>rank.fisher</code>) <em>does not</em> correspond to the number of parameters in the model (<code>n.parameters</code>) this indicates a serious issue with the identifiability of the model. A common reason is that one of the parameter estimates lies on the bound of the parameter space (i.e., 0 or 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>A data.frame containing the parameter estimates and corresponding confidence intervals. If a restriction file was present, the restricted parameters are marked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>list</code> of two matrices; the first one (<code>observed</code>) contains the entered data, the second one (<code>predicted</code>) contains the predicted values.</p>
</td>
</tr>
</table>
<p>For multi-dataset fits (i.e., <code>data</code> is a <code>matrix</code> or <code>data.frame</code>) a <code>list</code> with similar elements, but the following differences:<br>
The first elements, <code>goodness.of.fit</code>, <code>information.criteria</code>, and <code>model.info</code>, contain the same information as for individual fits, but each are <code>lists</code> with three elements containing the respective values for: each individual in the list element <code>individual</code>, the sum of the individual values in the list element <code>sum</code>, and the values corresponding to the fit for the aggregated data in the list element <code>aggregated</code>.<br><code>parameters</code> is a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>individual</code></td>
<td>
<p>A 3-dimensional array containing the parameter estimates ([,1,]), confidence intervals [,2:3,], and, if restrictions not <code>NULL</code>, column 4 [,4,] is 0 for non-restricted parameters, 1 for equality restricted parameters, and 2 for inequality restricted parameters. The first dimension refers to the parameters, the second to the information on each parameter, and the third to the individual/dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p>A <code>data.frame</code> with the mean parameter estimates from the individual estimates. No confidence intervals can be provided for these values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregated</code></td>
<td>
<p>A data.frame containing the parameter estimates and corresponding confidence intervals for the aggregated data. If a restriction file was present, the restricted parameters are marked.</p>
</td>
</tr>
</table>
<p>The element <code>data</code> contains two matrices, one with the <code>observed</code>, and one with the <code>predicted</code> data (or is a list containing lists with <code>individual</code> and <code>aggregated</code> <code>observed</code> and <code>predicted</code> data).
</p>
<p>If <code>n.optim</code> &gt; 1, the <code>summary</code> of the vector (matrix for multi-individual fit) containing the Log-Likelihood values returned by each run of <code>optim</code> is added to the output: <code>fitting.runs</code>
</p>
<p>When <code>output == "full"</code> the list contains the additional items:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>optim.runs</code></td>
<td>
<p>A list (or list of lists for multiple datasets) containing the outputs from all runs by <code>nlminb</code> (including those runs produced when fitting did not converge)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.fits</code></td>
<td>
<p>A list (or list of lists for multiple datasets) containing the outputs from the runs by <code>nlminb</code> that had the lowest likelihood (i.e., the successful runs)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>A list  containing the Hessian matrix or matrices of the final parameter estimates.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Warnings may relate to the optimization routine (e.g., <code>Optimization routine [...] did not converge successfully</code>).<br>
In these cases it is recommended to rerun the model to check if the results are stable.
</p>


<h3>Note</h3>

<p>All (model or restriction) files should end with an empty line, otherwise a warning will be shown.
</p>


<h3>Author(s)</h3>

<p>Henrik Singmann and David Kellen.
</p>


<h3>References</h3>

<p>Kellen, D., Klauer, K. C., &amp; Singmann, H. (2012). On the Measurement of Criterion Noise in Signal Detection Theory: The Case of Recognition Memory. <em>Psychological Review</em>. doi:10.1037/a0027727
</p>


<h3>See Also</h3>

<p><code>fit.model</code> or <code>fit.mpt</code> for a function that can fit model represented in a model file.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# the example may occasionally fail due to a starting values - integration mismatch.

# Fit an SDT for a 4 alternative ranking task (Kellen, Klauer, &amp; Singmann, 2012).

ranking.data &lt;- structure(c(39, 80, 75, 35, 61, 54, 73, 52, 44, 63, 40, 48, 80,
49, 43, 80, 68, 53, 81, 60, 60, 65, 49, 58, 69, 75, 71, 47, 44,
85, 23, 9, 11, 21, 12, 21, 14, 20, 19, 15, 29, 13, 14, 15, 22,
11, 12, 16, 13, 20, 20, 9, 26, 19, 13, 9, 14, 15, 24, 9, 19,
7, 9, 26, 16, 14, 6, 17, 21, 14, 20, 18, 5, 19, 17, 5, 11, 21,
4, 9, 15, 17, 7, 17, 11, 11, 9, 19, 20, 3, 19, 4, 5, 18, 11,
11, 7, 11, 16, 8, 11, 21, 1, 17, 18, 4, 9, 10, 2, 11, 5, 9, 18,
6, 7, 5, 6, 19, 12, 3), .Dim = c(30L, 4L))

expSDTrank &lt;- function(Q, param.names, n.params, tmp.env){
   
    e &lt;- vector("numeric",4)

    mu &lt;- Q[1]
    ss &lt;- Q[2]
       
    G1&lt;-function(x){
        ((pnorm(x)^3)*dnorm(x,mean=mu,sd=ss))
    }

    G2&lt;-function(x){
        ((pnorm(x)^2)*dnorm(x,mean=mu,sd=ss)*(1-pnorm(x)))*3
    }

     G3&lt;-function(x){
        (pnorm(x)*dnorm(x,mean=mu,sd=ss)*(1-pnorm(x))^2)*3
    }
 

    e[1] &lt;- integrate(G1,-Inf,Inf,rel.tol = .Machine$double.eps^0.5)$value    
    e[2] &lt;- integrate(G2,-Inf,Inf,rel.tol = .Machine$double.eps^0.5)$value
    e[3] &lt;- integrate(G3,-Inf,Inf,rel.tol = .Machine$double.eps^0.5)$value
    e[4] &lt;- 1-e[1]-e[2]-e[3]  
   
    return(e)
}



SDTrank &lt;- function(Q, data, param.names, n.params, tmp.env, lower.bound, upper.bound){
   
    e&lt;-vector("numeric",4)

    mu &lt;- Q[1]
    ss &lt;- Q[2]
       
    G1&lt;-function(x){
        ((pnorm(x)^3)*dnorm(x,mean=mu,sd=ss))
    }

    G2&lt;-function(x){
        ((pnorm(x)^2)*dnorm(x,mean=mu,sd=ss)*(1-pnorm(x)))*3
    }

     G3&lt;-function(x){
        (pnorm(x)*dnorm(x,mean=mu,sd=ss)*(1-pnorm(x))^2)*3
    }
 

    e[1] &lt;- integrate(G1,-Inf,Inf,rel.tol = .Machine$double.eps^0.5)$value    
    e[2] &lt;- integrate(G2,-Inf,Inf,rel.tol = .Machine$double.eps^0.5)$value
    e[3] &lt;- integrate(G3,-Inf,Inf,rel.tol = .Machine$double.eps^0.5)$value
    e[4] &lt;- 1-e[1]-e[2]-e[3]  
   
    LL &lt;- -sum(data[data!=0]*log(e[data!=0]))
    return(LL)
}

fit.mptinr(ranking.data, SDTrank, c("mu", "sigma"), 4, prediction = expSDTrank, 
		lower.bound = c(0,0.1), upper.bound = Inf)
 
## End(Not run)
</code></pre>


</div>