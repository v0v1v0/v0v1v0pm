<div class="container">

<table style="width: 100%;"><tr>
<td>fitSPM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>fitSPM fits a surplus production model</h2>

<h3>Description</h3>

<p>fitSPM fits a surplus production model (either Schaefer or 
Fox) by first applying optim (using Nelder-Mead) and then nlm. Being 
automated it is recommended that this only be used once plausible 
initial parameters have been identified (through rules of thumb or 
trial and error). It uses negLL1 to apply a negative log-likelihood, 
assuming log-normal residual errors and uses a penalty to prevent 
the first parameter (r) from becoming &lt; 0.0. If that is not wanted then
set funkone to FALSE, which would then use negLL by itself.
The output object is the usual object output from nlm, which can 
be neatly printed using the MQMF function outfit.
The $estimate values can be used in plotspmmod to plot the 
outcome, or in spmboot to conduct bootstrap sampling of the residuals 
from the CPUE model fit, to gain an appreciation of any uncertainty 
in the analysis. Because it requires log(parameters) it does not 
use the magnitude function to set the values of the parscale 
parameters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fitSPM(
  pars,
  fish,
  schaefer = TRUE,
  maxiter = 1000,
  funk = simpspm,
  funkone = TRUE,
  hess = FALSE,
  steptol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>the initial parameter values to start the search for the 
optimum. These need to be on the log-scale (log-transformed)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fish</code></td>
<td>
<p>the matrix containing the fishery data 'year', 'catch', and
'cpue' as a minimum. These exact column names are required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>schaefer</code></td>
<td>
<p>if TRUE, the default, then simpspm is used to fit the
Schaefer model. If FALSE then the approximate Fox model is fitted 
by setting the p parameter to 1e-08 inside simpspm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>the maximum number of iterations to be used by nlm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>funk</code></td>
<td>
<p>the function used to generate the predicted cpue</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>funkone</code></td>
<td>
<p>default = TRUE. Means use negLL1, which constrains the
first parameter (r) to be greater than 0. If FALSE then use negLL
which is identical to negLL1 but lacks the constraint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hess</code></td>
<td>
<p>default is FALSE; should one calculate the hessian matrix?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steptol</code></td>
<td>
<p>the internal step tolerance, required in case nlm reports
the steptol as being too small. defaults to 1e-06</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an nlm output object as a list
</p>


<h3>Examples</h3>

<pre><code class="language-R"> data(dataspm) 
 dataspm &lt;- as.matrix(dataspm) # faster than a data.frame
 pars &lt;- log(c(r=0.2,K=6000,Binit=2800,sigma=0.2))
 ans &lt;- fitSPM(pars,fish=dataspm,schaefer=TRUE,maxiter=1000)
 outfit(ans)   # Schaefer model  -12.12879
 ansF &lt;- fitSPM(pars,dataspm,schaefer=FALSE,maxiter=1000)
 outfit(ansF)  # Fox model       -12.35283 
</code></pre>


</div>