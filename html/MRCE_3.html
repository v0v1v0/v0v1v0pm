<div class="container">

<table style="width: 100%;"><tr>
<td>mrce</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Do multivariate regression with covariance estimation (MRCE)</h2>

<h3>Description</h3>

<p>Let <code class="reqn">S_{+}^q</code> be the set of <code class="reqn">q</code> by <code class="reqn">q</code> symmetric and positive definite matrices
and let <code class="reqn">y_i\in R^q</code> be the measurements of the <code class="reqn">q</code> responses for the <code class="reqn">i</code>th subject
(<code class="reqn">i=1,\ldots, n</code>).
The model assumes that <code class="reqn">y_i</code>
is a realization of the <code class="reqn">q</code>-variate random vector
</p>
<p style="text-align: center;"><code class="reqn">Y_i = \mu + \beta'x_i + \varepsilon_i, \ \ \ \ i=1,\ldots, n</code>
</p>
  
<p>where <code class="reqn">\mu\in R^q</code> is an unknown intercept vector;
<code class="reqn">\beta\in R^{p\times q}</code> is an unknown regression coefficient matrix;
<code class="reqn">x_i \in R^p</code> is the known vector of values for <code class="reqn">i</code>th subjects's predictors,
and <code class="reqn">\varepsilon_1,\ldots, \varepsilon_n</code> are <code class="reqn">n</code> independent copies of a <code class="reqn">q</code>-variate Normal random 
vector with mean 0 and unknown inverse covariance 
matrix <code class="reqn">\Omega \in S_{+}^q</code>.
</p>
<p>This function computes penalized likelihood estimates of the unknown parameters 
<code class="reqn">\mu</code>, <code class="reqn">\beta</code>, and <code class="reqn">\Omega</code>.
Let <code class="reqn">\bar y=n^{-1} \sum_{i=1}^n y_i</code> and <code class="reqn">\bar{x} = n^{-1}\sum_{i=1}^n x_i</code>.
These estimates are
</p>
<p style="text-align: center;"><code class="reqn">
(\hat{\beta}, \hat\Omega) = \arg\min_{(B, Q)\in R^{p\times q}\times S_{+}^q}
\left\{g(B, Q) +\lambda_1 
\left(\sum_{j\neq k} |Q_{jk}| + 1(p\geq n) \sum_{j=1}^q |Q_{jj}| \right)
+ 2\lambda_{2}\sum_{j=1}^p\sum_{k=1}^q  |B_{jk}|\right\}</code>
</p>

<p>and <code class="reqn">\hat\mu=\bar y - \hat\beta'\bar x</code>, where 
</p>
<p style="text-align: center;"><code class="reqn">
g(B, Q) = {\rm tr}\{n^{-1}(Y-XB)'(Y-XB) Q\}-\log|Q|,</code>
</p>

<p><code class="reqn">Y\in R^{n\times q}</code> has <code class="reqn">i</code>th row <code class="reqn">(y_{i}-\bar y)'</code>,
and <code class="reqn">X\in R^{n\times p}</code> has <code class="reqn">i</code>th row <code class="reqn">(x_{i}-\bar{x})'</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mrce(X,Y, lam1=NULL, lam2=NULL, lam1.vec=NULL, lam2.vec=NULL,
     method=c("single", "cv", "fixed.omega"),
     cov.tol=1e-4, cov.maxit=1e3, omega=NULL, 
     maxit.out=1e3, maxit.in=1e3, tol.out=1e-8, 
     tol.in=1e-8, kfold=5, silent=TRUE, eps=1e-5, 
     standardize=FALSE, permute=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> matrix of the values for the prediction variables. 
The <code class="reqn">i</code>th row of <code>X</code> is <code class="reqn">x_i</code> defined above (<code class="reqn">i=1,\ldots, n</code>). 
Do not include a column of ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">q</code> matrix of the observed responses. 
The <code class="reqn">i</code>th row of <code>Y</code> is <code class="reqn">y_i</code> defined above (<code class="reqn">i=1,\ldots, n</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam1</code></td>
<td>
<p>A single value for <code class="reqn">\lambda_1</code> defined above.  This
argument is only used if <code>method="single"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam2</code></td>
<td>
<p>A single value for <code class="reqn">\lambda_2</code> defined above
(or a <code class="reqn">p</code> by <code class="reqn">q</code> matrix with <code class="reqn">(j,k)</code>th entry <code class="reqn">\lambda_{2jk}</code>
in which case the penalty <code class="reqn">2\lambda_{2}\sum_{j=1}^p\sum_{k=1}^q  |B_{jk}|</code> becomes
<code class="reqn">2\sum_{j=1}^p\sum_{k=1}^q \lambda_{2jk}|B_{jk}|</code>). This
argument is not used if <code>method="cv"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam1.vec</code></td>
<td>
<p>A vector of candidate values for <code class="reqn">\lambda_1</code> from which the cross validation procedure
searches: only used when <code>method="cv"</code>
and must be specified by the user when <code>method="cv"</code>.  Please arrange in decreasing order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam2.vec</code></td>
<td>
<p>A vector of candidate values for <code class="reqn">\lambda_2</code> from which the cross validation procedure
searches: only used when <code>method="cv"</code>
and must be specified by the user when <code>method="cv"</code>. Please arrange in decreasing order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>There are three options:
</p>

<ul>
<li> <p><code>method="single"</code> computes the MRCE estimate of the regression coefficient matrix
with penalty tuning parameters <code>lam1</code> and <code>lam2</code>;
</p>
</li>
<li> <p><code>method="cv"</code> performs <code>kfold</code> cross
validation using candidate tuning parameters in <code>lam1.vec</code> and <code>lam2.vec</code>;
</p>
</li>
<li> <p><code>method="fixed.omega"</code> computes the regression coefficient matrix estimate for which <code class="reqn">Q</code> (defined above) 
is fixed at <code>omega</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.tol</code></td>
<td>
<p>Convergence tolerance for the glasso algorithm that minimizes the objective function (defined above)
with <code class="reqn">B</code> fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.maxit</code></td>
<td>
<p>The maximum number of iterations allowed for the glasso algorithm that minimizes the objective function 
(defined above)
with <code class="reqn">B</code> fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>A user-supplied fixed value of <code class="reqn">Q</code>.  Only used when 
<code>method="fixed.omega"</code> in which case the minimizer of the objective function (defined above) with <code class="reqn">Q</code>
fixed at <code>omega</code> is returned.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit.out</code></td>
<td>
<p>The maximum number of iterations allowed for the outer loop of the exact MRCE algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit.in</code></td>
<td>
<p>The maximum number of iterations allowed for the algorithm that minimizes the objective function, defined above,
with <code class="reqn">\Omega</code> fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol.out</code></td>
<td>
<p>Convergence tolerance for outer loop of the exact MRCE algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol.in</code></td>
<td>
<p>Convergence tolerance for the algorithm that minimizes the objective function, defined above,
with <code class="reqn">\Omega</code> fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kfold</code></td>
<td>
<p>The number of folds to use when <code>method="cv"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Logical: when <code>silent=FALSE</code> this function displays progress updates to the screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>The algorithm will terminate if the minimum diagonal entry of the current iterate's residual
sample covariance is less than <code>eps</code>.  This may need adjustment depending on the scales of the variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical: should the columns of <code>X</code> be standardized so each has unit length and zero average.  The parameter estimates are returned on the original unstandarized scale.
The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permute</code></td>
<td>
<p>Logical: when <code>method="cv"</code>, should the subject indices be permutted?  The default is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Please see Rothman, Levina, and Zhu (2010)
for more information on the algorithm and model.
This version of the software uses the glasso algorithm (Friedman et al., 2008) through the R package <code>glasso</code>.
If the algorithm is running slowly, track its progress with <code>silent=FALSE</code>.  
In some cases, choosing <code>cov.tol=0.1</code> and <code>tol.out=1e-10</code> allows the algorithm to make
faster progress.  If one uses a matrix for <code>lam2</code>, consider setting <code>tol.in=1e-12</code>.
</p>
<p>When <code class="reqn">p \geq n</code>,
the diagonal of the optimization variable corresponding 
to the inverse covariance matrix of the error is penalized.
Without diagonal penalization, if there exists a <code class="reqn">\bar B</code> such
that the <code class="reqn">q</code>th column of <code class="reqn">Y</code> is equal to the <code class="reqn">q</code>th
column of <code class="reqn">X\bar B</code>,
then a global minimizer of the objective function 
(defined above) does not exist.
</p>
<p>The algorithm that minimizes the objective function, defined above,
with <code class="reqn">Q</code> fixed uses a similar update strategy and termination 
criterion to those used by Friedman et al. (2010) in the corresponding R package <code>glmnet</code>.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Bhat</code></td>
<td>
<p>This is <code class="reqn">\hat\beta \in R^{p\times q}</code> defined above.  If <code>method="cv"</code>, 
then <code>best.lam1</code> and <code>best.lam2</code> defined below are used for <code class="reqn">\lambda_1</code> and <code class="reqn">\lambda_2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muhat</code></td>
<td>
<p>This is the intercept estimate <code class="reqn">\hat\mu \in R^q</code> defined above.
If <code>method="cv"</code>, 
then <code>best.lam1</code> and <code>best.lam2</code> defined below are used for <code class="reqn">\lambda_1</code> and <code class="reqn">\lambda_2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega</code></td>
<td>
<p>This is <code class="reqn">\hat\Omega \in S_{+}^q</code> defined above.  If <code>method="cv"</code>, 
then <code>best.lam1</code> and <code>best.lam2</code> defined below are used for <code class="reqn">\lambda_1</code> and <code class="reqn">\lambda_2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mx</code></td>
<td>
<p>This is <code class="reqn">\bar x \in R^p</code> defined above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>my</code></td>
<td>
<p>This is <code class="reqn">\bar y \in R^q</code> defined above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.lam1</code></td>
<td>
<p>The selected value for <code class="reqn">\lambda_1</code> by cross validation.   Will be <code>NULL</code> unless <code>method="cv"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.lam2</code></td>
<td>
<p>The selected value for <code class="reqn">\lambda_2</code> by cross validation.   Will be <code>NULL</code> unless <code>method="cv"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.err</code></td>
<td>
<p>Cross validation error matrix with <code>length(lam1.vec)</code> rows and
<code>length(lam2.vec)</code> columns.  Will be <code>NULL</code> unless <code>method="cv"</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The algorithm is fastest when <code class="reqn">\lambda_1</code> and <code class="reqn">\lambda_2</code> are large.  
Use <code>silent=FALSE</code> to 
check if the algorithm is converging before the total iterations exceeds <code>maxit.out</code>.
</p>


<h3>Author(s)</h3>

<p>Adam J. Rothman
</p>


<h3>References</h3>

<p>Rothman, A. J., Levina, E., and Zhu, J. (2010) Sparse multivariate regression with covariance estimation.
Journal of Computational and Graphical Statistics. 19: 947–962.
</p>
<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2008). 
Sparse inverse covariance estimation with the graphical lasso. 
Biostatistics, 9(3), 432-441.
</p>
<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010). 
Regularization Paths for Generalized Linear Models via Coordinate Descent. 
Journal of Statistical Software, 33(1), 1-22.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(48105)
n=50
p=10
q=5

Omega.inv=diag(q)
for(i in 1:q) for(j in 1:q)
  Omega.inv[i,j]=0.7^abs(i-j)
out=eigen(Omega.inv, symmetric=TRUE)
Omega.inv.sqrt=tcrossprod(out$vec*rep(out$val^(0.5), each=q),out$vec)
Omega=tcrossprod(out$vec*rep(out$val^(-1), each=q),out$vec)

X=matrix(rnorm(n*p), nrow=n, ncol=p)
E=matrix(rnorm(n*q), nrow=n, ncol=q)%*%Omega.inv.sqrt
Beta=matrix(rbinom(p*q, size=1, prob=0.1)*runif(p*q, min=1, max=2), nrow=p, ncol=q)
mu=1:q

Y=rep(1,n)%*%t(mu) + X%*%Beta + E

lam1.vec=rev(10^seq(from=-2, to=0, by=0.5))
lam2.vec=rev(10^seq(from=-2, to=0, by=0.5))
cvfit=mrce(Y=Y, X=X, lam1.vec=lam1.vec, lam2.vec=lam2.vec, method="cv")
cvfit

fit=mrce(Y=Y, X=X, lam1=10^(-1.5), lam2=10^(-0.5), method="single")
fit

lam2.mat=1000*(fit$Bhat==0)
refit=mrce(Y=Y, X=X, lam2=lam2.mat, method="fixed.omega", omega=fit$omega, tol.in=1e-12) 
refit
</code></pre>


</div>