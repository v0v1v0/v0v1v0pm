<div class="container">

<table style="width: 100%;"><tr>
<td>MRFA_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a Multi-Resolution Functional ANOVA (MRFA) Model</h2>

<h3>Description</h3>

<p>The function performs the multi-resolution functional ANOVA (MRFA) approach.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MRFA_fit(
  X,
  Y,
  weights = rep(1, length(Y)),
  order = 10,
  level = 10,
  lambda.min = 1e-05,
  converge.tol = 1e-10,
  nvar.max = min(3 * length(Y), 3000),
  k = 2,
  pen.norm = c("2", "N")[1],
  model = LinReg(),
  standardize.d = TRUE,
  center = TRUE,
  standardize = TRUE,
  parallel = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a design matrix with dimension <code>n</code> by <code>d</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>a response vector of size <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a vector of observation weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>a positive integer specifying the highest order of interactions that can be entertained in the model. The default is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>a positive integer specifying the highest resolution level that can be entertained in the model. The default is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>a positive value specifying the minimum penalty value to be performed before the convergence criterion is met.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converge.tol</code></td>
<td>
<p>convergence tolerance. It converges when relative difference with respect to function value (penalized likelihood) is smaller than the tolerance. The default is 1e-10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvar.max</code></td>
<td>
<p>maximum number of non-zero variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>a positive integer specifying the order of Wendland covariance function. The default is 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen.norm</code></td>
<td>
<p>a character string specifying the type of penalty norm for group lasso to be computed. "2" or 2 specifies 2-norm, and "N" specifies native norm. The default is "2".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>an object of class specifying other models. <code>LinReg()</code> (default) fits a linear regression, <code>LogReg()</code> fits a logistic regression, and <code>PoissReg()</code> fits a Poisson regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize.d</code></td>
<td>
<p>logical. If <code>TRUE</code>, the columns of the design matrix will be standardized into [0,1].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>logical. If <code>TRUE</code>, the columns of the model matrix will be centered (except a possible intercept column).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>logical. If <code>TRUE</code>, the model matrix will be blockwise orthonormalized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical. If <code>TRUE</code>, apply function in parallel in <code>ldply</code> using parallel backend provided by foreach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, additional diagnostics are printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A multi-resolution functional ANOVA (MRFA) model targets a low resolution representation of a low order functional ANOVA, with respect to strong effect heredity, to form an accurate emulator in a large-scale and high dimensional problem. This function fits an MRFA model using a modified group lasso algrithm. One can consider the loss function </p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sum_{i=1}^n\left(y_i-\sum_{|u|=1}^{D_{\rm max}}\sum_{r=1}^{R_{\rm max}}\sum_{k=1}^{n_u(r)}\beta_u^{rk}\varphi_u^{rk}(x_{iu})\right)^2+\lambda\sum_{|u|=1}^{D_{\rm max}}\sum_{r=1}^{R_{\rm max}}\sqrt{N_u(r)\sum_{v\subseteq u}\sum_{s\le r}\sum_{k=1}^{n_v(s)}(\beta_v^{sk})^2},</code>
</p>
<p> where <code class="reqn">\varphi_u^{rk}(x_{iu})</code> is the basis function with resolution level <code class="reqn">r</code> and with dimension <code class="reqn">u\subset\{1,2,\ldots,d\}</code>, and <code class="reqn">D_{\rm max}</code> and <code class="reqn">R_{\rm max}</code> respectively are the maximal orders of functional ANOVA and multi-resolution level, which are indicated by <code>order</code> and <code>level</code>.
</p>
<p>The group lasso path along the penalty parameter <code class="reqn">\lambda</code> is given by the function, where the <code class="reqn">\lambda_{\max}</code> is automatically given and <code class="reqn">\lambda_{\min}</code> is given by users, which is indicated by <code>lambda.min</code>. The group lasso algrithm is implemented via the modifications to the source code of the <code>grplasso</code> package (Meier, 2015).
</p>
<p><code>lambda.min</code>, <code>converge.tol</code> and <code>nvar.max</code> are the options for stopping the fitting process. Smaller <code>lambda.min</code>, or smaller <code>converge.tol</code>, or larger <code>nvar.max</code> yields more accurate results, paricularly for deterministic computer experiments. <code>pen.norm</code> specifies the type of penalty norm in the loss function. <code>model</code> specifies the response type, which can be non-continuous response, in the case the loss function is replaced by negative log-likelihood function. More details can be seen in Sung et al. (2017+).
</p>


<h3>Value</h3>

<p>An MRFA object is returned, for which <code>aic.MRFA</code>, <code>bic.MRFA</code> and <code>predict</code> methods exist.
</p>


<h3>Author(s)</h3>

<p>Chih-Li Sung &lt;iamdfchile@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code>predict.MRFA</code> for prediction of the MRFA model.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

#####             Testing function: OTL circuit function                     #####
#####  Thanks to Sonja Surjanovic and Derek Bingham, Simon Fraser University #####
otlcircuit &lt;- function(xx)
{
  Rb1  &lt;- 50   + xx[1] * 100
  Rb2  &lt;- 25   + xx[2] * 45
  Rf   &lt;- 0.5  + xx[3] * 2.5
  Rc1  &lt;- 1.2  + xx[4] * 1.3
  Rc2  &lt;- 0.25 + xx[5] * 0.95
  beta &lt;- 50   + xx[6] * 250

  Vb1 &lt;- 12*Rb2 / (Rb1+Rb2)
  term1a &lt;- (Vb1+0.74) * beta * (Rc2+9)
  term1b &lt;- beta*(Rc2+9) + Rf
  term1 &lt;- term1a / term1b

  term2a &lt;- 11.35 * Rf
  term2b &lt;- beta*(Rc2+9) + Rf
  term2 &lt;- term2a / term2b

  term3a &lt;- 0.74 * Rf * beta * (Rc2+9)
  term3b &lt;- (beta*(Rc2+9)+Rf) * Rc1
  term3 &lt;- term3a / term3b

  Vm &lt;- term1 + term2 + term3
  return(Vm)
}

library(MRFA)
#####   Training data and testing data   #####
set.seed(2)
n &lt;- 1000; n_new &lt;- 100; d &lt;- 6
X.train &lt;- matrix(runif(d*n), ncol = d)
Y.train &lt;- apply(X.train, 1, otlcircuit)
X.test &lt;- matrix(runif(d*n_new), ncol = d)
Y.test &lt;- apply(X.test, 1, otlcircuit)

#####   Fitting    #####
MRFA_model &lt;- MRFA_fit(X.train, Y.train, verbose = TRUE)

#####   Prediction   ######
Y.pred &lt;- predict(MRFA_model, X.test, lambda = min(MRFA_model$lambda))$y_hat
print(sqrt(mean((Y.test - Y.pred)^2)))

## End(Not run)
</code></pre>


</div>