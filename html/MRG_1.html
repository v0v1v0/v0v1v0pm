<div class="container">

<table style="width: 100%;"><tr>
<td>createMRGobject</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a single object containing all necessary objects for multiResGrid functions</h2>

<h3>Description</h3>

<p>Create a single object containing all necessary objects for multiResGrid functions
</p>


<h3>Usage</h3>

<pre><code class="language-R">createMRGobject(
  ifg,
  ress = c(1, 5, 10, 20, 40) * 1000,
  geovar = c("GEO_LCT", "geometry"),
  lnames = NULL,
  vars = NULL,
  weights = NULL,
  mincount = 10,
  countFeatureOrTotal = "feature",
  nlarge = 2,
  plim = 0.85,
  verbose = FALSE,
  nclus = 1,
  clusType = NULL,
  domEstat = TRUE,
  consistencyCheck = FALSE,
  outfile = NULL,
  splitlim = 5e+07,
  checkDominance = TRUE,
  checkReliability = FALSE,
  userfun = NULL,
  strat = NULL,
  confrules = "individual",
  suppresslim = 0,
  sumsmall = FALSE,
  suppresslimSum = 0,
  reliabilitySplit = TRUE,
  plotIntermediate = FALSE,
  addIntermediate = FALSE,
  locAdj = "LL",
  postProcess = TRUE,
  rounding = -1,
  remCols = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ifg</code></td>
<td>
<p>Either a data.frame or tibble or sf-object with the locations and the data of the survey or census data,
or a list of such objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ress</code></td>
<td>
<p>A vector with the different resolutions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geovar</code></td>
<td>
<p>Name of geodata variable in the objects. Must me the same for all of the surveys/censuses, if 
the data sets are not submitted as sf-objects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lnames</code></td>
<td>
<p>Names for the different surveys or censuses if ifg is a list. 
Typically it could be survey years</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>Variable(s) of interest that should be aggregated (necessary when ifg is
used for individual farm specific anonymization rules)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Extrapolation factor(s) (weights) wi of unit i in the sample of units nc 
falling into
a specific cell c. Weights are used for disclosure control measures. 
A weight of 1 will be used if missing.
If only one weight is given, it will be used for all variables. If the length is more than one,
the length has to be equal to the number of variables. If the same weight is used for several variables,
it must be repeated in the weights-vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mincount</code></td>
<td>
<p>The minimum number of farms for a grid cell (threshold rule)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>countFeatureOrTotal</code></td>
<td>
<p>Should the frequency limit be applied on records with a positive
value for a certain feature, or on all records, independent of value of feature</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlarge</code></td>
<td>
<p>Parameter to be used if the nlarge(st) farms should count for maximum plim percent of
the total value for the variable in the grid cell (see details of <code>gridData</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plim</code></td>
<td>
<p>See nlarge</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>indicates if some extra output should be printed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nclus</code></td>
<td>
<p>Number of clusters to use for parallel processing. No parallelization is used
for <code>nclus = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusType</code></td>
<td>
<p>The type of cluster; see <code>makeCluster</code> for more details.
The default of makeCluster is used if type is missing or NA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domEstat</code></td>
<td>
<p>Should the dominance rule be applied as in the IFS handbook (TRUE), where 
the weights are rounded before finding the  first nlarge contributors, or should 
it be the first nlarge contributors*weight, where also fractions are considered (FALSE)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>consistencyCheck</code></td>
<td>
<p>logical; whether consistency between the gridded values and
the similar values from ifg should be checked. The gridded value is derived
from rasterize and the second one from st_join. The two methods can in some 
cases treat border cases between grid cells differently.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outfile</code></td>
<td>
<p>File to direct the output in case of parallel processing, 
see <code>makeCluster</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitlim</code></td>
<td>
<p>For large dataset - split the data set in batches of more or less splitlim size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkDominance</code></td>
<td>
<p>Logical - should the dominance rule be applied?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkReliability</code></td>
<td>
<p>Logical - should the prediction variance be checked, and used for the aggregation?
This considerably increases computation time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>userfun</code></td>
<td>
<p>This gives the possibility to add a user defined function with additional confidentiality rules which 
the grid cell has to pass</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strat</code></td>
<td>
<p>Column name defining the strata for stratified sampling, used if checkReliability is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confrules</code></td>
<td>
<p>Should the frequency rule (number of holdings) refer to the number of holdings with 
a value of the individual vars above zero ("individual") or the total number of holdings in 
the data set ("total")?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suppresslim</code></td>
<td>
<p>Parameter that can be used to avoid that almost empty grid cells are merged with cells 
with considerably higher number of observations. The value is a minimum percentage of the total
potential new cell for a grid cell to be aggregated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sumsmall</code></td>
<td>
<p>Logical; should the suppresslimSum value be applied on the sum of
small grid cells within the lower resolution grid cell?
Note that different combinations of suppreslim and suppreslimSum values 
might not give completely intuitive results.For instance, if both are equal, then
a higher value can lead to more grid cells being left unaggregated for smaller grid sizes, leading
to aggregation for a large grid cell</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suppresslimSum</code></td>
<td>
<p>Parameter similar to suppreslim, but affecting the total
of grid cells to be suppressed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reliabilitySplit</code></td>
<td>
<p>Logical or number - parameter to be used in
calculation of the reliability (if checkReliability = TRUE). It can either give the 
number of groups, or if TRUE, it will create groups of approdcimately 50,000 records per group. 
If FALSE, the data set will not be split, independent on the size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotIntermediate</code></td>
<td>
<p>Logical or number - make a simple plot showing which grid cells have already 
passed the frequency rule. plotintermediate = TRUE, the function will wait 5 seconds after plotting 
before continuing, otherwise it will wait plotintermediate seconds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addIntermediate</code></td>
<td>
<p>Logical; will add a list of all intermediate himgs
and lohs (overlay of himg and the lower resolution grid) as an attribute to
the object to be returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locAdj</code></td>
<td>
<p>parameter to adjust the coordinates if they are exactly on the borders between grid cells. The values
can either be FALSE, or "jitter" (adding a small random value to the coordinates, essentially spreading
them randomly around the real location), "UR", "UL", "LR" or "LL", to describe which corner of the grid 
cell the location belong (upper right, upper left, lower right or lower left).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>postProcess</code></td>
<td>
<p>Logical; should the postprocessing be done as part
of creation of the multiresolution grid (TRUE), or be done in a separate 
step afterwards (FALSE). The second option is useful when wanting
to check the confidential grid cells of the final map</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rounding</code></td>
<td>
<p>either logical (FALSE) or an integer indicating the number 
of decimal places 
to be used. Negative values are allowed (such as the default
value rounding to the closest 10). See also the details
for <code>digits</code> in <code>round</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remCols</code></td>
<td>
<p>Logical; Should intermediate columns be removed? Can be set
to FALSE for further analyses. Temporary columns will not be removed if their names 
partly match the variable names of <code>vars</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Possible arguments to userfun or other internal functions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function creates a single object, containing both 
the mapped data and the parameters for for further processing.
This assures that all processing is done with the same variables.
</p>


<h3>Value</h3>

<p>A list containing the necessary elements for further processing 
with the <code>MRG</code>-package.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(sf)
library(giscoR)

# These are SYNTHETIC agricultural FSS data 
data(ifs_dk) # Census data

# Create spatial data
ifg = fssgeo(ifs_dk, locAdj = "LL")

ress = 1000*2^(1:7)
MRGobject = createMRGobject(ifg = ifg, ress = ress, var = "UAA")
# Run the adaptive grid function only with farm number as con, then plot results
himg1 = multiResGrid(MRGobject)

himg1 = multiResGrid(MRGobject)
# Parameters can be updated in the object or in the call to multiResGrid
MRGobject$suppresslim = 0.02
himg2 = multiResGrid(MRGobject)
himg3 = multiResGrid(MRGobject, suppresslim = 0.05)

 

</code></pre>


</div>