<div class="container">

<table style="width: 100%;"><tr>
<td>ModiSkeleton</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Infer a graph skeleton (undirected graph)
</h2>

<h3>Description</h3>

<p>This function implements the MRPC algorithm in Badsha and Fu (2019) and Badsha et al. (2021) to infers a graph skeleton (i.e., an undirected graph). It is based on the function skeleton from the <code>pcalg</code> package (Kalisch et al., 2012). Both functions perform marginal and conditional indpenendence tests. However, <code>ModiSkeleton</code> implements an online false discovery rate (FDR) control method in order to control the overall FDR, whereas skeleton controls only the type I error rate for each individual test. See details below.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ModiSkeleton(data, suffStat, FDR, alpha, indepTest, labels, p,
             method = c("stable", "original", "stable.fast"),
             m.max = Inf, fixedGaps = NULL, fixedEdges = NULL,
             NAdelete = TRUE, FDRcontrol = c("LOND", "ADDIS", "NONE"),
             tau, lambda, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<p>Many arguments are similar to those in skeleton and pc in the <code>pcalg</code> package. Several arguments here are also arguments for the function MRPC.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Data matrix, where the rows are samples and the columns are features (e.g., genetic variants (GVs) and phenotypes). Columns are for GVs, if available, appear before other columns for phenotypes (e.g., gene expression). For example, if there is one GV, then the first column of the data matrix is the GV and the remaining columns are the gene expression data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffStat</code></td>
<td>
<p>A list of sufficient statistics. When the data is continuous or can be viewed as continuous, this list contains the correlation matrix of the data and the sample size, which are the necessary elements for the conditional independence tests in gaussCItest. When the data is discrete, this list contains the entire dataset.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FDR</code></td>
<td>

<p>Desired overall FDR level.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>significance level (number in (0,1) for the individual tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indepTest</code></td>
<td>
<p>Name of the statistical test. It is used to test the independence of x and y given S, where x and y are variables and S is a vector, possibly empty, of variables. The return value of indepTest is the p-value of the test for conditional independence.  Different tests may used for different data types. For example, <code>indepTest='gaussCItest'</code> for Gaussian data, <code>indepTest='disCItest'</code> for discrete data, and <code>indepTest='binCItest'</code> for binary data. See additional details in help(gaussCItest).
</p>
<p>ci.test in the <code>bnlearn</code> package (Marco Scutari, 2010) may also be used for testing conditional independence and return a p-value. The default test statistic is the mutual information for categorical variables, the Jonckheere-Terpstra test for ordered factors and the linear correlation for continuous variables. See help(ci.test).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>A character vector of names of variables (nodes). These are typically the column names of the data matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>(optional) The number of variables (nodes). Need to be specified if the labels are not provided, in which case the labels are set to 1:p.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>(optional) Character string specifying method. The default, "stable" provides an order-independent skeleton.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.max</code></td>
<td>

<p>(optional) Maximum size of the conditioning sets that are considered in the conditional independence tests.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedGaps</code></td>
<td>
<p>(optional) A logical matrix of dimension p*p. If entry [x, y], [y, x], or both are TRUE, the edge x—y is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedEdges</code></td>
<td>
<p> (optional) A logical matrix of dimension p*p. If entry [x, y], [y, x], or both are TRUE, the edge x—y is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NAdelete</code></td>
<td>
<p>(optional) If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FDRcontrol</code></td>
<td>
<p>A character string specifying whether online FDR control should be applied, and if so, what method to use. The two FDR control options are "LOND" (Javanmard and Montanari, 2015) or "ADDIS" (Tian and Ramdas, 2019). If "NONE" is specified, the type I error rate "alpha" will be used for each test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>A number between 0 and 1. This value is used to determine if a p-value will be considered for testing. For example, if a p-value is greater than tau then it is discarded and no test will be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A number between 0 and tau. This value is used to determine if a p-value is a candidate for rejection. For example, if a p-value is smaller than lambda then it can be rejected when testing the hypothesis (if the p-value is smaller than alphai).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>(optional) If TRUE, detailed output is provided. Default is FALSE for no output details
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The ModiSkeleton function incorporates sequential hypothesis testing to infer the graph skeleton. This function starts with a complete graph (all nodes are connected with undirected edges) and performs a series of marginal and conditional independence tests, removing the corresponding edge if the test is not rejected.
</p>
<p><b>First</b>, all pairs of nodes are tested for marginal independence. If two nodes x and y are judged to be marginally independent at a type I error rate alpha, the edge between them is deleted and the empty set is saved as separation sets S[x, y] and S[y, x]. After all pairs have been tested for marginal independence, some edges may be removed.
</p>
<p><b>Second</b>, nodes (x, y) with an edge are tested for conditional independence given all subsets of the neighboring nodes. If there is any node z such that x and y are conditionally independent given z, the edge between x and y is removed and node z is saved as separation set, sepset, S[x, y] and S[y, x]. The algorithm continues in this way by increasing the size of the conditioning set step by step. The algorithm stops if all adjacency sets in the current graph are smaller than the size of the conditioning set. The result is the skeleton in which every edge is still undirected.
</p>
<p>Unlike existing algorithms, which control only the type I error rate for each individual test, MRPC implements the LOND (Level On the Number of Discoveries) method (Javanmard and Montanari, 2015), which is a sequential hypothesis testing procedure and sets value of alpha for each test based on the number of discoveries (i.e., rejections), to control the overall false discovery rate.
</p>


<h3>Value</h3>

<p>An object containing an estimate of the skeleton of the underlying DAG as follow:
</p>

<dl>
<dt>
<code>call</code>:</dt>
<dd>
<p>A call object: the original function call.</p>
</dd>
<dt>
<code>n</code>:</dt>
<dd>
<p>The sample 
size used to estimate the graph.</p>
</dd>
<dt>
<code>max.ord</code>:</dt>
<dd>
<p>The 
maximum size of the conditioning set used 
in the conditional independence tests of   
the first part of the algorithm.</p>
</dd>
<dt>
<code>n.edgetests</code>:</dt>
<dd>
<p>The number of 
conditional independence tests performed by
the first part of the algorithm.</p>
</dd>
<dt>
<code>sepset</code>:</dt>
<dd>
<p>Separation sets.</p>
</dd>
<dt>
<code>pMax</code>:</dt>
<dd>
<p>A square matrix
, where the (i, j)th entry contains the 
maximum p-value of all conditional
independence tests for edge i–j.</p>
</dd>
<dt>
<code>graph</code>:</dt>
<dd>
<p>Object of class <code>"graph"</code>:
The undirected or partially directed graph that was estimated.</p>
</dd>
<dt>
<code>zMin</code>:</dt>
<dd>
<p>Deprecated.</p>
</dd>
<dt>
<code>test</code>:</dt>
<dd>
<p>The number of tests that have been performed.</p>
</dd>
<dt>
<code>alpha</code>:</dt>
<dd>
<p>The level of significance 
for the current test.</p>
</dd>
<dt>
<code>R</code>:</dt>
<dd>
<p>All of the decisions made from tests that have been performed. A 1 indicates a rejected null hypothesis and 0 represents a null hypothesis that was not rejected.</p>
</dd>
<dt>
<code>K</code>:</dt>
<dd>
<p>The total number of rejections.</p>
</dd>
<dt>
<code>pval</code>:</dt>
<dd>
<p>A vector of p-values calculated for each test.</p>
</dd>
<dt>
<code>normalizer</code>:</dt>
<dd>
<p>The value that ensures the vector gammai sums to one.</p>
</dd>
<dt>
<code>exponent</code>:</dt>
<dd>
<p>The exponent of the p-series used to calculate each value of the gammai vector.</p>
</dd>
<dt>
<code>alphai</code>:</dt>
<dd>
<p>A vector containing the alpha value calculated for each test.</p>
</dd>
<dt>
<code>kappai</code>:</dt>
<dd>
<p>A vector containing the iteration at which each rejected test occurs.</p>
</dd>
<dt>
<code>kappai_star</code>:</dt>
<dd>
<p>Each element of this vector is the sum of the Si vector up to the iteration at which each rejection occurs.</p>
</dd>
<dt>
<code>Ci</code>:</dt>
<dd>
<p>A vector indicating whether or not a p-value is a candidate for being rejected.</p>
</dd>
<dt>
<code>Si</code>:</dt>
<dd>
<p>A vector indicating whether or not a p-value was discarded.</p>
</dd>
<dt>
<code>Ci_plus</code>:</dt>
<dd>
<p>Each element of this vector represents the number of times each kappai value was counted when calculating each alphai value.</p>
</dd>
<dt>
<code>gammai</code>:</dt>
<dd>
<p>The elements of this vector are the values of the p-series 0.4374901658/(m^(1.6)), where m is the iteration at which each test is performed.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>2. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812.
</p>
<p>3. Javanmard A and Montanari A (2015). On Online Control of False Discovery Rate. arXiv:150206197 [statME].
</p>
<p>4. Kalisch M, Machler M, Colombo D, Maathuis MH and Buhlmann P (2012). Causal Inference Using Graphical Models with the R Package pcalg. Journal of Statistical Software, 47, 26.
</p>
<p>5. Tian J and Ramdas A (2019). ADDIS: an adaptive discarding algorithm for online FDR control with conservative nulls. In Advances in Neural Information Processing Systems (pp. 9388-9396).
</p>


<h3>See Also</h3>

<p>MRPC; EdgeOrientation; SimulateData.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Model 1 (mediation)

# The 1st column of the data matrix is a genetic variant
# and the remaining columns are gene expression nodes.
data &lt;- simu_data_M1 # load data for model 1
n &lt;- nrow(data)      # Number of row
V &lt;- colnames(data)  # Column names

# Calculate Pearson correlation
suffStat_C &lt;- list(C = cor(data),
                   n = n)

# Infer a graph skeleton
Skel.fit &lt;- ModiSkeleton(data, 
                         suffStat = suffStat_C,
                         FDR = 0.05, 
                         indepTest = 'gaussCItest',
                         labels = V, 
                         FDRcontrol = 'LOND', 
                         verbose = FALSE)

# Plot the results

plot(Skel.fit@graph,
     main ="Estimated Skeleton")

# Other models are available and may be called as follows:
# Model 0
# data &lt;- simu_data_M0

# Model 2
# data &lt;- simu_data_M2

# Model 3
# data &lt;- simu_data_M3

# Model 4
# data &lt;- simu_data_M4

# Model Multiparent
# data &lt;- simu_data_multiparent

# Model Star
# data &lt;- simu_data_starshaped

# Model Layered
# data &lt;- simu_data_layered


## End(Not run)
</code></pre>


</div>