<div class="container">

<table style="width: 100%;"><tr>
<td>implement.MSPRT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Implementing the MSPRT
</h2>

<h3>Description</h3>

<p>This function implements the MSPRT for a sequentially observed data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">implement.MSPRT(obs, obs1, obs2, design.MSPRT.object, 
                termination.threshold, test.type, side = "right",
                theta0, Type1.target = 0.005, Type2.target = 0.2,
                N.max, N1.max, N2.max, 
                sigma = 1, sigma1 = 1, sigma2 = 1,
                batch.size, batch1.size, batch2.size,
                verbose = T, plot.it = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obs</code></td>
<td>

<p>Numeric vector. The vector of data in the order they are sequentially observed for one-sample tests.
Note: Its length can't exceed the length of <code>batch.size</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs1</code></td>
<td>

<p>Numeric vector. The vector of data in the order they are sequentially observed from Group-1 for two-sample tests.
Note: Its length can't exceed the length of <code>batch1.size</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs2</code></td>
<td>

<p>Numeric vector. The vector of data in the order they are sequentially observed from Group-2 for two-sample tests.
Note: Its length can't exceed the length of <code>batch2.size</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design.MSPRT.object</code></td>
<td>

<p>List. The output returned from <code>design.MSPRT</code> corresponding to the MSPRT for which the operating characteristics are desired.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>termination.threshold</code></td>
<td>

<p>Positive numeric. Termination threshold of the designed MSPRT.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.type</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta0</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Type1.target</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Type2.target</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N.max</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N1.max</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N2.max</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma1</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch.size</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch1.size</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch2.size</code></td>
<td>

<p>Same as in <code>design.MSPRT</code>. Not required if <code>design.MSPRT.object</code> is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical. If TRUE (<strong>default</strong>), returns messages of the current proceedings. Otherwise it doesn't.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.it</code></td>
<td>

<p>0, 1 or 2 (<strong>default</strong>). 
</p>

<ul>
<li>
<p> if <code>plot.it=0</code>, no plot is returned.
</p>
</li>
<li>
<p> if <code>plot.it=1</code>, only the ggplot object required to get a comparison plot is returned, but it's not plotted.
</p>
</li>
<li>
<p> if <code>plot.it=2</code>, a comparison plot and the corresponding ggplot object is returned.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>design.MSPRT.object</code> is provided, one can only additionally provide <code>nReplicate</code>, <code>nCore</code>, <code>verbose</code> and <code>seed</code> (Easier option). Otherwise, just like in <code>design.MSPRT</code>, all the other arguments together with <code>termination.threshold</code> (obtained from <code>design.MSPRT</code>) needs to be provided adequately.
</p>


<h3>Value</h3>

<p>List. The list has the following named components in case of one-sided one-sample tests:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>Positive integer. Number of samples required to reach the decision.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decision</code></td>
<td>

<p>Character. The decision reached. The possibilities are <code>'accept'</code>, <code>'reject'</code> and <code>'continue'</code>. They respectively correspond to accepting <code class="reqn">H_0</code>, rejecting <code class="reqn">H_0</code> and continue sampling.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RejectH0.threshold</code></td>
<td>

<p>Positive numeric. Threshold for rejecting <code class="reqn">H_0</code> in the MSPRT.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RejectH1.threshold</code></td>
<td>

<p>Positive numeric. Threshold for accepting <code class="reqn">H_1</code> in the MSPRT.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LR</code></td>
<td>

<p>Numeric vector. Vector of weighted likelihood ratios (proportion tests) or likelihood ratios (z tests) or Bayes factor (t tests) that are computed at each step of sequential analysis until either a decision is reached or the maximum available number of samples (<code>N.max</code> in one-sample tests, or <code>N1.max</code> and <code>N2.max</code> in two-sample tests) has been used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>UMPBT alternative</code></td>
<td>

<p>This stores the UMPBT alternative(s) as
</p>

<ul>
<li> <p><code>UMPBT</code> for proportion tests. Of the same type as it is returned by <code>UMPBT.alt</code> in these tests.
</p>
</li>
<li> <p><code>theta.UMPBT</code> for z and t tests. This is a numeric in case of z tests and a numeric vector in case of t tests. For t tests the UMPBT alternative depends on the data. So the numeric vector returned in this case contains the UMPBT alternative computed at step of sequential analysis and is based on all data observed until that step.
</p>
</li>
</ul>
</td>
</tr>
</table>
<p>In case of two-sample tests, the <code>n</code> output above is replaced by <code>n1</code> and <code>n2</code>. They are positive integers and refer to the number of samples from Group-1 and 2 required to reach the decision.
</p>
<p>In case of two-sided tests at level of significance <code class="reqn">\alpha</code>, the MSPRT carries out a right and a left sided test simultaneously at level of significance <code class="reqn">\alpha/2</code>. In this case the outputs are same as above with following changes in components in the returned list:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>LR</code></td>
<td>

<p>List. It has two components named <code>right</code> and <code>left</code> corresponding to the right and left sided tests of size <code class="reqn">\alpha/2</code>. Each of these components stores the vector of weighted likelihood ratios (proportion tests) or likelihood ratios (z tests) or Bayes factor (t tests) that are computed at each step of sequential analysis until either a decision is reached or the maximum available number of samples (<code>N.max</code> in one-sample tests, or <code>N1.max</code> and <code>N2.max</code> in two-sample tests) has been used for that sided test.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>UMPBT or theta.UMPBT</code></td>
<td>
<p>List with two components named <code>right</code> and <code>left</code> corresponding to the right and left sided tests of size <code class="reqn">\alpha/2</code>. Each of these contains the UMPBT alternative (of the same type as the output from <code>UMPBT.alt</code> for the test with respective sides.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Sandipan Pramanik, Valen E. Johnson and Anirban Bhattacharya
</p>


<h3>References</h3>

<p>Pramanik S., Johnson V. E. and Bhattacharya A. (2020+). A Modified Sequential Probability Ratio Test. <a href="https://arxiv.org/pdf/1811.08478.pdf">[Arxiv]</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#################### one-sample proportion test ####################

#### right sided ####
### design
#design.oneprop.right = design.MSPRT(test.type = 'oneProp', side = 'right',
#                                    N.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0.5  # change effect size to experiment
#y = rbinom(20, 1, theta.gen)
#implement.oneprop.right = implement.MSPRT(obs = y, 
#                                          design.MSPRT.object = design.oneprop.right)

#### left sided ####
### design
#design.oneprop.left = design.MSPRT(test.type = 'oneProp', side = 'left',
#                                   N.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0.5  # change effect size to experiment
#y = rbinom(20, 1, theta.gen)
#implement.oneprop.left = implement.MSPRT(obs = y, 
#                                          design.MSPRT.object = design.oneprop.left)

#### both sided ####
### design
#design.oneprop.both = design.MSPRT(test.type = 'oneProp', side = 'both',
#                                   N.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0.5  # change effect size to experiment
#y = rbinom(20, 1, theta.gen)
#implement.oneprop.both = implement.MSPRT(obs = y, 
#                                         design.MSPRT.object = design.oneprop.both)


#################### one-sample z test ####################

#### right sided ####
### design
#design.onez.right = design.MSPRT(test.type = 'oneZ', side = 'right',
#                                 N.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y = rnorm(20, theta.gen, design.onez.right$sigma)
#implement.onez.right = implement.MSPRT(obs = y, 
#                                       design.MSPRT.object = design.onez.right)

#### left sided ####
### design
#design.onez.left = design.MSPRT(test.type = 'oneZ', side = 'left',
#                                N.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y = rnorm(20, theta.gen, design.onez.left$sigma)
#implement.onez.left = implement.MSPRT(obs = y, 
#                                      design.MSPRT.object = design.onez.left)

#### both sided ####
### design
#design.onez.both = design.MSPRT(test.type = 'oneZ', side = 'both',
#                                N.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y = rnorm(20, theta.gen, design.onez.both$sigma)
#implement.onez.both = implement.MSPRT(obs = y, 
#                                      design.MSPRT.object = design.onez.both)


#################### one-sample t test ####################

#### right sided ####
### design
#design.onet.right = design.MSPRT(test.type = 'oneT', side = 'right',
#                                 N.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y = rnorm(20, theta.gen, 1)
#implement.onet.right = implement.MSPRT(obs = y, 
#                                       design.MSPRT.object = design.onet.right)

#### left sided ####
### design
#design.onet.left = design.MSPRT(test.type = 'oneT', side = 'left',
#                                N.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y = rnorm(20, theta.gen, 1)
#implement.onet.left = implement.MSPRT(obs = y, 
#                                      design.MSPRT.object = design.onet.left)

#### both sided ####
### design
#design.onet.both = design.MSPRT(test.type = 'oneT', side = 'both',
#                                N.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y = rnorm(20, theta.gen, 1)
#implement.onet.both = implement.MSPRT(obs = y, 
#                                      design.MSPRT.object = design.onet.both)


#################### two-sample z test ####################

#### right sided ####
### design
#design.twoz.right = design.MSPRT(test.type = 'twoZ', side = 'right',
#                                 N1.max = 20, N2.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y1 = rnorm(20, theta.gen/2, design.twoz.right$sigma1)
#y2 = rnorm(20, -theta.gen/2, design.twoz.right$sigma2)
#implement.twoz.right = implement.MSPRT(obs1 = y1, obs2 = y2,
#                                       design.MSPRT.object = design.twoz.right)

#### left sided ####
### design
#design.twoz.left = design.MSPRT(test.type = 'twoZ', side = 'left',
#                                N1.max = 20, N2.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y1 = rnorm(20, theta.gen/2, design.twoz.left$sigma1)
#y2 = rnorm(20, -theta.gen/2, design.twoz.left$sigma2)
#implement.twoz.left = implement.MSPRT(obs1 = y1, obs2 = y2,
#                                      design.MSPRT.object = design.twoz.left)

#### both sided ####
### design
#design.twoz.both = design.MSPRT(test.type = 'twoZ', side = 'both',
#                                N1.max = 20, N2.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y1 = rnorm(20, theta.gen/2, design.twoz.both$sigma1)
#y2 = rnorm(20, -theta.gen/2, design.twoz.both$sigma2)
#implement.twoz.both = implement.MSPRT(obs1 = y1, obs2 = y2,
#                                      design.MSPRT.object = design.twoz.both)


#################### two-sample t test ####################

#### right sided ####
### design
#design.twot.right = design.MSPRT(test.type = 'twoT', side = 'right',
#                                 N1.max = 20, N2.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y1 = rnorm(20, theta.gen/2, 1)
#y2 = rnorm(20, -theta.gen/2, 1)
#implement.twot.right = implement.MSPRT(obs1 = y1, obs2 = y2,
#                                       design.MSPRT.object = design.twot.right)

#### left sided ####
### design
#design.twot.left = design.MSPRT(test.type = 'twoT', side = 'left',
#                                N1.max = 20, N2.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y1 = rnorm(20, theta.gen/2, 1)
#y2 = rnorm(20, -theta.gen/2, 1)
#implement.twot.left = implement.MSPRT(obs1 = y1, obs2 = y2,
#                                      design.MSPRT.object = design.twot.left)

#### both sided ####
### design
#design.twot.both = design.MSPRT(test.type = 'twoT', side = 'both',
#                                N1.max = 20, N2.max = 20)

### implementation
#set.seed(1)
#theta.gen = 0  # change effect size to experiment
#y1 = rnorm(20, theta.gen/2, 1)
#y2 = rnorm(20, -theta.gen/2, 1)
#implement.twot.both = implement.MSPRT(obs1 = y1, obs2 = y2,
#                                      design.MSPRT.object = design.twot.both)
</code></pre>


</div>