<div class="container">

<table style="width: 100%;"><tr>
<td>MST</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multivariate Survival Trees</h2>

<h3>Description</h3>

<p>Constructs trees for multivariate survival data using marginal and frailty models.  A wrapper function that grows a large initial tree, prunes the tree, and selects the best sized tree.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MST(formula, data, test = NULL, weights_data, weights_test, subset,
  method = c("marginal", "gamma.frailty", "exp.frailty", "stratified", "independence"),
  minsplit = 20, minevents = 3, minbucket = round(minsplit/3), maxdepth = 10,
  mtry = NULL, distinct = TRUE, delta = 0.05, nCutPoints = 50,
  selection.method = c("test.sample", "bootstrap"),
  B = 30, LeBlanc = TRUE, min.boot.tree.size = 1,
  plot.Ga = TRUE, filename = NULL, horizontal = TRUE, details = FALSE, sortTrees = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A linear survival model with the response on the left of a ~ operator and the predictors, separated by + operators, on the right.  Cluster (or id) variable is distinguished by a vertical bar <code>|</code> (e.g. <code>Surv(time,status) ~ x1 + x2 | id</code>).  Categorical predictors must be treated as a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data to grow and prune the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>Test sample if available</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights_data</code></td>
<td>
<p>An optional vector of weights to grow the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights_test</code></td>
<td>
<p>An optional vector of weights to select the best-sized tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be used to grow the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Indicates method of handling correlation: must be either <code>"marginal"</code>,
<code>"gamma.frailty"</code>, <code>"exp.frailty"</code>, <code>"stratified"</code>, or <code>"independence"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minsplit</code></td>
<td>
<p>Number: Controls the minimum node size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minevents</code></td>
<td>
<p>Number: Controls the minimum number of uncensored event times</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minbucket</code></td>
<td>
<p>Number: Controls the minimum number of observations in any terminal node</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxdepth</code></td>
<td>
<p>Number: Maximum depth of tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtry</code></td>
<td>
<p>Number of variables considered at each split.  The default is to consider all variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distinct</code></td>
<td>
<p>Logical: Indicates if all distinct cutpoints or only percentiles considered</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Consider cutpoints from delta to 1 <code class="reqn">-</code> delta.  Only used when <code>distinct = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nCutPoints</code></td>
<td>
<p>Number of cutpoints (percentiles) considered.  Only used when <code>distinct = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.method</code></td>
<td>
<p>Indicates method of selecting the best-sized subtree: <code>"test.sample"</code> or <code>"bootstrap"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Number of bootstrap samples.  Only used if <code>selection.method = "bootstrap"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LeBlanc</code></td>
<td>
<p>Logical: Indicates if entire sample used (alternative is out-of-bag sample).  Only used if <code>selection.method = "bootstrap"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.boot.tree.size</code></td>
<td>
<p>Number: Minimum size of tree grown at each bootstrap</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.Ga</code></td>
<td>
<p>Logical: Indicates if goodness-of-fit vs. tree size should be plotted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>Name of the file plotted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>horizontal</code></td>
<td>
<p>Logical: Indicates if plot should be landscape</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p>Logical: Indicates if detailed information on the construction should be printed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortTrees</code></td>
<td>
<p>Logical: Indicates if trees should be sorted such that each split to the left has lower risk of failure</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Marginal and frailty models are the two main ways to analyze correlated failure times.  Let <code class="reqn">X_{ij}</code> represent the covariate vector for the <code class="reqn">j</code>th member in the <code class="reqn">i</code>th cluster.
</p>
<p>The marginal model uses the Cox (1972) proportional hazards model:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{ij}(t|X_{ij})=\lambda_{0}(t) \exp(\beta \cdot I(X_{ij} \leq c))</code>
</p>

<p>where <code class="reqn">\lambda_{0}(t)</code> is an unspecified baseline hazard function and <code class="reqn">I(\cdot)</code> is the indicator function.
</p>
<p>The gamma frailty model uses the proportional hazards model:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{ij}(t|X_{ij}, w_{i})=\lambda_{0}(t) \exp(\beta \cdot I(X_{ij} \leq c)) w_{i}</code>
</p>

<p>where <code class="reqn">\lambda_{0}(t)</code> is an unspecified baseline hazard function, <code class="reqn">I(\cdot)</code> is the indicator function, and <code class="reqn">w_{i}</code> is the frailty term for the <code class="reqn">i</code>th cluster.
</p>
<p>The exponential frailty model uses the proportional hazards model:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{ij}(t|X_{ij}, w_{i})=\exp(\beta_{0} + \beta_{1} \cdot I(X_{ij} \leq c)) w_{i}</code>
</p>

<p>where <code class="reqn">I(\cdot)</code> is the indicator function and <code class="reqn">w_{i}</code> is the frailty term for the <code class="reqn">i</code>th cluster.
</p>
<p>For the marginal model, a robust logrank statistic is calculated for each covariate <code class="reqn">X</code> and possible cutpoint <code class="reqn">c</code>.  The estimate of the score function and likelihood of <code class="reqn">\beta</code> can be obtained assuming independence.  However, the variance-covariance structure adjusts for the dependence using a sandwich-type estimator.  The best split is the one with the largest robust logrank statistic.
</p>
<p>For the frailty models, a score test statistic is calculated from the maximum integrated log likelihood for each covariate <code class="reqn">X</code> and possible cutpoint <code class="reqn">c</code>.  The frailty term must follow some known positive distribution; one common choice is <code class="reqn">w_{i} \sim \Gamma(1/\nu, 1/\nu)</code> where <code class="reqn">\nu</code> represents an unknown variance.  Note, the exponential frailty model replaces the baseline hazard function with a constant, yielding different score test statistics and typically computationally faster splits.  The best split is the one with the largest score test statistic.
</p>
<p>Stratified model grows a tree by minimizing the within-strata variation.  This method should be used with care because the tree will not split on variables with a fixed value within each stratum.  The independence model ignores the dependence and uses the logrank statistic as the splitting rule.
</p>
<p>For continuous variables with many distinct cutpoints, the number of cutpoints considered can be reduced to percentiles.  Using percentiles increases efficiency at the expense of less accuracy.
</p>
<p>Growing the initial tree is done by splitting nodes (as described above) reiteratively until the maximum depth of the tree is reached or a small number of observations remain at terminal node.  However, as the final tree model can be any subtree of the initial tree, the number of subtrees can become massive.  A goodness-of-fit with an added penalty for the number of internal nodes is used to prune the trees (i.e. reduce the number of subtrees considered).  The best-sized tree is selected by the largest goodness-of-fit with the added penalty using either the test sample or bootstrap samples.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tree0</code></td>
<td>
<p>The initial tree.  Tree listed as constparty object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prunining.info</code></td>
<td>
<p>Trees pruned and considered in the best tree selection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.tree.size</code></td>
<td>
<p>The best tree size based on the penalty used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.tree.structure</code></td>
<td>
<p>The best tree structure based on the penalty used.  Tree listed as constparty object</p>
</td>
</tr>
</table>
<p>Note, the constparty object requires a constant fit from each terminal node.  Thus, the <code>predict</code> and <code>plot</code> functions ignore the dependence, so users are recommended to fit their own model when making predictions (see example)
</p>


<h3>Warning</h3>

<p>Error messages in the gamma frailty models sometimes occur when using the bootstrap method.  Increasing <code>minsplit</code> may help fix these errors.  The exponential frailty model can have problems for large, extremely unbalanced designs.  Currently weights can only be applied to marginal and gamma frailty models.</p>


<h3>Note</h3>

<p>Code may take awhile to implement large datasets.  To decrease computation time, user should use test sample (<code>selection.method = "test.sample"</code>). User can also split continuous variables based on percentiles (<code>distinct = FALSE</code>) at the expense of slightly less accuracy.  Gamma frailty models are more computationally intensive
</p>


<h3>Author(s)</h3>

<p>Xiaogang Su, Peter Calhoun, and Juanjuan Fan
</p>


<h3>References</h3>

<p>Calhoun P., Su X., Nunn M., Fan J. (2018) Constructing Multivariate Survival Trees: The MST Package for R. <em>Journal of Statistical Software</em>, <b>83</b>(12), 1–21.
</p>
<p>Cox D.R. (1972) Regression models and life-tables (with discussion).  <em>Journal of the Royal Statistical Society Series B</em>, <b>34</b>(2), 187–220.
</p>
<p>Fan J., Su X., Levine R., Nunn M., LeBlanc M. (2006) Trees for Correlated Survival Data by Goodness of Split, With Applications to Tooth Prognosis. <em>Journal of American Statistical Association</em>, <b>101</b>(475), 959–967.
</p>
<p>Fan J., Nunn M., Su X. (2009) Multivariate exponential survival trees and their application to tooth prognosis.  <em>Computational Statistics and Data Analysis</em>, <b>53</b>(4), 1110–1121.
</p>
<p>Su X., Fan J. (2004) Multivariate Survival Trees: A Maximum Likelihood Approach Based on Frailty Models.  <em>Biometrics</em>, <b>60</b>(1), 93–99.
</p>


<h3>See Also</h3>

<p><span class="pkg">rpart</span>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(186117)
data &lt;- rmultime(N = 200, K = 4, beta = c(-1, 0.8, 0.8, 0, 0), cutoff = c(0.5, 0.3, 0, 0),
    model = "marginal.multivariate.exponential", rho = 0.65)$dat
test &lt;- rmultime(N = 100, K = 4, beta = c(-1, 0.8, 0.8, 0, 0), cutoff = c(0.5, 0.3, 0, 0),
    model = "marginal.multivariate.exponential", rho = 0.65)$dat

#Construct Multivariate Survival Tree:
fit &lt;- MST(formula = Surv(time, status) ~ x1 + x2 + x3 + x4 | id, data, test,
    method = "marginal", minsplit = 100, minevents = 20, selection.method = "test.sample")

(tree_final &lt;- getTree(fit, 4))
plot(tree_final)

#Fit a model from the final tree
data$term_nodes &lt;- as.factor(predict(tree_final, newdata = data, type = 'node'))
coxph(Surv(time, status) ~ term_nodes + cluster(id), data = data)
</code></pre>


</div>