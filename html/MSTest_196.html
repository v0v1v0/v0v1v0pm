<div class="container">

<table style="width: 100%;"><tr>
<td>VARmdl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Vector autoregressive model</h2>

<h3>Description</h3>

<p>This function estimates a vector autoregresive model with <code>p</code> lags. This can be used for the null hypothesis of a linear model against an alternative hypothesis of a Markov switching vector autoregressive model with <code>k</code> regimes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">VARmdl(Y, p, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>a <code>(T x q)</code> matrix of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer determining the number of autoregressive lags.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>List with model options including:
</p>

<ul>
<li>
<p> const: Boolean determining whether to estimate model with constant if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li>
<li>
<p> getSE: Boolean determining whether to compute standard errors of parameters if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List of class <code>VARmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li>
<p> y: a <code>(T-p x q)</code> matrix of observations.
</p>
</li>
<li>
<p> X: a <code>(T-p x p*q + const)</code> matrix of lagged observations with a leading column of <code>1</code>s if <code>const=TRUE</code> or not if <code>const=FALSE</code>.
</p>
</li>
<li>
<p> x: a <code>(T-p x p*q)</code> matrix of lagged observations.
</p>
</li>
<li>
<p> fitted: a <code>(T-p x q)</code> matrix of fitted values.
</p>
</li>
<li>
<p> resid: a <code>(T-p x q)</code> matrix of residuals.
</p>
</li>
<li>
<p> inter: a <code>(1 x q)</code> vector of estimated intercepts of each process.
</p>
</li>
<li>
<p> mu: a <code>(1 x q)</code> vector of estimated means of each process.
</p>
</li>
<li>
<p> coef: coefficient estimates. First row are the intercept (i.e., not <code>mu</code>) if <code>const=TRUE</code>. This is the same as <code>t(phi)</code> if <code>const=FALSE</code>.
</p>
</li>
<li>
<p> intercept: estimate of intercepts.
</p>
</li>
<li>
<p> phi: a <code>(q x p*q)</code> matrix of estimated autoregressive coefficients.
</p>
</li>
<li>
<p> Fmat: Companion matrix containing autoregressive coefficients.
</p>
</li>
<li>
<p> stdev: a <code>(q x 1)</code> vector of estimated standard deviation of each process.
</p>
</li>
<li>
<p> sigma: a <code>(q x q)</code> estimated covariance matrix.
</p>
</li>
<li>
<p> theta: vector containing: <code>mu</code>, <code>vech(sigma)</code>, and <code>vec(t(phi))</code>.
</p>
</li>
<li>
<p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li>
<p> theta_sig_ind: vector indicating location of variance and covariances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li>
<p> theta_var_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li>
<p> theta_phi_ind: vector indicating location of autoregressive coefficients with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li>
<p> stationary: Boolean indicating if process is stationary if <code>TRUE</code> or non-stationary if <code>FALSE</code>.
</p>
</li>
<li>
<p> n: number of observations after lag transformation (i.e., <code>n = T-p</code>).
</p>
</li>
<li>
<p> p: number of autoregressive lags.
</p>
</li>
<li>
<p> q: number of series.
</p>
</li>
<li>
<p> k: number of regimes. This is always <code>1</code> in <code>VARmdl</code>.
</p>
</li>
<li>
<p> Fmat: matrix from companion form. Used to determine is process is stationary.
</p>
</li>
<li>
<p> control: List with model options used.
</p>
</li>
<li>
<p> logLike: log-likelihood.
</p>
</li>
<li>
<p> AIC: Akaike information criterion.
</p>
</li>
<li>
<p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li>
<p> Hess: Hessian matrix. Approximated using <code>hessian</code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li>
<p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code>nearest_spd</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li>
<p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li>
<p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>MSVARmdl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># ----- Bivariate VAR(1) process ----- #
set.seed(1234)
# Define DGP of VAR process
mdl_var &lt;- list(n     = 1000, 
                p     = 1,
                q     = 2,
                mu    = c(5,-2),
                sigma = rbind(c(5.0, 1.5),
                              c(1.5, 1.0)),
                phi   = rbind(c(0.50, 0.30),
                              c(0.20, 0.70)))

# Simulate process using simuVAR() function
y_simu &lt;- simuVAR(mdl_var)

# Set options for model estimation
control &lt;- list(const  = TRUE, 
                getSE  = TRUE)

# Estimate model
y_var_mdl &lt;- VARmdl(y_simu$y, p = 2, control)
summary(y_var_mdl)
</code></pre>


</div>