<div class="container">

<table style="width: 100%;"><tr>
<td>PredictLogReg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prediction of the category to which a mass spectrum belongs from a multinomial logistic regression model</h2>

<h3>Description</h3>

<p>This function predicts the category (species, phenotypes...) to which a mass spectrum belongs from a set of shortlisted mass-over-charge values of interest and a short-listed multinomial logistic regression model (see <code>LogReg</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">PredictLogReg(peaks,
              model,
              moz,
              tolerance = 6,
              toleranceStep = 2,
              normalizeFun = TRUE,
              noMatch=0,
              Reference = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>peaks</code></td>
<td>
<p>a list of <code>MassPeaks</code> objects (see <code>MALDIquant</code> R package).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a model or a list of models estimated from a set of shortlisted mass-over-charge values (output of the <code>LogReg</code> function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moz</code></td>
<td>
<p>a <code>vector</code> with the set of shortlisted mass-over-charge values used to estimate the model <code>Model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>a <code>numeric</code> value of accepted tolerance to match peaks to the set of shortlisted mass-over-charge values. It is fixed to 6 Da by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toleranceStep</code></td>
<td>
<p>a <code>numeric</code> value added to the <code>tolerance</code> parameter to match peaks to the set of shortlisted mass-over-charge values. It is fixed to 2 Da by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalizeFun</code></td>
<td>
<p>a <code>logical</code> value, if <code>TRUE</code> (default) the maximum intensity will be equal to 1, the other intensities will be expressed in ratio to this maximum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noMatch</code></td>
<td>
<p>a <code>numeric</code> value used to replace intensity values if there is no match detected between peaks and the set of shortlisted mass-over-charge values <code>moz</code>. It is fixed to 0 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Reference</code></td>
<td>
<p>a <code>factor</code> with a length equal to the number of rows in <code>X</code> and containing the categories of each mass spectrum in <code>X</code>. <code>"NULL"</code> by default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>PredictLogReg</code> function allows predicting the membership of a mass spectrum to a category from a multinomial regression model. The mass spectrum from the <code>peaks</code> object will be matched to the discriminant mass-over-chage (m/z) values (<code>sel_moz</code> object from the <code>SelectionVar</code> or <code>SelectionVarStat</code> functions)  with a tolerance between 2 m/z and defined by the <code>tolerance</code> parameter (by default this value is 6 Da). If a repetition of a same m/z occurs in the selection, only the m/z that is closest in mass peaks (<code>moz</code>) is used. When no match, intensity values are replaced by the <code>noMatch</code> argument. If no m/z values from <code>peaks</code> object matched with the m/z in the object <code>moz</code>, the tolerance will be increased according to a numeric value defined in the <code>toleranceStep</code> parameter and a warning will be notified. Note that it is possible to not perform the <code>SelectionVar</code> function prior to the <code>PredictLogReg</code> function, and to replace the argument <code>moz</code> by all the m/z values present in a mass spectrum.</p>


<h3>Value</h3>

<p>Returns a <code>dataframe</code> containing probabilities of membership by category for each mass spectrum in <code>peaks</code>. The method used is provided in the <code>method</code> column. The <code>comb_fisher</code> method is the result of the Fisher's method when merging probabilities of membership of used prediction models.The <code>max_vote</code> method is the result of the maximum voting from used prediction models.
</p>
<p>If the <code>Reference</code> parameter is not null, the function returns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Confusion.Matrix</code></td>
<td>
<p>a <code>list</code> of confusion matrix (cross-tabulation with associated statitics) corresponding to the output of the <code>confusionMatrix</code> function of the <code>caret</code> R package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gobal.stat</code></td>
<td>
<p>a <code>data.frame</code> with three columns corresponding to the value (<code>value</code> column) of a statistic parameter (<code>Statistic.parameter</code> column) from a method used (<code>model</code> column) obtained with the <code>LogReg</code> function. See <code>LogReg</code> function for the Statistic.parameter column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Details.stat</code></td>
<td>
<p>a <code>data.frame</code> with four columns corresponding to the same as <code>Gobal.stat</code> dataframe with the class concerned for estimated statistic parameter (class column). All statistic parameters are extracted from the output of the <code>confusionMatrix</code> function of the <code>caret</code> R package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Correct.ClassificationFreq</code></td>
<td>
<p>a <code>data.frame</code> with predicted class (Prediction column) from a method (Model column) and the reference of the categories of each mass spectrum (Reference column). The <code>Freq</code> column indicates the number of times the category was correctly predicted by the method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Incorrect.ClassificationFreq</code></td>
<td>
<p>a <code>data.frame</code> with predicted class (Prediction column) from a method (<code>Model</code> column) and the reference of the categories of each mass spectrum (<code>Reference</code> column). The <code>Freq</code> column indicates the number of times the category was not correctly predicted by the method. </p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Kuhn, M. (2008). Building predictive models in R using the caret package. Journal of statistical software, 28(1), 1-26.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

library("MSclassifR")
library("MALDIquant")

###############################################################################
## 1. Pre-processing of mass spectra

# load mass spectra and their metadata
data("CitrobacterRKIspectra","CitrobacterRKImetadata", package = "MSclassifR")
# standard pre-processing of mass spectra
spectra &lt;- SignalProcessing(CitrobacterRKIspectra)
# detection of peaks in pre-processed mass spectra
peaks &lt;- MSclassifR::PeakDetection(x = spectra, averageMassSpec=FALSE)
# matrix with intensities of peaks arranged in rows (each column is a mass-over-charge value)
IntMat &lt;- MALDIquant::intensityMatrix(peaks)
rownames(IntMat) &lt;- paste(CitrobacterRKImetadata$Strain_name_spot)
# remove missing values in the matrix
IntMat[is.na(IntMat)] &lt;- 0
# normalize peaks according to the maximum intensity value for each mass spectrum
IntMat &lt;- apply(IntMat,1,function(x) x/(max(x)))
# transpose the matrix for statistical analysis
X &lt;- t(IntMat)
# define the known categories of mass spectra for the classification
Y &lt;- factor(CitrobacterRKImetadata$Species)

###############################################################################
## 2. Selection of discriminant mass-over-charge values using RFERF
# with 5 to 10 variables,
# without sampling method and trained
# with the Accuracy coefficient metric

a &lt;- MSclassifR::SelectionVar(X,
                              Y,
                              MethodSelection = c("RFERF"),
                              MethodValidation = c("cv"),
                              PreProcessing = c("center","scale","nzv","corr"),
                              NumberCV = 2,
                              Metric = "Kappa",
                              Sizes = c(5:10))

sel_moz=a$sel_moz

###############################################################################
## 3. Perform LogReg from shortlisted discriminant mass-over-charge values

# linear multinomial regression
# without sampling mehod and
# trained with the Kappa coefficient metric

model_lm=MSclassifR::LogReg(X=X,
                            moz=sel_moz,
                            Y=factor(Y),
                            number=2,
                            repeats=2,
                            Metric = "Kappa")
# Estimated model:
model_lm

# nonlinear multinomial regression using neural networks
# with up-sampling method and
# trained with the Kappa coefficient metric

model_nn=MSclassifR::LogReg(X=X,
                            moz=sel_moz,
                            Y=factor(Y),
                            number=2,
                            repeats=2,
                            kind="nnet",
                            Metric = "Kappa",
                            Sampling = "up")
# Estimated model:
model_nn

# nonlinear multinomial regression using random forests
# without down-sampling method and
# trained with the Kappa coefficient metric

model_rf=MSclassifR::LogReg(X=X,
                            moz=sel_moz,
                            Y=factor(Y),
                            number=2,
                            repeats=2,
                            kind="rf",
                            Metric = "Kappa",
                            Sampling = "down")

# Estimated model:
model_rf

# nonlinear multinomial regression using xgboost
# with down-sampling method and
# trained with the Kappa coefficient metric

model_xgb=MSclassifR::LogReg(X=X,
                             moz=sel_moz,
                             Y=factor(Y),
                             number=2,
                             repeats=2,
                             kind="xgb",
                             Metric = "Kappa",
                             Sampling = "down")
# Estimated model:
model_xgb

# nonlinear multinomial regression using svm
# with down-sampling method and
# trained with the Kappa coefficient metric

model_svm=MSclassifR::LogReg(X=X,
                             moz=sel_moz,
                             Y=factor(Y),
                             number=2,
                             repeats=2,
                             kind="svm",
                             Metric = "Kappa",
                             Sampling = "down")
# Estimated model:
model_svm

# Of note, you can also load a model already saved
# (see example in LogReg function) for the next step
###############################################################################
## 4. Probabilities of belonging to each category for the mass spectra
## and associated statitics

# Collect all the estimated models in a list

Models &lt;- list(model_lm$train_mod,
               model_nn$train_mod,
               model_rf$train_mod,
               model_xgb$train_mod,
               model_svm$train_mod)

# Predict classes of mass spectra with 6 Da of tolerance for matching peaks.
prob_cat=MSclassifR::PredictLogReg(peaks = peaks[c(1:5)],
                                   model = Models,
                                   moz = sel_moz,
                                   tolerance = 6,
                                   Reference = Y[c(1:5)])

################################################################################
## 5. Example of meta-classifiers based on several random forest models
## to optimize a Kappa value using the SMOTE method for imbalanced datasets.
## -&gt; a merge of the prediction probabilities using the Fisher's method
## leads generally to robust prediction models.

#Selecting peaks with mda method
a=SelectionVar(X,Y,MethodSelection="mda",Ntree=5*ncol(X))
sel_moz=a$sel_moz

#Building 4 Random Forest models
models=NULL;nbm=4;
for (i in 1:nbm){
  model_rf=MSclassifR::LogReg(X=X,
                             moz=sel_moz,
                             Y=factor(Y),
                             number=5,
                             repeats=5,
                             kind="rf",
                             Metric = "Kappa",
                             Sampling = "smote")
  models &lt;- c(models,list(model_rf$train_mod))
}

#Combining their prediction probabilities
prob_cat=MSclassifR::PredictLogReg(peaks = peaks,model = models,moz = sel_moz,
tolerance = 6,Reference = Y)


</code></pre>


</div>