<div class="container">

<table style="width: 100%;"><tr>
<td>compute_statistics</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculates the value of the test statistics both for single time series
analysis and multiple time series analysis.</h2>

<h3>Description</h3>

<p>Calculates the value of the test statistics both for single time series
analysis and multiple time series analysis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">compute_statistics(
  data,
  sigma = 1,
  sigma_vec = 1,
  n_ts = 1,
  grid = NULL,
  ijset = NULL,
  deriv_order = 0,
  epidem = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Vector (in case of n_ts = 1) or matrix (in case of
n_ts &gt; 1) that contains (a number of) time series
that needs to be analyzed. In the latter case,
each column of the matrix must contain one time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>The estimator of the square root of the long-run
variance <code class="reqn">\sigma</code> in case of n_ts = 1,
or the estimator of the overdispersion parameter
<code class="reqn">\sigma</code> in case of n_ts &gt; 1 and epidemic = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma_vec</code></td>
<td>
<p>Vector that consists of estimators of the square root
of the long-run variances <code class="reqn">\sigma_i</code> in case of
n_ts &gt; 1 and epidemic = FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_ts</code></td>
<td>
<p>Number of time series analysed. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>Grid of location-bandwidth points as produced by
the functions <code>construct_grid</code> or
<code>construct_weekly_grid</code>, it is a list with
the elements 'gset', 'bws', 'gtype'. If not provided,
then the defalt grid is used.
For the construction of the default grid,
see <code>construct_grid</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ijset</code></td>
<td>
<p>In case of multiple time series (n_ts &gt; 1),
we need to know which pairs of time series to compare.
This matrix consists of all pairs of indices <code class="reqn">(i, j)</code>
that we want to compare. If not provided, then all
possible pairwise comparison are performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv_order</code></td>
<td>
<p>In case of a single time series, this denotes the order of
the derivative of the trend that we estimate.
Default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epidem</code></td>
<td>
<p>Logical variable, TRUE if we are using
dealing with epidemic time trends. Default is FALSE.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>In case of n_ts = 1, the function returns a list
with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>Value of the multiscale statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gset_with_vals</code></td>
<td>
<p>A matrix that contains the values of the normalised 
kernel averages for each pair of location-bandwidth
with the corresponding location and bandwidth.</p>
</td>
</tr>
</table>
<p>In case of n_ts &gt; 1, the function returns a list
with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>Value of the multiscale statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat_pairwise</code></td>
<td>
<p>Matrix of the values of the pairwise statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ijset</code></td>
<td>
<p>The matrix that  consists of all pairs of indices
<code class="reqn">(i, j)</code> that we compared. The order of these
pairs corresponds to the order in the list
gset_with_vals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gset_with_vals</code></td>
<td>
<p>A list of matrices, each matrix corresponding to a 
specific pairwise comparison. The order of the list 
is determined by ijset. Each matrix contains
the values of the normalisedkernel averages
for each pair of location-bandwidth
with the corresponding location and bandwidth.</p>
</td>
</tr>
</table>
</div>