<div class="container">

<table style="width: 100%;"><tr>
<td>mtlr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Train a Multi-Task Logistic Regression (MTLR) Model</h2>

<h3>Description</h3>

<p>Trains a MTLR model for survival prediction. Right, left, and interval censored data are all supported.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mtlr(formula, data, time_points = NULL, nintervals = NULL,
  normalize = T, C1 = 1, train_biases = T, train_uncensored = T,
  seed_weights = NULL, threshold = 1e-05, maxit = 5000,
  lower = -15, upper = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object with the response to the left of the "~" operator. The response must be a survival object returned
by the <code>Surv</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data.frame containing the features for survival prediction. These must be variables corresponding to the formula object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_points</code></td>
<td>
<p>the time points for MTLR to create weights. If left as NULL, the time_points chosen will be based on equally spaced quantiles
of the survival times. In the case of interval censored data note that only the start time is considered and not the end time for selecting time points.
It is strongly recommended to specify time points if your data is heavily interval censored. If time_points is not NULL then nintervals is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nintervals</code></td>
<td>
<p>Number of time intervals to use for MTLR. Note the number of time points will be nintervals + 1. If left as NULL
a default of sqrt(N) is used where N is the number of observations in the supplied dataset. This parameter is ignored if time_points is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>if TRUE, variables will be normalized (mean 0, standard deviation of 1). This is STRONGLY suggested. If normalization
does not occur it is much more likely that MTLR will fail to converge. Additionally, if FALSE consider adjusting "lower" and "upper"
used for L-BFGS-B optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C1</code></td>
<td>
<p>The L2 regularization parameter for MTLR. C1 can also be selected via <code>mtlr_cv</code>. See "Learning Patient-Specific Cancer Survival Distributions as a Sequence of Dependent
Regressors" by Yu et al. (2011) for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train_biases</code></td>
<td>
<p>if TRUE, biases will be trained before feature weights (and again trained while training feature weights). This
has shown to speed up total training time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train_uncensored</code></td>
<td>
<p>if TRUE, one round of training will occur assuming all event times are uncensored. This is done due to the non-convexity issue
that arises in the presence of censored data. However if ALL data is censored we recommend setting this option to FALSE as it has shown to give poor
results in this case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed_weights</code></td>
<td>
<p>the initialization weights for the biases and the features. If left as NULL all weights are initialized to zero. If seed_weights are
specified then either nintervals or time_points must also be specified. The length of seed_weights should correspond to (number of features + 1)*(length of
time_points) = (number of features + 1)*(nintervals + 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>The threshold for the convergence tolerance (in the objective function) when training the feature weights.
This threshold will be passed to optim.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>The maximum iterations to run for MTLR. This parameter will be passed to optim.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>The lower bound for L-BFGS-B optimization. This parameter will be passed to optim.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>The upper bound for L-BFGS-B optimization. This parameter will be passed to optim.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function allows one to train an MTLR model given a dataset containing survival data. mtlr uses the Limited-Memory
Broyden–Fletcher–Goldfarb–Shanno (L-BFGS-B) approximation method to train feature weights. This training is outsourced to the internal
optim function in R. Currently only a few parameters (namely threshold, maxit,lower, upper) of optim are supported, more will
likely become available in the future.
</p>
<p>Weights are initialized to 0 prior to training. Under default settings, the bias weights
will be trained before considering feature weights. As Yu et al. (2011) specified, the introduction of censored observations creates a non-convex
loss function. To address this, weights are first trained assuming all event times are <em>uncensored</em>. Once these starting weights have
been trained another round of training is performed using the true values of the event indicator (censored/uncensored). However, in the event of
all censored data this has shown to negatively effect the results. If all data is censored (either left, right, or interval2) we suggest setting
train_uncensored = FALSE.
</p>
<p>Yu et al. (2011) actually suggested two regularization parameters, C1 to control the size of the feature weights and C2 to control the smoothness.
In Ping Jin's masters thesis (Using Survival Prediction Techniques to Learn Consumer-Specific Reservation Price Distributions) he showed that C2
is not required for smoothness and C1 will suffice (Appendix A.2) so we do not support the C2 parameter in this implementation.
</p>
<p>If an error occurs from optim it is likely the weights are getting too large. Including fewer time points (or specifying better time points) in
addition to changing the lower/upper bounds of L-BFGS-B may resolve these issues. The most common failure has been that the objective value sees
infinite values due to extremely large feature weights.
</p>
<p><strong>Censored data:</strong> Right, left, and interval censored data are all supported both separately and mixed. The convention to input these types of
data follows the Surv object format.
Per the Surv documentation, "The [interval2] approach is to think of each observation as a time interval with (-infinity, t) for left censored,
(t, infinity) for right censored, (t,t) for exact and (t1, t2) for an interval. This is the approach used for type = interval2.
Infinite values can be represented either by actual infinity (Inf) or NA." See the examples below for an example of inputting this type of data.
</p>


<h3>Value</h3>

<p>An mtlr object returns the following:
</p>

<ul>
<li>
<p> weight_matrix: The matrix of feature weights determined by MTLR.
</p>
</li>
<li>
<p> x: The dataframe of features (response removed). Note observations with missing values will have been removed (this is the dataset on which
MTLR was trained).
</p>
</li>
<li>
<p> y: The matrix of response values MTLR uses for training. Each column corresponds to an observation and rows as time points. A value of 1
indicates a observation was either censored or had their event occur by that time.
</p>
</li>
<li>
<p> response: The response as a Surv object (specified by formula).
</p>
</li>
<li>
<p> time_points: The timepoints selected and used to train MTLR.
</p>
</li>
<li>
<p> C1: The regularization parameter used.
</p>
</li>
<li>
<p> Call: The original call to mtlr.
</p>
</li>
<li>
<p> Terms: The x-value terms used in mtlr. These are later used in <code>predict.mtlr</code>
</p>
</li>
<li>
<p> scale: The means and standard deviations of features when normalize = TRUE. These are used in <code>predict.mtlr</code>. Will be
NULL if normalize = FALSE.
</p>
</li>
<li>
<p> xlevels: The levels of the features used. This is used again by <code>predict.mtlr</code>.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>predict.mtlr</code> <code>mtlr_cv</code> <code>plot.mtlr</code>  <code>plotcurves</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Access the Surv function and the leukemia/lung dataset.
library(survival)
simple_mod &lt;- mtlr(Surv(time,status)~., data = leukemia)
simple_mod

bigger_mod &lt;- mtlr(Surv(time,status)~., data = lung)
bigger_mod

#Note that observations with missing data were removed:
nrow(lung)
nrow(bigger_mod$x)


# Mixed censoring types
time1 = c(NA, 4, 7, 12, 10, 6, NA, 3) #NA for right censored
time2 = c(14, 4, 10, 12, NA, 9, 5, NA) #NA for left censored
#time1 == time2 indicates an exact death time. time2&gt; time1 indicates interval censored.
set.seed(42)
dat = cbind.data.frame(time1, time2, importantfeature = rnorm(8))
formula = Surv(time1,time2,type = "interval2")~.
mixedmod = mtlr(formula, dat)

</code></pre>


</div>