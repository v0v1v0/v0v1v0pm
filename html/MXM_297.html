<div class="container">

<table style="width: 100%;"><tr>
<td>Orientation rules for the PC algorithm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
The orientations part of the PC algorithm.
</h2>

<h3>Description</h3>

<p>The function takes the outcome of the PC algorithm, as produced by <code>pc.skel</code> or <code>pc.con</code> and performes 
the 4 orientation rules. A graph is also possible to visualize.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pc.or(mod) 
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>

<p>An object with the results of the PC algorithm, as produced by <code>pc.skel</code> or <code>pc.con</code>. There was an extra 
argument for plotting the skeleton but it does not work with the current visualisation packages, hence we removed the argument. 
Use <code>plotnetwork</code> to plot the skeleton.   
</p>
</td>
</tr></table>
<h3>Details</h3>

<p>After having calculated the skeleton of the PC algorithm one may wants to perform orientations, leading to causal relationships. 
The rules as stated in Spirtes, Glymour and Scheines (2001) are
</p>

<ol>
<li> <p><b>Rule 0</b>. For each triple of vertices X, Y, Z such that the pair X, Y and the pair Y, Z are each adjacent in C but the pair X, Z 
are not adjacent in C, orient X - Y - Z as X -&gt; Y &lt;- Z if and only if Y is not in Sepset(X, Z). 
</p>
</li>
<li> <p><b>Rule 1</b>. If A -&gt; B, B and C are adjacent, A and C are not adjacent, and there is no arrowhead at B, then orient B - C as B -&gt; C.
</p>
</li>
<li> <p><b>Rule 2</b>. If there is a directed path from A to B, and an edge between A and B, then orient A - B as A -&gt; B.
</p>
</li>
<li> <p><b>Rule 3</b>. If A -&gt; B &lt;- C, A - D - C, A and C are not adjacent, and D - B, then orient D - B as D -&gt; B. 
</p>
</li>
</ol>
<p>The first rule is applied once. Rules 2-4 are applied repeatedly until no more edges can be oriented. If when a rule is applied and a cycle is 
detected, the rule is cancelled. Also, when applying Rules 1-3 we try to avoid the creation of new v-structures (X -&gt; Y &lt;- Z). 
</p>


<h3>Value</h3>

<p>A list including:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Gini</code></td>
<td>

<p>The initial adjacency matrix, no orientations. This is the matrix produced by <code>pc.skel</code> or <code>pc.con</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>

<p>The final adjaceny matrix with the orientations. If G[i, j] = 2 then G[j, i] = 3. This means that there is an arrow from node i to node j. 
If G[i, j] = G[j, i] = 0; 
there is no edge between nodes i and j. If G[i, j] = G[j, i] = 1; there is an (undirected) edge between nodes i and j.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>runtime</code></td>
<td>

<p>The run time of the algorithm. A numeric vector. The first element is the user time, the second element is the system time and the 
third element is the elapsed time.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Michail Tsagris
</p>
<p>R implementation and documentation: Michail Tsagris <a href="mailto:mtsagris@uoc.gr">mtsagris@uoc.gr</a>
</p>


<h3>References</h3>

<p>Spirtes P.,  Glymour C. and Scheines R. (2001). Causation, Prediction, and Search. The MIT Press, Cambridge, MA, USA, 3nd edition.
</p>
<p>Zhang, Jiji. (2008). On the completeness of orientation rules for causal discovery in the presence of latent confounders and selection bias. 
Artificial Intelligence 172(16): 1873â€“1896.
</p>
<p>Tsagris M. (2019). Bayesian network learning with the PC algorithm: an improved and correct variation. 
Applied Artificial Intelligence 33(2): 101-123.
</p>


<h3>See Also</h3>

<p><code> pc.con, pc.skel, mmhc.skel, is.dag, mb 
</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate a dataset with continuous data
y &lt;- rdag2(2000, p = 20, nei = 3)
ind &lt;- sample(1:20, 20)
tru &lt;- y$G[ind, ind] 
x &lt;- y$x[, ind]
mod &lt;- pc.con(x)
mod$runtime

plotnetwork(tru) 

b &lt;- pc.or(mod)
plotnetwork(b$G)

plotnetwork( dag2eg(tru) )  ## essential graph
plotnetwork(b$G)
</code></pre>


</div>