<div class="container">

<table style="width: 100%;"><tr>
<td>diabetes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Pseudonymised and randomised time series dataset of diabetes patients for control chart applications
</h2>

<h3>Description</h3>

<p>Pseudonymised and randomised time series data of 800 patients. The patients are divided into two main groups by therapy type: insulin analogues (artificial insulins) and glucagon-like peptides (GLP, promotes insulin secretion). The patients' well-being is indicated by the blood sugar (more accurately, the glicated haemoglobin - HbA1c) level.
</p>


<h3>Usage</h3>

<pre><code class="language-R">data("diabetes")</code></pre>


<h3>Format</h3>

<p>A data frame with 87598 observations on the following 11 variables.
</p>

<dl>
<dt><code>ID</code></dt>
<dd>
<p>Patient ID</p>
</dd>
<dt><code>DATE</code></dt>
<dd>
<p>Date of the sampling/observation</p>
</dd>
<dt><code>AGE</code></dt>
<dd>
<p>Age of the patient</p>
</dd>
<dt><code>THERAPY</code></dt>
<dd>
<p>Therapy type</p>
</dd>
<dt><code>THERAPY_COST_EUR</code></dt>
<dd>
<p>Therapy cost</p>
</dd>
<dt><code>HEALTHCARE_BURDEN_EUR</code></dt>
<dd>
<p>Event (e.g. heart attack) cost for the health care provider</p>
</dd>
<dt><code>HBA1C_AVG</code></dt>
<dd>
<p>Blood sugar average for the 30-day sampling cycle</p>
</dd>
<dt><code>HBA1C_SD</code></dt>
<dd>
<p>Blood sugar standard deviation for the 30-day sampling cycle</p>
</dd>
<dt><code>SAMPLING_IN_MONTH</code></dt>
<dd>
<p>Number of sampling for the 30-day sampling cycle</p>
</dd>
<dt><code>ICD</code></dt>
<dd>
<p>Diabetes diagnosis type (International Classification of Diseases)</p>
</dd>
<dt><code>THERAPY_VECTOR</code></dt>
<dd>
<p>Therapy vector of the patient, i.e. taking into account the time the therapy lasts after initiation</p>
</dd>
</dl>
<h3>Details</h3>

<p>The example data focuses on two therapy types: insulin analogues (artificial insulins) and glucagon-like peptides (GLP, promotes insulin secretion). Of course there are more treatment types, the database also lists oral antidiabetics (OAD) and human insulins, but we choose to make the data simpler by focusing on GLP and analogue therapies. For the sake of comparison the therapies are grouped in this way: the first group is insulin analogues with possible parallel OAD therapies but human insulin and GLP excluded. The second group is GLP therapies with possible parallel OAD and insulin analogue therapies but human insulin excluded. Essentially we are comparing the effect and cost of insulin analogues with the effect and cost of additional GLP therapies. For cost calculations, the 2021 March 21 EUR-HUF exchange rate was used (1 EUR = 369.05 HUF).
</p>
<p>The example below contains a lengthy code which exemplifies the process of gathering useful data for control chart use. Detailed application of this data can be found in the package's vignette.
</p>


<h3>Source</h3>

<p>The original dataset is based on a month-aggregated time series data of diabetic patients from Hungary which was gathered from the period of 2007 September - 2017 September. The data came from two sources: the National Health Insurance Fund of Hungary and the South-Pest Central Hospital. The first source provided information about diagnoses, treatments, health care event and related costs while the latter provided laboratory data regarding blood sugar level. Patients with International Classification of Diseases (ICD) codes (diagnosis) of E10, E11 and E14, and at least one blood sugar measurement were included initially. Only the data of patients with at least one E11 (type II diabetes) diagnosis in the study period was kept. An additional homogenising filter was the requirement of age above 40 at the time of the first diagnosis. Disease progression and therapy effectiveness estimation required at least two blood sugar (HbA1c) measurements with simultaneous therapy data. A total of 4434 patients satisfied all conditions out of which 2151 had at least two HbA1c measurements.
</p>


<h3>References</h3>

<p>https://ecmiindmath.org/2019/08/19/markov-chain-based-cost-optimal-control-charts/
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("diabetes")
str(diabetes)

## Not run: 
##### Example of data assessment for control chart use #####
### Packages
require(zoo)
require(reshape2)

RANDOMISED_DATA &lt;- diabetes

### Functions
weighted.var &lt;- function(x, w, na.rm = FALSE) {
    if (na.rm) {
        w &lt;- w[i &lt;- !is.na(x)]
        x &lt;- x[i]
    }
    sum.w &lt;- sum(w)
    sum.w2 &lt;- sum(w^2)
    mean.w &lt;- sum(x * w) / sum(w)
    (sum.w / (sum.w^2 - sum.w2)) * sum(w * (x - mean.w)^2, na.rm =
na.rm)
}

estBetaParams &lt;- function(mu, var) {
  alpha &lt;- ((1 - mu) / var - 1 / mu) * mu ^ 2
  beta &lt;- alpha * (1 / mu - 1)
  return(params = list(alpha = alpha, beta = beta))
}

### Setting up data
# Way too high HbA1C levels are discarded as outliers
RANDOMISED_DATA$HBA1C_AVG[RANDOMISED_DATA$HBA1C_AVG&gt;20 &amp; !is.na(RANDOMISED_DATA$HBA1C_AVG)] &lt;- NA

# Lowest HbA1c level taken into account
lowest &lt;- 4

### Gathering data for several estimates
RANDOMISED_DATA &lt;- RANDOMISED_DATA[RANDOMISED_DATA$ID %in%
RANDOMISED_DATA$ID[grepl("E11",RANDOMISED_DATA$ICD)],]

# Process standard deviation
sigma_param &lt;- sigma &lt;- sqrt(weighted.mean((RANDOMISED_DATA$HBA1C_SD[
RANDOMISED_DATA$SAMPLING_IN_MONTH&gt;=2 &amp; !is.na(RANDOMISED_DATA$SAMPLING_IN_MONTH)])^2,
RANDOMISED_DATA$SAMPLING_IN_MONTH[RANDOMISED_DATA$SAMPLING_IN_MONTH&gt;=2 &amp;
!is.na(RANDOMISED_DATA$SAMPLING_IN_MONTH)]))

IDLIST &lt;- unique(RANDOMISED_DATA$ID[!is.na(RANDOMISED_DATA$HBA1C_AVG)][
duplicated(RANDOMISED_DATA$ID[!is.na(RANDOMISED_DATA$HBA1C_AVG)])])
IDLIST &lt;- unique(RANDOMISED_DATA$ID[(RANDOMISED_DATA$ID %in% IDLIST) &amp; RANDOMISED_DATA$AGE&gt;39])

shiftdat &lt;- NULL
stimedat &lt;- NULL
repaidat &lt;- NULL
deltats  &lt;- NULL
deltaATC &lt;- NULL
for(i in IDLIST)
{
	smalldat    &lt;- RANDOMISED_DATA[RANDOMISED_DATA$ID==i,c("DATE","HBA1C_AVG","THERAPY_VECTOR")]
	smalldat    &lt;- smalldat[!is.na(smalldat$DATE) &amp; !is.na(smalldat$HBA1C_AVG),]
	patshiftdat &lt;- as.data.frame(cbind(i,smalldat$DATE[2:dim(smalldat)[1]],diff(smalldat$DATE),
	diff(smalldat$HBA1C_AVG))[diff(smalldat$HBA1C_AVG)&gt;2*sigma,,drop=FALSE])
	if(dim(patshiftdat)[1]&gt;1) stimedat &lt;- rbind(stimedat,cbind(i,diff(as.Date(patshiftdat$V2))))
	patrepaidat &lt;- as.data.frame(cbind(i,diff(smalldat$DATE),(smalldat$HBA1C_AVG-lowest)[2:
    length(smalldat$HBA1C_AVG)]/(smalldat$HBA1C_AVG-lowest)[1:(length(smalldat$HBA1C_AVG)-1)],
		as.character(smalldat$THERAPY_VECTOR[1:(length(smalldat$THERAPY_VECTOR)-1)]))[
		(which(diff(smalldat$HBA1C_AVG)&lt;(-2*sigma) &amp;
		smalldat$HBA1C_AVG[1:(length(smalldat$HBA1C_AVG)-1)]&gt;6 &amp;
		smalldat$HBA1C_AVG[1:(length(smalldat$HBA1C_AVG)-1)]&lt;=20)),,drop=FALSE])

	shiftdat &lt;- rbind(shiftdat,patshiftdat)
	repaidat &lt;- rbind(repaidat,patrepaidat)
	deltats  &lt;- rbind(deltats,cbind(i,diff(as.Date(RANDOMISED_DATA$DATE[
	!is.na(RANDOMISED_DATA$HBA1C_AVG) &amp; RANDOMISED_DATA$ID==i]))))
	try(deltaATC &lt;- rbind(deltaATC,cbind(i,diff(as.Date(RANDOMISED_DATA$DATE[
	!is.na(RANDOMISED_DATA$THERAPY) &amp; RANDOMISED_DATA$ID==i])))), silent=TRUE)
}
colnames(shiftdat) &lt;- c("ID","TIME","TIMEDIFF","SHIFTSIZE")
colnames(deltats)  &lt;- c("ID","DeltaT")
colnames(deltaATC) &lt;- c("ID","deltaATC")

# delta: expected shift size
delta_param &lt;- mean(shiftdat$SHIFTSIZE[shiftdat$TIMEDIFF&gt;=90 &amp; shiftdat$TIMEDIFF&lt;184])

# Empirical distribution of elapsed times (between samplings)
summary(deltats[,2])
mean(deltats[,2])
median(deltats[,2])
sd(deltats[,2])

# s: expected number of shifts per unit time
stimedat           &lt;- as.data.frame(stimedat)
colnames(stimedat) &lt;- c("ID","TIMEDIFF")
s_param            &lt;- 1/mean(stimedat$TIMEDIFF[stimedat$TIMEDIFF&lt;367])

# alphas, betas: therapy effectiveness parameters
colnames(repaidat) &lt;- c("ID","TIMEDIFF","REMAIN","THERAP")
repaidat$REMAIN    &lt;- as.numeric(as.character(repaidat$REMAIN))
repaidat$TIMEDIFF  &lt;- as.numeric(as.character(repaidat$TIMEDIFF))
repaidat$THERAP    &lt;- as.character(repaidat$THERAP)
repaidat           &lt;- repaidat[repaidat$TIMEDIFF&gt;=90 &amp; repaidat$TIMEDIFF&lt;184,]
repaidat$REMAIN[repaidat$REMAIN&lt;0] &lt;- 0

ther_eff &lt;- as.data.frame(rbind(
cbind("ANALOGUE",repaidat$REMAIN[repaidat$TIMEDIFF&gt;=90 &amp; repaidat$TIMEDIFF&lt;184 &amp;
grepl("ANALOGUE",repaidat$THERAP) &amp; !grepl("-H",repaidat$THERAP) &amp; !grepl("GLP",repaidat$THERAP)]),
cbind("GLP",repaidat$REMAIN[repaidat$TIMEDIFF&gt;=90 &amp; repaidat$TIMEDIFF&lt;184 &amp;
grepl("GLP",repaidat$THERAP) &amp; !grepl("-H",repaidat$THERAP)])))
ther_eff[,1]       &lt;- factor(ther_eff[,1], levels = c("ANALOGUE", "GLP"))
ther_eff[,2]       &lt;- as.numeric(as.character(ther_eff[,2]))
colnames(ther_eff) &lt;- c("Type","Effectiveness")

ANALOGUE &lt;- estBetaParams(mean(repaidat$REMAIN[repaidat$TIMEDIFF&gt;=90 &amp; repaidat$TIMEDIFF&lt;184 &amp;
grepl("ANALOGUE",repaidat$THERAP) &amp; !grepl("-H",repaidat$THERAP) &amp; !grepl("GLP",repaidat$THERAP)]),
			 var(repaidat$REMAIN[repaidat$TIMEDIFF&gt;=90 &amp; repaidat$TIMEDIFF&lt;184 &amp;
			 grepl("ANALOGUE",repaidat$THERAP) &amp; !grepl("-H",repaidat$THERAP) &amp;
			 !grepl("GLP",repaidat$THERAP)]))
GLP &lt;- estBetaParams(mean(repaidat$REMAIN[repaidat$TIMEDIFF&gt;=90 &amp; repaidat$TIMEDIFF&lt;184 &amp;
                       grepl("GLP",repaidat$THERAP) &amp; !grepl("-H",repaidat$THERAP)]),
                     var(repaidat$REMAIN[repaidat$TIMEDIFF&gt;=90 &amp; repaidat$TIMEDIFF&lt;184 &amp;
                       grepl("GLP",repaidat$THERAP) &amp; !grepl("-H",repaidat$THERAP)]))

### Repair cost
HBA1C_fill &lt;- NULL
for (i in unique(RANDOMISED_DATA$ID[!is.na(RANDOMISED_DATA$HBA1C_AVG)]))
{
  vec &lt;- RANDOMISED_DATA$HBA1C_AVG[RANDOMISED_DATA$ID==i]
  vec[which(is.na(vec))[which(is.na(vec))&lt;which(!is.na(vec))[1]]] &lt;- vec[which(!is.na(vec))[1]]
  vec[which(is.na(vec))[which(is.na(vec))&gt;which(!is.na(vec))[length(which(!is.na(vec)))]]] &lt;-
    vec[which(!is.na(vec))[length(which(!is.na(vec)))]]
  vec &lt;- na.approx(vec)
  HBA1C_fill &lt;- rbind(HBA1C_fill,cbind(i,vec))

  smaldat &lt;- RANDOMISED_DATA[RANDOMISED_DATA$ID==i,]
  smaldat$THERAPY_COST_EUR[smaldat$THERAPY_COST_EUR==0 &amp; smaldat$THERAPY_VECTOR!=""] &lt;- NA
  if(is.na(smaldat$THERAPY_COST_EUR[1])) smaldat$THERAPY_COST_EUR[1]                 &lt;- 0
  new_burden &lt;- na.locf(smaldat$THERAPY_COST_EUR)

  seged                     &lt;- cbind(rle(is.na(smaldat$THERAPY_COST_EUR))[[2]],
                                     rle(is.na(smaldat$THERAPY_COST_EUR))[[1]])
  seged[,2][seged[,1]==0]   &lt;- seged[,2][seged[,1]==0]-1
  seged[,2][seged[,1]==1]   &lt;- seged[,2][seged[,1]==1]+1
  if(seged[length(seged[,1]),1]==0) seged[length(seged[,2]),2] &lt;- seged[length(seged[,2]),2]+1
  seged2                    &lt;- cbind(rep(seged[,1], seged[,2]),rep(seged[,2], seged[,2]))
  new_burden[seged2[,1]==1] &lt;- new_burden[seged2[,1]==1]/seged2[,2][seged2[,1]==1]

  RANDOMISED_DATA$THERAPY_COST_EUR[RANDOMISED_DATA$ID==i]	&lt;-	new_burden
}

RANDOMISED_DATA$HBA1C_fill &lt;- NA
RANDOMISED_DATA$HBA1C_fill[RANDOMISED_DATA$ID%in%HBA1C_fill[,1]] &lt;- HBA1C_fill[,2]
RANDOMISED_DATA$HBA1C_fill_filter &lt;- RANDOMISED_DATA$HBA1C_fill
RANDOMISED_DATA$HBA1C_fill_filter[RANDOMISED_DATA$HBA1C_fill_filter&gt;=10] &lt;- NA

discparam    &lt;-	150
cutHBA1C_AVG &lt;-	cut(na.omit(RANDOMISED_DATA$HBA1C_fill_filter),breaks=discparam)
newlvls      &lt;-	seq(min(na.omit(RANDOMISED_DATA$HBA1C_fill_filter)),
                    max(na.omit(RANDOMISED_DATA$HBA1C_fill_filter)),
                    (max(na.omit(RANDOMISED_DATA$HBA1C_fill_filter))-
                      min(na.omit(RANDOMISED_DATA$HBA1C_fill_filter)))/discparam)[1:discparam] +
                    (max(na.omit(RANDOMISED_DATA$HBA1C_fill_filter))-
                      min(na.omit(RANDOMISED_DATA$HBA1C_fill_filter)))/discparam/2
levels(cutHBA1C_AVG) &lt;- newlvls
costs                &lt;- cbind(as.numeric(as.character(cutHBA1C_AVG)),
                               RANDOMISED_DATA$THERAPY_COST_EUR[!is.na(
                               RANDOMISED_DATA$HBA1C_fill_filter)]/30,
                               as.character(RANDOMISED_DATA$THERAPY[
                               !is.na(RANDOMISED_DATA$HBA1C_fill_filter)]))
costs           &lt;- as.data.frame(costs)
colnames(costs)	&lt;- c("HBA1C","HC_BURDEN","THERAP")
costs$HBA1C     &lt;- as.numeric(as.character(costs$HBA1C))
costs$HC_BURDEN	&lt;- as.numeric(as.character(costs$HC_BURDEN))
costs$THERAP    &lt;- as.character(costs$THERAP)

costs$THERAP[grepl("ANALOGUE", costs$THERAP) &amp; !grepl("GLP", costs$THERAP)] &lt;- "ANALOGUE"
costs$THERAP[grepl("GLP",costs$THERAP)]                                     &lt;- "GLP"

cost.ANALOGUE &lt;- as.data.frame(cbind(sort(unique(costs$HBA1C[costs$THERAP=="ANALOGUE"])),
                                as.numeric(tapply(costs$HC_BURDEN[costs$THERAP=="ANALOGUE"],
                                  costs$HBA1C[costs$THERAP=="ANALOGUE"],mean))))
colnames(cost.ANALOGUE) &lt;- c("HBA1C","HC_BURDEN")

cost.GLP &lt;-	as.data.frame(cbind(sort(unique(costs$HBA1C[costs$THERAP=="GLP"])),
                            as.numeric(tapply(costs$HC_BURDEN[costs$THERAP=="GLP"],
                              costs$HBA1C[costs$THERAP=="GLP"],mean))))
colnames(cost.GLP) &lt;-	c("HBA1C","HC_BURDEN")

## ANALOGUE therapy
# Mean
cost.ANALOGUE           &lt;- na.omit(as.data.frame(cbind(as.numeric(
                                     costs$HBA1C[costs$THERAP=="ANALOGUE"]),
                                     costs$HC_BURDEN[costs$THERAP=="ANALOGUE"])))
colnames(cost.ANALOGUE) &lt;- c("HBA1C","HC_BURDEN")
cost.ANALOGUE           &lt;- cost.ANALOGUE[order(cost.ANALOGUE$HBA1C),]
cost.ANALOGUE           &lt;- cost.ANALOGUE[cost.ANALOGUE$HBA1C&gt;lowest,]
cost.ANALOGUE$HBA1C     &lt;- cost.ANALOGUE$HBA1C-min(lowest)

# Fit non-linear model
mod.ANALOGUE &lt;- nls(HC_BURDEN ~  a + b/(HBA1C + c),
                    start = list(a = 5, b = -5, c = 1), cost.ANALOGUE,
                    control = list(maxiter = 50000, minFactor = 0.000000000000001))

cost_ANALOGUE_plotdat &lt;- cbind("ANALOGUE",as.data.frame(cbind(seq(0,6,6/99),
                                predict(mod.ANALOGUE,
                                 newdata=data.frame(HBA1C = seq(0,6,6/99))))))

# Variance
cost_var.ANALOGUE  &lt;- na.omit(as.data.frame(cbind(sort(unique(
                               costs$HBA1C[costs$THERAP=="ANALOGUE"])),
                               as.numeric(tapply(costs$HC_BURDEN[costs$THERAP=="ANALOGUE"],
                               costs$HBA1C[costs$THERAP=="ANALOGUE"],var)))))
colnames(cost_var.ANALOGUE)	&lt;- c("HBA1C","HC_BURDEN")
cost_var.ANALOGUE           &lt;- cost_var.ANALOGUE[cost_var.ANALOGUE$HBA1C&gt;lowest,]
cost_var.ANALOGUE$HBA1C     &lt;- cost_var.ANALOGUE$HBA1C-min(lowest)

# Fit non-linear model
mod_var.ANALOGUE &lt;- nls(HC_BURDEN ~  a + b/(HBA1C + c),
                        start = list(a = 5, b = -3, c = 0.1),
                        cost_var.ANALOGUE[cost_var.ANALOGUE$HBA1C&lt;10-lowest,],
                        control = list(maxiter = 50000, minFactor = 0.000000000000001))

cost_ANALOGUE_plotdat &lt;- cbind(cost_ANALOGUE_plotdat,
                               cost_ANALOGUE_plotdat[,3] -
                                 sqrt(predict(mod_var.ANALOGUE,
                                   newdata=data.frame(HBA1C = seq(0,6,6/99)))),
                               cost_ANALOGUE_plotdat[,3] +
                                 sqrt(predict(mod_var.ANALOGUE,
                                   newdata=data.frame(HBA1C = seq(0,6,6/99)))))
colnames(cost_ANALOGUE_plotdat) &lt;- c("Data","HbA1c","Therapy cost","low","high")

## GLP
# Mean
cost.GLP           &lt;- na.omit(as.data.frame(cbind(as.numeric(
                                costs$HBA1C[costs$THERAP=="GLP"]),
                                costs$HC_BURDEN[costs$THERAP=="GLP"])))
colnames(cost.GLP) &lt;- c("HBA1C","HC_BURDEN")
cost.GLP           &lt;- cost.GLP[order(cost.GLP$HBA1C),]
cost.GLP           &lt;- cost.GLP[cost.GLP$HBA1C&gt;lowest,]
cost.GLP$HBA1C     &lt;- cost.GLP$HBA1C-min(lowest)

# Simple linear
mod.GLP &lt;- nls(HC_BURDEN ~ a + b * HBA1C,
               start = list(a = 1, b = 1), cost.GLP,
               control = list(maxiter = 50000, minFactor = 0.000000000000001))

cost_GLP_plotdat &lt;-	cbind("GLP",as.data.frame(cbind(seq(0,6,6/99),
                     predict(mod.GLP, newdata=data.frame(HBA1C = seq(0,6,6/99))))))

# Variance
cost_var.GLP           &lt;- na.omit(as.data.frame(cbind(sort(unique(
                                   costs$HBA1C[costs$THERAP=="GLP"])),
                                   as.numeric(tapply(costs$HC_BURDEN[costs$THERAP=="GLP"],
                                   costs$HBA1C[costs$THERAP=="GLP"],var)))))
colnames(cost_var.GLP) &lt;- c("HBA1C","HC_BURDEN")
cost_var.GLP           &lt;- cost_var.GLP[cost_var.GLP$HBA1C&gt;lowest,]
cost_var.GLP$HBA1C     &lt;- cost_var.GLP$HBA1C-min(lowest)

# Simple linear
mod_var.GLP &lt;- nls(HC_BURDEN ~  a + b*(HBA1C),
                   start = list(a = 5, b = -3), cost_var.GLP,
                   control = list(maxiter = 50000, minFactor = 0.000000000000001))

cost_GLP_plotdat &lt;- cbind(cost_GLP_plotdat,
                          cost_GLP_plotdat[,3] -
                           sqrt(predict(mod_var.GLP, newdata=data.frame(HBA1C = seq(0,6,6/99)))),
                          cost_GLP_plotdat[,3] +
                           sqrt(predict(mod_var.GLP, newdata=data.frame(HBA1C = seq(0,6,6/99)))))
colnames(cost_GLP_plotdat) &lt;- c("Data","HbA1c","Therapy cost","low","high")

### Out-of-control cost
COST_CUMU&lt;-NULL
for (i in unique(RANDOMISED_DATA$ID[!is.na(RANDOMISED_DATA$HEALTHCARE_BURDEN_EUR)]))
{
	vec       &lt;- RANDOMISED_DATA$HEALTHCARE_BURDEN_EUR[RANDOMISED_DATA$ID==i]
	vec2      &lt;- rollapply(vec,min(6,length(vec)),
	              sum,align="left",partial=TRUE)/
	               (pmin(length(vec)-(1:length(vec))+1,6)*30)
	COST_CUMU &lt;- rbind(COST_CUMU,cbind(i,vec2))
}

RANDOMISED_DATA$COST_CUMU &lt;- NA
RANDOMISED_DATA$COST_CUMU[RANDOMISED_DATA$ID%in%COST_CUMU[,1]] &lt;- COST_CUMU[,2]

discparam    &lt;- 150
cutHBA1C_AVG &lt;- cut(na.omit(RANDOMISED_DATA$HBA1C_fill_filter),breaks=discparam)
newlvls      &lt;- seq(min(na.omit(RANDOMISED_DATA$HBA1C_fill_filter)),
                    max(na.omit(RANDOMISED_DATA$HBA1C_fill_filter)),
                    (max(na.omit(RANDOMISED_DATA$HBA1C_fill_filter))-
                      min(na.omit(RANDOMISED_DATA$HBA1C_fill_filter)))/discparam)[1:discparam] +
                      (max(na.omit(RANDOMISED_DATA$HBA1C_fill_filter))-
                        min(na.omit(RANDOMISED_DATA$HBA1C_fill_filter)))/discparam/2
levels(cutHBA1C_AVG) &lt;- newlvls
ooc_costs &lt;- cbind(round(as.numeric(as.character(cutHBA1C_AVG)),1),
              RANDOMISED_DATA$COST_CUMU[!is.na(RANDOMISED_DATA$HBA1C_fill_filter)])
ooc_costs &lt;- as.data.frame(ooc_costs)

# Mean
disc_ooc_cost           &lt;- as.data.frame(cbind(as.numeric(ooc_costs[,1]),ooc_costs[,2]))
colnames(disc_ooc_cost)	&lt;- c("HBA1C","COST")
disc_ooc_cost           &lt;- disc_ooc_cost[order(disc_ooc_cost$HBA1C),]
disc_ooc_cost           &lt;- disc_ooc_cost[disc_ooc_cost$HBA1C &gt;= lowest,]
disc_ooc_cost$HBA1C     &lt;- disc_ooc_cost$HBA1C - lowest

mod.COST &lt;- nls(COST ~ a + c*HBA1C^2, start = list(a = 1, c = 1), disc_ooc_cost)

cost_COST_plotdat &lt;- cbind("Complications",as.data.frame(cbind(seq(0, 6, 6/99),
                           predict(mod.COST, newdata=data.frame(HBA1C = seq(0, 6, 6/99))))))

# Variance
disc_ooc_cost_var           &lt;- as.data.frame(cbind(sort(unique(ooc_costs[,1])),
                                as.numeric(tapply(ooc_costs[,2],ooc_costs[,1],var))))
colnames(disc_ooc_cost_var) &lt;- c("HBA1C","COST")

disc_ooc_cost_var       &lt;- disc_ooc_cost_var[disc_ooc_cost_var$HBA1C&gt;=lowest,]
disc_ooc_cost_var$HBA1C &lt;- disc_ooc_cost_var$HBA1C-lowest

mod_var.COST &lt;- nls(COST ~ a + c*HBA1C^2,
                    start = list(a = 0.5, c = 0.5), disc_ooc_cost_var,
                    control = list(maxiter = 50000, minFactor = 0.000000000000001))

cost_COST_plotdat &lt;- cbind(cost_COST_plotdat,
                           cost_COST_plotdat[,3] -
                             sqrt(predict(mod_var.COST,
                               newdata=data.frame(HBA1C = seq(0,6,6/99)))),
                           cost_COST_plotdat[,3] +
                             sqrt(predict(mod_var.COST,
                               newdata=data.frame(HBA1C = seq(0,6,6/99)))))
colnames(cost_COST_plotdat) &lt;- c("Data","HbA1c","Therapy cost","low","high")

cost_plots       &lt;- rbind(cost_ANALOGUE_plotdat,cost_GLP_plotdat,cost_COST_plotdat)
cost_plots$HbA1c &lt;- cost_plots$HbA1c + lowest
cost_plots[,"Therapy cost"]               &lt;- cost_plots[,"Therapy cost"]/1
cost_plots[,"low"]                        &lt;- cost_plots[,"low"]/1
cost_plots[,"low"][cost_plots[,"low"]&lt;0]  &lt;- 0
cost_plots[,"high"]                       &lt;- cost_plots[,"high"]/1

cost_plots &lt;- cost_plots

### Sampling cost: official, government-regulated prices related to sampling
### converted from HUF to EUR
sampling_cost=2875/369.05

### Empirical costs for comparison
# GLP
mean(RANDOMISED_DATA[grepl("GLP", RANDOMISED_DATA$THERAPY),]$THERAPY_COST_EUR)/30 +
mean(RANDOMISED_DATA[grepl("GLP", RANDOMISED_DATA$THERAPY),]$COST_CUMU) +
sampling_cost/mean(deltats[,2])

sd(RANDOMISED_DATA[grepl("GLP", RANDOMISED_DATA$THERAPY),]$THERAPY_COST_EUR/30 +
RANDOMISED_DATA[grepl("GLP", RANDOMISED_DATA$THERAPY),]$COST_CUMU +
sampling_cost/mean(deltats[,2]))

# ANALOGUE
mean(RANDOMISED_DATA[grepl("ANALOGUE", RANDOMISED_DATA$THERAPY) &amp;
 !grepl("GLP", RANDOMISED_DATA$THERAPY),]$THERAPY_COST_EUR)/30 +
mean(RANDOMISED_DATA[grepl("ANALOGUE", RANDOMISED_DATA$THERAPY) &amp;
 !grepl("GLP", RANDOMISED_DATA$THERAPY),]$COST_CUMU) +
sampling_cost/mean(deltats[,2])

sd(RANDOMISED_DATA[grepl("ANALOGUE", RANDOMISED_DATA$THERAPY) &amp;
 !grepl("GLP", RANDOMISED_DATA$THERAPY),]$THERAPY_COST_EUR/30 +
RANDOMISED_DATA[grepl("ANALOGUE", RANDOMISED_DATA$THERAPY) &amp;
 !grepl("GLP", RANDOMISED_DATA$THERAPY),]$COST_CUMU +
sampling_cost/mean(deltats[,2]))

### Empirical HbA1c distribution
# GLP
empi.GLP  &lt;- RANDOMISED_DATA$HBA1C_fill[grepl("GLP", RANDOMISED_DATA$THERAPY) &amp;
               RANDOMISED_DATA$HBA1C_fill&gt;=4 &amp; RANDOMISED_DATA$HBA1C_fill&lt;=20]
cutHBA1C  &lt;- cut(na.omit(empi.GLP),breaks=100)
newlvls   &lt;- seq(min(na.omit(empi.GLP)),max(na.omit(empi.GLP)),
                     (max(na.omit(empi.GLP))-min(na.omit(empi.GLP)))/100)[1:100] +
                      (max(na.omit(empi.GLP))-min(na.omit(empi.GLP)))/100/2
levels(cutHBA1C)    &lt;- newlvls
empi.GLP            &lt;- as.data.frame(table(cutHBA1C)/sum(table(cutHBA1C)))
empi.GLP$cutHBA1C   &lt;- as.numeric(as.character(empi.GLP$cutHBA1C))
empi.GLP            &lt;- cbind("GLP", empi.GLP)
colnames(empi.GLP)  &lt;- c("Therapy", "HbA1c", "Probability")

# ANALOGUE
empi.ANALOGUE   &lt;- RANDOMISED_DATA$HBA1C_fill[grepl("ANALOGUE", RANDOMISED_DATA$THERAPY) &amp;
                    !grepl("GLP", RANDOMISED_DATA$THERAPY) &amp;
                      RANDOMISED_DATA$HBA1C_fill&gt;=4 &amp; RANDOMISED_DATA$HBA1C_fill&lt;=20]
cutHBA1C        &lt;- cut(na.omit(empi.ANALOGUE),breaks=100)
newlvls         &lt;- seq(min(na.omit(empi.ANALOGUE)),
                       max(na.omit(empi.ANALOGUE)),
                       (max(na.omit(empi.ANALOGUE))-
                         min(na.omit(empi.ANALOGUE)))/100)[1:100] +
                          (max(na.omit(empi.ANALOGUE))-
                            min(na.omit(empi.ANALOGUE)))/100/2
levels(cutHBA1C)        &lt;- newlvls
empi.ANALOGUE           &lt;- as.data.frame(table(cutHBA1C)/sum(table(cutHBA1C)))
empi.ANALOGUE$cutHBA1C  &lt;- as.numeric(as.character(empi.ANALOGUE$cutHBA1C))
empi.ANALOGUE           &lt;- cbind("ANALOGUE", empi.ANALOGUE)
colnames(empi.ANALOGUE)	&lt;- c("Therapy", "HbA1c", "Probability")

# Merging datasets
hba1c_empir &lt;- rbind(empi.ANALOGUE, empi.GLP)

# The list of gathered data and statistics:
# sigma_param, s_param, delta_param, ANALOGUE
# GLP, mod.ANALOGUE, mod_var.ANALOGUE
# mod.GLP, mod_var.GLP, mod.COST, mod_var.COST
# cost_plots, sampling_cost, hba1c_empir


## End(Not run)
</code></pre>


</div>