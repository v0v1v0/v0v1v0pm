<div class="container">

<table style="width: 100%;"><tr>
<td>itheta_vcov</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute variance covariance of Inverse 'Unified' Second Moment</h2>

<h3>Description</h3>

<p>Computes the variance covariance matrix of the inverse unified 
second moment matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">itheta_vcov(X,vcov.func=vcov,fit.intercept=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of observed returns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov.func</code></td>
<td>
<p>a function which takes an object of class <code>lm</code>,
and computes a variance-covariance matrix. If equal to the string
<code>"normal"</code>, we assume multivariate normal returns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.intercept</code></td>
<td>
<p>a boolean controlling whether we add a column
of ones to the data, or fit the raw uncentered second moment.
For now, must be true when assuming normal returns.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given <code class="reqn">p</code>-vector <code class="reqn">x</code> with mean <code class="reqn">\mu</code> and
covariance, <code class="reqn">\Sigma</code>, let <code class="reqn">y</code> be <code class="reqn">x</code>
with a one prepended. Then let 
<code class="reqn">\Theta = E\left(y y^{\top}\right)</code>,
the uncentered second moment matrix. The inverse of
<code class="reqn">\Theta</code> contains the (negative) Markowitz portfolio 
and the precision matrix. 
</p>
<p>Given <code class="reqn">n</code> contemporaneous observations of <code class="reqn">p</code>-vectors,
stacked as rows in the <code class="reqn">n \times p</code> matrix <code class="reqn">X</code>,
this function estimates the mean and the asymptotic 
variance-covariance matrix of <code class="reqn">\Theta^{-1}</code>.
</p>
<p>One may use the default method for computing covariance,
via the <code>vcov</code> function, or via a 'fancy' estimator,
like <code>sandwich:vcovHAC</code>, <code>sandwich:vcovHC</code>, <em>etc.</em>
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a <code class="reqn">q = (p+1)(p+2)/2</code> vector of 1 + squared maximum
Sharpe, the negative Markowitz 
portfolio, then the vech'd precision matrix of the sample data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ohat</code></td>
<td>
<p>the <code class="reqn">q \times q</code> estimated variance 
covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of rows in <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pp</code></td>
<td>
<p>the number of assets plus <code>as.numeric(fit.intercept)</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>By flipping the sign of <code class="reqn">X</code>, the inverse of 
<code class="reqn">\Theta</code> contains the <em>positive</em> Markowitz
portfolio and the precision matrix on <code class="reqn">X</code>. Performing
this transform before passing the data to this function
should be considered idiomatic.
</p>
<p>A more general form of this function exists as <code>mp_vcov</code>.
</p>
<p>Replaces similar functionality from SharpeR package, but with 
modified API.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. "Asymptotic Distribution of the Markowitz Portfolio."
2013 <a href="https://arxiv.org/abs/1312.0557">https://arxiv.org/abs/1312.0557</a>
</p>
<p>Pav, S. E. "Portfolio Inference with this One Weird Trick."
R in Finance, 2014 <a href="http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf">http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf</a>
</p>


<h3>See Also</h3>

<p><code>theta_vcov</code>, <code>mp_vcov</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">X &lt;- matrix(rnorm(1000*3),ncol=3)
# putting in -X is idiomatic:
ism &lt;- itheta_vcov(-X)
iSigmas.n &lt;- itheta_vcov(-X,vcov.func="normal")
iSigmas.n &lt;- itheta_vcov(-X,fit.intercept=FALSE)
# compute the marginal Wald test statistics:
qidx &lt;- 2:ism$pp
wald.stats &lt;- ism$mu[qidx] / sqrt(diag(ism$Ohat[qidx,qidx]))

# make it fat tailed:
X &lt;- matrix(rt(1000*3,df=5),ncol=3)
ism &lt;- itheta_vcov(X)
qidx &lt;- 2:ism$pp
wald.stats &lt;- ism$mu[qidx] / sqrt(diag(ism$Ohat[qidx,qidx]))

if (require(sandwich)) {
 ism &lt;- itheta_vcov(X,vcov.func=vcovHC)
 qidx &lt;- 2:ism$pp
 wald.stats &lt;- ism$mu[qidx] / sqrt(diag(ism$Ohat[qidx,qidx]))
}

# add some autocorrelation to X
Xf &lt;- filter(X,c(0.2),"recursive")
colnames(Xf) &lt;- colnames(X)
ism &lt;- itheta_vcov(Xf)
qidx &lt;- 2:ism$pp
wald.stats &lt;- ism$mu[qidx] / sqrt(diag(ism$Ohat[qidx,qidx]))

if (require(sandwich)) {
ism &lt;- itheta_vcov(Xf,vcov.func=vcovHAC)
 qidx &lt;- 2:ism$pp
 wald.stats &lt;- ism$mu[qidx] / sqrt(diag(ism$Ohat[qidx,qidx]))
}

</code></pre>


</div>