<div class="container">

<table style="width: 100%;"><tr>
<td>theta_vcov</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute variance covariance of 'Unified' Second Moment</h2>

<h3>Description</h3>

<p>Computes the variance covariance matrix of sample mean and second moment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">theta_vcov(X,vcov.func=vcov,fit.intercept=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of observed returns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov.func</code></td>
<td>
<p>a function which takes an object of class <code>lm</code>,
and computes a variance-covariance matrix. If equal to the string
<code>"normal"</code>, we assume multivariate normal returns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.intercept</code></td>
<td>
<p>a boolean controlling whether we add a column
of ones to the data, or fit the raw uncentered second moment.
For now, must be true when assuming normal returns.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given <code class="reqn">p</code>-vector <code class="reqn">x</code>, the 'unified' sample is the 
<code class="reqn">(p+1)(p+2)/2</code> vector of 1, <code class="reqn">x</code>, and 
<code class="reqn">\mbox{vech}(x x^{\top})</code> stacked on top
of each other.
Given <code class="reqn">n</code> contemporaneous observations of <code class="reqn">p</code>-vectors,
stacked as rows in the <code class="reqn">n \times p</code> matrix <code class="reqn">X</code>,
this function computes the mean and the variance-covariance
matrix of the 'unified' sample. 
</p>
<p>One may use the default method for computing covariance,
via the <code>vcov</code> function, or via a 'fancy' estimator,
like <code>sandwich:vcovHAC</code>, <code>sandwich:vcovHC</code>, <em>etc.</em>
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a <code class="reqn">q = (p+1)(p+2)/2</code> vector of 1, then the mean, 
then the vech'd second moment of the sample data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ohat</code></td>
<td>
<p>the <code class="reqn">q \times q</code> estimated variance covariance 
matrix. When <code>fit.intercept</code> is true, the left column and top row
are all zeros.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of rows in <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pp</code></td>
<td>
<p>the number of assets plus <code>as.numeric(fit.intercept)</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Replaces similar functionality from SharpeR package, but with 
modified API.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. "Asymptotic Distribution of the Markowitz Portfolio."
2013 <a href="https://arxiv.org/abs/1312.0557">https://arxiv.org/abs/1312.0557</a>
</p>
<p>Pav, S. E. "Portfolio Inference with this One Weird Trick."
R in Finance, 2014 <a href="http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf">http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf</a>
</p>


<h3>See Also</h3>

<p><code>itheta_vcov</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">X &lt;- matrix(rnorm(1000*3),ncol=3)
Sigmas &lt;- theta_vcov(X)
Sigmas.n &lt;- theta_vcov(X,vcov.func="normal")
Sigmas.n &lt;- theta_vcov(X,fit.intercept=FALSE)

# make it fat tailed:
X &lt;- matrix(rt(1000*3,df=5),ncol=3)
Sigmas &lt;- theta_vcov(X)

if (require(sandwich)) {
 Sigmas &lt;- theta_vcov(X,vcov.func=vcovHC)
}

# add some autocorrelation to X
Xf &lt;- filter(X,c(0.2),"recursive")
colnames(Xf) &lt;- colnames(X)
Sigmas &lt;- theta_vcov(Xf)

if (require(sandwich)) {
Sigmas &lt;- theta_vcov(Xf,vcov.func=vcovHAC)
}


</code></pre>


</div>