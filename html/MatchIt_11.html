<div class="container">

<table style="width: 100%;"><tr>
<td>method_cardinality</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cardinality Matching</h2>

<h3>Description</h3>

<p>In <code>matchit()</code>, setting <code>method = "cardinality"</code> performs cardinality
matching and other forms of matching that use mixed integer programming.
Rather than forming pairs, cardinality matching selects the largest subset
of units that satisfies user-supplied balance constraints on mean
differences. One of several available optimization programs can be used to
solve the mixed integer program. The default is the GLPK library as
implemented in the <em>Rglpk</em> package, but performance can be dramatically
improved using the HiGHS and the <em>highs</em> package, which are free, or Gurobi and the <em>gurobi</em> package, for which there is a
free academic license.
</p>
<p>This page details the allowable arguments with <code>method = "cardinality"</code>. See <code>matchit()</code> for an explanation of what each argument
means in a general context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for cardinality matching:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "cardinality",
        estimand = "ATT",
        exact = NULL,
        mahvars = NULL,
        s.weights = NULL,
        ratio = 1,
        verbose = FALSE,
        tols = .05,
        std.tols = TRUE,
        solver = "glpk",
        ...) </pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a two-sided formula object containing the treatment and
covariates to be balanced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>set here to <code>"cardinality"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimand</code></td>
<td>
<p>a string containing the desired estimand. Allowable options
include <code>"ATT"</code>, <code>"ATC"</code>, and <code>"ATE"</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>for which variables exact matching should take place. Separate
optimization will occur within each subgroup of the exact matching
variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mahvars</code></td>
<td>
<p>which variables should be used for pairing after subset selection. Can only be set when <code>ratio</code> is a whole number. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into the optimization. The balance constraints refer to the product of the
sampling weights and the matching weights, and the sum of the product of the
sampling and matching weights will be maximized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>
<p>the desired ratio of control to treated units. Can be set to
<code>NA</code> to maximize sample size without concern for this ratio. See
Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments that control the matching specification:
</p>

<dl>
<dt><code>tols</code></dt>
<dd> <p><code>numeric</code>; a vector of imbalance
tolerances for mean differences, one for each covariate in <code>formula</code>.
If only one value is supplied, it is applied to all. See <code>std.tols</code>
below. Default is <code>.05</code> for standardized mean differences of at most
.05 for all covariates between the treatment groups in the matched sample.
</p>
</dd>
<dt><code>std.tols</code></dt>
<dd> <p><code>logical</code>; whether each entry in <code>tols</code>
corresponds to a raw or standardized mean difference. If only one value is
supplied, it is applied to all. Default is <code>TRUE</code> for standardized mean
differences. The standardization factor is the pooled standard deviation
when <code>estimand = "ATE"</code>, the standard deviation of the treated group
when <code>estimand = "ATT"</code>, and the standard deviation of the control
group when <code>estimand = "ATC"</code> (the same as used in
<code>summary.matchit()</code>).</p>
</dd>
<dt><code>solver</code></dt>
<dd>
<p> the name of solver to use to
solve the optimization problem. Available options include <code>"highs"</code>, <code>"glpk"</code>,
<code>"symphony"</code>, and <code>"gurobi"</code> for HiGHS (implemented in the <em>highs</em> package), GLPK (implemented in the
<em>Rglpk</em> package), SYMPHONY (implemented in the <em>Rsymphony</em>
package), and Gurobi (implemented in the <em>gurobi</em> package),
respectively. The differences between them are in speed and solving ability.
GLPK (the default) and HiGHS are the easiest to install, but Gurobi is recommended as
it consistently outperforms other solvers and can find solutions even when
others can't, and in less time. Gurobi is proprietary but can be used with a
free trial or academic license. SYMPHONY may not produce reproducible
results, even with a seed set.  </p>
</dd>
<dt><code>time</code></dt>
<dd>
<p> the maximum amount of
time before the optimization routine aborts, in seconds. Default is 120 (2
minutes). For large problems, this should be set much higher.  </p>
</dd>
</dl>
<p>The arguments <code>distance</code> (and related arguments), <code>replace</code>, <code>m.order</code>, and <code>caliper</code> (and related arguments) are ignored with a warning.</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Cardinality and Profile Matching</h4>

<p>Two types of matching are
available with <code>method = "cardinality"</code>: cardinality matching and
profile matching.
</p>
<p><strong>Cardinality matching</strong> finds the largest matched set that satisfies the
balance constraints between treatment groups, with the additional constraint
that the ratio of the number of matched control to matched treated units is
equal to <code>ratio</code> (1 by default), mimicking k:1 matching. When not all
treated units are included in the matched set, the estimand no longer
corresponds to the ATT, so cardinality matching should be avoided if
retaining the ATT is desired. To request cardinality matching,
<code>estimand</code> should be set to <code>"ATT"</code> or <code>"ATC"</code> and
<code>ratio</code> should be set to a positive integer. 1:1 cardinality matching
is the default method when no arguments are specified.
</p>
<p><strong>Profile matching</strong> finds the largest matched set that satisfies balance
constraints between each treatment group and a specified target sample. When
<code>estimand = "ATT"</code>, it will find the largest subset of the control
units that satisfies the balance constraints with respect to the treated
group, which is left intact. When <code>estimand = "ATE"</code>, it will find the
largest subsets of the treated group and of the control group that are
balanced to the overall sample. To request profile matching for the ATT,
<code>estimand</code> should be set to <code>"ATT"</code> and <code>ratio</code> to <code>NA</code>.
To request profile matching for the ATE, <code>estimand</code> should be set to
<code>"ATE"</code> and <code>ratio</code> can be set either to <code>NA</code> to maximize the
size of each sample independently or to a positive integer to ensure that
the ratio of matched control units to matched treated treats is fixed,
mimicking k:1 matching. Unlike cardinality matching, profile matching
retains the requested estimand if a solution is found.
</p>
<p>Neither method involves creating pairs in the matched set, but it is
possible to perform an additional round of pairing within the matched sample
after cardinality matching or profile matching for the ATE with a fixed whole number
sample size ratio by supplying the desired pairing variables to <code>mahvars</code>. Doing so will trigger optimal matching using <code>optmatch::pairmatch()</code> on the Mahalanobis distance computed using the variables supplied to <code>mahvars</code>. The balance or composition of the matched sample will not change, but additional
precision and robustness can be gained by forming the pairs.
</p>
<p>The weights are scaled so that the sum of the weights in each group is equal
to the number of matched units in the smaller group when cardinality
matching or profile matching for the ATE, and scaled so that the sum of the
weights in the control group is equal to the number of treated units when
profile matching for the ATT. When the sample sizes of the matched groups
is the same (i.e., when <code>ratio = 1</code>), no scaling is done. Robust
standard errors should be used in effect estimation after cardinality or
profile matching (and cluster-robust standard errors if additional pairing
is done in the matched sample). See <code>vignette("estimating-effects")</code>
for more information.
</p>



<h4>Specifying Balance Constraints</h4>

<p>The balance constraints are on
the (standardized) mean differences between the matched treatment groups for
each covariate. Balance constraints should be set by supplying arguments to
<code>tols</code> and <code>std.tols</code>. For example, setting <code>tols = .1</code> and
<code>std.tols = TRUE</code> requests that all the mean differences in the matched
sample should be within .1 standard deviations for each covariate. Different
tolerances can be set for different variables; it might be beneficial to
constrain the mean differences for highly prognostic covariates more tightly
than for other variables. For example, one could specify <code style="white-space: pre;">⁠tols = c(.001, .05), std.tols = c(TRUE, FALSE)⁠</code>
to request that the standardized
mean difference for the first covariate is less than .001 and the raw mean
difference for the second covariate is less than .05. The values should be
specified in the order they appear in <code>formula</code>, except when
interactions are present. One can run the following code:
</p>
<pre>MatchIt:::get_assign(model.matrix(~X1*X2 + X3, data = data))[-1]</pre>
<p>which will output a vector of numbers and the variable to which each number
corresponds; the first entry in <code>tols</code> corresponds to the variable
labeled 1, the second to the variable labeled 2, etc.
</p>



<h4>Dealing with Errors and Warnings</h4>

<p>When the optimization cannot be
solved at all, or at least within the time frame specified in the argument
to <code>time</code>, an error or warning will appear. Unfortunately, it is hard
to know exactly the cause of the failure and what measures should be taken
to rectify it.
</p>
<p>A warning that says <code>"The optimizer failed to find an optimal solution in the time alotted. The returned solution may not be optimal."</code> usually
means that an optimal solution may be possible to find with more time, in
which case <code>time</code> should be increased or a faster solver should be
used. Even with this warning, a potentially usable solution will be
returned, so don't automatically take it to mean the optimization failed.
Sometimes, when there are multiple solutions with the same resulting sample
size, the optimizers will stall at one of them, not thinking it has found
the optimum. The result should be checked to see if it can be used as the
solution.
</p>
<p>An error that says <code>"The optimization problem may be infeasible."</code>
usually means that there is a issue with the optimization problem, i.e.,
that there is no possible way to satisfy the constraints. To rectify this,
one can try relaxing the constraints by increasing the value of <code>tols</code>
or use another solver. Sometimes Gurobi can solve problems that the other
solvers cannot.
</p>



<h3>Outputs</h3>

<p>Most outputs described in <code>matchit()</code> are returned with
<code>method = "cardinality"</code>. Unless <code>mahvars</code> is specified, the <code>match.matrix</code> and <code>subclass</code>
components are omitted because no pairing or subclassification is done. When
<code>include.obj = TRUE</code> in the call to <code>matchit()</code>, the output of the
optimization function will be included in the output. When <code>exact</code> is
specified, this will be a list of such objects, one for each stratum of the
exact variables.
</p>


<h3>References</h3>

<p>In a manuscript, you should reference the solver used in the
optimization. For example, a sentence might read:
</p>
<p><em>Cardinality matching was performed using the MatchIt package (Ho, Imai, King, &amp; Stuart, 2011) in R with the optimization performed by HiGHs (Huangfu &amp; Hall, 2018).</em>
</p>
<p>See <code>vignette("matching-methods")</code> for more literature on cardinality
matching.
</p>


<h3>See Also</h3>

<p><code>matchit()</code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p><em><a href="https://CRAN.R-project.org/package=designmatch"><span class="pkg">designmatch</span></a></em>, which performs cardinality and profile matching with many more options and
more flexibility. The implementations of cardinality matching differ between
<em>MatchIt</em> and <em>designmatch</em>, so their results might differ.
</p>
<p><em><a href="https://CRAN.R-project.org/package=optweight"><span class="pkg">optweight</span></a></em>, which offers similar functionality but in the context of weighting rather
than matching.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data("lalonde")

#Choose your solver; "gurobi" is best, "highs" is free and
#easy to install
solver &lt;- "highs"

# 1:1 cardinality matching
m.out1 &lt;- matchit(treat ~ age + educ + re74,
                  data = lalonde, method = "cardinality",
                  estimand = "ATT", ratio = 1,
                  tols = .2, solver = solver)
m.out1
summary(m.out1)

# Profile matching for the ATT
m.out2 &lt;- matchit(treat ~ age + educ + re74,
                  data = lalonde, method = "cardinality",
                  estimand = "ATT", ratio = NA,
                  tols = .2, solver = solver)
m.out2
summary(m.out2, un = FALSE)

# Profile matching for the ATE
m.out3 &lt;- matchit(treat ~ age + educ + re74,
                  data = lalonde, method = "cardinality",
                  estimand = "ATE", ratio = NA,
                  tols = .2, solver = solver)
m.out3
summary(m.out3, un = FALSE)


# Pairing after 1:1 cardinality matching:
m.out1b &lt;- matchit(treat ~ age + educ + re74,
                   data = lalonde, method = "cardinality",
                   estimand = "ATT", ratio = 1,
                   tols = .15, solver = solver,
                   mahvars = ~ age + educ + re74)

# Note that balance doesn't change but pair distances
# are lower for the paired-upon variables
summary(m.out1b, un = FALSE)
summary(m.out1, un = FALSE)

# In these examples, a high tol was used and
# few covariate matched on in order to not take too long;
# with real data, tols should be much lower and more
# covariates included if possible.

</code></pre>


</div>