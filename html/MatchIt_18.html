<div class="container">

<table style="width: 100%;"><tr>
<td>method_quick</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast Generalized Full Matching</h2>

<h3>Description</h3>

<p>In <code>matchit()</code>, setting <code>method = "quick"</code> performs generalized full
matching, which is a form of subclassification wherein all units, both
treatment and control (i.e., the "full" sample), are assigned to a subclass
and receive at least one match. It uses an algorithm that is extremely fast
compared to optimal full matching, which is why it is labeled as "quick", at the
expense of true optimality. The method is described in Sävje, Higgins, &amp; Sekhon (2021). The method relies on and is a wrapper
for <code>quickmatch::quickmatch()</code>.
</p>
<p>Advantages of generalized full matching include that the matching order is not
required to be specified, units do not need to be discarded, and it is less
likely that extreme within-subclass distances will be large, unlike with
standard subclassification. The primary output of generalized full matching is a set of
matching weights that can be applied to the matched sample; in this way,
generalized full matching can be seen as a robust alternative to propensity score
weighting, robust in the sense that the propensity score model does not need
to be correct to estimate the treatment effect without bias.
</p>
<p>This page details the allowable arguments with <code>method = "quick"</code>.
See <code>matchit()</code> for an explanation of what each argument means in a general
context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for generalized full matching:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "quick",
        distance = "glm",
        link = "logit",
        distance.options = list(),
        estimand = "ATT",
        exact = NULL,
        mahvars = NULL,
        discard = "none",
        reestimate = FALSE,
        s.weights = NULL,
        caliper = NULL,
        std.caliper = TRUE,
        verbose = FALSE,
        ...)
</pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a two-sided formula object containing the treatment and
covariates to be used in creating the distance measure used in the matching.
This formula will be supplied to the functions that estimate the distance
measure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>set here to <code>"quick"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>the distance measure to be used. See <code>distance</code>
for allowable options. Cannot be supplied as a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>when <code>distance</code> is specified as a method of estimating
propensity scores, an additional argument controlling the link function used
in estimating the distance measure. See <code>distance</code> for allowable
options with each option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.options</code></td>
<td>
<p>a named list containing additional arguments
supplied to the function that estimates the distance measure as determined
by the argument to <code>distance</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimand</code></td>
<td>
<p>a string containing the desired estimand. Allowable options
include <code>"ATT"</code>, <code>"ATC"</code>, and <code>"ATE"</code>. The estimand controls
how the weights are computed; see the Computing Weights section at
<code>matchit()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>for which variables exact matching should take place.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mahvars</code></td>
<td>
<p>for which variables Mahalanobis distance matching should take
place when <code>distance</code> corresponds to a propensity score (e.g., to discard units for common support). If specified, the
distance measure will not be used in matching.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discard</code></td>
<td>
<p>a string containing a method for discarding units outside a
region of common support. Only allowed when <code>distance</code> corresponds to a
propensity score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reestimate</code></td>
<td>
<p>if <code>discard</code> is not <code>"none"</code>, whether to
re-estimate the propensity score in the remaining sample prior to matching.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into propensity score models and balance statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>caliper</code></td>
<td>
<p>the width of the caliper used for caliper matching. A caliper can only be placed on the propensity score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.caliper</code></td>
<td>
<p><code>logical</code>; when a caliper is specified, whether it
is in standard deviation units (<code>TRUE</code>) or raw units (<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>quickmatch::quickmatch()</code>. Allowed arguments include <code>treatment_constraints</code>, <code>size_constraint</code>, <code>target</code>, and other arguments passed to <code>scclust::sc_clustering()</code> (see <code>quickmatch::quickmatch()</code> for details). In particular, changing <code>seed_method</code> from its default can improve performance.
No arguments will be passed to <code>distances::distances()</code>.
</p>
<p>The arguments <code>replace</code>, <code>ratio</code>, <code>min.controls</code>, <code>max.controls</code>, <code>m.order</code>, and <code>antiexact</code> are ignored with a warning.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Generalized full matching is similar to optimal full matching, but has some additional flexibility that can be controlled by some of the extra arguments available. By default, <code>method = "quick"</code> performs a standard full match in which all units are matched (unless restricted by the caliper) and assigned to a subclass. Each subclass could contain multiple units from each treatment group. The subclasses are chosen to minimize the largest within-subclass distance between units (including between units of the same treatment group). Notably, generalized full matching requires less memory and can run much faster than optimal full matching and optimal pair matching and, in some cases, even than nearest neighbor matching, and it can be used with huge datasets (e.g., in the millions) while running in under a minute.
</p>


<h3>Outputs</h3>

<p>All outputs described in <code>matchit()</code> are returned with
<code>method = "quick"</code> except for <code>match.matrix</code>. This is because
matching strata are not indexed by treated units as they are in some other
forms of matching. When <code>include.obj = TRUE</code> in the call to
<code>matchit()</code>, the output of the call to <code>quickmatch::quickmatch()</code> will be
included in the output. When <code>exact</code> is specified, this will be a list
of such objects, one for each stratum of the <code>exact</code> variables.
</p>


<h3>References</h3>

<p>In a manuscript, be sure to cite the <em>quickmatch</em> package if using
<code>matchit()</code> with <code>method = "quick"</code>:
</p>
<p>Sävje, F., Sekhon, J., &amp; Higgins, M. (2018). quickmatch: Quick generalized full matching. <a href="https://CRAN.R-project.org/package=quickmatch">https://CRAN.R-project.org/package=quickmatch</a>
</p>
<p>For example, a sentence might read:
</p>
<p><em>Generalized full matching was performed using the MatchIt package (Ho,
Imai, King, &amp; Stuart, 2011) in R, which calls functions from the quickmatch
package (Savje, Sekhon, &amp; Higgins, 2018).</em>
</p>
<p>You should also cite the following paper, which develops and describes the method:
</p>
<p>Sävje, F., Higgins, M. J., &amp; Sekhon, J. S. (2021). Generalized Full Matching. <em>Political Analysis</em>, 29(4), 423–447. <a href="https://doi.org/10.1017/pan.2020.32">doi:10.1017/pan.2020.32</a>
</p>


<h3>See Also</h3>

<p><code>matchit()</code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p><code>quickmatch::quickmatch()</code>, which is the workhorse.
</p>
<p><code>method_full</code> for optimal full matching, which is nearly the same but offers more customizability and more optimal solutions at the cost of speed.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data("lalonde")

# Generalize full PS matching
m.out1 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "quick")
m.out1
summary(m.out1)

</code></pre>


</div>