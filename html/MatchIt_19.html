<div class="container">

<table style="width: 100%;"><tr>
<td>method_subclass</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Subclassification</h2>

<h3>Description</h3>

<p>In <code>matchit()</code>, setting <code>method = "subclass"</code> performs
subclassification on the distance measure (i.e., propensity score).
Treatment and control units are placed into subclasses based on quantiles of
the propensity score in the treated group, in the control group, or overall,
depending on the desired estimand. Weights are computed based on the
proportion of treated units in each subclass. Subclassification implemented
here does not rely on any other package.
</p>
<p>This page details the allowable arguments with <code>method = "subclass"</code>.
See <code>matchit()</code> for an explanation of what each argument means in a general
context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for subclassification:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "subclass",
        distance = "glm",
        link = "logit",
        distance.options = list(),
        estimand = "ATT",
        discard = "none",
        reestimate = FALSE,
        s.weights = NULL,
        verbose = FALSE,
        ...) </pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a two-sided formula object containing the treatment and
covariates to be used in creating the distance measure used in the
subclassification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>set here to <code>"subclass"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>the distance measure to be used. See <code>distance</code>
for allowable options. Must be a vector of distance scores or the name of a method of estimating propensity scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>when <code>distance</code> is specified as a string, an additional
argument controlling the link function used in estimating the distance
measure. See <code>distance</code> for allowable options with each option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.options</code></td>
<td>
<p>a named list containing additional arguments
supplied to the function that estimates the distance measure as determined
by the argument to <code>distance</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimand</code></td>
<td>
<p>the target <code>estimand</code>. If <code>"ATT"</code>, the default,
subclasses are formed based on quantiles of the distance measure in the
treated group; if <code>"ATC"</code>, subclasses are formed based on quantiles of
the distance measure in the control group; if <code>"ATE"</code>, subclasses are
formed based on quantiles of the distance measure in the full sample. The
estimand also controls how the subclassification weights are computed; see
the Computing Weights section at <code>matchit()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discard</code></td>
<td>
<p>a string containing a method for discarding units outside a
region of common support.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reestimate</code></td>
<td>
<p>if <code>discard</code> is not <code>"none"</code>, whether to
re-estimate the propensity score in the remaining sample prior to
subclassification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into propensity score models and balance statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments that control the subclassification:
</p>

<dl>
<dt><code>subclass</code></dt>
<dd>
<p>either the number of subclasses desired
or a vector of quantiles used to divide the distance measure into
subclasses. Default is 6.</p>
</dd>
<dt><code>min.n</code></dt>
<dd>
<p> the minimum number of
units of each treatment group that are to be assigned each subclass. If the
distance measure is divided in such a way that fewer than <code>min.n</code> units
of a treatment group are assigned a given subclass, units from other
subclasses will be reassigned to fill the deficient subclass. Default is 1.
</p>
</dd>
</dl>
<p>The arguments <code>exact</code>, <code>mahvars</code>, <code>replace</code>, <code>m.order</code>, <code>caliper</code> (and related arguments), and <code>ratio</code> are ignored with a warning.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>After subclassification, effect estimates can be computed separately in the
subclasses and combined, or a single marginal effect can be estimated by
using the weights in the full sample. When using the weights, the method is
sometimes referred to as marginal mean weighting through stratification
(MMWS; Hong, 2010) or fine stratification weighting (Desai et al., 2017).
The weights can be interpreted just like inverse probability weights. See <code>vignette("estimating-effects")</code> for details.
</p>
<p>Changing <code>min.n</code> can change the quality of the weights. Generally, a
low <code>min.w</code> will yield better balance because subclasses only contain
units with relatively similar distance values, but may yield higher variance
because extreme weights can occur due to there being few members of a
treatment group in some subclasses. When <code>min.n = 0</code>, some subclasses may fail to
contain units from both treatment groups, in which case all units in such subclasses
will be dropped.
</p>
<p>Note that subclassification weights can also be estimated using
<em>WeightIt</em>, which provides some additional methods for estimating
propensity scores. Where propensity score-estimation methods overlap, both
packages will yield the same weights.
</p>


<h3>Outputs</h3>

<p>All outputs described in <code>matchit()</code> are returned with
<code>method = "subclass"</code> except that <code>match.matrix</code> is excluded and
one additional component, <code>q.cut</code>, is included, containing a vector of
the distance measure cutpoints used to define the subclasses. Note that when
<code>min.n &gt; 0</code>, the subclass assignments may not strictly obey the
quantiles listed in <code>q.cut</code>. <code>include.obj</code> is ignored.
</p>


<h3>References</h3>

<p>In a manuscript, you don't need to cite another package when
using <code>method = "subclass"</code> because the subclassification is performed
completely within <em>MatchIt</em>. For example, a sentence might read:
</p>
<p><em>Propensity score subclassification was performed using the MatchIt
package (Ho, Imai, King, &amp; Stuart, 2011) in R.</em>
</p>
<p>It may be a good idea to cite Hong (2010) or Desai et al. (2017) if the
treatment effect is estimated using the subclassification weights.
</p>
<p>Desai, R. J., Rothman, K. J., Bateman, B. . T., Hernandez-Diaz, S., &amp;
Huybrechts, K. F. (2017). A Propensity-score-based Fine Stratification
Approach for Confounding Adjustment When Exposure Is Infrequent:
Epidemiology, 28(2), 249–257. <a href="https://doi.org/10.1097/EDE.0000000000000595">doi:10.1097/EDE.0000000000000595</a>
</p>
<p>Hong, G. (2010). Marginal mean weighting through stratification: Adjustment
for selection bias in multilevel data. Journal of Educational and Behavioral
Statistics, 35(5), 499–531. <a href="https://doi.org/10.3102/1076998609359785">doi:10.3102/1076998609359785</a>
</p>


<h3>See Also</h3>

<p><code>matchit()</code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p><code>method_full</code> for optimal full matching and <code>method_quick</code> for generalized full matching, which are similar to
subclassification except that the number of subclasses and subclass
membership are chosen to optimize the within-subclass distance.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data("lalonde")

# PS subclassification for the ATT with 7 subclasses
s.out1 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "subclass", subclass = 7)
s.out1
summary(s.out1, subclass = TRUE)

# PS subclassification for the ATE with 10 subclasses
# and at least 2 units in each group per subclass
s.out2 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "subclass", subclass = 10,
                  estimand = "ATE", min.n = 2)
s.out2
summary(s.out2)

</code></pre>


</div>