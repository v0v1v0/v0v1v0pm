<div class="container">

<table style="width: 100%;"><tr>
<td>summary.matchit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>View a balance summary of a <code>matchit</code> object</h2>

<h3>Description</h3>

<p>Computes and prints balance statistics for <code>matchit</code> and
<code>matchit.subclass</code> objects. Balance should be assessed to ensure the
matching or subclassification was effective at eliminating treatment group
imbalance and should be reported in the write-up of the results of the
analysis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'matchit'
summary(
  object,
  interactions = FALSE,
  addlvariables = NULL,
  standardize = TRUE,
  data = NULL,
  pair.dist = TRUE,
  un = TRUE,
  improvement = FALSE,
  ...
)

## S3 method for class 'matchit.subclass'
summary(
  object,
  interactions = FALSE,
  addlvariables = NULL,
  standardize = TRUE,
  data = NULL,
  pair.dist = FALSE,
  subclass = FALSE,
  un = TRUE,
  improvement = FALSE,
  ...
)

## S3 method for class 'summary.matchit'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a <code>matchit</code> object; the output of a call to <code>matchit()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interactions</code></td>
<td>
<p><code>logical</code>; whether to compute balance statistics
for two-way interactions and squares of covariates. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addlvariables</code></td>
<td>
<p>additional variable for which balance statistics are to
be computed along with the covariates in the <code>matchit</code> object. Can be
entered in one of three ways: as a data frame of covariates with as many
rows as there were units in the original <code>matchit()</code> call, as a string
containing the names of variables in <code>data</code>, or as a right-sided
<code>formula</code> with the additional variables (and possibly their
transformations) found in <code>data</code>, the environment, or the
<code>matchit</code> object. Balance on squares and interactions of the additional
variables will be included if <code>interactions = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p><code>logical</code>; whether to compute standardized
(<code>TRUE</code>) or unstandardized (<code>FALSE</code>) statistics. The standardized
statistics are the standardized mean difference and the mean and maximum of
the difference in the (weighted) empirical cumulative distribution functions
(ECDFs). The unstandardized statistics are the raw mean difference and the
mean and maximum of the quantile-quantile (QQ) difference. Variance ratios
are produced either way. See Details below. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a optional data frame containing variables named in
<code>addlvariables</code> if specified as a string or formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pair.dist</code></td>
<td>
<p><code>logical</code>; whether to compute average absolute pair
distances. For matching methods that don't include a <code>match.matrix</code>
component in the output (i.e., exact matching, coarsened exact matching,
full matching, and subclassification), computing pair differences can take a
long time, especially for large datasets and with many covariates. For other
methods (i.e., nearest neighbor, optimal, and genetic matching), computation
is fairly quick. Default is <code>FALSE</code> for subclassification and
<code>TRUE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>un</code></td>
<td>
<p><code>logical</code>; whether to compute balance statistics for the
unmatched sample. Default <code>TRUE</code>; set to <code>FALSE</code> for more concise
output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>improvement</code></td>
<td>
<p><code>logical</code>; whether to compute the percent reduction
in imbalance. Default <code>FALSE</code>. Ignored if <code>un = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subclass</code></td>
<td>
<p>after subclassification, whether to display balance for
individual subclasses, and, if so, for which ones. Can be <code>TRUE</code>
(display balance for all subclasses), <code>FALSE</code> (display balance only in
aggregate), or the indices (e.g., <code>1:6</code>) of the specific subclasses for
which to display balance. When anything other than <code>FALSE</code>, aggregate
balance statistics will not be displayed. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>summay.matchit</code> or <code>summary.matchit.subclass</code> object;
the output of a call to <code>summary()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>the number of digits to round balance statistics to.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>summary()</code> computes a balance summary of a <code>matchit</code> object. This
include balance before and after matching or subclassification, as well as
the percent improvement in balance. The variables for which balance
statistics are computed are those included in the <code>formula</code>,
<code>exact</code>, and <code>mahvars</code> arguments to <code>matchit()</code>, as well as the
distance measure if <code>distance</code> is was supplied as a numeric vector or
method of estimating propensity scores. The <code>X</code> component of the
<code>matchit</code> object is used to supply the covariates.
</p>
<p>The standardized mean differences are computed both before and after
matching or subclassification as the difference in treatment group means
divided by a standardization factor computed in the unmatched (original)
sample. The standardization factor depends on the argument supplied to
<code>estimand</code> in <code>matchit()</code>: for <code>"ATT"</code>, it is the standard
deviation in the treated group; for <code>"ATC"</code>, it is the standard
deviation in the control group; for <code>"ATE"</code>, it is the square root of
the average of the variances within each treatment group. The post-matching
mean difference is computed with weighted means in the treatment groups
using the matching or subclassification weights.
</p>
<p>The variance ratio is computed as the ratio of the treatment group
variances. Variance ratios are not computed for binary variables because
their variance is a function solely of their mean. After matching, weighted
variances are computed using the formula used in <code>cov.wt()</code>. The percent
reduction in bias is computed using the log of the variance ratios.
</p>
<p>The eCDF difference statistics are computed by creating a (weighted) eCDF
for each group and taking the difference between them for each covariate
value. The eCDF is a function that outputs the (weighted) proportion of
units with covariate values at or lower than the input value. The maximum
eCDF difference is the same thing as the Kolmogorov-Smirnov statistic. The
values are bounded at zero and one, with values closer to zero indicating
good overlap between the covariate distributions in the treated and control
groups. For binary variables, all eCDF differences are equal to the
(weighted) difference in proportion and are computed that way.
</p>
<p>The QQ difference statistics are computed by creating two samples of the
same size by interpolating the values of the larger one. The values are
arranged in order for each sample. The QQ difference for each quantile is
the difference between the observed covariate values at that quantile
between the two groups. The difference is on the scale of the original
covariate. Values close to zero indicate good overlap between the covariate
distributions in the treated and control groups. A weighted interpolation is
used for post-matching QQ differences. For binary variables, all QQ
differences are equal to the (weighted) difference in proportion and are
computed that way.
</p>
<p>The pair distance is the average of the absolute differences of a variable
between pairs. For example, if a treated unit was paired with four control
units, that set of units would contribute four absolute differences to the
average. Within a subclass, each combination of treated and control unit
forms a pair that contributes once to the average. The pair distance is
described in Stuart and Green (2008) and is the value that is minimized when
using optimal (full) matching. When <code>standardize = TRUE</code>, the
standardized versions of the variables are used, where the standardization
factor is as described above for the standardized mean differences. Pair
distances are not computed in the unmatched sample (because there are no
pairs). Because pair distance can take a while to compute, especially with
large datasets or for many covariates, setting <code>pair.dist = FALSE</code> is
one way to speed up <code>summary()</code>.
</p>
<p>The effective sample size (ESS) is a measure of the size of a hypothetical
unweighted sample with roughly the same precision as a weighted sample. When
non-uniform matching weights are computed (e.g., as a result of full
matching, matching with replacement, or subclassification), the ESS can be
used to quantify the potential precision remaining in the matched sample.
The ESS will always be less than or equal to the matched sample size,
reflecting the loss in precision due to using the weights. With non-uniform
weights, it is printed in the sample size table; otherwise, it is removed
because it does not contain additional information above the matched sample
size.
</p>
<p>After subclassification, the aggregate balance statistics are computed using
the subclassification weights rather than averaging across subclasses.
</p>
<p>All balance statistics (except pair differences) are computed incorporating
the sampling weights supplied to <code>matchit()</code>, if any. The unadjusted
balance statistics include the sampling weights and the adjusted balance
statistics use the matching weights multiplied by the sampling weights.
</p>
<p>When printing, <code>NA</code> values are replaced with periods (<code>.</code>), and
the pair distance column in the unmatched and percent balance improvement
components of the output are omitted.
</p>


<h3>Value</h3>

<p>For <code>matchit</code> objects, a <code>summary.matchit</code> object, which
is a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the original call to <code>matchit()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn</code></td>
<td>
<p>a matrix of the
sample sizes in the original (unmatched) and matched samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sum.all</code></td>
<td>
<p>if <code>un = TRUE</code>, a matrix of balance statistics for each
covariate in the original (unmatched) sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sum.matched</code></td>
<td>
<p>a matrix of
balance statistics for each covariate in the matched sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduction</code></td>
<td>
<p>if <code>improvement = TRUE</code>, a matrix of the percent
reduction in imbalance for each covariate in the matched sample</p>
</td>
</tr>
</table>
<p>For <code>match.subclass</code> objects, a <code>summary.matchit.subclass</code> object,
which is a list as above containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the original call to <code>matchit()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sum.all</code></td>
<td>
<p>if <code>un = TRUE</code>, a matrix of balance statistics for each covariate in the original
sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sum.subclass</code></td>
<td>
<p>if <code>subclass</code> is not <code>FALSE</code>, a list
of matrices of balance statistics for each subclass</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sum.across</code></td>
<td>
<p>a
matrix of balance statistics for each covariate computed using the
subclassification weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduction</code></td>
<td>
<p>if <code>improvement = TRUE</code>, a
matrix of the percent reduction in imbalance for each covariate in the
matched sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qn</code></td>
<td>
<p>a matrix of sample sizes within each subclass</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn</code></td>
<td>
<p>a matrix of the sample sizes in the original (unmatched) and
matched samples</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>summary()</code> for the generic method; <code>plot.summary.matchit()</code> for
making a Love plot from <code>summary()</code> output.
</p>
<p><code>cobalt::bal.tab.matchit()</code>, which also displays balance for <code>matchit</code>
objects.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data("lalonde")
m.out &lt;- matchit(treat ~ age + educ + married +
                   race + re74, data = lalonde,
                 method = "nearest", exact = ~ married,
                 replace = TRUE)
summary(m.out, interactions = TRUE)

s.out &lt;- matchit(treat ~ age + educ + married +
                   race + nodegree + re74 + re75,
                 data = lalonde, method = "subclass")
summary(s.out, addlvariables = ~log(age) + I(re74==0))
summary(s.out, subclass = TRUE)

</code></pre>


</div>