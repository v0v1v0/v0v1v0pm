<div class="container">

<table style="width: 100%;"><tr>
<td>mlr.bias.constructor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generating the treatment effect bias constructor vector
</h2>

<h3>Description</h3>

<p>Generaring the vector that, multiplied by <code>Z.o%*%gamma.o</code> (contribution of omitted covariates to outcome), produces the treatment effect bias - due to model misspecification in the form of covariate omission - when using linear regression for causal inference.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mlr.bias.constructor(tr, Z.i = NULL, details = FALSE, idx = 1:length(tr))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tr</code></td>
<td>
<p>Binary treatment indicator vector (1=treatment, 0=control), whose coefficient in the linear regression model is TE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.i</code></td>
<td>
<p>Matrix of adjustment covariates included in linear regression. We must have <code>nrow(Z.i) == length(tr)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p>Boolean flag, indicating whether intermediate objects used in generating the constrcutor vector must be returned or not. This only works if at least one adjustment covariate is included in the regression (<code>Z.i</code> is not <code>NULL</code>), and there are no repeated observations, i.e. <code>max(table(idx))==1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx</code></td>
<td>
<p>Index of observations to be used, with possible duplication, e.g. as indexes of matched subset.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of same length as <code>tr</code> is returned. If <code>details = TRUE</code> and <code>Z.i</code> is not <code>NULL</code>, then the following objects are attached as attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Vector of length <code>ncol(Z.i)</code>, reflecting the sum of each included covariate in treatment group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Vector of length <code>ncol(Z.i)</code>, reflecting the sum of each included covariate across both treatment and control groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u.i</code></td>
<td>
<p>Vector of length <code>ncol(Z.i)</code>, reflecting the mean difference between groups (control - treatment) for each included covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Weighted, within-group covariance matrix of included covariates. It is a square matrix of dimension <code>ncol(Z.i)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iA</code></td>
<td>
<p>Inverse of <code>A</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# number of included adjustment covariates
K &lt;- 10
# number of observations in treatment group
Nt &lt;- 100
# number of observations in control group
Nc &lt;- 100
N &lt;- Nt + Nc

# treatment indicator variable
tr &lt;- c(rep(1, Nt), rep(0, Nc))
# matrix of included (adjustment) covariates
Z.i &lt;- matrix(runif(K*N), ncol = K)

ret &lt;- mlr.bias.constructor(tr = tr, Z.i = Z.i)

# comparing with brute-force approach
X.i &lt;- cbind(tr, 1, Z.i)
ret2 &lt;- (solve(t(X.i) %*% X.i, t(X.i)))[1, ]

cat("check 1:", all.equal(ret2, ret), "\n")

# sampling with replacement
idx &lt;- sample(1:N, size = round(0.75*N), replace = TRUE)
ret3 &lt;- mlr.bias.constructor(tr = tr, Z.i = Z.i, idx = idx)
ret4 &lt;- (solve(t(X.i[idx, ]) %*% X.i[idx, ], t(X.i[idx, ])))[1, ]

cat("check 2:", all.equal(ret3, ret4), "\n")

</code></pre>


</div>