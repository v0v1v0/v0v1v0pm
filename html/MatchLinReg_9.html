<div class="container">

<table style="width: 100%;"><tr>
<td>mlr.orthogonalize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Orthogonalization of vectors with repsect to a matrix
</h2>

<h3>Description</h3>

<p>Decomposing a collection of vectors into parallel and orthogonal components with respect to the subspace spanned by columns of a reference matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mlr.orthogonalize(X, Z, normalize = FALSE, tolerance = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Matrix whose columns form the subspace, with respect to which we want to orthogonalize columns of <code>Z</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>Matrix whose columns we want to orthogonalize with respect to the subpsace spanned by columns of <code>X</code>. We must have <code>nrow(Z) == nrow(X)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>Boolean flag, indicating whether the orthogonal component of <code>Z</code> columns must be normalized so that their L2 norms equal <code>nrow(Z)</code> (mean squared is 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>If unnormalized projection of a column of <code>Z</code> has an L2 norm below <code>tolerance</code>, it will not be normalized (even if requested via <code>normalize</code>) and instead a zero vector will be returned.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Current implementation uses Singular Value Decomposition (<code>svd</code>) of <code>X</code> to form an orthonormal basis from columns of <code>X</code> to facilitate the projection process.
</p>


<h3>Value</h3>

<p>A matrix of same dimensions as <code>Z</code> is returned, with each column containing the orthogonal component of the corresponding column of <code>Z</code>. Parallel components are attached as <code>parallel</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
K &lt;- 10
N &lt;- 100
Ko &lt;- 5

X &lt;- matrix(runif(N*K), ncol = K)
Z &lt;- matrix(runif(N*Ko), ncol = Ko)

ret &lt;- mlr.orthogonalize(X = X, Z = Z, normalize = FALSE)

orthogonal &lt;- ret
parallel &lt;- attr(ret, "parallel")
Z.rec &lt;- parallel + orthogonal

# check that parallel and orthogonal components add up to Z
cat("check 1:", all.equal(as.numeric(Z.rec), as.numeric(Z)), "\n")
# check that inner product of orthogonal columns and X columns are zero
cat("check 2:", all.equal(t(orthogonal) %*% X, matrix(0, nrow = Ko, ncol = K)), "\n")

</code></pre>


</div>