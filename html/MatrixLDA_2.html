<div class="container">

<table style="width: 100%;"><tr>
<td>MatLDA_Grid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fits the <code class="reqn">J</code>-class penalized matrix-normal model for a two-dimensional grid of tuning parameters. Used for tuning parameter selection. </h2>

<h3>Description</h3>

<p>A function for fitting the penalized matrix normal model for a two-dimensional grid of tuning parameters. Meant to be used with a validation set to select tuning parameters. Can also be used inside a <code class="reqn">k</code>-fold cross-validation function where the training set is the data outside the <code class="reqn">k</code>th fold and the validation set is comprised of the <code class="reqn">k</code>th fold sample data. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">MatLDA_Grid(X, class, lambda1, lambda2, quiet = TRUE, Xval = NULL,
  classval = NULL, k.iter = 100, cov.tol = 1e-05, m.tol = 1e-05,
  full.tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An <code class="reqn">r \times c \times N</code> array of training set predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class</code></td>
<td>
<p><code class="reqn">N</code>-vector of training set class labels; should be numeric from <code class="reqn">\left\{1,...,J\right\}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p>A vector of non-negative candidate tuning parameters for the mean penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>
<p>A vector of non-negative candidate tuning parameters for the Kronecker penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>Logical. Should the objective function value be printed at each update? Default is <code>TRUE</code>. Note that <code>quiet=FALSE</code> will increase computational time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xval</code></td>
<td>
<p>An <code class="reqn">r \times c \times N_{\rm val}</code> array of validation set predictors. Default is <code>NULL</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classval</code></td>
<td>
<p><code class="reqn">N_{\rm val}</code>-vector of validation set class labels; should be numeric from <code class="reqn">\left\{1,...,J\right\}</code>.Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.iter</code></td>
<td>
<p>Maximum number of iterations for full blockwise coordinate descent algorithm. Default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.tol</code></td>
<td>
<p>Convergence tolerance for graphical lasso subalgorithms; passed to <code>glasso</code>. Default is <code class="reqn">1e^{-5}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.tol</code></td>
<td>
<p>Convergence tolerance for mean update alternating minimization algorithm. Default is <code class="reqn">1e^{-5}</code>. It is recommended to track the objective function value using <code>quiet = FALSE</code> and adjust tolerance if necessary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full.tol</code></td>
<td>
<p>Convergence tolerance for full blockwise coordinate descent algorithm; based on decrease in objective function value. Default is <code class="reqn">1e^{-6}</code>. It is recommended to track the objective function value using <code>quiet = FALSE</code> and adjust tolerance if necessary. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Val.mat</code></td>
<td>
<p>A matrix of dimension <code>length</code>(lambda1) <code class="reqn">\times</code><code>length</code>(lambda2) with validation set misclassification propotions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G.mat</code></td>
<td>
<p>A matrix of dimension <code>length</code>(lambda1) <code class="reqn">\times</code><code>length</code>(lambda2) with the number of pairwise mean differences that are zero, i.e., a larger entry corresponds to a more sparse model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U.mat</code></td>
<td>
<p>A matrix of dimension <code>length</code>(lambda1) <code class="reqn">\times</code><code>length</code>(lambda2) with the number of zeros in <code class="reqn">\hat{U}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V.mat</code></td>
<td>
<p>A matrix of dimension <code>length</code>(lambda1) <code class="reqn">\times</code><code>length</code>(lambda2) with the number of zeros in <code class="reqn">\hat{V}</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>


<ul><li>
<p> Molstad, A. J., and Rothman, A. J. (2018). A penalized likelihood method for classification with matrix-valued predictors. <em>Journal of Computational and Graphical Statistics</em>.
</p>
</li></ul>
<h3>Examples</h3>

<pre><code class="language-R">
## Generate realizations of matrix-normal random variables
## set sample size, dimensionality, number of classes, 
## and marginal class probabilities

N = 75
N.test = 150
N.val = 75

N.total = N + N.test + N.val

r = 16
p = 16
C = 3

pi.list = rep(1/C, C)

## create class means
M.array = array(0, dim=c(r, p, C))
M.array[3:4, 3:4, 1] = 1
M.array[5:6, 5:6, 2] = .5
M.array[3:4, 3:4, 3] = -2
M.array[5:6, 5:6, 3] = -.5


## create covariance matrices U and V
Uinv = matrix(0, nrow=r, ncol=r)
for (i in 1:r) {
	for (j in 1:r) {
		Uinv[i,j] = .5^abs(i-j)
	}
}

eoU = eigen(Uinv)
Uinv.sqrt = tcrossprod(tcrossprod(eoU$vec, 
diag(eoU$val^(1/2))),eoU$vec)

Vinv = matrix(.5, nrow=p, ncol=p)
diag(Vinv) = 1 
eoV = eigen(Vinv)
Vinv.sqrt = tcrossprod(tcrossprod(eoV$vec, 
diag(eoV$val^(1/2))),eoV$vec)

## generate N.total realizations of matrix-variate normal data
set.seed(10)
dat.array = array(0, dim=c(r,p,N.total))
class.total = numeric(length=N.total)
for(jj in 1:N.total){
	class.total[jj] = sample(1:C, 1, prob=pi.list)
	dat.array[,,jj] = tcrossprod(crossprod(Uinv.sqrt, 
	matrix(rnorm(r*p), nrow=r)),
	Vinv.sqrt) + M.array[,,class.total[jj]]
}

## store generated data 
X = dat.array[,,1:N]
X.val = dat.array[,,(N+1):(N+N.val)]
X.test = dat.array[,,(N+N.val+1):N.total]

class = class.total[1:N]
class.val = class.total[(N+1):(N+N.val)]
class.test = class.total[(N+N.val+1):N.total]

## fit two-dimensional grid of tuning parameters; 
## measure classification accuracy on validation set
lambda1 = c(2^seq(-5, 0, by=1))
lambda2 = c(2^seq(-8, -4, by=1))
fit.grid = MatLDA_Grid(X=X, class=class, lambda1=lambda1, 
	lambda2=lambda2, quiet=TRUE,
	Xval=X.val, classval= class.val,
	k.iter = 100, cov.tol=1e-5, m.tol=1e-5, full.tol=1e-6)

## identify minimum misclassification proportion; 
## select tuning parameters corresponding to 
## smallest model at minimum misclassification proportion
CV.mat = fit.grid$Val.mat
G.mat = fit.grid$G.mat*(CV.mat==min(CV.mat))
ind1 = (which(G.mat==max(G.mat), arr.ind=TRUE))[,2]
ind2 = (which(G.mat==max(G.mat), arr.ind=TRUE))[,1]
out = unique(ind2[which(ind2==max(ind2))])
lambda1.cv = lambda1[out]
out2 = unique(max(ind1[ind2==out]))
lambda2.cv = lambda2[out2]

## refit model with sinlge tuning parameter pair
out = MatLDA(X=X, class=class, lambda1=lambda1.cv, 
	lambda2=lambda2.cv, quiet=FALSE,
	Xval=X.test, classval= class.test,
	k.iter = 100, cov.tol=1e-5, m.tol=1e-5, full.tol=1e-6)

## print misclassification proportion on test set 
out$Val

## print images of estimated mean differences
dev.new(width=10, height=3)
par(mfrow=c(1,3))
image(t(abs(out$M[,,1] - out$M[,,2]))[,r:1], 
main=expression(paste("|", hat(mu)[1], "-", hat(mu)[2], "|")), 
col = grey(seq(1, 0, length = 100)))
image(t(abs(out$M[,,1] - out$M[,,3]))[,r:1], 
main=expression(paste("|", hat(mu)[1], "-", hat(mu)[3], "|")), 
col = grey(seq(1, 0, length = 100)))
image(t(abs(out$M[,,2] - out$M[,,3]))[,r:1], 
main=expression(paste("|", hat(mu)[2], "-", hat(mu)[3], "|")), 
col = grey(seq(1, 0, length = 100)))

</code></pre>


</div>