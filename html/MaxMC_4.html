<div class="container">

<table style="width: 100%;"><tr>
<td>mmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find the Maximized Monte Carlo (MMC) p-value on a set of nuisance
parameters.</h2>

<h3>Description</h3>

<p>The <code>dgp</code> function defined by the user is used to
generate new observations in order to compute the simulated
statistics.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mmc(
  y,
  statistic,
  ...,
  dgp = function(y, v) sample(y, replace = TRUE),
  est = NULL,
  lower,
  upper,
  N = 99,
  type = c("geq", "leq", "absolute", "two-tailed"),
  method = c("GenSA", "pso", "GA", "gridSearch"),
  control = list(),
  alpha = NULL,
  monitor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A vector or data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>A function or a character string that specifies
how the statistic is computed. The function needs to input the
<code>y</code> and output a scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other named arguments for statistic which are
passed unchanged each time it is called</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dgp</code></td>
<td>
<p>A function. The function inputs the first argument
<code>y</code> and a vector of nuisance parameters <code>v</code> and outputs a simulated <code>y</code>.
It should represent the data generating process under the null.
Default value is the function <code>sample(y, replace = TRUE)</code>, i.e. the
bootstrap resampling of <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est</code></td>
<td>
<p>A vector with length of v. It is the starting
point of the algorithm. If <code>est</code> is a consistent estimate
of <code>v</code> then <code>mmc</code> will return both the MMC and Local Monte Carlo (LMC).
Default is NULL, in which case, default values will be generated automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>A vector with length of v. Lower bounds for
nuisance parameters under the null. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>A vector with length of v. Upper bounds for
nuisance parameters under the null. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>An atomic vector. Number of replications of the test
statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A character string. It specifies the type of test
the p-value function produces. The possible values are
<code>geq</code>, <code>leq</code>, <code>absolute</code> and <code>two-tailed</code>.
Default is <code>geq</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A character string. Type of algorithm to be
used for global optimization. The four available methods
are simulated annealing (<code>GenSA</code>), particle swarm (<code>psoptim</code>),
genetic algorithm (<code>GA</code>), and grid search (<code>gridSearch</code>)
Default is <code>GenSA</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list. Arguments to be used to control the
behavior of the algorithm chosen in <code>method</code>. See controls section for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>An atomic vector. If <code>mmc</code> finds a
p-value over <code>alpha</code>, then the algorithm will stop. This is particularly
useful if we are only looking at testing a hypothesis at a particular level.
Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monitor</code></td>
<td>
<p>A logical. If set to TRUE, then the p-values at every
iteration and the cumulative maximum p-value are plotted on a graphical device.
Default is FALSE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Then <code>pvalue</code> is applied to the statistic and
its simulated values.<code>pvalue</code> computes the
p-value by ranking the statistic compared to its simulated
values. Ties in the ranking are broken according to a
uniform distribution.
</p>
<p>We allow for four types of p-value: <code>leq</code>, <code>geq</code>,
<code>absolute</code> and <code>two-tailed</code>. For one-tailed test,
<code>leq</code> returns the proportion of simulated values smaller
than the statistic while <code>geq</code> returns the proportion of
simulated values greater than the statistic. For two-tailed
test with a symmetric statistic, one can use the
absolute value of the statistic and its simulated values to
retrieve a two-tailed test (i.e. type = <code>absolute</code>).
If the statistic is not symmetric, one can specify the p-value
type as <code>two-tailed</code> which is equivalent to twice the minimum
of <code>leq</code> and <code>geq</code>.
</p>
<p>Ties in the ranking are broken according to a uniform
distribution.
</p>
<p>Usually, to ensure that the MMC procedure is exact, <code>lower</code> and
<code>upper</code> must be set such that any theoretically possible
values for the nuisance parameters under the null are covered. This
can be computationally expansive.
</p>
<p>Alternatively, the consistent set estimate MMC method (CSEMMC)
which is applicable when a consistent set estimator of the nuisance
parameters is available can be used. If such set is available, by setting
<code>lower</code> and <code>upper</code> accordingly, <code>mmc</code> will yield
an asymptotically justified version of the MMC procedure.
</p>
<p>One version of this procedure is the Two-stage constrained maximized
Monte Carlo test, where first a confidence set of level
<code class="reqn">1-\alpha_1</code> for the nuisance parameters is obtained and then the MMC with
confidence level <code class="reqn">\alpha_2</code> is taken over this particular set.
This procedure yields a conservative test with level
<code class="reqn">\alpha=\alpha_1+\alpha_2</code>. Note that we generally advise
against using asymptotic Wald-type confidence intervals based on
their poor performance. Instead, it is simply best to build
confidence set using problem-specific tools.
</p>


<h3>Value</h3>

<p>The returned value is an object of class <code>mmc</code>
containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>S0</code></td>
<td>
<p>Observed value of <code>statistic</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval</code></td>
<td>
<p>Maximized Monte Carlo p-value of <code>statistic</code> under null.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Data specified in call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p><code>statistic</code> function specified in
call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dgp</code></td>
<td>
<p><code>dgp</code> function specified in call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est</code></td>
<td>
<p><code>est</code> vector if specified in call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p><code>lower</code> vector if specified in call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p><code>upper</code> vector if specified in call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Number of replications specified in call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p><code>type</code> of p-value specified in call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p><code>method</code> specified in call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>Original call to <code>mmc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Value of <code>.Random.seed</code> at the start of
<code>mmc</code> call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lmc</code></td>
<td>
<p>If <code>par</code> is specified, it returns an
object of class <code>mc</code> corresponding to the Local Monte
Carlo test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt_result</code></td>
<td>
<p>An object returning the optimization
results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rejection</code></td>
<td>
<p>If <code>alpha</code> is specified, it returns
a vector specifying whether the hypothesis was rejected at level <code>alpha</code>.</p>
</td>
</tr>
</table>
<h3>Controls</h3>



<h4>Controls - <code>GenSA</code>
</h4>


<dl>
<dt>maxit</dt>
<dd>
<p>Integer. Maximum number of iterations of
the algorithm. Defaults to
1000.</p>
</dd>
<dt>nb.stop.improvement</dt>
<dd>
<p>Integer. The program will
stop when there is no any improvement in
nb.stop.improvement steps. Defaults to 25</p>
</dd>
<dt>smooth</dt>
<dd>
<p>Logical.TRUE when the objective function
is smooth, or differentiable almost everywhere in the
region of par, FALSE otherwise. Default value is TRUE.</p>
</dd>
<dt>max.call</dt>
<dd>
<p>Integer. Maximum number of call of the
objective function. Default is set to 1e7.</p>
</dd>
<dt>max.time</dt>
<dd>
<p>Numeric. Maximum running time in seconds.</p>
</dd>
<dt>temperature</dt>
<dd>
<p>Numeric. Initial value for temperature.</p>
</dd>
<dt>visiting.param</dt>
<dd>
<p>Numeric. Parameter for visiting
distribution.</p>
</dd>
<dt>acceptance.param</dt>
<dd>
<p>Numeric. Parameter for acceptance
distribution.</p>
</dd>
<dt>simple.function</dt>
<dd>
<p>Logical. FALSE means that the
objective function has only a few local minima. Default
is FALSE which means that the objective function is
complicated with many local minima.</p>
</dd>
</dl>
<h4>Controls - <code>psoptim</code>
</h4>


<dl>
<dt>maxit</dt>
<dd>
<p>The maximum number of iterations. Defaults to
1000.</p>
</dd>
<dt>maxf</dt>
<dd>
<p>The maximum number of function evaluations
(not considering any performed during numerical gradient
computation). Defaults to Inf.</p>
</dd>
<dt>reltol</dt>
<dd>
<p>The tolerance for restarting. Once the
maximal distance between the best particle and all other
particles is less than reltol*d the algorithm restarts.
Defaults to 0 which disables the check for restarting.</p>
</dd>
<dt>s</dt>
<dd>
<p>The swarm size. Defaults to
floor(10+2*sqrt(length(par))) unless type is "SPSO2011"
in which case the default is 40.</p>
</dd>
<dt>k</dt>
<dd>
<p>The exponent for calculating number of informants.
Defaults to 3.</p>
</dd>
<dt>p</dt>
<dd>
<p>The average percentage of informants for each
particle. A value of 1 implies that all particles are
fully informed. Defaults to 1-(1-1/s)^k.</p>
</dd>
<dt>w</dt>
<dd>
<p>The exploitation constant. A vector of length 1
or 2. If the length is two, the actual constant used is
gradially changed from w[1] to w[2] as the number of
iterations or function evaluations approach the limit
provided. Defaults to 1/(2*log(2)).</p>
</dd>
<dt>c.p</dt>
<dd>
<p>The local exploration constant. Defaults to
.5+log(2).</p>
</dd>
<dt>c.g</dt>
<dd>
<p>The global exploration constant. Defaults to
.5+log(2).</p>
</dd>
<dt>d</dt>
<dd>
<p>The diameter of the search space. Defaults to the
euclidean distance between upper and lower.</p>
</dd>
<dt>v.max</dt>
<dd>
<p>The maximal (euclidean) length of the velocity
vector. Defaults to NA which disables clamping of the
velocity. However, if specified the actual clamping of the
length is v.max*d.</p>
</dd>
<dt>rand.order</dt>
<dd>
<p>Logical; if TRUE the particles are
processed in random order. If vectorize is TRUE then the
value of rand.order does not matter. Defaults to TRUE.</p>
</dd>
<dt>max.restart</dt>
<dd>
<p>The maximum number of restarts.
Defaults to Inf.</p>
</dd>
<dt>maxit.stagnate</dt>
<dd>
<p>The maximum number of iterations
without improvement. Defaults to 25</p>
</dd>
<dt>vectorize</dt>
<dd>
<p>Logical; if TRUE the particles are
processed in a vectorized manner. This reduces the
overhead associated with iterating over each particle and
may be more time efficient for cheap function evaluations.
Defaults to TRUE.</p>
</dd>
<dt>type</dt>
<dd>
<p>Character vector which describes which
reference implementation of SPSO is followed. Can take
the value of "SPSO2007" or "SPSO2011". Defaults to
"SPSO2007".</p>
</dd>
</dl>
<h4>Controls - <code>GA</code>
</h4>


<dl>
<dt>popSize</dt>
<dd>
<p>the population size.</p>
</dd>
<dt>pcrossover</dt>
<dd>
<p>the probability of crossover between
pairs of chromosomes. Typically this is a large value and
by default is set to 0.8.</p>
</dd>
<dt>pmutation</dt>
<dd>
<p>the probability of mutation in a parent
chromosome. Usually mutation occurs with a small
probability, and by default is set to 0.1.</p>
</dd>
<dt>updatePop</dt>
<dd>
<p>a logical defaulting to FALSE. If set at
TRUE the first attribute attached to the value returned by
the user-defined fitness function is used to update the
population. Be careful though, this is an experimental
feature!</p>
</dd>
<dt>postFitness</dt>
<dd>
<p>a user-defined function which, if
provided, receives the current ga-class object as input,
performs post fitness-evaluation steps, then returns an
updated version of the object which is used to update the
GA search. Be careful though, this is an experimental
feature!</p>
</dd>
<dt>maxiter</dt>
<dd>
<p>the maximum number of iterations to run
before the GA search is halted.</p>
</dd>
<dt>run</dt>
<dd>
<p>the number of consecutive generations without
any improvement in the best fitness value before the GA
is stopped.</p>
</dd>
<dt>optim</dt>
<dd>
<p>a logical defaulting to FALSE determining
whether or not a local search using general-purpose
optimisation algorithms should be used. See argument
optimArgs for further details and finer control.</p>
</dd>
<dt>optimArgs</dt>
<dd>
<p>a list controlling the local search
algorithm with the following components:
</p>

<dl>
<dt>method</dt>
<dd>
<p>a string specifying the general-purpose
optimisation method to be used, by default is set to
"L-BFGS-B". Other possible methods are those reported
in <code>optim</code>.</p>
</dd>
<dt>poptim</dt>
<dd>
<p>a value in the range [0,1] specifying the
probability of performing a local search at each
iteration of GA (default 0.1).</p>
</dd>
<dt>pressel</dt>
<dd>
<p>a value in the range [0,1] specifying the
pressure selection (default 0.5). The local search is
started from a random solution selected with probability
proportional to fitness. High values of pressel tend to
select the solutions with the largest fitness, whereas
low values of pressel assign quasi-uniform probabilities
to any solution.</p>
</dd>
<dt>control</dt>
<dd>
<p>a list of control parameters. See 'Details'
section in <code>optim</code>.</p>
</dd>
</dl>
</dd>
<dt>keepBest</dt>
<dd>
<p>a logical argument specifying if best
solutions at each iteration should be saved in a slot
called bestSol. See ga-class.</p>
</dd>
<dt>parallel</dt>
<dd>
<p>a logical argument specifying if parallel
computing should be used (TRUE) or not (FALSE, default)
for evaluating the fitness function. This argument could
also be used to specify the number of cores to employ; by
default, this is taken from detectCores. Finally, the
functionality of parallelization depends on system OS:
on Windows only 'snow' type functionality is available,
while on Unix/Linux/Mac OSX both 'snow' and 'multicore'
(default) functionalities are available.</p>
</dd>
</dl>
<h4>Controls - <code>gridSearch</code>
</h4>


<dl>
<dt>n</dt>
<dd>
<p>the number of levels. Default is 10.</p>
</dd>
<dt>printDetail</dt>
<dd>
<p>print information on the number of
objective function evaluations</p>
</dd>
<dt>method</dt>
<dd>
<p>can be loop (the default), multicore or
snow. See Details.</p>
</dd>
<dt>mc.control</dt>
<dd>
<p>a list containing settings that will be
passed to mclapply if method is multicore. Must be a list
of named elements; see the documentation of mclapply in
parallel.</p>
</dd>
<dt>cl</dt>
<dd>
<p>default is NULL. If method snow is used, this
must be a cluster object or an integer (the number of
cores).</p>
</dd>
<dt>keepNames</dt>
<dd>
<p>logical: should the names of levels be
kept?</p>
</dd>
<dt>asList</dt>
<dd>
<p>does fun expect a list? Default is FALSE</p>
</dd>
</dl>
<h3>References</h3>

<p>Dufour, J.-M. (2006), Monte Carlo Tests with nuisance parameters:
A general approach to finite sample inference and nonstandard asymptotics in econometrics.
<em>Journal of Econometrics</em>, <b>133(2)</b>, 443-447.
</p>
<p>Dufour, J.-M. and Khalaf L. (2003), Monte Carlo Test Methods in Econometrics.
in Badi H. Baltagi, ed., <em>A Companion to Theoretical Econometrics</em>, Blackwell Publishing Ltd, 494-519.
</p>
<p>Y. Xiang, S. Gubian. B. Suomela, J. Hoeng (2013). Generalized Simulated Annealing for
Efficient Global Optimization: the GenSA Package for R. <em>The R Journal</em>, Volume
<b>5/1</b>, June 2013.
URL <a href="https://journal.r-project.org/">https://journal.r-project.org/</a>.
</p>
<p>Claus Bendtsen. (2012). pso: Particle Swarm Optimization. R package version 1.0.3.
<a href="https://CRAN.R-project.org/package=pso">https://CRAN.R-project.org/package=pso</a>
</p>
<p>Luca Scrucca (2013). GA: A Package for Genetic Algorithms in R. <em>Journal of
Statistical
Software</em>, <b>53(4)</b>, 1-37. URL <a href="https://www.jstatsoft.org/article/view/v053i04">https://www.jstatsoft.org/article/view/v053i04</a>.
</p>
<p>Luca Scrucca (2016). On some extensions to GA package: hybrid optimisation,
parallelisation and islands evolution. Submitted to <em>R Journal</em>. Pre-print available at
arXiv URL <a href="http://arxiv.org/abs/1605.01931">http://arxiv.org/abs/1605.01931</a>.
</p>
<p>Manfred Gilli (2011), Dietmar Maringer and Enrico Schumann. Numerical Methods and
Optimization
in Finance. <em>Academic Press</em>.
</p>


<h3>See Also</h3>

<p><code>mc</code>, <code>pvalue</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example 1
## Exact Unit Root Test
library(fUnitRoots)

# Set seed
set.seed(123)

# Generate an AR(2) process with phi = (-1.5,0.5), and n = 25
y &lt;- filter(rnorm(25), c(-1.5, 0.5), method = "recursive")

# Set bounds for the nuisance parameter v
lower &lt;- -1
upper &lt;- 1

# Set the function to generate an AR(2) integrated process
dgp &lt;- function(y, v) {
    ran.y &lt;- filter(rnorm(length(y)), c(1-v,v), method = "recursive")
}

# Set the Augmented-Dicky Fuller statistic
statistic &lt;- function(y){
    out &lt;- suppressWarnings(adfTest(y, lags = 2, type = "nc"))
    return(out@test$statistic)
}

# Apply the mmc procedure
mmc(y, statistic = statistic , dgp = dgp, lower = lower,
    upper = upper, N = 99, type = "leq", method = "GenSA",
    control = list(max.time = 2))


## Example 2
## Behrens-Fisher Problem
library(MASS)

# Set seed
set.seed(123)

# Generate sample x1 ~ N(0,1) and x2 ~ N(0,4)
x1 &lt;- rnorm(15, mean = 0, sd = 1)
x2 &lt;- rnorm(25, mean = 0, sd = 2)
data &lt;- list(x1 = x1, x2 = x2)

# Fit a normal distribution on x1 and x2 using maximum likelihood
fit1 &lt;- fitdistr(x1, "normal")
fit2 &lt;- fitdistr(x2, "normal")

# Extract the estimate for the nuisance parameters v = (sd_1, sd_2)
est &lt;- c(fit1$estimate["sd"], fit2$estimate["sd"])

# Set the bounds of the nuisance parameters equal to the 99% CI
lower &lt;- est - 2.577 * c(fit2$sd["sd"], fit1$sd["sd"])
upper &lt;- est + 2.577 * c(fit2$sd["sd"], fit1$sd["sd"])

# Set the function for the DGP under the null (i.e. two population means are equal)
dgp &lt;- function(data, v) {
    x1 &lt;- rnorm(length(data$x1), mean = 0, sd = v[1])
    x2 &lt;- rnorm(length(data$x2), mean = 0, sd = v[2])
    return(list(x1 = x1, x2 = x2))
}

# Set the statistic function to Welch's t-test
welch &lt;- function(data) {
    test &lt;- t.test(data$x2, data$x1)
    return(test$statistic)
}

# Apply Welch's t-test
t.test(data$x2, data$x1)

# Apply the mmc procedure
mmc(y = data, statistic = welch, dgp = dgp, est = est,
    lower = lower, upper = upper, N = 99,	type = "absolute",
    method = "pso")

</code></pre>


</div>