<div class="container">

<table style="width: 100%;"><tr>
<td>parseDatetime</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parse datetime strings</h2>

<h3>Description</h3>

<p>Transforms numeric and string representations of Ymd[HMS] datetimes to
<code>POSIXct</code> format.
</p>
<p>Y, Ym, Ymd, YmdH, YmdHM, and YmdHMS formats are understood, where:
</p>

<dl>
<dt>Y</dt>
<dd>
<p>four digit year</p>
</dd>
<dt>m</dt>
<dd>
<p>month number (1-12, 01-12) or english name month (October, oct.)</p>
</dd>
<dt>d</dt>
<dd>
<p>day number of the month (0-31 or 01-31)</p>
</dd>
<dt>H</dt>
<dd>
<p>hour number (0-24 or 00-24)</p>
</dd>
<dt>M</dt>
<dd>
<p>minute number (0-59 or 00-59)</p>
</dd>
<dt>S</dt>
<dd>
<p>second number (0-61 or 00-61)</p>
</dd>
</dl>
<p>This allows for mixed inputs. For example, 20181012130900,
"2018-10-12-13-09-00", and "2018 Oct. 12 13:09:00" will all be converted to
the same <code>POSIXct</code> datetime. The incoming datetime vector does not need
to have a homogeneous format either â€“ "20181012" and "2018-10-12 13:09" can
exist in the same vector without issue. All incoming datetimes will be
interpreted in the specified timezone.
</p>
<p>If <code>datetime</code> is a <code>POSIXct</code> it will be returned unmodified, and
formats not recognized will be returned as <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">parseDatetime(
  datetime = NULL,
  timezone = NULL,
  expectAll = FALSE,
  isJulian = FALSE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>datetime</code></td>
<td>
<p>Vector of character or integer datetimes in Ymd[HMS] format
(or POSIXct).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timezone</code></td>
<td>
<p>Olson timezone used to interpret dates (required).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expectAll</code></td>
<td>
<p>Logical value determining if the function should fail if
any elements fail to parse (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isJulian</code></td>
<td>
<p>Logical value determining whether <code>datetime</code> should be
interpreted as a Julian date with day of year as a decimal number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>Logical value passed on to <code>lubridate::parse_date_time</code> to
optionally suppress warning messages.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of POSIXct datetimes.
</p>


<h3>Mazama Science Conventions</h3>

<p>Within Mazama Science package, datetimes not in <code>POSIXct</code> format are
often represented as decimal values with no separation (ex: 20181012,
20181012130900), either as numerics or strings.
</p>


<h3>Implementation</h3>

<p><code>parseDatetime</code> is essentially a wrapper around
<code>parse_date_time</code>, handling which formats we want to
account for.
</p>


<h3>Note</h3>

<p>If <code>datetime</code> is a character string containing signed offset
information, <em>e.g.</em> "-07:00", this information is used to generate an
equivalent UTC time which is then assigned to the timezone specified by
the <code>timezone</code> argument.
</p>


<h3>See Also</h3>

<p><code>parse_date_time</code> for implementation details.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(MazamaCoreUtils)

# All y[md-hms] formats are accepted
parseDatetime(2018, timezone = "America/Los_Angeles")
parseDatetime(201808, timezone = "America/Los_Angeles")
parseDatetime(20180807, timezone = "America/Los_Angeles")
parseDatetime(2018080718, timezone = "America/Los_Angeles")
parseDatetime(201808071812, timezone = "America/Los_Angeles")
parseDatetime(20180807181215, timezone = "America/Los_Angeles")
parseDatetime("2018-08-07 18:12:15", timezone = "America/Los_Angeles")
parseDatetime("2018-08-07 18:12:15-07:00", timezone = "America/Los_Angeles")
parseDatetime("2018-08-07 18:12:15-07:00", timezone = "UTC")

# Julian days are accepeted
parseDatetime(2018219181215, timezone = "America/Los_Angeles",
              isJulian = TRUE)

# Vector dates are accepted and daylight savings is respected
parseDatetime(
  c("2018-10-24 12:00", "2018-10-31 12:00",
    "2018-11-07 12:00", "2018-11-08 12:00"),
  timezone = "America/New_York"
)

badInput &lt;- c("20181013", NA, "20181015", "181016", "10172018")

# Return a vector with \code{NA} for dates that could not be parsed
parseDatetime(badInput, timezone = "UTC", expectAll = FALSE)

## Not run: 
# Fail if any dates cannot be parsed
parseDatetime(badInput, timezone = "UTC", expectAll = TRUE)

## End(Not run)

</code></pre>


</div>