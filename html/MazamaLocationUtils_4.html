<div class="container">

<table style="width: 100%;"><tr>
<td>clusterByDistance</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add distance-clustering information to a dataframe</h2>

<h3>Description</h3>

<p>Distance clustering is used to identify unique deployments of a
sensor in an environmental monitoring field study. GPS-reported locations can
be jittery and result in a sensor self-reporting from a cluster of nearby locations.
Clustering helps resolve this by assigning a single location to the cluster.
</p>
<p>Standard <code>kmeans</code> clustering does not work well when clusters can have
widely differing numbers of members. A much better result is acheived with
the Partitioning Around Medoids method available in <code>cluster::pam()</code>.
</p>
<p>The value of <code>clusterDiameter</code> is compared with the output of
<code>cluster::pam(...)$clusinfo[,'av_diss']</code> to determine the number of clusters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">clusterByDistance(
  tbl,
  clusterDiameter = 1000,
  lonVar = "longitude",
  latVar = "latitude",
  maxClusters = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tbl</code></td>
<td>
<p>Tibble with geolocation information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterDiameter</code></td>
<td>
<p>Diameter in meters used to determine the number of
clusters (see description).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lonVar</code></td>
<td>
<p>Name of longitude variable in the incoming tibble.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>latVar</code></td>
<td>
<p>Name of the latitude variable in the incoming tibble.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxClusters</code></td>
<td>
<p>Maximum number of clusters to try.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Input tibble with additional columns: <code>clusterLon, clusterLat, clusterID</code>.
</p>


<h3>Note</h3>

<p>In most applications, the table_addClustering function should be
used as it implements two-stage clustering using <code>clusterbyDistance()</code>.
</p>


<h3>References</h3>

<p><a href="https://working-with-data.mazamascience.com/2021/07/15/when-k-means-clustering-fails/">When k-means clustering fails</a>
</p>


<h3>See Also</h3>

<p>table_removeRecord
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(MazamaLocationUtils)

# Fremont, Seattle 47.6504, -122.3509
# Magnolia, Seattle 47.6403, -122.3997
# Downtown Seattle 47.6055, -122.3370

fremont_x &lt;- jitter(rep(-122.3509, 10), .0005)
fremont_y &lt;- jitter(rep(47.6504, 10), .0005)

magnolia_x &lt;- jitter(rep(-122.3997, 8), .0005)
magnolia_y &lt;- jitter(rep(47.6403, 8), .0005)

downtown_x &lt;- jitter(rep(-122.3370, 3), .0005)
downtown_y &lt;- jitter(rep(47.6055, 3), .0005)

# Apply clustering
tbl &lt;-
  dplyr::tibble(
    longitude = c(fremont_x, magnolia_x, downtown_x),
    latitude = c(fremont_y, magnolia_y, downtown_y)
  ) %&gt;%
  clusterByDistance(
    clusterDiameter = 1000
  )

plot(tbl$longitude, tbl$latitude, pch = tbl$clusterID)
</code></pre>


</div>