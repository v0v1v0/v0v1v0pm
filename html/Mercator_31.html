<div class="container">

<table style="width: 100%;"><tr>
<td>setClusters</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Changing Cluster and Color Assignments in Mercator
</h2>

<h3>Description</h3>

<p>Cluster assignments from unsupervised analyses typically assign
arbitrary integers to the classes. When comparing the results of
different algorithms or different distance metrics, it is helpful to
match the integers in order to use colors and symbols that are as
consistent as possible. These functions help achieve that goal.
</p>


<h3>Usage</h3>

<pre><code class="language-R">setClusters(DV, clusters)
recolor(DV, clusters)
remapColors(fix, vary)
recluster(DV, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>DV</code></td>
<td>
<p>An object of the <code>Mercator</code> class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusters</code></td>
<td>
<p>An integer vector specifiny the cluster membership of
each element.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix</code></td>
<td>
<p>An object of the <code>Mercator</code> class, used as the source
of color and cluster assignments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vary</code></td>
<td>
<p>An object of the <code>Mercator</code> class, used as the target
of color and cluster assignments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>An integer, the number of clusters.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the most general sense, clustering can be viewed as a function from
the space of "objects" of interest into a space of "class labels".  In
less mathematical terms, this simply means that each object gets
assigned an (arbitrary) class label. This is all well-and-good until
you try to compare the results of running two different clustering
algorithms that use different labels (or even worse, use the same
labels – typically the integers <code class="reqn">1, 2, \dots, K</code> – with
different meanings).  When that happens, you need a way to decide
which labels from the different sets are closest to meaning the
"same thing".
</p>
<p>The functions <code>setClusters</code> and <code>remapColors</code> solve this problem
in the context of <code>Mercator</code> objects. They accaomplish this task
using the greedy algorithm implemented and described in the
<code>remap</code> function in the <code>Thresher</code> package.
</p>


<h3>Value</h3>

<p>Both <code>setClusters</code> and <code>remapColors</code> return an object of class
<code>Mercator</code> in which only the cluster labels and associated color
and symbol representations (but not the distance metric used, the number
of clusters, the cluster assignments, nor the views) have been updated.
</p>
<p>The <code>recolor</code> function is currently an alias for
<code>setClusters</code>. However, using <code>recolor</code> is deprecated, and the
alias will likely be removed in the next version of the package.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

 <p><code>remap</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">#Form a BinaryMatrix
data("iris")
my.data &lt;- t(as.matrix(iris[,c(1:4)]))
colnames(my.data) &lt;- 1:ncol(my.data)
my.binmat &lt;- BinaryMatrix(my.data)

# Form a Mercator object; Set K to the number of known species
my.vis &lt;- Mercator(my.binmat, "euclid", "tsne", K=3)
table(getClusters(my.vis), iris$Species)
summary(my.vis)

# Recolor the Mercator object with known species
DS &lt;- recolor(my.vis, as.numeric(iris$Species))
table(getClusters(DS), iris$Species)

# Use a different metric
my.vis2 &lt;- Mercator(my.binmat, "manhattan", "tsne", K=3)
table(getClusters(my.vis2), iris$Species)
table(Pearson = getClusters(my.vis2), Euclid = getClusters(my.vis))

# remap colors so the two methods match as well as possible
my.vis2 &lt;- remapColors(my.vis, my.vis2)
table(Pearson = getClusters(my.vis2), Euclid = getClusters(my.vis))

# recluster with K=4
my.vis3 &lt;- recluster(my.vis, K = 4)

# view the results
opar &lt;- par(mfrow=c(1,2))
plot(my.vis, view = "tsne", main="t-SNE plot, Euclid")
plot(my.vis2, view = "tsne",  main="t-SNE plot, Pearson")
par(opar)
</code></pre>


</div>