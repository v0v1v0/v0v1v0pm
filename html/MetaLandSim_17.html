<div class="container">

<table style="width: 100%;"><tr>
<td>ifm.naive.MCMC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Estimate the naive design incidence function model
</h2>

<h3>Description</h3>

<p>Estimates the IFM assuming no false absences and omitting sites for particular years in which data were missing.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ifm.naive.MCMC(niter=1000,init,z.data, site.distance, site.area, sd.prop.e=0.2,
 sd.prop.x=0.5,sd.prop.y=10, sd.prop.b=0.2, sd.prop.alpha=5,nthin=1,print.by=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>

<p>Number of iterations in the MCMC chain.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>


<p>Named list with values to initialize the chain. E.g.:<br><br>
init1=list(alpha=runif(1,1,30), b=runif(1,0,5),y=runif(1,0,20),<br><br>
e=runif(1,0,1),x=runif(1,0,5)).<br><br>
alpha: initial value for alpha in dispersal model; described as 1 / average dispersal distance <br><br>
b: initial value for parameter b in colonization model <br><br>
y: initial value for parameter y in colonization model <br><br>
e: initial value for e in extinction model <br><br>
x: initial value for x in extinction model
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.data</code></td>
<td>

<p>nsite x nyears matrix. If contains NAs, the corresponding parts are omitted from the likelihood (the missing data are not estimated).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>site.distance</code></td>
<td>

<p>nsite x nsite matrix of distances between sites. The tuning parameters in the example are set for distances less than one, with max distance approximately 0.5.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>site.area</code></td>
<td>

<p>Vector of length nsite with areas. The tuning parameters in the example are set for average area approximately equal to 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.prop.e</code></td>
<td>

<p>Standard deviation of the proposal distribution for parameter e.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.prop.x</code></td>
<td>

<p>Standard deviation of the proposal distribution for parameter x.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.prop.y</code></td>
<td>

<p>Standard deviation of the proposal distribution for parameter y.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.prop.b</code></td>
<td>

<p>Standard deviation of the proposal distribution for parameter b.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.prop.alpha</code></td>
<td>

<p>Standard deviation of the proposal distribution for parameter alpha.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthin</code></td>
<td>

<p>If specified, keeps only every nthin^th sample from the MCMC chain. Use to save memory or when the chain is moving slowly.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.by</code></td>
<td>

<p>Specifies how often to print the number of the current iteration.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>e.chain</code></td>
<td>
<p>posterior sample of e</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.chain</code></td>
<td>
<p>posterior sampmle of x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.chain</code></td>
<td>
<p>posterior sample of y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.chain</code></td>
<td>
<p>posterior sample of b</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.chain</code></td>
<td>
<p>posterior sample of alpha</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance.chain</code></td>
<td>
<p>posterior sample of -2*loglik</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Benjamin Risk
</p>


<h3>References</h3>

<p>Risk, B. B., De Valpine, P., Beissinger, S. R. (2011). A robust design formulation of the incidence function model of metapopulation dynamics applied to two species of rails. Ecology, 92(2), 462-474.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(simulatedifm)

library("coda")

myniter=5000
nsite=nrow(z.sim)
nyear=ncol(z.sim)
nthin=1
nburnin=1000
## NOTE! The notation used here corresponds to MetaLandSim and differs from Risk et al 2011
## Here
## e (in MetaLandSim) = mu
## x = chi
## y = gamma
## b = beta
## alpha = alpha
##
# Priors:
#         e: [0,1]
#         x: [0,5]
#         y^2: [0,400]
#         b: [0,5]
#         alpha: [1,30]

# NOTE: If posteriors are truncated at zero, then estimates are biased. Rescale
# distances (e.g., divide by 10,000) and/or areas so that parameters are larger.

# Here, we run two chains with random initial values:
init1=list(alpha=runif(1,1,30), b=runif(1,0,5),y=runif(1,0,20),e=runif(1,0,1),x=runif(1,0,5))

a = Sys.time()
inm1 &lt;- ifm.naive.MCMC(niter=myniter,init=init1,z.data =
 z.sim,site.distance=sim.distance,site.area=sim.area,
  sd.prop.alpha=4,sd.prop.b=0.6,sd.prop.y=40,sd.prop.e=0.05,sd.prop.x=0.4,nthin=1,print.by=1000)
accept.calculate(inm1,model='naive')
Sys.time() - a

init2=list(alpha=runif(1,1,30), b=runif(1,0,5),y=runif(1,0,20),e=runif(1,0,1),x=runif(1,0,5))
inm2 &lt;- ifm.naive.MCMC(niter=myniter,init=init2,z.data =
z.sim,site.distance=sim.distance,site.area=sim.area,
sd.prop.alpha=4,sd.prop.b=0.6,sd.prop.y=40,sd.prop.e=0.05,sd.prop.x=0.4,nthin=1,print.by=1000)
accept.calculate(inm2,model='naive')
Sys.time() - a

coda.create(inm1,"sim_inm1",par.list=list("e.chain","x.chain","alpha.chain",
"b.chain","y.chain"),niter=myniter,nthin=nthin)
coda.create(inm2,"sim_inm2",par.list=list("e.chain","x.chain","alpha.chain",
"b.chain","y.chain"),niter=myniter,nthin=nthin)
coda.sim.inm1=read.coda("sim_inm1.txt","sim_inm1_Index.txt")
coda.sim.inm2=read.coda("sim_inm2.txt","sim_inm2_Index.txt")
coda.sim.inm.list=mcmc.list(coda.sim.inm1,coda.sim.inm2)
sim.inm=combine.chains(inm1,inm2,nburnin=nburnin,nthin=1)
coda.create(sim.inm,"sim_inm",par.list=list("e.chain","x.chain","alpha.chain",
"b.chain","y.chain"),niter=(2*myniter-2*nburnin),nthin=nthin)
coda.sim.inm.long=read.coda("sim_inm.txt","sim_inm_Index.txt")

summary(coda.sim.inm.list)
summary(coda.sim.inm.long)

gelman.diag(coda.sim.inm.list)

plot(coda.sim.inm.list)
plot(coda.sim.inm.long)
cumuplot(coda.sim.inm.long)

# calculate maximum a posteriori estimates:
m1 &lt;- as.matrix(sim.inm)
e &lt;- calcmode(m1[,1][[1]])
x &lt;- calcmode(m1[,1][[2]])
y &lt;- calcmode(m1[,1][[3]])
b &lt;- calcmode(m1[,1][[4]])
alpha &lt;- calcmode(m1[,1][[5]])


## End(Not run)
</code></pre>


</div>