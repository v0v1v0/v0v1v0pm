<div class="container">

<table style="width: 100%;"><tr>
<td>combine.chains</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Combines two chains into a single chain.
</h2>

<h3>Description</h3>

<p>Combines two lists of chains from ifm.naive.MCMC, ifm.missing.MCMC, or ifm.robust.MCMC into one list where each element is the concatenated chains.
</p>


<h3>Usage</h3>

<pre><code class="language-R">combine.chains(x1, x2, nburnin, nthin = 1, z.thin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>

<p>First list of chains.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2</code></td>
<td>

<p>Second list of chains.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nburnin</code></td>
<td>

<p>Number of initial iterations to discard.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthin</code></td>
<td>

<p>If nthin&gt;1, subsets to every nthin^th sample
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.thin</code></td>
<td>

<p>logical; defaults to TRUE. Thinning for the posterior sample of the occupancy states. If true, uses thinning equal to 5. The posterior sample of occupancy states is a large nsite x nyear x niter array, and this option reduces memory usage. Ignored if the chain is from the ifm.naive.MCMC (where occupancy states are fixed).
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Named list with the same names as the inputs x1 and x2
</p>


<h3>Author(s)</h3>

<p>Benjamin Risk
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(simulatedifm)

init1=list(alpha=runif(1,1,30), b=runif(1,0,5),y=runif(1,0,20),e=runif(1,0,1),x=runif(1,0,5))

inm1 &lt;- ifm.naive.MCMC(niter=500,init=init1,z.data =
 z.sim,site.distance=sim.distance,site.area=sim.area,
  sd.prop.alpha=4,sd.prop.b=0.6,sd.prop.y=40,sd.prop.e=0.05,sd.prop.x=0.4,nthin=1,print.by=100)
  
init1=list(alpha=runif(1,1,30), b=runif(1,0,5),y=runif(1,0,20),e=runif(1,0,1),x=runif(1,0,5))

inm2 &lt;- ifm.naive.MCMC(niter=500,init=init1,z.data =
 z.sim,site.distance=sim.distance,site.area=sim.area,
  sd.prop.alpha=4,sd.prop.b=0.6,sd.prop.y=40,sd.prop.e=0.05,sd.prop.x=0.4,nthin=1,print.by=100)

sim.inm=combine.chains(inm1,inm2,nburnin=0,nthin=1)
</code></pre>


</div>