<div class="container">

<table style="width: 100%;"><tr>
<td>DA.reg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make a regression of differences on averages</h2>

<h3>Description</h3>

<p>For each pair of methods in <code>data</code>, a regression of the differences on
the averages between methods is made and a linear relationship between
methods with prediction standard deviations is derived.
</p>


<h3>Usage</h3>

<pre><code class="language-R">DA.reg(
  data,
  Transform = NULL,
  trans.tol = 1e-06,
  print = TRUE,
  random.raters = FALSE,
  DA.slope = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>Meth</code> object. May also be a data frame with
columns <code>meth</code>, <code>item</code> and <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Transform</code></td>
<td>
<p>A character string, or a list of two functions, each
other's inverse. The measurements are transformed by this before analysis.
Possibilities are: "exp", "log", "logit", "pctlogit" (transforms percentages
by the logit), "sqrt", "sq" (square), "cll" (complementary log-minus-log),
"ll" (log-minus-log). For further details see <code>choose.trans</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans.tol</code></td>
<td>
<p>The tolerance used to check whether the supplied
transformation and its inverse combine to the identity.  Only used if
<code>Transform</code> is a list of two functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print</code></td>
<td>
<p>Should the results be printed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.raters</code></td>
<td>
<p>If methods really are a random selection of raters,
neither intercept nor slope different from 0 are sensible, so if this is
<code>TRUE</code>, intercept and slope in the regression of difference on averages
are fixed to 0. Meaning that we are essentially looking at the raw
differences as residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DA.slope</code></td>
<td>
<p>If this is TRUE, a slope of the differences in the verages
is estimated, otherwise the relationship is assumed constant.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the input object contains replicate measurements these are taken as
separate items in the order they appear in the dataset.
</p>


<h3>Value</h3>

<p><code>DA.reg</code> returns a <code>MethComp</code> object, i.e. a list
with three components, <code>Conv</code>, <code>VarComp</code>, and <code>data</code>.
<code>Conv</code> is a three-dimensional array, with dimensions <code>To</code>,
<code>From</code> (both with levels equal to the methods in <code>data</code>) and an
unnamed dimension with levels <code>"alpha"</code>, <code>"beta"</code>,
<code>"sd.pred"</code>, <code>"beta=1"</code>, referring to the linear relationship of
<code>To</code> to <code>From</code>, <code>"int(t-f)"</code>, <code>"slope(t-f)"</code>,
<code>"sd(t-f)"</code>, referring to the regression of the differences on the
averages, and <code>"int(sd)"</code>, <code>"slope(sd)"</code>, and <code>"s.d.=K"</code>,
referring to the regression of the absoulte residuals on the averages, and
<code>LoA-lo</code>, <code>LoA-hi</code>, the limits of agreement.
</p>
<p>Converting from method <code class="reqn">l</code> to method <code class="reqn">k</code> using
</p>
<p style="text-align: center;"><code class="reqn">y_{k|l}=\alpha+\beta y_l</code>
</p>
<p> with prediction standard deviation
<code class="reqn">\sigma</code>, just requires the entries
<code>[k,l,c("alpha","beta","sd.pred")]</code>, if we assume the s.d. is constant.
</p>
<p>The next entry is the p-values for the hypothesis <code class="reqn">\beta=1</code>, intercept
and slope of the SD of the differences as a linear function of the average
and finally p-value of the hypothesis that standard errors are constant over
the range. The latter three are derived by regressing the absolute values of
the residuals on the averages, and can be used to produce LoA where the s.d.
increases (or decreases) by the mean, using the function <code>DA2y</code>.
</p>
<p>The <code>VarComp</code> element of the list is <code>NULL</code>, and only present for
compatibility with the print method for <code>MethComp</code> objects.
</p>
<p>The <code>data</code> element is the input dataframe. The measurements in <code>y</code>
are left un-transformed, even if data are transformed (i.e. if the
<code>Transform</code> attribute of the object is non-null).
</p>
<p><code>DA2y</code> returns a 2 by 3 matrix with rownames <code>c("y1|2","y2|1")</code>
and columnnames <code>c("int","slope","sd")</code>, calculated under the
assumption that the differences were formed as <code>D &lt;- y1 - y2</code>.
</p>
<p><code>y2DA</code> returns a 3-component vector with names
<code>c("DA-int","DA-slope","DA-sd")</code>, referring to differences
<code>D=y1-y2</code> as a linear function of <code>A=(y1+y2)/2</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:bendix.carstensen@regionh.dk">bendix.carstensen@regionh.dk</a>,
<a href="http://BendixCarstensen.com/MethComp">http://BendixCarstensen.com/MethComp</a>
</p>


<h3>References</h3>

<p>B. Carstensen: Comparing methods of measurement: Extending the
LoA by regression.  Stat Med, 29:401-410, 2010.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data( milk )
DA.reg( milk )
data( sbp )
print( DA.reg(sbp), digits=3 )
# Slope, intercept : y1 = 0.7 + 1.2*y2 (0.4)
A &lt;- c(0.7,1.2,0.4)
( y2DA( A ) )
( DA2y( y2DA( A ) ) )

</code></pre>


</div>