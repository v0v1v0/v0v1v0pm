<div class="container">

<table style="width: 100%;"><tr>
<td>BA.est</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bias and variance components for a Bland-Altman plot.</h2>

<h3>Description</h3>

<p>A variance component model is fitted to method comparison data with
replicate measurements in each method by item stratum. The purpose is to
simplify the construction of a correct Bland-Altman-plot when replicate
measurements are available, and to give the REML-estimates of the relevant
variance components.
</p>


<h3>Usage</h3>

<pre><code class="language-R">BA.est(
  data,
  linked = TRUE,
  IxR = has.repl(data),
  MxI = has.repl(data),
  corMxI = FALSE,
  varMxI = TRUE,
  IxR.pr = FALSE,
  bias = TRUE,
  alpha = 0.05,
  Transform = NULL,
  trans.tol = 1e-06,
  random.raters = FALSE,
  lmecontrol = lmeControl(msMaxIter = 300),
  weightfunction = c("mean", "median")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>Meth</code> object representing method comparison data
with replicate measurements, i.e. with columns <code>meth</code>, <code>item</code>,
<code>repl</code> and <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linked</code></td>
<td>
<p>Logical. Are replicates linked within item across methods?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IxR</code></td>
<td>
<p>Logical. Should an item by repl interaction be included in the
model. This is needed when the replicates are linked within item across
methods, so it is just another name for the <code>linked</code> argument.  If
<code>linked=</code> is given, this is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MxI</code></td>
<td>
<p>Logical. Should the method by item interaction (matrix effect) be
included in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corMxI</code></td>
<td>
<p>Logical. Should the method by item interaction allow
coorelated effects within item. Ignored if only two methods are compared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varMxI</code></td>
<td>
<p>Logical. Should the method by item interaction have a variance
that varies between methods. Ignored if only two methods are compared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IxR.pr</code></td>
<td>
<p>Logical. Should the item by repl interaction variation be
included in the prediction standard deviation?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bias</code></td>
<td>
<p>Logical. Should a systematic bias between methods be estimated?
If <code>FALSE</code> no bias between methods are assumed, i.e.  <code class="reqn">\alpha_m=0,
m=1,\ldots M</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numerical. Significance level. By default the value 2 is used
when computing prediction intervals, otherwise the
<code class="reqn">1-\alpha/2</code> t-quantile is used. The number of d.f. is taken
as the number of units minus the number of items minus the number of methods
minus 1 (<code class="reqn">I-M-1</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Transform</code></td>
<td>
<p>Transformation applied to data (<code>y</code>) before analysis.
See <code>check.trans</code> for possible values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans.tol</code></td>
<td>
<p>Numerical. The tolerance used to check whether the supplied
transformation and its inverse combine to the identity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.raters</code></td>
<td>
<p>Logical. Should methods/raters be considered as random.
Defaults to <code>FALSE</code> which corresponds to a fixed effect of
methods/raters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lmecontrol</code></td>
<td>
<p>A list of control parameters passed on to <code>lme</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightfunction</code></td>
<td>
<p>Function to weigh variance components for random
raters. Defaults to <code>mean</code> but can also be <code>median</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model fitted is: </p>
<p style="text-align: center;"><code class="reqn">y=\alpha_m + \mu_i + c_{mi} + a_{ir} + e_{mir},
</code>
</p>
<p style="text-align: center;"><code class="reqn"> \quad
\mathrm{var}(c_{mi})=\tau_m^2, </code>
</p>
<p style="text-align: center;"><code class="reqn"> \quad
\mathrm{var}(a_{ir})=\omega^2, </code>
</p>
<p style="text-align: center;"><code class="reqn"> \quad
\mathrm{var}(e_{mir})=\sigma_m^2, </code>
</p>
<p style="text-align: center;"><code class="reqn">
</code>
</p>
<p> We can only fit separate variances
for the <code class="reqn">\tau s</code> if more than two methods are compared (i.e.
<code>nM</code> &gt; 2), hence varMxI is ignored when <code>nM</code>==2.
</p>
<p>The function <code>VC.est</code> is the workhorse; <code>BA.est</code> just calls it.
<code>VC.est</code> figures out which model to fit by <code>lme</code>, extracts results
and returns estimates. <code>VC.est</code> is also used as part of the fitting
algorithm in <code>AltReg</code>, where each iteration step requires fit of
this model. The function <code>VC.est</code> is actually just a wrapper for the
functions <code>VC.est.fixed</code> that handles the case with fixed methods
(usually 2 or three) i.e. the classical method comparison problem, and
<code>VC.est.random</code> that handles the situation where "methods" are merely a
random sample of raters from some population of raters; and therefore are
regarded as random.
</p>


<h3>Value</h3>

<p><code>BA.est</code> returns an object of class
<code>c("MethComp","BA.est")</code>, a list with four elements <code>Conv</code>,
<code>VarComp</code>, <code>LoA</code>, <code>RepCoef</code>; <code>VC.est</code> returns
(invisibly!) a list with elements <code>Bias</code>, <code>VarComp</code>, <code>Mu</code>,
<code>RanEff</code>.  These list components are: </p>
<table>
<tr style="vertical-align: top;">
<td><code>Conv</code></td>
<td>
<p>3-dimensional array
with dimensions "To", "From" and unnamed.  The first two dimensions have the
methods compared as levels, the last one
<code>c("alpha","beta","sd.pred","LoA: lower","upper")</code>.  It represents the
mean conversions between methods and the prediction standard deviation.
</p>
<p>Where "To" and "From" take the same value the value of the "sd" component is
<code class="reqn">\sqrt{2}</code> times the residual variation for the method. If
<code>IxR.pr=TRUE</code> the variation between replicates are included too, i.e.
<code class="reqn">\sqrt{2(\sigma_m^2+\omega^2)} </code> sqrt[2(sigma_m^2+omega^2)]. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VarComp</code></td>
<td>
<p>A matrix of variance components (on the SD scale) with
methods as rows and variance components "IxR", "MxI" and "res" as columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LoA</code></td>
<td>
<p>Four-column matrix with mean difference, lower and upper limit of
agreement and prediction SD. Each row in the matrix represents a pair of
methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RepCoef</code></td>
<td>
<p>Two-column matrix of repeatability SDs and
repeatability coefficients. The SDs are the standard deviation of the
difference between two measurements by the same method on the item under
identical circumstances; the repeatability coefficient the numerical extent
of the prediction interval for this difference, i.e.
<code class="reqn">2\sqrt{2}</code> times the sd.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mu</code></td>
<td>
<p>Estimates of the
item-specific parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RanEff</code></td>
<td>
<p>Estimates of the random effects
from the model (BLUPS).  This is a (possibly empty) list with possible
elements named <code>MxI</code> and <code>IxR</code> according to whether these random
effects are in the model.</p>
</td>
</tr>
</table>
<p> The returned object has an attribute,
<code>Transform</code> with the transformation applied to data before analysis,
and its inverse â€” see <code>choose.trans</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen
</p>


<h3>References</h3>

<p>Carstensen, Simpson &amp; Gurrin: Statistical models for assessing
agreement in method comparison studies with replicate measurements, The
International Journal of Biostatistics: Vol. 4 : Iss. 1, Article 16.
<a href="http://www.bepress.com/ijb/vol4/iss1/16">http://www.bepress.com/ijb/vol4/iss1/16</a>.
</p>


<h3>See Also</h3>

<p><code>BA.plot</code>, <code>perm.repl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data( ox )
ox &lt;- Meth( ox )
summary( ox )
BA.est( ox )
BA.est( ox, linked=FALSE )
BA.est( ox, linked=TRUE, Transform="pctlogit" )
## Not run: 
data( sbp )
BA.est( sbp )
BA.est( sbp, linked=FALSE )
# Check what you get from VC.est
str( VC.est( sbp ) )
## End(Not run)

</code></pre>


</div>