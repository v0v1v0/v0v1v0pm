<div class="container">

<table style="width: 100%;"><tr>
<td>graph_lme</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Metric graph linear mixed effects models</h2>

<h3>Description</h3>

<p>Fitting linear mixed effects model in metric graphs. The random effects can be
Gaussian Whittle-Matern fields, discrete Gaussian Markov random fields based
on the graph Laplacian, as well as Gaussian random fields with isotropic
covariance functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">graph_lme(
  formula,
  graph,
  model = list(type = "linearModel"),
  which_repl = NULL,
  optim_method = "L-BFGS-B",
  possible_methods = c("Nelder-Mead", "L-BFGS-B"),
  model_options = list(),
  BC = 0,
  previous_fit = NULL,
  fix_coeff = FALSE,
  parallel = FALSE,
  n_cores = parallel::detectCores() - 1,
  optim_controls = list(),
  improve_hessian = FALSE,
  hessian_args = list(),
  check_euclidean = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Formula object describing the relation between the response
variables and the fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>The random effects model that will be used (it also includes the
option of not having any random effects). It can be either a character,
whose options are 'lm', for linear models without random effects; 'WM1' and
'WM2' for Whittle-Matern models with <code class="reqn">\alpha</code>=1 and 2, with exact
precision matrices, respectively; 'WM' for Whittle-Matern models where one
also estimates the smoothness parameter via finite-element method; 'isoExp'
for a model with isotropic exponential covariance; 'GL1' and 'GL2' for a
SPDE model based on graph Laplacian with <code class="reqn">\alpha</code> = 1 and 2, respectively.
'WMD1' is the directed Whittle-Matern with  <code class="reqn">\alpha</code>=1.
There is also the option to provide it as a list containing the elements
<code>type</code>, which can be <code>linearModel</code>, <code>WhittleMatern</code>, <code>graphLaplacian</code> or <code>isoCov</code>.
<code>linearModel</code> corresponds to a linear model without random effects.
For <code>WhittleMatern</code> models, that is, if the list contains <code>type = 'WhittleMatern'</code>,
one can choose between a finite element approximation of the precision matrix
by adding <code>fem = TRUE</code> to the list, or to use the exact precision matrix
(by setting <code>fem = FALSE</code>). If <code>fem</code> is <code>FALSE</code>, there is also the parameter
<code>alpha</code>, to determine the order of the SPDE, which is either 1 or 2. If <code>fem</code>
is <code>TRUE</code> and <code>alpha</code> is not specified, then the default value of <code>alpha=1</code>
will be used. If <code>fem</code> is <code>TRUE</code> and one does not specify <code>alpha</code>, it will be
estimated from the data. However, if one wants to have <code>alpha</code> fixed to some
value, the user can specify either <code>alpha</code> or <code>nu</code> in the list. See the
vignettes for examples. Finally, for type 'WhittleMatern', there is an optional
argument, <code>rspde_order</code>, that chooses the order of the rational approximation.
By default <code>rspde_order</code> is 2.
Finally, if one wants to fit a nonstationary model, then <code>fem</code> necessarily
needs to be <code>TRUE</code>, and one needs to also supply the matrices <code>B.tau</code>
and <code>B.kappa</code> or <code>B.range</code> and <code>B.sigma</code>.
For <code>graph-Laplacian</code> models, the list must also contain a parameter <code>alpha</code>
(which is 1 by default). For <code>isoCov</code> models, the list must
contain a parameter <code>cov_function</code>, containing the covariance function.
The function accepts a string input for the following covariance functions:
'exp_covariance', 'WM1', 'WM2', 'GL1', 'GL2'. For another covariance function,
the function itself must be provided as the <code>cov_function</code> argument. The
default is 'exp_covariance', the exponential covariance. We also have
covariance-based versions of the Whittle-Matern and graph Laplacian models,
however they are much slower, they are the following (string) values for
'cov_function': 'alpha1' and 'alpha2' for Whittle-Matern fields, and 'GL1'
and 'GL2' for graph Laplacian models. Finally, for <code>Whittle-Matern</code> models,
there is an additional parameter <code>version</code>, which can be either 1 or 2, to
tell which version of the likelihood should be used. Version is 1 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_repl</code></td>
<td>
<p>Vector or list containing which replicates to consider in
the model. If <code>NULL</code> all replicates will be considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim_method</code></td>
<td>
<p>The method to be used with <code>optim</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>possible_methods</code></td>
<td>
<p>Which methods to try in case the optimization fails or the hessian is not positive definite. The options are 'Nelder-Mead', 'L-BFGS-B', 'BFGS', 'CG' and 'SANN'. By default only 'Nelder-Mead' and 'L-BFGS-B' are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_options</code></td>
<td>
<p>A list containing additional options to be used in the model. Currently, it is possible to fix parameters during the estimation or change the starting values of the parameters. The general structure of the elements of the list is <code>fix_parname</code> and <code>start_parname</code>, where <code>parname</code> stands for the name of the parameter. If <code>fix_parname</code> is not <code>NULL</code>, then the model with be fitted with the <code>parname</code> being fixed at the value that was passed. If <code>start_parname</code> is not <code>NULL</code>, the model will be fitted using the value passed as starting value for <code>parname</code>. the For 'WM' models, the possible elements of the list are: <code>fix_sigma_e</code>, <code>start_sigma_e</code>, <code>fix_nu</code>, <code>start_nu</code>, <code>fix_sigma</code>, <code>start_sigma</code>, <code>fix_range</code>, <code>start_range</code>. Alternatively, one can use <code>fix_sigma_e</code>, <code>start_sigma_e</code>, <code>fix_nu</code>, <code>start_nu</code>, <code>fix_tau</code>, <code>start_tau</code>, <code>fix_kappa</code>, <code>start_kappa</code>. For 'WM1', 'WM2', 'isoExp', 'GL1' and 'GL2' models, the possible elements of the list are <code>fix_sigma_e</code>, <code>start_sigma_e</code>, <code>fix_sigma</code>, <code>start_sigma</code>, <code>fix_range</code>, <code>start_range</code>. Alternatively, one can use <code>fix_sigma_e</code>, <code>start_sigma_e</code>, <code>fix_tau</code>, <code>start_tau</code>, <code>fix_kappa</code>, <code>start_kappa</code>. For 'isoCov' models, the possible values are <code>fix_sigma_e</code>, <code>start_sigma_e</code>, <code>fix_par_vec</code>, <code>start_par_vec</code>. Observe that contrary to the other models, for 'isoCov' models, both <code>fix_par_vec</code> and <code>start_par_vec</code> should be given as vectors of the size of the dimension of the vector for the input of the covariance function passed to the 'isoCov' model. Furthermore, for 'isoCov' models, <code>fix_par_vec</code> is a logical vector, indicating which parameters to be fixed, and the values will be kept fixed to the values given to <code>start_par_vec</code>, one can also use <code>fix_sigma_e</code> and <code>start_sigma_e</code> for controlling the std. deviation of the measurement error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BC</code></td>
<td>
<p>For <code>WhittleMatern</code> models, decides which boundary condition to use
(0,1). Here, 0 is Neumann boundary conditions and 1 specifies stationary boundary
conditions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>previous_fit</code></td>
<td>
<p>An object of class <code>graph_lme</code>. Use the fitted coefficients as starting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix_coeff</code></td>
<td>
<p>If using a previous fit, should all coefficients be fixed at the starting values?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical. Indicating whether to use <code>optimParallel()</code> or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p>Number of cores to be used if parallel is true.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim_controls</code></td>
<td>
<p>Additional controls to be passed to <code>optim()</code> or <code>optimParallel()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>improve_hessian</code></td>
<td>
<p>Should a more precise estimate of the hessian be obtained?
Turning on might increase the overall time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian_args</code></td>
<td>
<p>List of controls to be used if <code>improve_hessian</code> is <code>TRUE</code>.
The list can contain the arguments to be passed to the <code>method.args</code> argument
in the <code>hessian</code> function. See the help of the <code>hessian</code> function in 'numDeriv'
package for details. Observet that it only accepts the "Richardson" method for
now, the method "complex" is not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_euclidean</code></td>
<td>
<p>Check if the graph used to compute the resistance distance has Euclidean edges? The graph used to compute the resistance distance has the observation locations as vertices.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the fitted model.
</p>


</div>