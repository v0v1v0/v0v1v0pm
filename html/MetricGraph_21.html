<div class="container">

<table style="width: 100%;"><tr>
<td>graph_spde</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>'INLA' implementation of Whittle-Matérn fields for metric graphs</h2>

<h3>Description</h3>

<p>This function creates an 'INLA' object that can be used
in 'INLA' or 'inlabru' to fit Whittle-Matérn fields on metric graphs.
</p>


<h3>Usage</h3>

<pre><code class="language-R">graph_spde(
  graph_object,
  alpha = 1,
  stationary_endpoints = "all",
  parameterization = c("matern", "spde"),
  start_range = NULL,
  prior_range = NULL,
  start_kappa = NULL,
  start_sigma = NULL,
  prior_kappa = NULL,
  prior_sigma = NULL,
  shared_lib = "detect",
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph_object</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The order of the SPDE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stationary_endpoints</code></td>
<td>
<p>Which vertices of degree 1 should contain
stationary boundary conditions?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameterization</code></td>
<td>
<p>Which parameterization to be used? The options are
'matern' (sigma and range) and 'spde' (sigma and kappa).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_range</code></td>
<td>
<p>Starting value for range parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior_range</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation of the range parameter on
the log scale. Will not be used if prior.kappa is non-null.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_kappa</code></td>
<td>
<p>Starting value for kappa.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_sigma</code></td>
<td>
<p>Starting value for sigma.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior_kappa</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation of kappa on the log scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior_sigma</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation of sigma on the log scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shared_lib</code></td>
<td>
<p>Which shared lib to use for the cgeneric implementation?
If "detect", it will check if the shared lib exists locally, in which case it will
use it. Otherwise it will use 'INLA's shared library.
If 'INLA', it will use the shared lib from 'INLA's installation. If 'MetricGraph', then
it will use the local installation (does not work if your installation is from CRAN).
Otherwise, you can directly supply the path of the .so (or .dll) file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>Should debug be displayed?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is used to construct a Matern SPDE model on a metric graph.
The latent field <code class="reqn">u</code> is the solution of the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa^2 - \Delta)^\alpha u = \sigma W,</code>
</p>
<p> where <code class="reqn">W</code> is Gaussian
white noise on the metric graph. This model implements exactly
the cases in which <code class="reqn">\alpha = 1</code> or <code class="reqn">\alpha = 2</code>. For a finite
element approximation for general <code class="reqn">\alpha</code> we refer the reader to the
'rSPDE' package and to the Whittle–Matérn fields with general smoothness vignette.
</p>
<p>We also have the alternative parameterization <code class="reqn">\rho = \frac{\sqrt{8(\alpha-0.5)}}{\kappa}</code>,
which can be interpreted as a range parameter.
</p>
<p>Let <code class="reqn">\kappa_0</code> and <code class="reqn">\sigma_0</code> be the starting values for <code class="reqn">\kappa</code> and
<code class="reqn">\sigma</code>, we write <code class="reqn">\sigma = \exp\{\theta_1\}</code> and <code class="reqn">\kappa = \exp\{\theta_2\}</code>.
We assume priors on <code class="reqn">\theta_1</code> and <code class="reqn">\theta_2</code> to be normally distributed
with mean, respectively, <code class="reqn">\log(\sigma_0)</code> and <code class="reqn">\log(\kappa_0)</code>, and variance 10.
Similarly, if we let <code class="reqn">\rho_0</code> be the starting value for <code class="reqn">\rho</code>, then
we write <code class="reqn">\rho = \exp\{\theta_2\}</code> and assume a normal prior for <code class="reqn">\theta_2</code>,
with mean <code class="reqn">\log(\rho_0)</code> and variance 10.
</p>


<h3>Value</h3>

<p>An 'INLA' object.
</p>


</div>