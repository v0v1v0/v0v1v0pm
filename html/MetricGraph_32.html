<div class="container">

<table style="width: 100%;"><tr>
<td>metric_graph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Metric graph</h2>

<h3>Description</h3>

<p>Class representing a general metric graph.
</p>


<h3>Details</h3>

<p>A graph object created from vertex and edge matrices, or from an
<code>sp::SpatialLines</code> object where each line is representing and edge. For more details,
see the vignette:
<code>vignette("metric_graph", package = "MetricGraph")</code>
</p>


<h3>Value</h3>

<p>Object of <code>R6Class</code> for creating metric graphs.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>V</code></dt>
<dd>
<p>Matrix with positions in Euclidean space of the vertices of the
graph.</p>
</dd>
<dt><code>nV</code></dt>
<dd>
<p>The number of vertices.</p>
</dd>
<dt><code>E</code></dt>
<dd>
<p>Matrix with the edges of the graph, where each row represents an
edge, <code>E[i,1]</code> is the vertex at the start of the ith edge and <code>E[i,2]</code> is
the vertex at the end of the edge.</p>
</dd>
<dt><code>nE</code></dt>
<dd>
<p>The number of edges.</p>
</dd>
<dt><code>edge_lengths</code></dt>
<dd>
<p>Vector with the lengths of the edges in the graph.</p>
</dd>
<dt><code>C</code></dt>
<dd>
<p>Constraint matrix used to set Kirchhoff constraints.</p>
</dd>
<dt><code>CoB</code></dt>
<dd>
<p>Change-of-basis object used for Kirchhoff constraints.</p>
</dd>
<dt><code>PtV</code></dt>
<dd>
<p>Vector with the indices of the vertices which are observation
locations.</p>
</dd>
<dt><code>mesh</code></dt>
<dd>
<p>Mesh object used for plotting.</p>
</dd>
<dt><code>edges</code></dt>
<dd>
<p>The coordinates of the edges in the graph.</p>
</dd>
<dt><code>vertices</code></dt>
<dd>
<p>The coordinates of the vertices in the graph, along with several attributes.</p>
</dd>
<dt><code>geo_dist</code></dt>
<dd>
<p>Geodesic distances between the vertices in the graph.</p>
</dd>
<dt><code>res_dist</code></dt>
<dd>
<p>Resistance distances between the observation locations.</p>
</dd>
<dt><code>Laplacian</code></dt>
<dd>
<p>The weighted graph Laplacian of the vertices in the
graph. The weights are given by the edge lengths.</p>
</dd>
<dt><code>characteristics</code></dt>
<dd>
<p>List with various characteristics of the graph.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-metric_graph-new"><code>metric_graph$new()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-set_edge_weights"><code>metric_graph$set_edge_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_edge_weights"><code>metric_graph$get_edge_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_vertices_incomp_dir"><code>metric_graph$get_vertices_incomp_dir()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-summary"><code>metric_graph$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-print"><code>metric_graph$print()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_characteristics"><code>metric_graph$compute_characteristics()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-check_euclidean"><code>metric_graph$check_euclidean()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-check_distance_consistency"><code>metric_graph$check_distance_consistency()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_geodist"><code>metric_graph$compute_geodist()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_geodist_PtE"><code>metric_graph$compute_geodist_PtE()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_geodist_mesh"><code>metric_graph$compute_geodist_mesh()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_resdist"><code>metric_graph$compute_resdist()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_resdist_PtE"><code>metric_graph$compute_resdist_PtE()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_degrees"><code>metric_graph$get_degrees()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_PtE_edges"><code>metric_graph$compute_PtE_edges()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_resdist_mesh"><code>metric_graph$compute_resdist_mesh()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_laplacian"><code>metric_graph$compute_laplacian()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-prune_vertices"><code>metric_graph$prune_vertices()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_groups"><code>metric_graph$get_groups()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_PtE"><code>metric_graph$get_PtE()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_edge_lengths"><code>metric_graph$get_edge_lengths()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_locations"><code>metric_graph$get_locations()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-observation_to_vertex"><code>metric_graph$observation_to_vertex()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-edgeweight_to_data"><code>metric_graph$edgeweight_to_data()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_mesh_locations"><code>metric_graph$get_mesh_locations()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-clear_observations"><code>metric_graph$clear_observations()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-process_data"><code>metric_graph$process_data()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-add_observations"><code>metric_graph$add_observations()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-mutate"><code>metric_graph$mutate()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-drop_na"><code>metric_graph$drop_na()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-select"><code>metric_graph$select()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-filter"><code>metric_graph$filter()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-summarise"><code>metric_graph$summarise()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_data"><code>metric_graph$get_data()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-buildDirectionalConstraints"><code>metric_graph$buildDirectionalConstraints()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-buildC"><code>metric_graph$buildC()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-build_mesh"><code>metric_graph$build_mesh()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_fem"><code>metric_graph$compute_fem()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-mesh_A"><code>metric_graph$mesh_A()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-fem_basis"><code>metric_graph$fem_basis()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-VtEfirst"><code>metric_graph$VtEfirst()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-plot"><code>metric_graph$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-plot_connections"><code>metric_graph$plot_connections()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-is_tree"><code>metric_graph$is_tree()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-plot_function"><code>metric_graph$plot_function()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-plot_movie"><code>metric_graph$plot_movie()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-add_mesh_observations"><code>metric_graph$add_mesh_observations()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_initial_graph"><code>metric_graph$get_initial_graph()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-coordinates"><code>metric_graph$coordinates()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-clone"><code>metric_graph$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-metric_graph-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>metric_graph</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$new(
  edges = NULL,
  V = NULL,
  E = NULL,
  vertex_unit = NULL,
  length_unit = vertex_unit,
  edge_weights = 1,
  kirchhoff_weights = NULL,
  longlat = FALSE,
  crs = NULL,
  proj4string = NULL,
  which_longlat = "sp",
  project = FALSE,
  project_data = FALSE,
  which_projection = "Winkel tripel",
  tolerance = list(vertex_vertex = 0.001, vertex_edge = 0.001, edge_edge = 0),
  check_connected = TRUE,
  remove_deg2 = FALSE,
  merge_close_vertices = TRUE,
  factor_merge_close_vertices = 1,
  remove_circles = TRUE,
  verbose = 1,
  lines = deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>edges</code></dt>
<dd>
<p>A list containing coordinates as <code style="white-space: pre;">⁠m x 2⁠</code> matrices (that is, of <code>matrix</code> type) or m x 2 data frames (<code>data.frame</code> type) of sequence of points connected by straightlines. Alternatively, you can also prove an object of type <code>SpatialLinesDataFrame</code> or <code>SpatialLines</code> (from <code>sp</code> package) or <code>MULTILINESTRING</code> (from <code>sf</code> package).</p>
</dd>
<dt><code>V</code></dt>
<dd>
<p>n x 2 matrix with Euclidean coordinates of the n vertices.</p>
</dd>
<dt><code>E</code></dt>
<dd>
<p>m x 2 matrix where each row represents one of the m edges.</p>
</dd>
<dt><code>vertex_unit</code></dt>
<dd>
<p>The unit in which the vertices are specified. The options are 'degrees' (the great circle distance in km), 'km', 'm' and 'miles'. The default is <code>NULL</code>, which means no unit. However, if you set <code>length_unit</code>, you need to set <code>vertex_unit</code>.</p>
</dd>
<dt><code>length_unit</code></dt>
<dd>
<p>The unit in which the lengths will be computed. The options are 'km', 'm' and 'miles'. The default is <code>vertex_unit</code>. Observe that if <code>vertex_unit</code> is <code>NULL</code>, <code>length_unit</code> can only be <code>NULL</code>.
If <code>vertex_unit</code> is 'degrees', then the default value for <code>length_unit</code> is 'km'.</p>
</dd>
<dt><code>edge_weights</code></dt>
<dd>
<p>Either a number, a numerical vector with length given by the number of edges, providing the edge weights, or a <code>data.frame</code> with the number of rows being equal to the number of edges, where
each row gives a vector of weights to its corresponding edge. Can be changed by using the <code>set_edge_weights()</code> method.</p>
</dd>
<dt><code>kirchhoff_weights</code></dt>
<dd>
<p>If non-null, the name (or number) of the column of <code>edge_weights</code> that contain the Kirchhoff weights. Must be equal to 1 (or <code>TRUE</code>) in case <code>edge_weights</code> is a single number and those are the Kirchhoff weights.</p>
</dd>
<dt><code>longlat</code></dt>
<dd>
<p>If <code>TRUE</code>, then it is assumed that the coordinates are given.
in Longitude/Latitude and that distances should be computed in meters. If <code>TRUE</code> it takes precedence over
<code>vertex_unit</code> and <code>length_unit</code>, and is equivalent to <code>vertex_unit = 'degrees'</code> and <code>length_unit = 'm'</code>.</p>
</dd>
<dt><code>crs</code></dt>
<dd>
<p>Coordinate reference system to be used in case <code>longlat</code> is set to <code>TRUE</code> and <code>which_longlat</code> is <code>sf</code>. Object of class crs. The default is <code>sf::st_crs(4326)</code>.</p>
</dd>
<dt><code>proj4string</code></dt>
<dd>
<p>Projection string of class CRS-class to be used in case <code>longlat</code> is set to <code>TRUE</code> and <code>which_longlat</code> is <code>sp</code>. The default is <code>sp::CRS("+proj=longlat +datum=WGS84")</code>.</p>
</dd>
<dt><code>which_longlat</code></dt>
<dd>
<p>Compute the distance using which package? The options are <code>sp</code> and <code>sf</code>. The default is <code>sp</code>.</p>
</dd>
<dt><code>project</code></dt>
<dd>
<p>If <code>longlat</code> is <code>TRUE</code> should a projection be used to compute the distances to be used for the tolerances (see <code>tolerance</code> below)? The default is <code>FALSE</code>. When <code>TRUE</code>, the construction of the graph is faster.</p>
</dd>
<dt><code>project_data</code></dt>
<dd>
<p>If <code>longlat</code> is <code>TRUE</code> should the vertices be project to planar coordinates? The default is <code>FALSE</code>. When <code>TRUE</code>, the construction of the graph is faster.</p>
</dd>
<dt><code>which_projection</code></dt>
<dd>
<p>Which projection should be used in case <code>project</code> is <code>TRUE</code>? The options are <code>Robinson</code>, <code style="white-space: pre;">⁠Winkel tripel⁠</code> or a proj4string. The default is <code style="white-space: pre;">⁠Winkel tripel⁠</code>.</p>
</dd>
<dt><code>tolerance</code></dt>
<dd>
<p>List that provides tolerances during the construction of the graph:
</p>

<ul>
<li> <p><code>vertex_vertex</code> Vertices that are closer than this number are merged (default = 1e-7).
</p>
</li>
<li> <p><code>vertex_edge</code> If a vertex at the end of one edge is closer than this
number to another edge, this vertex is connected to that edge
(default = 1e-7). Previously <code>vertex_line</code>, which is now deprecated.
</p>
</li>
<li> <p><code>edge_edge</code> If two edges at some point are closer than this number, a new
vertex is added at that point and the two edges are connected (default = 0).
</p>
</li>
<li> <p><code>vertex_line</code>, Deprecated. Use <code>vertex_edge</code> instead.
</p>
</li>
<li> <p><code>line_line</code>, Deprecated. Use <code>edge_edge</code> instead.
</p>
</li>
</ul>
<p>In case <code>longlat = TRUE</code>, the tolerances are given in <code>length_unit</code>.</p>
</dd>
<dt><code>check_connected</code></dt>
<dd>
<p>If <code>TRUE</code>, it is checked whether the graph is
connected and a warning is given if this is not the case.</p>
</dd>
<dt><code>remove_deg2</code></dt>
<dd>
<p>Set to <code>TRUE</code> to remove all vertices of degree 2 in the
initialization. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>merge_close_vertices</code></dt>
<dd>
<p>should an additional step to merge close vertices be done?</p>
</dd>
<dt><code>factor_merge_close_vertices</code></dt>
<dd>
<p>Which factor to be multiplied by tolerance <code>vertex_vertex</code> when merging close vertices at the additional step?</p>
</dd>
<dt><code>remove_circles</code></dt>
<dd>
<p>All circlular edges with a length smaller than this number
are removed. If <code>TRUE</code>, the <code>vertex_vertex</code> tolerance will be used. If <code>FALSE</code>, no circles will be removed.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>Print progress of graph creation. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
<dt><code>lines</code></dt>
<dd>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a> Use <code>edges</code> instead.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>A graph object can be initialized in two ways. The first method
is to specify V and E. In this case, all edges are assumed to be straight
lines. The second option is to specify the graph via the <code>lines</code> input.
In this case, the vertices are set by the end points of the lines.
Thus, if two lines are intersecting somewhere else, this will not be
viewed as a vertex.
</p>



<h5>Returns</h5>

<p>A <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-set_edge_weights"></a>



<h4>Method <code>set_edge_weights()</code>
</h4>

<p>Sets the edge weights
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$set_edge_weights(
  weights = rep(1, self$nE),
  kirchhoff_weights = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>weights</code></dt>
<dd>
<p>Either a number, a numerical vector with length given by the number of edges, providing the edge weights, or a <code>data.frame</code> with the number of rows being equal to the number of edges, where
each row gives a vector of weights to its corresponding edge.</p>
</dd>
<dt><code>kirchhoff_weights</code></dt>
<dd>
<p>If non-null, the name (or number) of the column of <code>weights</code> that contain the Kirchhoff weights. Must be equal to 1 (or <code>TRUE</code>) in case <code>weights</code> is a single number and those are the Kirchhoff weights.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-get_edge_weights"></a>



<h4>Method <code>get_edge_weights()</code>
</h4>

<p>Gets the edge weights
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_edge_weights(data.frame = FALSE, tibble = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data.frame</code></dt>
<dd>
<p>If the edge weights are given as vectors, should the result be returned as a data.frame?</p>
</dd>
<dt><code>tibble</code></dt>
<dd>
<p>Should the edge weights be returned as tibble?</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A vector or <code>data.frame</code> containing the edge weights.
</p>


<hr>
<a id="method-metric_graph-get_vertices_incomp_dir"></a>



<h4>Method <code>get_vertices_incomp_dir()</code>
</h4>

<p>Gets vertices with incompatible directions
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_vertices_incomp_dir()</pre></div>



<h5>Returns</h5>

<p>A vector containing the vertices with incompatible directions.
</p>


<hr>
<a id="method-metric_graph-summary"></a>



<h4>Method <code>summary()</code>
</h4>

<p>Prints a summary of various informations of the graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$summary(
  messages = FALSE,
  compute_characteristics = TRUE,
  check_euclidean = TRUE,
  check_distance_consistency = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>messages</code></dt>
<dd>
<p>Should message explaining how to build the results be given for missing quantities?</p>
</dd>
<dt><code>compute_characteristics</code></dt>
<dd>
<p>Should the characteristics of the graph be computed?</p>
</dd>
<dt><code>check_euclidean</code></dt>
<dd>
<p>Check if the graph has Euclidean edges?</p>
</dd>
<dt><code>check_distance_consistency</code></dt>
<dd>
<p>Check the distance consistency assumption?</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Prints various characteristics of the graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$print()</pre></div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-compute_characteristics"></a>



<h4>Method <code>compute_characteristics()</code>
</h4>

<p>Computes various characteristics of the graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_characteristics(check_euclidean = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>check_euclidean</code></dt>
<dd>
<p>Also check if the graph has Euclidean edges? This essentially means that the distance consistency check will also be perfomed. If the graph does not have Euclidean edges due to another reason rather than the distance consistency, then it will already be indicated that the graph does not have Euclidean edges.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The computed characteristics
are stored in the <code>characteristics</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-check_euclidean"></a>



<h4>Method <code>check_euclidean()</code>
</h4>

<p>Check if the graph has Euclidean edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$check_euclidean()</pre></div>



<h5>Returns</h5>

<p>Returns <code>TRUE</code> if the graph has Euclidean edges, or <code>FALSE</code> otherwise.
The result is stored in the <code>characteristics</code> element of the <code>metric_graph</code> object.
The result is displayed when the graph is printed.
</p>


<hr>
<a id="method-metric_graph-check_distance_consistency"></a>



<h4>Method <code>check_distance_consistency()</code>
</h4>

<p>Checks distance consistency of the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$check_distance_consistency()</pre></div>



<h5>Returns</h5>

<p>No return value.
The result is stored in the <code>characteristics</code> element of the <code>metric_graph</code> object.
The result is displayed when the graph is printed.
</p>


<hr>
<a id="method-metric_graph-compute_geodist"></a>



<h4>Method <code>compute_geodist()</code>
</h4>

<p>Computes shortest path distances between the vertices in the
graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_geodist(full = FALSE, obs = TRUE, group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>full</code></dt>
<dd>
<p>Should the geodesic distances be computed for all
the available locations? If <code>FALSE</code>, it will be computed
separately for the locations of each group.</p>
</dd>
<dt><code>obs</code></dt>
<dd>
<p>Should the geodesic distances be computed at the observation
locations?</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>Vector or list containing which groups to compute the distance
for. If <code>NULL</code>, it will be computed for all groups.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The computed geodesic
distances are stored in the <code>geo_dist</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-compute_geodist_PtE"></a>



<h4>Method <code>compute_geodist_PtE()</code>
</h4>

<p>Computes shortest path distances between the vertices in the
graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_geodist_PtE(
  PtE,
  normalized = TRUE,
  include_vertices = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PtE</code></dt>
<dd>
<p>Points to compute the metric for.</p>
</dd>
<dt><code>normalized</code></dt>
<dd>
<p>are the locations in PtE in normalized distance?</p>
</dd>
<dt><code>include_vertices</code></dt>
<dd>
<p>Should the original vertices be included in the
distance matrix?</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A matrix containing the geodesic distances.
</p>


<hr>
<a id="method-metric_graph-compute_geodist_mesh"></a>



<h4>Method <code>compute_geodist_mesh()</code>
</h4>

<p>Computes shortest path distances between the vertices in the
mesh.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_geodist_mesh()</pre></div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The geodesic distances
on the mesh are stored in <code>mesh$geo_dist</code> in the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-compute_resdist"></a>



<h4>Method <code>compute_resdist()</code>
</h4>

<p>Computes the resistance distance between the observation
locations.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_resdist(
  full = FALSE,
  obs = TRUE,
  group = NULL,
  check_euclidean = FALSE,
  include_vertices = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>full</code></dt>
<dd>
<p>Should the resistance distances be computed for all
the available locations. If <code>FALSE</code>, it will be computed
separately for the locations of each group.</p>
</dd>
<dt><code>obs</code></dt>
<dd>
<p>Should the resistance distances be computed at the observation
locations?</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>Vector or list containing which groups to compute the distance
for. If <code>NULL</code>, it will be computed for all groups.</p>
</dd>
<dt><code>check_euclidean</code></dt>
<dd>
<p>Check if the graph used to compute the resistance distance has Euclidean edges? The graph used to compute the resistance distance has the observation locations as vertices.</p>
</dd>
<dt><code>include_vertices</code></dt>
<dd>
<p>Should the vertices of the graph be also included in the resulting matrix when using <code>FULL=TRUE</code>?</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The geodesic distances
are stored in the <code>res_dist</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-compute_resdist_PtE"></a>



<h4>Method <code>compute_resdist_PtE()</code>
</h4>

<p>Computes the resistance distance between the observation
locations.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_resdist_PtE(
  PtE,
  normalized = TRUE,
  include_vertices = FALSE,
  check_euclidean = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PtE</code></dt>
<dd>
<p>Points to compute the metric for.</p>
</dd>
<dt><code>normalized</code></dt>
<dd>
<p>Are the locations in PtE in normalized distance?</p>
</dd>
<dt><code>include_vertices</code></dt>
<dd>
<p>Should the original vertices be included in the
Laplacian matrix?</p>
</dd>
<dt><code>check_euclidean</code></dt>
<dd>
<p>Check if the graph used to compute the resistance distance has Euclidean edges? The graph used to compute the resistance distance has the observation locations as vertices.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A matrix containing the resistance distances.
</p>


<hr>
<a id="method-metric_graph-get_degrees"></a>



<h4>Method <code>get_degrees()</code>
</h4>

<p>Returns the degrees of the vertices in the metric graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_degrees(which = "degree")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt>
<dd>
<p>If "degree", returns the degree of the vertex. If "indegree", returns the indegree,
and if "outdegree", it returns the outdegree.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A vector containing the degrees of the vertices.
</p>


<hr>
<a id="method-metric_graph-compute_PtE_edges"></a>



<h4>Method <code>compute_PtE_edges()</code>
</h4>

<p>Computes the relative positions of the coordinates of the edges and save it as an attribute to each edge. This improves the quality of plots obtained by the <code>plot_function()</code> method, however it might be costly to compute.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_PtE_edges()</pre></div>



<h5>Returns</h5>

<p>No return value, called for its side effects.
</p>


<hr>
<a id="method-metric_graph-compute_resdist_mesh"></a>



<h4>Method <code>compute_resdist_mesh()</code>
</h4>

<p>Computes the resistance metric between the vertices in the
mesh.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_resdist_mesh()</pre></div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The geodesic distances
on the mesh are stored in the <code>mesh$res_dist</code> element in the <code>metric_graph</code>
object.
</p>


<hr>
<a id="method-metric_graph-compute_laplacian"></a>



<h4>Method <code>compute_laplacian()</code>
</h4>

<p>Computes the weigthed graph Laplacian for the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_laplacian(full = FALSE, obs = TRUE, group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>full</code></dt>
<dd>
<p>Should the resistance distances be computed for all
the available locations. If <code>FALSE</code>, it will be computed
separately for the locations of each group.</p>
</dd>
<dt><code>obs</code></dt>
<dd>
<p>Should the resistance distances be computed at the observation
locations? It will only compute for locations in which there is at least one observations that is not NA.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>Vector or list containing which groups to compute the
Laplacian for. If <code>NULL</code>, it will be computed for all groups.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No reutrn value. Called for its side effects. The Laplacian is stored
in the <code>Laplacian</code> element in the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-prune_vertices"></a>



<h4>Method <code>prune_vertices()</code>
</h4>

<p>Removes vertices of degree 2 from the metric graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$prune_vertices(check_weights = TRUE, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>check_weights</code></dt>
<dd>
<p>If <code>TRUE</code> will only prune edges with different weights.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>Print progress of pruning. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Vertices of degree 2 are removed as long as the corresponding edges that
would be merged are compatible in terms of direction.
</p>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-get_groups"></a>



<h4>Method <code>get_groups()</code>
</h4>

<p>Gets the groups from the data.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_groups(get_cols = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>get_cols</code></dt>
<dd>
<p>Should the names of the columns that created the group variable be returned?</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A vector containing the available groups in the internal data.
</p>


<hr>
<a id="method-metric_graph-get_PtE"></a>



<h4>Method <code>get_PtE()</code>
</h4>

<p>Gets PtE from the data.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_PtE()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt>
<dd>
<p>For which group, should the PtE be returned? <code>NULL</code> means that all PtEs available will be returned.</p>
</dd>
<dt><code>include_group</code></dt>
<dd>
<p>Should the group be included as a column? If <code>TRUE</code>, the PtEs for each group will be concatenated, otherwise a single matrix containing the unique PtEs will be returned.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A matrix with two columns, where the first column contains the edge
number and the second column contains the distance on edge of the
observation locations.
</p>


<hr>
<a id="method-metric_graph-get_edge_lengths"></a>



<h4>Method <code>get_edge_lengths()</code>
</h4>

<p>Gets the edge lengths with the corresponding unit.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_edge_lengths(unit = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>unit</code></dt>
<dd>
<p>If non-NULL, changes from <code>length_unit</code> from the graph construction to <code>unit</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a vector with the length unit (if the graph was constructed with a length unit).
</p>


<hr>
<a id="method-metric_graph-get_locations"></a>



<h4>Method <code>get_locations()</code>
</h4>

<p>Gets the spatial locations from the data.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_locations()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> object with observation locations. If <code>longlat = TRUE</code>, the column names are lon and lat, otherwise the column names are x and y.
</p>


<hr>
<a id="method-metric_graph-observation_to_vertex"></a>



<h4>Method <code>observation_to_vertex()</code>
</h4>

<p>Adds observation locations as vertices in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$observation_to_vertex(tolerance = 1e-15, mesh_warning = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tolerance</code></dt>
<dd>
<p>Observations locations are merged to a single vertex if
they are closer than this number (given in relative edge distance between
0 and 1). The default is <code>1e-15</code>.</p>
</dd>
<dt><code>mesh_warning</code></dt>
<dd>
<p>Display a warning if the graph structure change and the metric graph has a mesh object.</p>
</dd>
<dt><code>share_weights</code></dt>
<dd>
<p>Should the same weight be shared among the split edges? If <code>FALSE</code>, the weights will be removed, and a common weight given by 1 will be given.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-edgeweight_to_data"></a>



<h4>Method <code>edgeweight_to_data()</code>
</h4>

<p>Turns edge weights into data on the metric graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$edgeweight_to_data(
  loc = NULL,
  mesh = FALSE,
  data_loc = FALSE,
  weight_col = NULL,
  add = TRUE,
  data_coords = c("PtE", "spatial"),
  normalized = FALSE,
  tibble = TRUE,
  verbose = 1,
  suppress_warnings = FALSE,
  return = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>loc</code></dt>
<dd>
<p>A <code>matrix</code> or <code>data.frame</code> with two columns containing the locations to generate the data from the edge weights. If <code>data_coords</code> is 'spatial', the first column must be the x-coordinate of the data, and the second column must be the y-coordinate. If <code>data_coords</code> is 'PtE', the first column must be the edge number and the second column must be the distance on edge.</p>
</dd>
<dt><code>mesh</code></dt>
<dd>
<p>Should the data be generated to the mesh locations? In this case, the <code>loc</code> argument will be ignored. Observe that the metric graph must have a mesh built for one to use this option. CAUTION: To add edgeweight to data to both the data locations and mesh locations, please, add at the data locations first, then to mesh locations.</p>
</dd>
<dt><code>data_loc</code></dt>
<dd>
<p>Should the data be generated to the data locations? In this case, the <code>loc</code> argument will be ignored. Observe that the metric graph must have data for one to use this option. CAUTION: To add edgeweight to data to both the data locations and mesh locations, please, add at the data locations first, then to mesh locations.</p>
</dd>
<dt><code>weight_col</code></dt>
<dd>
<p>Which columns of the edge weights should be turned into data? If <code>NULL</code>, all columns will be turned into data.</p>
</dd>
<dt><code>add</code></dt>
<dd>
<p>Should the data generated be added to the metric graph internal data?</p>
</dd>
<dt><code>data_coords</code></dt>
<dd>
<p>To be used only if <code>mesh</code> is <code>FALSE</code>. It decides which
coordinate system to use. If <code>PtE</code>, the user must provide <code>edge_number</code> and
<code>distance_on_edge</code>, otherwise if <code>spatial</code>, the user must provide
<code>coord_x</code> and <code>coord_y</code>.</p>
</dd>
<dt><code>normalized</code></dt>
<dd>
<p>if TRUE, then the distances in <code>distance_on_edge</code> are
assumed to be normalized to (0,1). Default FALSE.</p>
</dd>
<dt><code>tibble</code></dt>
<dd>
<p>Should the data be returned as a <code>tidyr::tibble</code>?</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>Print progress of the steps when adding observations. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
<dt><code>suppress_warnings</code></dt>
<dd>
<p>Suppress warnings related to duplicated observations?</p>
</dd>
<dt><code>return</code></dt>
<dd>
<p>Should the data be returned? If <code>return_removed</code> is <code>TRUE</code>, only the removed locations will be return (if there is any).</p>
</dd>
</dl>
</div>


<hr>
<a id="method-metric_graph-get_mesh_locations"></a>



<h4>Method <code>get_mesh_locations()</code>
</h4>

<p>Returns a list or a matrix with the mesh locations.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_mesh_locations(bru = FALSE, loc = NULL, normalized = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bru</code></dt>
<dd>
<p>Should an 'inlabru'-friendly list be returned?</p>
</dd>
<dt><code>loc</code></dt>
<dd>
<p>If <code>bru</code> is set to <code>TRUE</code>, the name of the location variable.
The default name is 'loc'.</p>
</dd>
<dt><code>normalized</code></dt>
<dd>
<p>If TRUE, then the distances in <code>distance_on_edge</code> are
assumed to be normalized to (0,1). Default TRUE.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list or a matrix containing the mesh locations.
</p>


<hr>
<a id="method-metric_graph-clear_observations"></a>



<h4>Method <code>clear_observations()</code>
</h4>

<p>Clear all observations from the <code>metric_graph</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$clear_observations()</pre></div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-process_data"></a>



<h4>Method <code>process_data()</code>
</h4>

<p>Process data to the metric graph data format.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$process_data(
  data = NULL,
  edge_number = "edge_number",
  distance_on_edge = "distance_on_edge",
  coord_x = "coord_x",
  coord_y = "coord_y",
  data_coords = c("PtE", "spatial"),
  group = NULL,
  group_sep = ".",
  normalized = FALSE,
  tibble = TRUE,
  duplicated_strategy = "closest",
  include_distance_to_graph = TRUE,
  only_return_removed = FALSE,
  tolerance = max(self$edge_lengths)/2,
  verbose = FALSE,
  suppress_warnings = FALSE,
  Spoints = lifecycle::deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p>A <code>data.frame</code> or named list containing the observations. In
case of groups, the data.frames for the groups should be stacked vertically,
with a column indicating the index of the group. If <code>data</code> is not <code>NULL</code>,
it takes priority over any eventual data in <code>Spoints</code>.</p>
</dd>
<dt><code>edge_number</code></dt>
<dd>
<p>Column (or entry on the list) of the <code>data</code> that
contains the edge numbers. If not supplied, the column with name
"edge_number" will be chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code>.</p>
</dd>
<dt><code>distance_on_edge</code></dt>
<dd>
<p>Column (or entry on the list) of the <code>data</code> that
contains the edge numbers. If not supplied, the column with name
"distance_on_edge" will be chosen.  Will not be used if <code>Spoints</code> is not
<code>NULL</code>.</p>
</dd>
<dt><code>coord_x</code></dt>
<dd>
<p>Column (or entry on the list) of the <code>data</code> that contains
the x coordinate. If not supplied, the column with name "coord_x" will be
chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code> or if <code>data_coords</code> is
<code>PtE</code>.</p>
</dd>
<dt><code>coord_y</code></dt>
<dd>
<p>Column (or entry on the list) of the <code>data</code> that contains
the y coordinate. If not supplied, the column with name "coord_x" will be
chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code> or if <code>data_coords</code> is
<code>PtE</code>.</p>
</dd>
<dt><code>data_coords</code></dt>
<dd>
<p>It decides which
coordinate system to use. If <code>PtE</code>, the user must provide <code>edge_number</code> and
<code>distance_on_edge</code>, otherwise if <code>spatial</code>, the user must provide
<code>coord_x</code> and <code>coord_y</code>. The option <code>euclidean</code> is <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a>. Use <code>spatial</code> instead.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>Vector. If the data is grouped (for example measured at different time
points), this argument specifies the columns (or entries on the list) in
which the group variables are stored. It will be stored as a single column <code>.group</code> with the combined entries.</p>
</dd>
<dt><code>group_sep</code></dt>
<dd>
<p>separator character for creating the new group variable when grouping two or more variables.</p>
</dd>
<dt><code>normalized</code></dt>
<dd>
<p>if TRUE, then the distances in <code>distance_on_edge</code> are
assumed to be normalized to (0,1). Default FALSE.</p>
</dd>
<dt><code>tibble</code></dt>
<dd>
<p>Should the data be returned as a <code>tidyr::tibble</code>?</p>
</dd>
<dt><code>duplicated_strategy</code></dt>
<dd>
<p>Which strategy to handle observations on the same location on the metric graph (that is, if there are two or more observations projected at the same location).
The options are 'closest' and 'jitter'. If 'closest', only the closest observation will be used. If 'jitter', a small perturbation will be performed on the projected observation location. The default is 'closest'.</p>
</dd>
<dt><code>include_distance_to_graph</code></dt>
<dd>
<p>When <code>data_coord</code> is 'spatial', should the distance of the observations to the graph be included as a column?</p>
</dd>
<dt><code>only_return_removed</code></dt>
<dd>
<p>Should the removed data (if it exists) when using 'closest' <code>duplicated_strategy</code> be returned instead of the processed data?</p>
</dd>
<dt><code>tolerance</code></dt>
<dd>
<p>Parameter to control a warning when adding observations.
If the distance of some location and the closest point on the graph is
greater than the tolerance, the function will display a warning.
This helps detecting mistakes on the input locations when adding new data.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>If <code>TRUE</code>, report steps and times.</p>
</dd>
<dt><code>suppress_warnings</code></dt>
<dd>
<p>Suppress warnings related to duplicated observations?</p>
</dd>
<dt><code>Spoints</code></dt>
<dd>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a> Use <code>data</code> instead.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The observations are
stored in the <code>data</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-add_observations"></a>



<h4>Method <code>add_observations()</code>
</h4>

<p>Add observations to the metric graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$add_observations(
  data = NULL,
  edge_number = "edge_number",
  distance_on_edge = "distance_on_edge",
  coord_x = "coord_x",
  coord_y = "coord_y",
  data_coords = c("PtE", "spatial"),
  group = NULL,
  group_sep = ".",
  normalized = FALSE,
  clear_obs = FALSE,
  tibble = FALSE,
  tolerance = max(self$edge_lengths)/2,
  duplicated_strategy = "closest",
  include_distance_to_graph = TRUE,
  return_removed = TRUE,
  verbose = 1,
  suppress_warnings = FALSE,
  Spoints = lifecycle::deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p>A <code>data.frame</code> or named list containing the observations. In
case of groups, the data.frames for the groups should be stacked vertically,
with a column indicating the index of the group. <code>data</code> can also be an <code>sf</code> object or a
<code>SpatialPointsDataFrame</code> object.
in which case <code>data_coords</code> will automatically be spatial, and there is no need to specify the <code>coord_x</code> or <code>coord_y</code> arguments.</p>
</dd>
<dt><code>edge_number</code></dt>
<dd>
<p>Column (or entry on the list) of the <code>data</code> that
contains the edge numbers. If not supplied, the column with name
"edge_number" will be chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code>.</p>
</dd>
<dt><code>distance_on_edge</code></dt>
<dd>
<p>Column (or entry on the list) of the <code>data</code> that
contains the edge numbers. If not supplied, the column with name
"distance_on_edge" will be chosen.  Will not be used if <code>Spoints</code> is not
<code>NULL</code>.</p>
</dd>
<dt><code>coord_x</code></dt>
<dd>
<p>Column (or entry on the list) of the <code>data</code> that contains
the x coordinate. If not supplied, the column with name "coord_x" will be
chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code> or if <code>data_coords</code> is
<code>PtE</code>.</p>
</dd>
<dt><code>coord_y</code></dt>
<dd>
<p>Column (or entry on the list) of the <code>data</code> that contains
the y coordinate. If not supplied, the column with name "coord_x" will be
chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code> or if <code>data_coords</code> is
<code>PtE</code>.</p>
</dd>
<dt><code>data_coords</code></dt>
<dd>
<p>It decides which
coordinate system to use. If <code>PtE</code>, the user must provide <code>edge_number</code> and
<code>distance_on_edge</code>, otherwise if <code>spatial</code>, the user must provide
<code>coord_x</code> and <code>coord_y</code>. The option <code>euclidean</code> is <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a>. Use <code>spatial</code> instead.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>Vector. If the data is grouped (for example measured at different time
points), this argument specifies the columns (or entries on the list) in
which the group variables are stored. It will be stored as a single column <code>.group</code> with the combined entries.</p>
</dd>
<dt><code>group_sep</code></dt>
<dd>
<p>separator character for creating the new group variable when grouping two or more variables.</p>
</dd>
<dt><code>normalized</code></dt>
<dd>
<p>if TRUE, then the distances in <code>distance_on_edge</code> are
assumed to be normalized to (0,1). Default FALSE.</p>
</dd>
<dt><code>clear_obs</code></dt>
<dd>
<p>Should the existing observations be removed before adding the data?</p>
</dd>
<dt><code>tibble</code></dt>
<dd>
<p>Should the data be returned as a <code>tidyr::tibble</code>?</p>
</dd>
<dt><code>tolerance</code></dt>
<dd>
<p>Parameter to control a warning when adding observations.
If the distance of some location and the closest point on the graph is
greater than the tolerance, the function will display a warning.
This helps detecting mistakes on the input locations when adding new data.</p>
</dd>
<dt><code>duplicated_strategy</code></dt>
<dd>
<p>Which strategy to handle observations on the same location on the metric graph (that is, if there are two or more observations projected at the same location).
The options are 'closest' and 'jitter'. If 'closest', only the closest observation will be used. If 'jitter', a small perturbation will be performed on the projected observation location. The default is 'closest'.</p>
</dd>
<dt><code>include_distance_to_graph</code></dt>
<dd>
<p>When <code>data_coord</code> is 'spatial', should the distance of the observations to the graph be included as a column?</p>
</dd>
<dt><code>return_removed</code></dt>
<dd>
<p>Should the removed data (if it exists) when using 'closest' <code>duplicated_strategy</code> be returned?</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>Print progress of the steps when adding observations. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
<dt><code>suppress_warnings</code></dt>
<dd>
<p>Suppress warnings related to duplicated observations?</p>
</dd>
<dt><code>Spoints</code></dt>
<dd>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a> Use <code>data</code> instead.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The observations are
stored in the <code>data</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-mutate"></a>



<h4>Method <code>mutate()</code>
</h4>

<p>Use <code>dplyr::mutate</code> function on the internal metric graph data object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$mutate(..., .drop_na = FALSE, .drop_all_na = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Arguments to be passed to <code>dplyr::mutate()</code>.</p>
</dd>
<dt><code>.drop_na</code></dt>
<dd>
<p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt>
<dd>
<p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::mutate()</code> within the internal metric graph data object.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code> object containing the resulting data list after the mutate.
</p>


<hr>
<a id="method-metric_graph-drop_na"></a>



<h4>Method <code>drop_na()</code>
</h4>

<p>Use <code>tidyr::drop_na()</code> function on the internal metric graph data object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$drop_na(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Arguments to be passed to <code>tidyr::drop_na()</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::drop_na()</code> within the internal metric graph data object.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code> object containing the resulting data list after the drop_na.
</p>


<hr>
<a id="method-metric_graph-select"></a>



<h4>Method <code>select()</code>
</h4>

<p>Use <code>dplyr::select</code> function on the internal metric graph data object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$select(..., .drop_na = FALSE, .drop_all_na = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Arguments to be passed to <code>dplyr::select()</code>.</p>
</dd>
<dt><code>.drop_na</code></dt>
<dd>
<p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt>
<dd>
<p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::select()</code> within the internal metric graph data object. Observe that it is a bit different from directly using <code>dplyr::select()</code> since it does not allow to remove the internal positions that are needed for the metric_graph methods to work.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code> object containing the resulting data list after the selection.
</p>


<hr>
<a id="method-metric_graph-filter"></a>



<h4>Method <code>filter()</code>
</h4>

<p>Use <code>dplyr::filter</code> function on the internal metric graph data object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$filter(..., .drop_na = FALSE, .drop_all_na = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Arguments to be passed to <code>dplyr::filter()</code>.</p>
</dd>
<dt><code>.drop_na</code></dt>
<dd>
<p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt>
<dd>
<p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::filter()</code> within the internal metric graph data object.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code> object containing the resulting data list after the filter.
</p>


<hr>
<a id="method-metric_graph-summarise"></a>



<h4>Method <code>summarise()</code>
</h4>

<p>Use <code>dplyr::summarise</code> function on the internal metric graph data object grouped by the spatial locations and the internal group variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$summarise(
  ...,
  .include_graph_groups = FALSE,
  .groups = NULL,
  .drop_na = FALSE,
  .drop_all_na = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Arguments to be passed to <code>dplyr::summarise()</code>.</p>
</dd>
<dt><code>.include_graph_groups</code></dt>
<dd>
<p>Should the internal graph groups be included in the grouping variables? The default is <code>FALSE</code>. This means that, when summarising, the data will be grouped by the internal group variable together with the spatial locations.</p>
</dd>
<dt><code>.groups</code></dt>
<dd>
<p>A vector of strings containing the names of the columns to be additionally grouped, when computing the summaries. The default is <code>NULL</code>.</p>
</dd>
<dt><code>.drop_na</code></dt>
<dd>
<p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt>
<dd>
<p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::summarise()</code> within the internal metric graph data object grouped by manually inserted groups (optional), the internal group variable (optional) and the spatial locations. Observe that if the integral group variable was not used as a grouping variable for the summarise, a new column, called <code>.group</code>, will be added, with the same value 1 for all rows.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code> object containing the resulting data list after the summarise.
</p>


<hr>
<a id="method-metric_graph-get_data"></a>



<h4>Method <code>get_data()</code>
</h4>

<p>Return the internal data with the option to filter by groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_data(
  group = NULL,
  tibble = TRUE,
  drop_na = FALSE,
  drop_all_na = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt>
<dd>
<p>A vector contaning which groups should be returned? The default is <code>NULL</code>, which gives the result for the all groups.</p>
</dd>
<dt><code>tibble</code></dt>
<dd>
<p>Should the data be returned as a <code>tidyr::tibble</code>?</p>
</dd>
<dt><code>drop_na</code></dt>
<dd>
<p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>drop_all_na</code></dt>
<dd>
<p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-metric_graph-buildDirectionalConstraints"></a>



<h4>Method <code>buildDirectionalConstraints()</code>
</h4>

<p>Build directional ODE constraint matrix from edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$buildDirectionalConstraints(alpha = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt>
<dd>
<p>how many derivatives the processes has</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Currently not implemented for circles (edges that start and end
in the same vertex)
</p>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-buildC"></a>



<h4>Method <code>buildC()</code>
</h4>

<p>Build Kirchoff constraint matrix from edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$buildC(alpha = 2, edge_constraint = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt>
<dd>
<p>the type of constraint (currently only supports 2)</p>
</dd>
<dt><code>edge_constraint</code></dt>
<dd>
<p>if TRUE, add constraints on vertices of degree 1</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Currently not implemented for circles (edges that start and end
in the same vertex)
</p>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-build_mesh"></a>



<h4>Method <code>build_mesh()</code>
</h4>

<p>Builds mesh object for graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$build_mesh(
  h = NULL,
  n = NULL,
  continuous = TRUE,
  continuous.outs = FALSE,
  continuous.deg2 = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>h</code></dt>
<dd>
<p>Maximum distance between mesh nodes (should be provided if n is
not provided).</p>
</dd>
<dt><code>n</code></dt>
<dd>
<p>Maximum number of nodes per edge (should be provided if h is not
provided).</p>
</dd>
<dt><code>continuous</code></dt>
<dd>
<p>If <code>TRUE</code> (default), the mesh contains only one node per vertex.
If <code>FALSE</code>, each vertex v is split into deg(v) disconnected nodes to allow
for the creation of discontinuities at the vertices.</p>
</dd>
<dt><code>continuous.outs</code></dt>
<dd>
<p>If <code>continuous = FALSE</code> and <code>continuous.outs = TRUE</code>, continuity is
assumed for the outgoing edges from each vertex.</p>
</dd>
<dt><code>continuous.deg2</code></dt>
<dd>
<p>If <code>TRUE</code>, continuity is assumed at degree 2 vertices.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The mesh is a list with the objects:
</p>

<ul>
<li> <p><code>PtE</code> The mesh locations excluding the original vertices;
</p>
</li>
<li> <p><code>V</code> The verties of the mesh;
</p>
</li>
<li> <p><code>E</code> The edges of the mesh;
</p>
</li>
<li> <p><code>n_e</code> The number of vertices in the mesh per original edge in the graph;
</p>
</li>
<li> <p><code>h_e</code> The mesh width per edge in the graph;
</p>
</li>
<li> <p><code>ind</code> The indices of the vertices in the mesh;
</p>
</li>
<li> <p><code>VtE</code> All mesh locations including the original vertices.
</p>
</li>
</ul>
<h5>Returns</h5>

<p>No return value. Called for its side effects. The mesh is stored in
the <code>mesh</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-compute_fem"></a>



<h4>Method <code>compute_fem()</code>
</h4>

<p>Build mass and stiffness matrices for given mesh object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_fem(petrov = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>petrov</code></dt>
<dd>
<p>Compute Petrov-Galerkin matrices? (default <code>FALSE</code>). These
are defined as <code class="reqn">Cpet_{ij} = &lt;\phi_i, \psi_j&gt;</code> and <code class="reqn">Gpet_{ij} = &lt;d\phi_i, \psi_j&gt;</code>,
where <code class="reqn">\psi_{i}</code> are piecewise constant basis functions on the edges of
the mesh.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The function builds: The matrix <code>C</code> which is the mass matrix with
elements <code class="reqn">C_{ij} = &lt;\phi_i, \phi_j&gt;</code>, the matrix <code>G</code> which is the stiffness
matrix with elements <code class="reqn">G_{ij} = &lt;d\phi_i, d\phi_j&gt;</code>, the matrix <code>B</code> with
elements <code class="reqn">B_{ij} = &lt;d\phi_i, \phi_j&gt;</code>, the matrix <code>D</code> with elements
<code class="reqn">D_{ij} = \sum_{v\in V}\phi_i(v)\phi_j(v)</code>, and the vector with weights
<code class="reqn">&lt;\phi_i, 1&gt;</code>.
</p>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The finite element
matrices <code>C</code>, <code>G</code> and <code>B</code> are stored in the <code>mesh</code> element in the
<code>metric_graph</code> object. If <code>petrov=TRUE</code>, the corresponding Petrov-Galerkin
matrices are stored in <code>Cpet</code> and <code>Gpet</code>.
</p>


<hr>
<a id="method-metric_graph-mesh_A"></a>



<h4>Method <code>mesh_A()</code>
</h4>

<p>Deprecated - Computes observation matrix for mesh.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a> in favour of <code>metric_graph$fem_basis()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$mesh_A(PtE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PtE</code></dt>
<dd>
<p>Locations given as (edge number in graph, normalized location on
edge)</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For n locations and a mesh with m nodes, <code>A</code> is an n x m matrix with
elements <code class="reqn">A_{ij} = \phi_j(s_i)</code>.
</p>



<h5>Returns</h5>

<p>The observation matrix.
</p>


<hr>
<a id="method-metric_graph-fem_basis"></a>



<h4>Method <code>fem_basis()</code>
</h4>

<p>Computes observation matrix for mesh.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$fem_basis(PtE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PtE</code></dt>
<dd>
<p>Locations given as (edge number in graph, normalized location on
edge)</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For n locations and a mesh with m nodes, <code>A</code> is an n x m matrix with
elements <code class="reqn">A_{ij} = \phi_j(s_i)</code>.
</p>



<h5>Returns</h5>

<p>The observation matrix.
</p>


<hr>
<a id="method-metric_graph-VtEfirst"></a>



<h4>Method <code>VtEfirst()</code>
</h4>

<p>Find one edge corresponding to each vertex.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$VtEfirst()</pre></div>



<h5>Returns</h5>

<p>A nV x 2 matrix the first element of the <code>i</code>th row is the edge
number corresponding to the <code>i</code>th vertex and the second value is 0
if the vertex is at the start of the edge and 1 if the vertex
is at the end of the edge.
</p>


<hr>
<a id="method-metric_graph-plot"></a>



<h4>Method <code>plot()</code>
</h4>

<p>Plots the metric graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$plot(
  data = NULL,
  newdata = NULL,
  group = 1,
  plotly = FALSE,
  interactive = FALSE,
  vertex_size = 3,
  vertex_color = "black",
  edge_width = 0.3,
  edge_color = "black",
  data_size = 1,
  support_width = 0.5,
  support_color = "gray",
  mesh = FALSE,
  X = NULL,
  X_loc = NULL,
  p = NULL,
  degree = FALSE,
  direction = FALSE,
  edge_weight = NULL,
  edge_width_weight = NULL,
  scale_color_main = ggplot2::scale_color_viridis_c(option = "D"),
  scale_color_weights = ggplot2::scale_color_viridis_c(option = "C"),
  scale_color_degree = ggplot2::scale_color_viridis_d(option = "D"),
  add_new_scale_weights = TRUE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p>Which column of the data to plot? If <code>NULL</code>, no data will be
plotted.</p>
</dd>
<dt><code>newdata</code></dt>
<dd>
<p>A dataset of class <code>metric_graph_data</code>, obtained by any <code>get_data()</code>, <code>mutate()</code>, <code>filter()</code>, <code>summarise()</code>, <code>drop_na()</code> methods of metric graphs, see the vignette on data manipulation for more details.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>If there are groups, which group to plot? If <code>group</code> is a
number, it will be the index of the group as stored internally. If <code>group</code>
is a character, then the group will be chosen by its name.</p>
</dd>
<dt><code>plotly</code></dt>
<dd>
<p>Use plot_ly for 3D plot (default <code>FALSE</code>). This option
requires the 'plotly' package.</p>
</dd>
<dt><code>interactive</code></dt>
<dd>
<p>Only works for 2d plots. If <code>TRUE</code>, an interactive plot will be displayed. Unfortunately, <code>interactive</code> is not compatible with <code>edge_weight</code> if <code>add_new_scale_weights</code> is TRUE.</p>
</dd>
<dt><code>vertex_size</code></dt>
<dd>
<p>Size of the vertices.</p>
</dd>
<dt><code>vertex_color</code></dt>
<dd>
<p>Color of vertices.</p>
</dd>
<dt><code>edge_width</code></dt>
<dd>
<p>Line width for edges. If <code>edge_width_weight</code> is not <code>NULL</code>, this determines the maximum edge width.</p>
</dd>
<dt><code>edge_color</code></dt>
<dd>
<p>Color of edges.</p>
</dd>
<dt><code>data_size</code></dt>
<dd>
<p>Size of markers for data.</p>
</dd>
<dt><code>support_width</code></dt>
<dd>
<p>For 3D plot, width of support lines.</p>
</dd>
<dt><code>support_color</code></dt>
<dd>
<p>For 3D plot, color of support lines.</p>
</dd>
<dt><code>mesh</code></dt>
<dd>
<p>Plot the mesh locations?</p>
</dd>
<dt><code>X</code></dt>
<dd>
<p>Additional values to plot.</p>
</dd>
<dt><code>X_loc</code></dt>
<dd>
<p>Locations of the additional values in the format
(edge, normalized distance on edge).</p>
</dd>
<dt><code>p</code></dt>
<dd>
<p>Existing objects obtained from 'ggplot2' or 'plotly' to add the graph to</p>
</dd>
<dt><code>degree</code></dt>
<dd>
<p>Show the degrees of the vertices?</p>
</dd>
<dt><code>direction</code></dt>
<dd>
<p>Show the direction of the edges?</p>
</dd>
<dt><code>edge_weight</code></dt>
<dd>
<p>Which column from edge weights to plot? If <code>NULL</code> edge weights are not plotted. To plot the edge weights when the metric graph <code>edge_weights</code> is a vector instead of a <code>data.frame</code>, simply set to 1.
<code>edge_weight</code> is only available for 2d plots. For 3d plots with edge weights, please use the <code>plot_function()</code> method.</p>
</dd>
<dt><code>edge_width_weight</code></dt>
<dd>
<p>Which column from edge weights to determine the edges widths? If <code>NULL</code> edge width will be determined from <code>edge_width</code>.</p>
</dd>
<dt><code>scale_color_main</code></dt>
<dd>
<p>Color scale for the data to be plotted.</p>
</dd>
<dt><code>scale_color_weights</code></dt>
<dd>
<p>Color scale for the edge weights. Will only be used if <code>add_new_scale_weights</code> is TRUE.</p>
</dd>
<dt><code>scale_color_degree</code></dt>
<dd>
<p>Color scale for the degrees.</p>
</dd>
<dt><code>add_new_scale_weights</code></dt>
<dd>
<p>Should a new color scale for the edge weights be created?</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments to pass to <code>ggplot()</code> or <code>plot_ly()</code></p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>plot_ly</code> (if <code>plotly = TRUE</code>) or <code>ggplot</code> object.
</p>


<hr>
<a id="method-metric_graph-plot_connections"></a>



<h4>Method <code>plot_connections()</code>
</h4>

<p>Plots the connections in the graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$plot_connections()</pre></div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-is_tree"></a>



<h4>Method <code>is_tree()</code>
</h4>

<p>Checks if the graph is a tree (without considering directions)
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$is_tree()</pre></div>



<h5>Returns</h5>

<p>TRUE if the graph is a tree and FALSE otherwise.
</p>


<hr>
<a id="method-metric_graph-plot_function"></a>



<h4>Method <code>plot_function()</code>
</h4>

<p>Plots continuous function on the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$plot_function(
  data = NULL,
  newdata = NULL,
  group = 1,
  X = NULL,
  plotly = FALSE,
  improve_plot = FALSE,
  continuous = TRUE,
  edge_weight = NULL,
  vertex_size = 5,
  vertex_color = "black",
  edge_width = 1,
  edge_color = "black",
  line_width = NULL,
  line_color = "rgb(0,0,200)",
  scale_color = ggplot2::scale_color_viridis_c(option = "d"),
  support_width = 0.5,
  support_color = "gray",
  p = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p>Which column of the data to plot? If <code>NULL</code>, no data will be
plotted.</p>
</dd>
<dt><code>newdata</code></dt>
<dd>
<p>A dataset of class <code>metric_graph_data</code>, obtained by any <code>get_data()</code>, <code>mutate()</code>, <code>filter()</code>, <code>summarise()</code>, <code>drop_na()</code> methods of metric graphs, see the vignette on data manipulation for more details.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>If there are groups, which group to plot? If <code>group</code> is a
number, it will be the index of the group as stored internally. If <code>group</code>
is a character, then the group will be chosen by its name.</p>
</dd>
<dt><code>X</code></dt>
<dd>
<p>A vector with values for the function
evaluated at the mesh in the graph</p>
</dd>
<dt><code>plotly</code></dt>
<dd>
<p>If <code>TRUE</code>, then the plot is shown in 3D. This option requires
the package 'plotly'.</p>
</dd>
<dt><code>improve_plot</code></dt>
<dd>
<p>Should the original edge coordinates be added to the data with linearly interpolated values to improve the plot?</p>
</dd>
<dt><code>continuous</code></dt>
<dd>
<p>Should continuity be assumed when the plot uses <code>newdata</code>?</p>
</dd>
<dt><code>edge_weight</code></dt>
<dd>
<p>Which column from edge weights to plot? If <code>NULL</code> edge weights are not plotted. To plot the edge weights when the metric graph <code>edge_weights</code> is a vector instead of a <code>data.frame</code>, simply set to 1.</p>
</dd>
<dt><code>vertex_size</code></dt>
<dd>
<p>Size of the vertices.</p>
</dd>
<dt><code>vertex_color</code></dt>
<dd>
<p>Color of vertices.</p>
</dd>
<dt><code>edge_width</code></dt>
<dd>
<p>Width for edges.</p>
</dd>
<dt><code>edge_color</code></dt>
<dd>
<p>For 3D plot, color of edges.</p>
</dd>
<dt><code>line_width</code></dt>
<dd>
<p>For 3D plot, line width of the function curve.</p>
</dd>
<dt><code>line_color</code></dt>
<dd>
<p>Color of the function curve.</p>
</dd>
<dt><code>scale_color</code></dt>
<dd>
<p>Color scale to be used for data and weights.</p>
</dd>
<dt><code>support_width</code></dt>
<dd>
<p>For 3D plot, width of support lines.</p>
</dd>
<dt><code>support_color</code></dt>
<dd>
<p>For 3D plot, color of support lines.</p>
</dd>
<dt><code>p</code></dt>
<dd>
<p>Previous plot to which the new plot should be added.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments for <code>ggplot()</code> or <code>plot_ly()</code></p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Either a <code>ggplot</code> (if <code>plotly = FALSE</code>) or a <code>plot_ly</code> object.
</p>


<hr>
<a id="method-metric_graph-plot_movie"></a>



<h4>Method <code>plot_movie()</code>
</h4>

<p>Plots a movie of a continuous function evolving on the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$plot_movie(
  X,
  plotly = TRUE,
  vertex_size = 5,
  vertex_color = "black",
  edge_width = 1,
  edge_color = "black",
  line_width = NULL,
  line_color = "rgb(0,0,200)",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt>
<dd>
<p>A m x T matrix where the ith column represents the function at the
ith time, evaluated at the mesh locations.</p>
</dd>
<dt><code>plotly</code></dt>
<dd>
<p>If <code>TRUE</code>, then plot is shown in 3D. This option requires the
package 'plotly'.</p>
</dd>
<dt><code>vertex_size</code></dt>
<dd>
<p>Size of the vertices.</p>
</dd>
<dt><code>vertex_color</code></dt>
<dd>
<p>Color of vertices.</p>
</dd>
<dt><code>edge_width</code></dt>
<dd>
<p>Width for edges.</p>
</dd>
<dt><code>edge_color</code></dt>
<dd>
<p>For 3D plot, color of edges.</p>
</dd>
<dt><code>line_width</code></dt>
<dd>
<p>For 3D plot, line width of the function curve.</p>
</dd>
<dt><code>line_color</code></dt>
<dd>
<p>Color of the function curve.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments for ggplot or plot_ly.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Either a <code>ggplot</code> (if <code>plotly=FALSE</code>) or a <code>plot_ly</code> object.
</p>


<hr>
<a id="method-metric_graph-add_mesh_observations"></a>



<h4>Method <code>add_mesh_observations()</code>
</h4>

<p>Add observations on mesh to the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$add_mesh_observations(data = NULL, group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p>A <code>data.frame</code> or named list containing the observations.
In case of groups, the data.frames for the groups should be stacked vertically,
with a column indicating the index of the group. If <code>data_frame</code> is not
<code>NULL</code>, it takes priority over any eventual data in <code>Spoints</code>.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>If the data_frame contains groups, one must provide the column
in which the group indices are stored.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The observations are
stored in the <code>data</code> element in the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-get_initial_graph"></a>



<h4>Method <code>get_initial_graph()</code>
</h4>

<p>Returns a copy of the initial metric graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_initial_graph()</pre></div>



<h5>Returns</h5>

<p>A <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-coordinates"></a>



<h4>Method <code>coordinates()</code>
</h4>

<p>Convert between locations on the graph and Euclidean
coordinates.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$coordinates(PtE = NULL, XY = NULL, normalized = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PtE</code></dt>
<dd>
<p>Matrix with locations on the graph (edge number and normalized
position on the edge).</p>
</dd>
<dt><code>XY</code></dt>
<dd>
<p>Matrix with locations in Euclidean space</p>
</dd>
<dt><code>normalized</code></dt>
<dd>
<p>If <code>TRUE</code>, it is assumed that the positions in <code>PtE</code> are
normalized to (0,1), and the object returned if <code>XY</code> is specified contains
normalized locations.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>If <code>PtE</code> is specified, then a matrix with Euclidean coordinates of
the locations is returned. If <code>XY</code> is provided, then a matrix with the
closest locations on the graph is returned.
Gets the edge weights
data.frame If the edge weights are given as vectors, should the result be returned as a data.frame?
A vector or <code>data.frame</code> containing the edge weights.
data List containing data on the metric graph.
</p>


<hr>
<a id="method-metric_graph-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">edge1 &lt;- rbind(c(0, 0), c(2, 0))
edge2 &lt;- rbind(c(2, 0), c(1, 1))
edge3 &lt;- rbind(c(1, 1), c(0, 0))
edges &lt;- list(edge1, edge2, edge3)
graph &lt;- metric_graph$new(edges)
graph$plot()

</code></pre>


</div>