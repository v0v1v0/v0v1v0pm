<div class="container">

<table style="width: 100%;"><tr>
<td>apk</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Average Precision at k</h2>

<h3>Description</h3>

<p><code>apk</code> computes the average precision at k, in the context of information
retrieval problems.
</p>


<h3>Usage</h3>

<pre><code class="language-R">apk(k, actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of elements of <code>predicted</code> to consider in the calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>actual</code></td>
<td>
<p>The ground truth vector of relevant documents. The vector can contain
any numeric or character values, order does not matter, and the
vector does not need to be the same length as <code>predicted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predicted</code></td>
<td>
<p>The predicted vector of retrieved documents. The vector can
contain any numeric of character values. However, unlike <code>actual</code>,
order does matter, with the most documents deemed most likely to
be relevant at the beginning.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>apk</code> loops over the first k values of <code>predicted</code>. For each value, if
the value is contained within <code>actual</code> and has not been predicted before,
we increment the number of sucesses by one and increment our score by the number
of successes divided by k. Then, we return our final score divided by the number
of relevant documents (i.e. the length of <code>actual</code>).
</p>
<p><code>apk</code> will return <code>NaN</code> if <code>length(actual)</code> equals <code>0</code>.
</p>


<h3>See Also</h3>

<p><code>apk</code> <code>f1</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">actual &lt;- c('a', 'b', 'd')
predicted &lt;- c('b', 'c', 'a', 'e', 'f')
apk(3, actual, predicted)
</code></pre>


</div>