<div class="container">

<table style="width: 100%;"><tr>
<td>MfU.Sample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Drawing MCMC Samples from a Multivariate Distribution Using a Univariate Sampler
</h2>

<h3>Description</h3>

<p>This function is an extended Gibbs wrapper around univariate samplers to allow for drawing samples from multivariate distributions. Four univariate samplers are currently available: 1) slice sample with stepout and shrinkage (Neal 2003, using Radford Neal's <code>R</code> code from his homepage), and 2) adaptive rejection sampling (Gilks and Wild 1992, using <code>ars</code> function from <span class="pkg">ars</span> package), 3) adaptive rejection Metropolis (Gilks et al 1995, using <code>arms</code> function  from <span class="pkg">HI</span> package), and 4) univariate Metropolis with Gaussian proposal. The wrapper performs a full cycle of univariate sampling steps, one coordinate at a time. In each step, the latest sample values obtained for other coordinates are used to form the conditional distributions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MfU.Sample(x, f, uni.sampler = "slice", ...
  , control = MfU.Control(length(x)))
MfU.Sample.Run(x, f, uni.sampler = c("slice", "ars", "arms", "unimet"), ...
  , control = MfU.Control(length(x)), nsmp = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Initial value for the multivariate distribution. It must be a numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>The multivariate log-density to be sampled. For any of <code>{"slice", "arms", "unimet"}</code>, the function must return the log-density (up to a constant). For <code>"ars"</code>, the function must accept a boolean flag <code>grad</code> and return the log-density (<code>grad=FALSE</code>) or its gradient (<code>grad=TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uni.sampler</code></td>
<td>
<p>Name of univariate sampler to be used. Default is "<code>slice</code>", standing for the univariate Slice Sampler with stepout and shrinkage, as described in Neal (2003). Other options are <code>"ars"</code>, referring to adaptive rejection sampling algorithm of Gilks and Wild (1992), <code>"arms"</code>, referring to adaptive rejection Metropolis algorithm of Gilks et al (1995), and <code>"unimet"</code>, referring to univariate Metropolis with Gaussian proposal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to be passed to <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>List of parameters controlling the execution of univariate samplers. See <code>MfU.Control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsmp</code></td>
<td>
<p>Number of MCMC samples to generate in <code>MfU.Sample.Run</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the case of ARS, the wrapper is an exact implementation of Gibbs sampling (Geman and Geman 1984), while for the other 3 samplers the wrapper can be considered a generalization of Gibbs sampling, where instead of drawing a sample from each conditional distribution, we perform a state transition for which the conditional probability is an invariant distribution. The wrapper takes advantage of the fact that conditional distributions for each coordinate are simply proportional to the full joint distribution, with all other variables held constant, at their most recent sampled values. Note that ARS requires log-concavity of the conditional distributions. Log-concavity of the full multivariate distribution is sufficient but not necessary for univariate conditionals to be log-concave. Slice sampler (default option) is derivative-free, robust with respect to choice of tuning parameters, and can be applied to a wider collection of multivariate distributions as a drop-in method with good results. Multivariate samplers such as Metropolis (Bishop 2006) or Stochastic Newton Sampler (Mahani et al 2014) do not require our wrapper.
</p>


<h3>Value</h3>

<p>For <code>MfU.Sample</code>, a vector of length <code>length(x)</code>, representing a sample from the multivariate log-density <code>f</code>; for <code>MfU.Sample.Run</code>, an object of class <code>"MfU"</code>, which is a matrix of sampled values, one sampler per row (<code>nsmp</code> rows), with sampling time attached as attribute <code>"t"</code>.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani</p>


<h3>References</h3>

<p>Bishop C.M. (2006). <em>Pattern Recognition and Machine Learning</em>. Springer New York.
</p>
<p>Geman S. and Geman D. (1984). Stochastic relaxation, Gibbs distributions, and the Bayesian restoration of images. <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, <b>6</b>, 721-741.
</p>
<p>Gilks W.R. and Wild P. (1992). Adaptive Rejection Sampling. <em>Applied Statistics</em>, <b>41</b>, 337-348.
</p>
<p>Gilks W.R., Best N.G., and Tan K.K.C. (1995) Adaptive rejection Metropolis sampling within Gibbs sampling. <em>Applied Statistics</em>, <b>44</b>, 455-472.
</p>
<p>Mahani A.S., Hasan A., Jiang M. and Sharabiani M.T.A. (2016). Stochastic Newton Sampler: The R Package sns. Journal of Statistical Software, Code Snippets, 74(2), 1-33. doi:10.18637/jss.v074.c02
</p>
<p>Mahani A.S and Sharabiani M.T.A. (2017). Multivariate-From-Univariate MCMC Sampler: The R Package MfUSampler. Journal of Statistical Software, Code Snippets, 78(1), 1-22. doi:10.18637/jss.v078.c01
</p>
<p>Neal R.M. (2003). Slice Sampling. <em>Annals of Statistics</em>, <b>31</b>, 705-767.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
z &lt;- c(1, 4, 7, 10, 13, 16, 19, 24)
m1.prior &lt;- c(17, 26, 39, 27, 35, 37, 26, 23)
m2.prior &lt;- c(215, 218, 137, 62, 36, 16, 13, 15)
m1.current &lt;- c(46, 52, 44, 54, 38, 39, 23, 52)
m2.current &lt;- c(290, 211, 134, 91, 53, 42, 23, 32)

m1.total &lt;- m1.prior + m1.current
m2.total &lt;- m2.prior + m2.current

logpost.retin &lt;- function(beta, z, m1, m2
  , beta0 = rep(0.0, 3), W = diag(1e+6, nrow = 3)) {
  X &lt;- cbind(1, z, z^2)
  
  beta &lt;- as.numeric(beta)
  Xbeta &lt;- X %*% beta
  log.prior &lt;- -0.5 * t(beta - beta0) %*% solve(W) %*% (beta - beta0)
  log.like &lt;- -sum((m1 + m2) * log(1 + exp(-Xbeta)) + m2 * Xbeta)
  log.post &lt;- log.prior + log.like

  return (log.post)
}

nsmp &lt;- 1000
beta.ini &lt;- c(0.0, 0.0, 0.0)
beta.smp &lt;- MfU.Sample.Run(beta.ini, logpost.retin, nsmp = nsmp
  , z = z, m1 = m1.total, m2 = m2.total)
summary(beta.smp)

</code></pre>


</div>