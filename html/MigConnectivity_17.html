<div class="container">

<table style="width: 100%;"><tr>
<td>estTransition</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate psi (transition probabilities between locations in two phases of
the annual cycle)</h2>

<h3>Description</h3>

<p>Estimation and resampling of uncertainty for psi (transition probabilities
between origin sites in one phase of the annual cycle and target sites in
another for migratory animals). Data can be from any combination of
geolocators (GL), telemetry/GPS, intrinsic markers such as isotopes and
genetics, and band/ring reencounter data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">estTransition(
  originSites = NULL,
  targetSites = NULL,
  originPoints = NULL,
  targetPoints = NULL,
  originAssignment = NULL,
  targetAssignment = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  isGL = FALSE,
  isTelemetry = FALSE,
  isRaster = FALSE,
  isProb = FALSE,
  captured = "origin",
  geoBias = NULL,
  geoVCov = NULL,
  geoBiasOrigin = geoBias,
  geoVCovOrigin = geoVCov,
  targetRaster = NULL,
  originRaster = NULL,
  banded = NULL,
  reencountered = NULL,
  verbose = 0,
  alpha = 0.05,
  resampleProjection = "ESRI:102010",
  nSim = ifelse(any(isRaster &amp; isGL) || any(isRaster &amp; isProb) || any(isGL &amp; isProb),
    5000, ifelse(any(isGL), 1000, ifelse(any(isRaster), 10, 1))),
  maxTries = 300,
  nBurnin = 5000,
  nChains = 3,
  nThin = 1,
  dataOverlapSetting = c("dummy", "none", "named"),
  fixedZero = NULL,
  targetRelAbund = NULL,
  method = c("bootstrap", "MCMC", "m-out-of-n-bootstrap"),
  m = NULL,
  psiPrior = NULL,
  returnAllInput = TRUE
)

estPsi(
  originSites = NULL,
  targetSites = NULL,
  originPoints = NULL,
  targetPoints = NULL,
  originAssignment = NULL,
  targetAssignment = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  isGL = FALSE,
  isTelemetry = FALSE,
  isRaster = FALSE,
  isProb = FALSE,
  captured = "origin",
  geoBias = NULL,
  geoVCov = NULL,
  geoBiasOrigin = geoBias,
  geoVCovOrigin = geoVCov,
  targetRaster = NULL,
  originRaster = NULL,
  banded = NULL,
  reencountered = NULL,
  verbose = 0,
  alpha = 0.05,
  resampleProjection = "ESRI:102010",
  nSim = ifelse(any(isRaster &amp; isGL) || any(isRaster &amp; isProb) || any(isGL &amp; isProb),
    5000, ifelse(any(isGL), 1000, ifelse(any(isRaster), 10, 1))),
  maxTries = 300,
  nBurnin = 5000,
  nChains = 3,
  nThin = 1,
  dataOverlapSetting = c("dummy", "none", "named"),
  fixedZero = NULL,
  targetRelAbund = NULL,
  method = c("bootstrap", "MCMC", "m-out-of-n-bootstrap"),
  m = NULL,
  psiPrior = NULL,
  returnAllInput = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>originSites</code></td>
<td>
<p>A polygon spatial layer (sf - MULTIPOLYGON)
defining the geographic representation of sites in the
origin season.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targetSites</code></td>
<td>
<p>A polygon spatial layer (sf - MULTIPOLYGON)
defining the geographic representation of sites in the
target season.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>originPoints</code></td>
<td>
<p>A <code>sf</code> or <code>SpatialPoints</code> object, with number
of rows or length being the number of animals tracked. Each point indicates
the origin location of an animal (or point estimate of same, for GL animals
released on target sites). Note that to simplify input of multiple
data types both between and for the same animal, if origin points are
provided for any animal, they must be provided for all except banding data
(can be dummy values), unless <code>dataOverlapSetting</code> is set to "none".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targetPoints</code></td>
<td>
<p>For GL or telemetry data, a <code>sf</code> or
<code>SpatialPoints</code> object, with length or number of rows number of animals
tracked. Each point indicates the point estimate location of an animal in
the target season. Note that to simplify input of multiple
data types both between and for the same animal, if target points are
provided for any animal, they must be provided for all except banding data
(can be dummy values), unless <code>dataOverlapSetting</code> is set to "none".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>originAssignment</code></td>
<td>
<p>Assignment of animals to origin season sites. Either
an integer vector with length number of animals tracked or a matrix of
probabilities with number of animals tracked rows and number of origin sites
columns (and rows summing to 1). The latter only applies to animals released
in the target sites where there is uncertainty about their origin site, for
example from genetic population estimates from the rubias package.
Optional, but some combination of these inputs should be defined. Note that
if <code>originAssignment</code> is a probability table, animals with known origin
sites can have 1 in that column and 0s in all others. Also note that if
<code>method</code> is "MCMC", anything in <code>originAssignment</code> and
<code>targetAssignment</code> will be assumed to represent animals tracked via
telemetry, with known origin and target sites.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targetAssignment</code></td>
<td>
<p>Assignment of animals to target season sites. Either
an integer vector with length number of animals tracked or a matrix of
probabilities with number of animals tracked rows and number of target sites
columns (and rows summing to 1). The latter only applies to animals released
in the origin sites where there is uncertainty about their target site, for
example from genetic population estimates from the rubias package.
Optional, but some combination of these inputs needs to be defined. Note
that if <code>targetAssignment</code> is a probability table, animals with known
target sites can have 1 in that column and 0s in all others.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>originNames</code></td>
<td>
<p>Optional, but recommended to keep track. Vector of names
for the origin sites. If not provided, the function will either try to get
these from another input or provide default names (capital letters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targetNames</code></td>
<td>
<p>Optional, but recommended to keep track. Vector of names
for the target sites. If not provided, the function will either try to get
these from another input or provide default names (numbers).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nSamples</code></td>
<td>
<p>Number of post-burn-in MCMC samples to store (<code>method</code>
== "MCMC") OR number of bootstrap runs for <code>method</code>
== "bootstrap". In the latter case, animals are sampled with replacement
for each. For all, the purpose is to estimate sampling uncertainty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isGL</code></td>
<td>
<p>Indicates whether or which animals were tracked with geolocators.
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE or FALSE for each animal in data
(except those in <code>banded</code>, which are handled separately). For
TRUE animals, the model applies <code>geoBias</code> and <code>geoVCov</code> to
<code>targetPoints</code> where <code>captured</code> == "origin" or "neither" and
<code>geoBiasOrigin</code> and <code>geoVCovOrigin</code> to
<code>originPoints</code> where <code>captured</code> == "target" or "neither".
Geolocator data should be entered as <code>originPoints</code> and
<code>targetPoints</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isTelemetry</code></td>
<td>
<p>Indicates whether or which animals were tracked with
telemetry/GPS (no location uncertainty on either end).
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE or FALSE for each animal in data
(except those in <code>banded</code>, which are handled separately).
Telemetry data can be entered as points or using the <code>targetAssignment</code>
and <code>originAssignment</code> arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isRaster</code></td>
<td>
<p>Indicates whether or which animals were tracked with
intrinsic markers (e.g., genetics or isotopes), with location uncertainty
expressed as a raster of probabilities by grid cells, either in
<code>targetRaster</code> or <code>originRaster</code>. Should be either single TRUE or
FALSE value, or vector with length of number of animals tracked, with TRUE
or FALSE for each animal in data (except those in <code>banded</code>, which are
handled separately).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isProb</code></td>
<td>
<p>Indicates whether or which animals were tracked with
intrinsic markers (e.g., genetics or isotopes), with location uncertainty
expressed as a probability table, either in <code>targetAssignment</code> or
<code>originAssignment</code>. Should be either single TRUE or FALSE value, or
vector with length of number of animals tracked, with TRUE or FALSE for each
animal in data (except those in <code>banded</code>, which are handled separately).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>captured</code></td>
<td>
<p>Indicates whether or which animals were captured in the
origin sites, the target sites, or neither (another phase of the annual
cycle). Location uncertainty will only be applied where the animal was not
captured. So this doesn't matter for telemetry data, and is assumed to be
"origin" for band return data. Should be either single "origin" (default),
"target", or "neither" value, or a character vector with length of number of
animals tracked, with "origin", "target", or "neither" for each animal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geoBias</code></td>
<td>
<p>For GL data, vector of length 2 indicating expected bias
in longitude and latitude of <code>targetPoints</code>, in
<code>resampleProjection</code> units (default meters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geoVCov</code></td>
<td>
<p>For GL data, 2x2 matrix with expected variance/covariance
in longitude and latitude of <code>targetPoints</code>, in
<code>resampleProjection</code> units (default meters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geoBiasOrigin</code></td>
<td>
<p>For GL data where <code>captured</code>!="origin", vector of
length 2 indicating expected bias in longitude and latitude of
<code>originPoints</code>, in <code>resampleProjection</code> units (default meters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geoVCovOrigin</code></td>
<td>
<p>For GL data where <code>captured</code>!="origin", 2x2 matrix
with expected variance/covariance in longitude and latitude of
<code>targetPoints</code>, in <code>resampleProjection</code> units (default meters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targetRaster</code></td>
<td>
<p>For intrinsic tracking data, the results of
<code>isoAssign</code> or a similar function of class <code>intrinsicAssign</code> or
class <code>RasterBrick</code>/<code>RasterStack</code>, for example from the package
<code>assignR</code>. In any case, it expresses location uncertainty on target
range, through a raster of probabilities by grid cells.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>originRaster</code></td>
<td>
<p>For intrinsic tracking data, the results of
<code>isoAssign</code> or a similar function of class <code>intrinsicAssign</code> or
class <code>RasterBrick</code>/<code>RasterStack</code>, for example from the package
<code>assignR</code>. In any case, it expresses location uncertainty on origin
range, through a raster of probabilities by grid cells.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>banded</code></td>
<td>
<p>For band return data, a vector or matrix of the number of
released animals from each origin site (including those never reencountered
in a target site). If a matrix, the second dimension is taken as the number
of age classes of released animals; the model estimates reencounter
probability by age class but assumes transition probabilities are the same.
Note that this age model is currently implemented only for <code>method</code>
set to "MCMC", and only when banding data is analyzed alone (no telemetry
data).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reencountered</code></td>
<td>
<p>For band return data, either a matrix with B rows and W
columns or a B x [number of ages] x W array. Number of animals reencountered
on each target site (by age class banded as) by origin site they came from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>0 (default) to 3. 0 prints no output during run (except on
convergence for <code>method</code> set to "MCMC"). 1 prints an update every 100
samples or bootstraps (or a status bar for "MCMC").  2 prints an update
every sample or bootstrap. 3 also prints the number of draws (for
tuning <code>nSim</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Level for confidence/credible intervals provided. Default (0.05)
gives 95 percent CI.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resampleProjection</code></td>
<td>
<p>Projection when sampling from location uncertainty.
Default is Equidistant Conic. The default setting preserves distances
around latitude = 0 and longitude = 0. Other projections may work well,
depending on the location of sites. Ignored unless data are entered using
sites and points and/or rasters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nSim</code></td>
<td>
<p>Tuning parameter for GL or intrinsic data. Affects only the
speed; 1000 seems to work well with our GL data and 10 for our intrinsic
data, but your results may vary. For data combinations, we put the default
higher (5000) to allow for more data conflicts. Should be integer &gt; 0.
Ignored when <code>method</code> is "MCMC".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxTries</code></td>
<td>
<p>Maximum number of times to run a single GL/intrinsic
bootstrap before exiting with an error. Default is 300; you may want to make
a little higher if your <code>nSim</code> is low and <code>nSamples</code> is high. Set
to NULL to never exit. This parameter was added to prevent setups where some
sample points never land on target sites from running indefinitely.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nBurnin</code></td>
<td>
<p>For <code>method</code> set to "MCMC", <code>estTransition</code> runs a
<code>JAGS</code> multinomial non-Markovian transitions model, for which it needs
the number of burn-in samples before beginning to store results. Default
5000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nChains</code></td>
<td>
<p>For <code>method</code> set to "MCMC", <code>estTransition</code> runs a
<code>JAGS</code> multinomial non-Markovian transitions model, for which it needs
the number of MCMC chains (to test for convergence). Default 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThin</code></td>
<td>
<p>For <code>method</code> set to "MCMC", <code>estTransition</code> runs a
<code>JAGS</code> multinomial non-Markovian transitions model, for which it needs
the thinning rate. Default 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataOverlapSetting</code></td>
<td>
<p>When there is more than one type of data, this
setting allows the user some flexibility for clarifying which type(s) of
data apply to which animals. Setting "dummy" (the default) indicates that
there are dummy values within each dataset for the animals that isGL,
isTelemetry, etc. don't have that data type (FALSE values). If no animals
have a data type, no dummy values are required. If no animals have more than
one type of data, the user can simplify processing their data by choosing
setting "none" here. In this case, there should be no dummy values, and only
the animals with a type of data should be included in that dataset. The
third setting ("named") is not yet implemented, but will eventually allow
another way to allow animals with more than one type of data with named
animals linking records. When there is only one type of data, it is fastest
to leave this on the default. Note that banding data entered through
<code>banded</code> and <code>reencountered</code> are assumed to have no
overlap with other data types, so none of this applies to those.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedZero</code></td>
<td>
<p>When the user has a priori reasons to believe one or more
transition probabilities are zero, they can indicate those here, and the
model will keep them fixed at zero. This argument should be a matrix with
two columns (for row and column of the transition probability matrix) and
number of transitions being fixed to zero rows. For MCMC modeling,
substantial evidence that a transition fixed to zero isn't zero may
cause an error. For bootstrap modeling, a warning
will come up if any bootstrap runs generate the transition fixed to zero,
and the function will quit with an error if a very large number of runs do
(&gt; 10 * nSamples). Fixing transitions to zero may also slow down the
bootstrap model somewhat.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targetRelAbund</code></td>
<td>
<p>When some/all data have location error at origin sites
(i.e., GL, raster, or probability table data with captured = "target" or
"none"), unless the data were collected in proportion to abundance at target
sites, simulation work indicates substantial bias in transition probability
estimates can result. However, if these data are resampled in proportion to
target site abundance, this bias is removed. This argument allows the user
to provide an estimate of relative abundance at the target sites. Either
a numeric vector of length [number target sites] that sums to 1, or an mcmc
object (such as is produced by <code>modelCountDataJAGS</code>) or matrix
with at least <code>nSamples</code> rows. If there are more than [number target
sites] columns, the relevant columns should be labeled "relN[1]" through
"relN[number target sites]".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>This important setting lets the user choose the estimation
method used: bootstrap or MCMC (Markov chain Monte Carlo). Bootstrap (the
default) now works with any and all types of data, whereas MCMC currently
only works with banding and telemetry data (enter telemetry data for MCMC
using <code>originAssignment</code> and <code>targetAssignment</code>, not
<code>originPoints</code> and <code>targetPoints</code>). However, MCMC is
usually faster (and may be a bit more accurate). The third option,
"m-out-of-n-bootstrap", is still under development and should be left alone.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>We read that the m-out-of-n-bootstrap method may improve the
coverage of confidence intervals for parameters on or near a boundary (0 or
1 in this case). So we're testing that out. This still under development and
not for the end user. In the m-out-of-n-bootstrap, m is the number of
samples taken each time (less than the true sample size, n). If the
"m-out-of-n-bootstrap" is chosen under <code>method</code> but this is left blank,
currently the default is n/4, rounded up (no idea if that is reasonable).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psiPrior</code></td>
<td>
<p>matrix with same dimensions as psi. Only relevant when
<code>method</code> is "MCMC". Each row provides a Dirichlet
(https://en.wikipedia.org/wiki/Dirichlet_distribution) prior on the
transition probabilities from that origin site. The default (NULL) supplies
Dirichlet parameters of all 1s, which is a standard uninformative Dirichlet
prior. Setting these to other positive numbers is useful when you think a
priori that certain transitions are unlikely, but don't want to rule them
out altogether using <code>fixedZero</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnAllInput</code></td>
<td>
<p>if TRUE (the default) the output includes all of the
inputs. If FALSE, only the inputs currently used by another MigConnectivity
function are included in the output. Switch this if you're worried about
computer memory (and the output will be much slimmer).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>estTransition</code> returns a list with the elements:
</p>

<dl>
<dt><code>psi</code></dt>
<dd>
<p>List containing estimates of transition probabilities:
</p>

<ul>
<li>
<p><code>sample</code> Array of sampled values for psi. <code>nSamples</code> x
[number of origin sites] x [number of target sites]. Provided to allow
the user to compute own summary statistics.
</p>
</li>
<li>
<p><code>mean</code> Main estimate of psi matrix. [number of origin sites]
x [number of target sites].
</p>
</li>
<li>
<p><code>se</code> Standard error of psi, estimated from SD of
<code>psi$sample</code>.
</p>
</li>
<li>
<p><code>simpleCI</code> <code>1 - alpha</code> confidence interval for psi,
estimated as <code>alpha/2</code> and <code>1 - alpha/2</code> quantiles of
<code>psi$sample</code>.
</p>
</li>
<li>
<p><code>bcCI</code> Bias-corrected <code>1 - alpha</code> confidence interval
for psi. May be preferable to <code>simpleCI</code> when <code>mean</code> is the
best estimate of psi. <code>simpleCI</code> is preferred when
<code>median</code> is a better estimator. When the mean and median are equal,
these should be identical.  Estimated as the
<code>pnorm(2 * z0 + qnorm(alpha / 2))</code> and
<code>pnorm(2 * z0 + qnorm(1 - alpha / 2))</code> quantiles of <code>sample</code>,
where z0 is the proportion of <code>sample &lt; mean</code>.
</p>
</li>
<li>
<p><code>hpdCI</code> <code>1 - alpha</code> credible interval for psi,
estimated using the highest posterior density (HPD) method.
</p>
</li>
<li>
<p><code>median</code> Median estimate of psi matrix.
</p>
</li>
<li>
<p><code>point</code> Simple point estimate of psi matrix, not accounting
for sampling error.
</p>
</li>
</ul>
</dd>
<dt><code>r</code></dt>
<dd>
<p>List containing estimates of reencounter probabilities at
each target site. NULL except when using direct band/ring reencounter
data.</p>
</dd>
<dt><code>input</code></dt>
<dd>
<p>List containing the inputs to <code>estTransition</code>.</p>
</dd>
<dt><code>BUGSoutput</code></dt>
<dd>
<p>List containing <code>R2jags</code> output. Only present
when using <code>method</code> of "MCMC".</p>
</dd>
</dl>
<h3>See Also</h3>

<p><code>estStrength</code>, <code>plot.estMigConnectivity</code>,
<code>estMC</code>, <code>estMantel</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  ##############################################################################
  # Examples 1 (banding data: first example is based on common tern banding
  #   data; the second is made up data to demonstrate data with two ages)
  ##############################################################################
  COTE_banded &lt;- c(10360, 1787, 2495, 336)
  COTE_reencountered &lt;- matrix(c(12, 0, 38, 15,
                                 111, 7, 6, 2,
                                 5, 0, 19, 4,
                                 1123, 40, 41, 7),
                               4, 4,
                               dimnames = list(LETTERS[1:4], 1:4))
  COTE_psi &lt;- estTransition(originNames = LETTERS[1:4],
                            targetNames = 1:4,
                            banded = COTE_banded,
                            reencountered = COTE_reencountered,
                            verbose = 1,
                            nSamples = 60000, nBurnin = 20000,
                            method = "MCMC")
  COTE_psi

  COTE_banded2 &lt;- matrix(rep(COTE_banded, 2), 4, 2)
  COTE_reencountered2 &lt;- array(c(12, 0, 38, 15, 6, 0, 17, 7,
                                 111, 7, 6, 2, 55, 3, 3, 1,
                                 5, 0, 19, 4, 2, 0, 10, 2,
                                 1123, 40, 41, 7, 660, 20, 20, 3),
                               c(4, 2, 4),
                               dimnames = list(LETTERS[1:4], c("J", "A"), 1:4))
  COTE_psi2 &lt;- estTransition(originNames = LETTERS[1:4],
                            targetNames = 1:4,
                            banded = COTE_banded2,
                            reencountered = COTE_reencountered2,
                            verbose = 0,
                            nSamples = 60000, nBurnin = 20000,
                            method = "MCMC")
  COTE_psi2

  ##############################################################################
  # Example 2 (geolocator and telemetry ovenbirds captured on origin sites)
  ##############################################################################
  data(OVENdata) # Ovenbird

  nSamplesGLGPS &lt;- 100 # Number of bootstrap iterations

  # Estimate transition probabilities; treat all data as geolocator
  GL_psi &lt;- estTransition(isGL=TRUE,
                          geoBias = OVENdata$geo.bias,
                          geoVCov = OVENdata$geo.vcov,
                          targetSites = OVENdata$targetSites,
                          originSites = OVENdata$originSites,
                          originPoints = OVENdata$originPoints,
                          targetPoints = OVENdata$targetPoints,
                          verbose = 2,
                          nSamples = nSamplesGLGPS,
                          resampleProjection=sf::st_crs(OVENdata$targetPoints))

  # Treat all data as is
  Combined.psi &lt;- estTransition(isGL=OVENdata$isGL,
                          isTelemetry = !OVENdata$isGL,
                  geoBias = OVENdata$geo.bias, # Light-level GL location bias
                  geoVCov = OVENdata$geo.vcov, # Location covariance matrix
                  targetSites = OVENdata$targetSites, # Nonbreeding/target sites
                  originSites = OVENdata$originSites, # Breeding/origin sites
                  originPoints = OVENdata$originPoints, # Capture Locations
                  targetPoints = OVENdata$targetPoints, #Device target locations
                  verbose = 2,   # output options
                  nSamples = nSamplesGLGPS, # This is set low for example
                  resampleProjection = sf::st_crs(OVENdata$targetPoints))

  print(Combined.psi)

  # For treating all data as GPS,
  # Move the latitude of birds with locations that fall offshore
  int &lt;- sf::st_intersects(OVENdata$targetPoints, OVENdata$targetSites)
  any(lengths(int)&lt;1)
  plot(OVENdata$targetPoints)
  plot(OVENdata$targetSites,add=TRUE)
  tp&lt;-sf::st_coordinates(OVENdata$targetPoints)
  text(tp[,1], tp[,2], label=c(1:39))

  tp[5,2] &lt;- 2450000
  tp[10,2]&lt;- 2240496
  tp[1,2]&lt;- 2240496
  tp[11,2]&lt;- 2026511
  tp[15,2]&lt;- 2031268
  tp[16,2]&lt;- 2031268

  oven_targetPoints&lt;-sf::st_as_sf(as.data.frame(tp),
                                  coords = c("X","Y"),
                                  crs = sf::st_crs(OVENdata$targetPoints))
  inter &lt;- sf::st_intersects(oven_targetPoints, OVENdata$targetSites)
  any(lengths(inter)&lt;1)
  plot(oven_targetPoints,add=TRUE, col = "green")
  plot(oven_targetPoints[lengths(inter)&lt;1,],add=TRUE, col = "darkblue")

  # Treat all data as GPS
  GPS_psi &lt;- estTransition(isTelemetry = TRUE,
                targetSites = OVENdata$targetSites, # Non-breeding/target sites
                originSites = OVENdata$originSites, # Breeding/origin sites
                originPoints = OVENdata$originPoints, # Capture Locations
                targetPoints = oven_targetPoints, # Device target locations
                verbose = 2,   # output options
                nSamples = nSamplesGLGPS) # This is set low for example



  ##############################################################################
  # Example 3 (all released origin; some telemetry, some GL, some probability
  # tables, some both GL and probability tables; data modified from ovenbird
  # example)
  ##############################################################################
  library(VGAM)
  nAnimals &lt;- 40
  isGL &lt;- c(OVENdata$isGL, FALSE)
  isTelemetry &lt;- c(!OVENdata$isGL, FALSE)
  isRaster &lt;- rep(FALSE, nAnimals)
  isProb &lt;- rep(FALSE, nAnimals)
  targetPoints &lt;- rbind(OVENdata$targetPoints, OVENdata$targetPoints[1,])
  targetSites &lt;- OVENdata$targetSites
  originSites &lt;- OVENdata$originSites
  resampleProjection &lt;- sf::st_crs(OVENdata$targetPoints)
  targetNames &lt;- OVENdata$targetNames
  originNames &lt;- OVENdata$originNames
  targetAssignment &lt;- array(0, dim = c(nAnimals, 3),
                            dimnames = list(NULL, targetNames))
  assignment0 &lt;- unclass(sf::st_intersects(x = targetPoints, y = targetSites,
                                           sparse = TRUE))
  assignment0[sapply(assignment0, function(x) length(x)==0)] &lt;- 0
  assignment0 &lt;- array(unlist(assignment0), nAnimals)
  for (ani in 1:nAnimals) {
    if (assignment0[ani]&gt;0)
      targetAssignment[ani, assignment0[ani]] &lt;- 1
    else{
      targetAssignment[ani, ] &lt;- rdiric(1, c(15, 1, 1))
      isProb[ani] &lt;- TRUE
    }
  }
  targetAssignment
  isProb
  nSamplesTry &lt;- 100 # Number of bootstrap iterations
  originPoints &lt;- rbind(OVENdata$originPoints,
                        OVENdata$originPoints[39,])
  system.time(psi3 &lt;-
                estTransition(isGL = isGL, isRaster = isRaster,
                              isProb = isProb,
                              isTelemetry = isTelemetry,
                              geoBias = OVENdata$geo.bias,
                              geoVCov = OVENdata$geo.vcov,
                              targetPoints = targetPoints,
                              targetAssignment = targetAssignment,
                              targetSites = targetSites,
                              resampleProjection = resampleProjection,
                              nSim = 20000, maxTries = 300,
                              originSites = originSites,
                              originPoints = originPoints,
                              captured = "origin",
                              originNames = OVENdata$originNames,
                              targetNames = OVENdata$targetNames,
                              verbose = 3,
                              nSamples = nSamplesTry))
  psi3

  nNonBreeding &lt;- nrow(OVENdata$targetSites)

  plot(psi3, legend = "top",
       main = paste("OVENlike w/", sum(isGL &amp; !isProb), "GL,",
                    sum(!isGL &amp; isProb), "probs,",
                    sum(isGL &amp; isProb), "both, and", sum(isTelemetry), "GPS"))

  ##############################################################################
  # Example 4 (add probability animals released on other end)
  ##############################################################################
  nAnimals &lt;- 45
  captured &lt;- rep(c("origin", "target"), c(40, 5))
  isGL &lt;- c(OVENdata$isGL, rep(FALSE, 6))
  isTelemetry &lt;- c(!OVENdata$isGL, rep(FALSE, 6))
  isRaster &lt;- rep(FALSE, nAnimals)
  isProb &lt;- rep(FALSE, nAnimals)
  targetPoints &lt;- rbind(OVENdata$targetPoints,
                        OVENdata$targetPoints[c(1:3,19,23,31),])
  targetAssignment &lt;- array(0, dim = c(nAnimals, 3),
                            dimnames = list(NULL, targetNames))
  assignment0 &lt;- unclass(sf::st_intersects(x = targetPoints, y = targetSites,
                                           sparse = TRUE))
  assignment0[sapply(assignment0, function(x) length(x)==0)] &lt;- 0
  assignment0 &lt;- array(unlist(assignment0), nAnimals)
  for (ani in 1:nAnimals) {
    if (assignment0[ani]&gt;0)
      targetAssignment[ani, assignment0[ani]] &lt;- 1
    else{
      targetAssignment[ani, ] &lt;- rdiric(1, c(15, 1, 1))
      isProb[ani] &lt;- TRUE
    }
  }
  targetAssignment
  isProb
  originPoints &lt;- rbind(OVENdata$originPoints,
                        OVENdata$originPoints[34:39,])

  originPoints &lt;- sf::st_transform(originPoints, crs = resampleProjection)
  originSites &lt;- sf::st_transform(OVENdata$originSites,
                                  crs = resampleProjection)

  assignment1 &lt;- unclass(sf::st_intersects(x = originPoints, y = originSites,
                                           sparse = TRUE))
  assignment1[sapply(assignment1, function(x) length(x)==0)] &lt;- 0
  assignment1 &lt;- array(unlist(assignment1), nAnimals)

  nOriginSites &lt;- nrow(originSites)

  originAssignment &lt;- array(0, dim = c(nAnimals, nOriginSites),
                            dimnames = list(NULL, originNames))
  for (ani in 1:40) {
    originAssignment[ani, assignment1[ani]] &lt;- 1
  }
  for (ani in 41:nAnimals) {
    originAssignment[ani, ] &lt;- rdiric(1, c(1, 1))
    isProb[ani] &lt;- TRUE
  }
  originAssignment
  isProb
  system.time(psi4 &lt;-
                estTransition(isGL = isGL, isRaster = isRaster,
                              isProb = isProb,
                              isTelemetry = isTelemetry,
                              geoBias = OVENdata$geo.bias,
                              geoVCov = OVENdata$geo.vcov,
                              targetPoints = targetPoints,
                              targetAssignment = targetAssignment,
                              targetSites = targetSites,
                              resampleProjection = resampleProjection,
                              nSim = 15000, maxTries = 300,
                              originSites = originSites,
                              originAssignment = originAssignment,
                              captured = captured,
                              originNames = OVENdata$originNames,
                              targetNames = OVENdata$targetNames,
                              verbose = 2,
                              nSamples = nSamplesTry,
                              targetRelAbund = c(0.1432, 0.3577, 0.4991)))
  psi4

  plot(psi4, legend = "top",
       main = paste(sum(isGL &amp; !isProb), "GL,",
                    sum(!isGL &amp; isProb &amp; captured == "origin"), "prob.,",
                    sum(isGL &amp; isProb), "both,",
                    sum(isTelemetry), "GPS (all\ncaptured origin), and",
                    sum(isProb &amp; captured == "target"),
                    "prob. (captured target)"))
  MC4 &lt;- estStrength(OVENdata$originDist, OVENdata$targetDist,
                                       OVENdata$originRelAbund, psi4,
                                       sampleSize = nAnimals)
  MC4

  ##############################################################################
  # Example 5 (all raster, from our OVEN example)
  ##############################################################################
  getCSV &lt;- function(filename) {
    tmp &lt;- tempdir()
    url1 &lt;- paste0(
      'https://github.com/SMBC-NZP/MigConnectivity/blob/master/data-raw/',
                   filename, '?raw=true')
    temp &lt;- paste(tmp, filename, sep = '/')
    utils::download.file(url1, temp, mode = 'wb')
    csv &lt;- read.csv(temp)
    unlink(temp)
    return(csv)

  }

  getRDS &lt;- function(speciesDist) {
    tmp &lt;- tempdir()
    extension &lt;- '.rds'
    filename &lt;- paste0(speciesDist, extension)
    url1 &lt;- paste0(
      'https://github.com/SMBC-NZP/MigConnectivity/blob/master/data-raw/Spatial_Layers/',
                   filename, '?raw=true')
    temp &lt;- paste(tmp, filename, sep = '/')
    utils::download.file(url1, temp, mode = 'wb')
    shp &lt;- readRDS(temp)
    unlink(temp)
    return(shp)
  }
  OVENdist &lt;- getRDS("OVENdist")

  OVENdist &lt;- sf::st_as_sf(OVENdist)

  OVENdist &lt;- sf::st_transform(OVENdist, 4326)

  OVENvals &lt;- getCSV("deltaDvalues.csv")

  OVENvals &lt;- OVENvals[grep(x=OVENvals$Sample,"NH", invert = TRUE),]

  originSites &lt;- getRDS("originSites")
  originSites &lt;- sf::st_as_sf(originSites)

  EVER &lt;- length(grep(x=OVENvals$Sample,"EVER"))
  JAM &lt;- length(grep(x=OVENvals$Sample,"JAM"))

  originRelAbund &lt;- matrix(c(EVER,JAM),nrow = 1,byrow = TRUE)
  originRelAbund &lt;- prop.table(originRelAbund,1)

  op &lt;- sf::st_centroid(originSites)

  originPoints &lt;- array(NA,c(EVER+JAM,2), list(NULL, c("x","y")))
  originPoints[grep(x = OVENvals$Sample,"JAM"),1] &lt;- sf::st_coordinates(op)[1,1]
  originPoints[grep(x = OVENvals$Sample,"JAM"),2] &lt;- sf::st_coordinates(op)[1,2]
  originPoints[grep(x = OVENvals$Sample,"EVER"),1]&lt;-sf::st_coordinates(op)[2,1]
  originPoints[grep(x = OVENvals$Sample,"EVER"),2]&lt;-sf::st_coordinates(op)[2,2]

  originPoints &lt;- sf::st_as_sf(data.frame(originPoints),
                               coords = c("x", "y"),
                               crs = sf::st_crs(originSites))

  iso &lt;- isoAssign(isovalues = OVENvals[,2],
                   isoSTD = 12,       # this value is for demonstration only
                   intercept = -10,   # this value is for demonstration only
                   slope = 0.8,       # this value is for demonstration only
                   odds = NULL,
                   restrict2Likely = FALSE,
                   nSamples = 1000,
                   sppShapefile = terra::vect(OVENdist),
                   assignExtent = c(-179,-60,15,89),
                   element = "Hydrogen",
                   period = "GrowingSeason",#this setting for demonstration only
                   seed = 12345,
                   verbose=1)


  nAnimals &lt;- dim(iso$probassign)[3]
  isGL &lt;-rep(FALSE, nAnimals); isRaster &lt;- rep(TRUE, nAnimals)
  isProb &lt;- rep(FALSE, nAnimals); isTelemetry &lt;- rep(FALSE, nAnimals)
  targetSites &lt;- sf::st_as_sf(iso$targetSites)
  targetSites &lt;- sf::st_make_valid(targetSites)
  targetSites &lt;- sf::st_union(targetSites, by_feature = TRUE)


  system.time(psi5 &lt;-
                estTransition(isGL = isGL,
                              isRaster = isRaster,
                              isProb = isProb,
                              isTelemetry = isTelemetry,
                              targetSites = targetSites,
                              resampleProjection = resampleProjection,
                              targetRaster = iso,
                              originSites = originSites,
                              originPoints = originPoints,
                              captured = rep("origin", nAnimals),
                              verbose = 2,
                              nSamples = nSamplesTry))
  psi5

</code></pre>


</div>