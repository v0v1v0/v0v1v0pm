<div class="container">

<table style="width: 100%;"><tr>
<td>get_heteroplasmy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>get_heteroplasmy</h2>

<h3>Description</h3>

<p>It is one of the two main functions of the <strong>MitoHEAR</strong> package
(together with <em>get_raw_counts_allele</em>). It computes the allele
frequencies and the heteroplasmy matrix starting from the counts matrix
obtained with <em>get_raw_counts_allele</em>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_heteroplasmy(
  raw_counts_allele,
  name_position_allele,
  name_position,
  number_reads,
  number_positions,
  filtering = 1,
  my.clusters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>raw_counts_allele</code></td>
<td>
<p>A raw counts matrix obtained from
<em>get_raw_counts_allele</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name_position_allele</code></td>
<td>
<p>A character vector with elements specifying the
genomic coordinate of the base and the allele (obtained from
<em>get_raw_counts_allele</em>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name_position</code></td>
<td>
<p>A character vector with elements specifying the genomic
coordinate of the base (obtained from <em>get_raw_counts_allele</em>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>number_reads</code></td>
<td>
<p>Integer specifying the minimum number of counts above
which we consider the base covered by the sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>number_positions</code></td>
<td>
<p>Integer specifying the minimumnumber of bases that
must be covered by the sample (with counts&gt;<em>number_reads</em>), in order to keep
the sample for down-stream analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filtering</code></td>
<td>
<p>Numeric value equal to 1 or 2. If 1 then only the bases
that are covered by all the samples are kept for the downstream analysis. If
2 then all the bases that are covered by more than 50% of the the samples
in each cluster (specified by <em>my.clusters</em>) are kept for the down-stream
analysis. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>my.clusters</code></td>
<td>
<p>Character vector specifying a partition of the samples.
It is only used when filtering is equal to 2. Default is NULL</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Starting from <em>raw counts allele matrix</em>, the function performed two
consequentially filtering steps. The first one is on the samples, keeping
only the ones that cover a number of bases above number_positions. The
second one is on the bases, defined by the parameter filtering. The
heteroplasmy for each sample-base pair is computed as <em>1-max(f)</em>, where
<em>f</em> are the frequencies of the four alleles.
</p>


<h3>Value</h3>

<p>It returns a list with 5 elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sum_matrix</code></td>
<td>
<p>A matrix (n_row=number of sample, n_col=number of bases)
with the counts for each sample/base, for all the initial samples and bases
included in the <em>raw counts allele matrix</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sum_matrix_qc</code></td>
<td>
<p>A matrix (n_row=number of sample, n_col=number of
bases) with the counts for each sample/base, for all the samples and bases
that pass the two consequentially filtering steps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heteroplasmy_matrix</code></td>
<td>
<p>A matrix with the same dimension of <em>sum_matrix_qc</em>
where each entry (i,j) is the heteroplasmy for sample i in base j.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allele_matrix</code></td>
<td>
<p>A matrix (n_row=number of sample,
n_col=4*number of bases) with allele frequencies, for all the samples and
bases that pass the two consequentially filtering steps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>Indices of the samples that
cover a base, for all bases and samples that pass the two consequentially
filtering steps; if all the samples cover all the bases, then <em>index</em> is NULL </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Gabriele Lubatti <a href="mailto:gabriele.lubatti@helmholtz-muenchen.de">gabriele.lubatti@helmholtz-muenchen.de</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Two samples and two bases whose reference allele is A and C.
# The two samples have 100 reads in the reference allele and 0 in all the others.
sample1_A &lt;- c(100, 0, 0, 0)
names_A &lt;- rep("1_A", length(sample1_A))
sample1_C &lt;- c(100, 0, 0, 0)
names_C &lt;- rep("2_C", length(sample1_C))
allele &lt;- c("A", "C", "T", "G")
names_A_allele &lt;- paste(names_A, allele, sep = " ")
names_C_allele &lt;- paste(names_C, allele, sep = " ")
sample1 &lt;- c(sample1_A, sample1_C)
sample2_A &lt;- c(100, 0, 0, 0)
sample2_C &lt;- c(100, 0, 0, 0)
sample2 &lt;- c(sample2_A, sample2_C)
test_allele &lt;- matrix(c(sample1, sample2), byrow = TRUE, ncol = 8, nrow = 2)
colnames(test_allele) &lt;- c(names_A_allele, names_C_allele)
row.names(test_allele) &lt;- c("sample1", "sample2")
name_position_allele_test &lt;- c(names_A_allele, names_C_allele)
name_position_test &lt;- c(names_A, names_C)
test &lt;- get_heteroplasmy(test_allele, name_position_allele_test, name_position_test, 50, 1, 1)
</code></pre>


</div>