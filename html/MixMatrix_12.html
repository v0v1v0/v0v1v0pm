<div class="container">

<table style="width: 100%;"><tr>
<td>MLmatrixnorm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maximum likelihood estimation for matrix normal distributions</h2>

<h3>Description</h3>

<p>Maximum likelihood estimates exist for <code class="reqn">N &gt; max(p/q,q/p)+1</code> and are
unique for <code class="reqn">N &gt; max(p,q)</code>. This finds the estimate for the mean and then
alternates between estimates for the <code class="reqn">U</code> and <code class="reqn">V</code> matrices until
convergence. An AR(1), compound symmetry, correlation matrix, or independence
restriction can be proposed for either or both variance matrices. However, if
they are inappropriate for the data, they may fail with a warning.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MLmatrixnorm(
  data,
  row.mean = FALSE,
  col.mean = FALSE,
  row.variance = "none",
  col.variance = "none",
  tol = 10 * .Machine$double.eps^0.5,
  max.iter = 100,
  U,
  V,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Either a list of matrices or a 3-D array with matrices in
dimensions 1 and 2, indexed by dimension 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.mean</code></td>
<td>
<p>By default, <code>FALSE</code>. If <code>TRUE</code>, will fit a
common mean within each row. If both this and <code>col.mean</code> are
<code>TRUE</code>, there will be a common mean for the entire matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.mean</code></td>
<td>
<p>By default, <code>FALSE</code>. If <code>TRUE</code>, will fit a
common mean within each row. If both this and <code>row.mean</code> are
<code>TRUE</code>, there will be a common mean for the entire matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.variance</code></td>
<td>
<p>Imposes a variance structure on the rows. Either
'none', 'AR(1)', 'CS' for 'compound symmetry', 'Correlation' for a
correlation matrix, or 'Independence' for
independent and identical variance across the rows.
Only positive correlations are allowed for AR(1) and CS covariances.
Note that while maximum likelihood estimators are available (and used) for
the unconstrained variance matrices, <code>optim</code> is used for any
constraints so it may be considerably slower.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.variance</code></td>
<td>
<p>Imposes a variance structure on the columns.
Either 'none', 'AR(1)', 'CS', 'Correlation', or 'Independence'.
Only positive correlations are allowed for
AR(1) and CS.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Convergence criterion. Measured against square deviation
between iterations of the two variance-covariance matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>Maximum possible iterations of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>(optional) Can provide a starting point for the <code>U</code> matrix.
By default, an identity matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>(optional) Can provide a starting point for the <code>V</code> matrix.
By default, an identity matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(optional) additional arguments can be passed to <code>optim</code>
if using restrictions on the variance.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list with a the following elements:
</p>

<dl>
<dt><code>mean</code></dt>
<dd>
<p>the mean matrix</p>
</dd>
<dt><code>scaling</code></dt>
<dd>
<p>the scalar variance parameter
(the first entry of the covariances are restricted to unity)</p>
</dd>
<dt><code>U</code></dt>
<dd>
<p>the between-row covariance matrix</p>
</dd>
<dt><code>V</code></dt>
<dd>
<p>the between-column covariance matrix</p>
</dd>
<dt><code>iter</code></dt>
<dd>
<p>the number of iterations</p>
</dd>
<dt><code>tol</code></dt>
<dd>
<p>the squared difference between iterations of
the variance matrices at the time of stopping</p>
</dd>
<dt><code>logLik</code></dt>
<dd>
<p>vector of log likelihoods at each iteration.</p>
</dd>
<dt><code>convergence</code></dt>
<dd>
<p>a convergence flag, <code>TRUE</code> if converged.</p>
</dd>
<dt><code>call</code></dt>
<dd>
<p>The (matched) function call.</p>
</dd>
</dl>
<h3>References</h3>

<p>Pierre Dutilleul.  The MLE algorithm for the matrix normal
distribution.
Journal of Statistical Computation and Simulation, (64):105â€“123, 1999.
</p>
<div class="sourceCode"><pre>Gupta, Arjun K, and Daya K Nagar. 1999. Matrix Variate Distributions.
Vol. 104. CRC Press. ISBN:978-1584880462
</pre></div>


<h3>See Also</h3>

<p><code>rmatrixnorm()</code> and <code>MLmatrixt()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(20180202)
# simulating from a given density
A &lt;- rmatrixnorm(
  n = 100, mean = matrix(c(100, 0, -100, 0, 25, -1000), nrow = 2),
  L = matrix(c(2, 1, 0, .1), nrow = 2), list = TRUE
)
# finding the parameters by ML estimation
results &lt;- MLmatrixnorm(A, tol = 1e-5)
print(results)
</code></pre>


</div>