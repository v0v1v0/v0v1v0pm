<div class="container">

<table style="width: 100%;"><tr>
<td>kdeem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kernel Density-based EM-type algorithm for Semiparametric Mixture Regression
with Unspecified Error Distributions</h2>

<h3>Description</h3>

<p>‘kdeem’ is used for semiparametric mixture regression using a kernel density-based
expectation-maximization (EM)-type algorithm with unspecified
homogeneous or heterogenous error distributions (Ma et al., 2012).
</p>


<h3>Usage</h3>

<pre><code class="language-R">kdeem(x, y, C = 2, ini = NULL, maxiter = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an n by p data matrix where n is the number of observations and p is the
number of explanatory variables (including the intercept).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>an n-dimensional vector of response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>number of mixture components. Default is 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ini</code></td>
<td>
<p>initial values for the parameters. Default is NULL, which obtains the initial values
using the <code>kdeem.lse</code> function.
If specified, it can be a list with the form of <code>list(beta, prop, tau, pi, h)</code>, where
<code>beta</code> is a p by C matrix for regression coefficients of C components,
<code>prop</code> is an n by C matrix for probabilities of each observation belonging to each component,
caculated based on the initial <code>beta</code> and <code>h</code>, <code>tau</code> is a vector of C precision parameters
(inverse of standard deviation), <code>pi</code> is a vector of C mixing proportions, and
<code>h</code> is the bandwidth for kernel estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum number of iterations for the algorithm. Default is 200.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It can be used for a semiparametric mixture of linear regression models with
unspecified component error distributions. The errors can be either homogeneous or heterogenous.
The model is as follows:
</p>
<p style="text-align: center;"><code class="reqn">f_{Y|\boldsymbol{X}}(y,\boldsymbol{x},\boldsymbol{\theta},g) = \sum_{j=1}^C\pi_j\tau_jg\{(y-\boldsymbol{x}^{\top}\boldsymbol{\beta}_j)\tau_j\}.</code>
</p>

<p>Here, <code class="reqn">\boldsymbol{\theta}=(\pi_1,...,\pi_{C-1},\boldsymbol{\beta}_1^{\top},..,\boldsymbol{\beta}_C^{\top},\tau_1,...,\tau_C)^{\top}</code>,
<code class="reqn">g(\cdot)</code> is an unspecified density function with mean 0 and variance 1, and <code class="reqn">\tau_j</code> is a precision parameter.
For the calculation of <code class="reqn">\beta</code> in the M-step, this function employs the universal optimizer function <code>ucminf</code> from the ‘ucminf’ package.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>posterior</code></td>
<td>
<p>posterior probabilities of each observation belonging to each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>estimated regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>estimated precision parameters, the inverse of standard deviation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi</code></td>
<td>
<p>estimated mixing proportions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>bandwidth used for the kernel estimation.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Ma, Y., Wang, S., Xu, L., &amp; Yao, W. (2021). Semiparametric mixture regression
with unspecified error distributions. Test, 30, 429-444.
</p>


<h3>See Also</h3>

<p><code>kdeem.h</code>, <code>kdeem.lse</code>, and <code>ucminf</code> for beta calculation.
</p>


<h3>Examples</h3>

<pre><code class="language-R">n = 300
C = 2
Dimen = 2
Beta.true.matrix = matrix(c(-3, 3, 3, -3), Dimen, C)
PI.true = c(0.5, 0.5)
x = runif(n)
X = cbind(1, x)
Group.ID = Rlab::rbern(n, prob = 0.5)
Error = rnorm(n, 0, 1)
n1 = sum(Group.ID)
n2 = n - n1
y = rep(0, n)
err = rep(0, n)

for(i in 1:n){
  if(Group.ID[i] == 1){
    err[i] = Error[i]
    y[i] = X[i, ] %*% Beta.true.matrix[, 1] + err[i]
  } else {
    err[i] = 0.5 * Error[i]
    y[i] = X[i, ] %*% Beta.true.matrix[, 2] + err[i]
  }
}
Result.kdeem.lse = kdeem.lse(x, y)
Result.kdeem.h = kdeem.h(x, y, 2, Result.kdeem.lse, maxiter = 200)
Result.kdeem = kdeem(x, y, 2, Result.kdeem.lse, maxiter = 200)
</code></pre>


</div>