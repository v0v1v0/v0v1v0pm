<div class="container">

<table style="width: 100%;"><tr>
<td>Covariance Matrices</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Covariance Matrices</h2>

<h3>Description</h3>

<p>These functions compute posterior probabilities,
Fisher information with covariance matrix of parameters,
covariance matrix of posterior probabilities, and covariance matrix of
logit posterior probabilities.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  post.prob(x, fcobj)
  cov.param(x, fcobj, post.z, drop.ETA1 = FALSE)
  cov.post.z(x, fcobj, post.z, cov.param = NULL, all.x = FALSE,
                 drop.ETA1 = FALSE)
  cov.logit.z(x, fcobj, post.z, cov.param = NULL, cov.post.z = NULL,
                  all.x = FALSE, drop.ETA1 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an input list of two elements <code>X.gbd</code> and <code>PV.gbd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fcobj</code></td>
<td>
<p>a <code>fclust</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post.z</code></td>
<td>
<p>a matrix of <code>dim = N * K</code> for posterior probabilities,
which is also the return value of <code>post.prob()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.param</code></td>
<td>
<p>a covariance matrix of <code>dim = d * d</code> for parameters,
which is also a return of <code>cov.param()</code>.
<code>d</code> is total number of parameters which is dependent
on data and models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.post.z</code></td>
<td>
<p>a covariance list of length equal to number of active
voxels, which is also a return of <code>cov.post.z()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.x</code></td>
<td>
<p>all cov matrices for all observations are returned if TRUE,
while for only active observations (those of class ids are
greater than 1) if FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.ETA1</code></td>
<td>
<p>if drop the <code>ETA[1]</code> from the cov matrix due to the
<code>min.1st.prop</code> constrain.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions are required to compute covariance matrices of
parameters and posterior probabilities.
</p>
<p>Use <code>post.prob()</code> to get the posterior probabilities.
</p>
<p>Input the returns of <code>post.prob()</code>
to <code>cov.param()</code> to obtain the cov matrix for parameters
(inversed Fisher information obtained from inner product of gradient
of log observed data likelihood). A list is returned with <code>I</code>
for Fisher information, and <code>cov</code> for the covariance matrix which
is inverted by <code>ginv()</code>.
</p>
<p>Input the returns of <code>post.prob()</code> and <code>cov.param()</code>
to <code>cov.post.z()</code> to obtain the cov matrix for posterior
probabilities by the multivariate delta method on the cov matrix for
parameters.
</p>
<p>Input the returns of <code>post.prob()</code>, <code>cov.param()</code>, and
<code>cov.post.z()</code> to <code>cov.logit.z()</code> to obtain cov matrix
for logit posterior probabilities by the multivariate delta method on
cov matrix of posterior probabilities.
</p>


<h3>Value</h3>

<p>A matrix or a list is returned.
</p>
<p>The <code>cov.param()</code> will return a list containing two elements
<code>I</code> for the Fisher information, and <code>cov</code> for the covariance matrix
by generalized inversed of the Fisher information. The dimension of both
elements are <code>d * d</code> where <code>d = K * 7 - 4</code> for 2D data and
<code>d = K * 9 - 4</code> for 3D data if <code>drop.ETA1 = TRUE</code>, otherwise
they are <code>d = K * 7 - 3</code> and <code>d = K * 9 -4</code>, respectively.
</p>
<p>The <code>cov.post.z()</code> will return a list containing cov matrices of
posterior probabilities for each valid/selected voxel.
</p>
<p>The <code>cov.logit.z()</code> will return a list containing cov matrices of
logit posterior probabilities for each valid/selected voxel.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
“A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies”,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code>EMCluster::lmt()</code>, <code>lmt.I()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(MixfMRI, quietly = TRUE)
library(EMCluster, quietly = TRUE)
.FC.CT$model.X &lt;- "I"
.FC.CT$CONTROL$debug &lt;- 0
K &lt;- 3
  

.rem &lt;- function(){

  ### Fit toy1.
  set.seed(1234)
  X.gbd &lt;- toy1$X.gbd
  X.range &lt;- apply(X.gbd, 2, range)
  X.gbd &lt;- t((t(X.gbd) - X.range[1,]) / (X.range[2,] - X.range[1,]))
  PV.gbd &lt;- toy1$PV.gbd
  fcobj &lt;- fclust(X.gbd, PV.gbd, K = K, min.1st.prop = 0.5)
  
  ### Test cov matrix of posterior z and logit posterior z.
  x &lt;- list(X.gbd = X.gbd, PV.gbd = PV.gbd)
  post.z &lt;- post.prob(x, fcobj)
  cov.param &lt;- cov.param(x, fcobj, post.z = post.z)
  cov.post.z &lt;- cov.post.z(x, fcobj, post.z = post.z,
                               cov.param = cov.param$cov)
  cov.logit.z &lt;- cov.logit.z(x, fcobj, post.z = post.z,
                                 cov.param = cov.param$cov,
                                 cov.post.z = cov.post.z)
  
  ### Compute cov matrix of log odds ratio for all k &gt; 1.
  A &lt;- cbind(rep(-1, K - 1), diag(1, K - 1))
  logit.p &lt;- log(post.z[fcobj$class != 1,] / (1 - post.z[fcobj$class != 1,]))
  log.or &lt;- logit.p %*% t(A)
  cov.log.or &lt;- lapply(cov.logit.z, function(x) A %*% x %*% t(A))
  
  ### Check if 0 vector covered by 95% confidence ellipsoid.
  id &lt;- 1
  plot(log.or[id,],
       xlim = log.or[id, 1] + c(-5, 5),
       ylim = log.or[id, 2] + c(-5, 5),
       main = "1st observation", xlab = "x", ylab = "y")
  plotBN(log.or[id,], cov.log.or[[id]])
  points(0, 0, col = 2)

}

</code></pre>


</div>