<div class="container">

<table style="width: 100%;"><tr>
<td>breeding.diploid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Breeding function</h2>

<h3>Description</h3>

<p>Function to simulate a step in a breeding scheme
</p>


<h3>Usage</h3>

<pre><code class="language-R">breeding.diploid(
  population,
  mutation.rate = 10^-8,
  remutation.rate = 10^-8,
  recombination.rate = 1,
  selection.m = NULL,
  selection.f = NULL,
  new.selection.calculation = TRUE,
  selection.function.matrix = NULL,
  selection.size = 0,
  ignore.best = 0,
  breeding.size = 0,
  breeding.sex = NULL,
  breeding.sex.random = FALSE,
  relative.selection = FALSE,
  class.m = 0,
  class.f = 0,
  add.gen = 0,
  recom.f.indicator = NULL,
  duplication.rate = 0,
  duplication.length = 0.01,
  duplication.recombination = 1,
  new.class = 0L,
  bve = FALSE,
  sigma.e = NULL,
  sigma.g = 100,
  new.bv.child = NULL,
  phenotyping.child = NULL,
  relationship.matrix = "vanRaden",
  relationship.matrix.ogc = "kinship",
  computation.A = NULL,
  computation.A.ogc = NULL,
  delete.haplotypes = NULL,
  delete.individuals = NULL,
  fixed.breeding = NULL,
  fixed.breeding.best = NULL,
  max.offspring = Inf,
  max.litter = Inf,
  store.breeding.totals = FALSE,
  forecast.sigma.g = TRUE,
  multiple.bve = "add",
  store.bve.data = FALSE,
  fixed.assignment = FALSE,
  reduce.group = NULL,
  reduce.group.selection = "random",
  selection.highest = c(TRUE, TRUE),
  selection.criteria = NULL,
  same.sex.activ = FALSE,
  same.sex.sex = 0.5,
  same.sex.selfing = FALSE,
  selfing.mating = FALSE,
  selfing.sex = 0.5,
  praeimplantation = NULL,
  heritability = NULL,
  repeatability = NULL,
  save.recombination.history = FALSE,
  martini.selection = FALSE,
  BGLR.bve = FALSE,
  BGLR.model = "RKHS",
  BGLR.burnin = 500,
  BGLR.iteration = 5000,
  BGLR.print = FALSE,
  copy.individual = FALSE,
  copy.individual.m = FALSE,
  copy.individual.f = FALSE,
  dh.mating = FALSE,
  dh.sex = 0.5,
  n.observation = NULL,
  bve.0isNA = FALSE,
  phenotype.bv = FALSE,
  delete.same.origin = FALSE,
  remove.effect.position = FALSE,
  estimate.u = FALSE,
  new.phenotype.correlation = NULL,
  new.residual.correlation = NULL,
  new.breeding.correlation = NULL,
  estimate.add.gen.var = FALSE,
  estimate.pheno.var = FALSE,
  best1.from.group = NULL,
  best2.from.group = NULL,
  best1.from.cohort = NULL,
  best2.from.cohort = NULL,
  add.class.cohorts = TRUE,
  store.comp.times = TRUE,
  store.comp.times.bve = TRUE,
  store.comp.times.generation = TRUE,
  import.position.calculation = NULL,
  BGLR.save = "RKHS",
  BGLR.save.random = FALSE,
  ogc = FALSE,
  ogc.target = "min.sKin",
  ogc.uniform = NULL,
  ogc.ub = NULL,
  ogc.lb = NULL,
  ogc.ub.sKin = NULL,
  ogc.lb.BV = NULL,
  ogc.ub.BV = NULL,
  ogc.eq.BV = NULL,
  ogc.ub.sKin.increase = NULL,
  ogc.lb.BV.increase = NULL,
  emmreml.bve = FALSE,
  rrblup.bve = FALSE,
  sommer.bve = FALSE,
  sommer.multi.bve = FALSE,
  nr.edits = 0,
  gene.editing.offspring = FALSE,
  gene.editing.best = FALSE,
  gene.editing.offspring.sex = c(TRUE, TRUE),
  gene.editing.best.sex = c(TRUE, TRUE),
  gwas.u = FALSE,
  approx.residuals = TRUE,
  sequenceZ = FALSE,
  maxZ = 5000,
  maxZtotal = 0,
  delete.sex = 1:2,
  gwas.group.standard = FALSE,
  y.gwas.used = "pheno",
  gen.architecture.m = 0,
  gen.architecture.f = NULL,
  add.architecture = NULL,
  ncore = 1,
  ncore.generation = 1,
  Z.integer = FALSE,
  store.effect.freq = FALSE,
  backend = "doParallel",
  randomSeed = NULL,
  randomSeed.generation = NULL,
  Rprof = FALSE,
  miraculix = NULL,
  miraculix.cores = 1,
  miraculix.mult = NULL,
  miraculix.chol = TRUE,
  best.selection.ratio.m = 1,
  best.selection.ratio.f = NULL,
  best.selection.criteria.m = "bv",
  best.selection.criteria.f = NULL,
  best.selection.manual.ratio.m = NULL,
  best.selection.manual.ratio.f = NULL,
  best.selection.manual.reorder = TRUE,
  bve.class = NULL,
  parallel.generation = FALSE,
  name.cohort = NULL,
  display.progress = TRUE,
  combine = FALSE,
  repeat.mating = NULL,
  repeat.mating.copy = NULL,
  repeat.mating.fixed = NULL,
  repeat.mating.overwrite = TRUE,
  time.point = 0,
  creating.type = 0,
  multiple.observation = FALSE,
  new.bv.observation = NULL,
  new.bv.observation.gen = NULL,
  new.bv.observation.cohorts = NULL,
  new.bv.observation.database = NULL,
  phenotyping = NULL,
  phenotyping.gen = NULL,
  phenotyping.cohorts = NULL,
  phenotyping.database = NULL,
  bve.gen = NULL,
  bve.cohorts = NULL,
  bve.database = NULL,
  sigma.e.gen = NULL,
  sigma.e.cohorts = NULL,
  sigma.e.database = NULL,
  sigma.g.gen = NULL,
  sigma.g.cohorts = NULL,
  sigma.g.database = NULL,
  gwas.gen = NULL,
  gwas.cohorts = NULL,
  gwas.database = NULL,
  bve.insert.gen = NULL,
  bve.insert.cohorts = NULL,
  bve.insert.database = NULL,
  reduced.selection.panel.m = NULL,
  reduced.selection.panel.f = NULL,
  breeding.all.combination = FALSE,
  depth.pedigree = 7,
  depth.pedigree.ogc = 7,
  copy.individual.keep.bve = TRUE,
  copy.individual.keep.pheno = TRUE,
  bve.avoid.duplicates = TRUE,
  report.accuracy = TRUE,
  share.genotyped = 1,
  singlestep.active = FALSE,
  remove.non.genotyped = TRUE,
  added.genotyped = 0,
  fast.uhat = TRUE,
  offspring.bve.parents.gen = NULL,
  offspring.bve.parents.database = NULL,
  offspring.bve.parents.cohorts = NULL,
  offspring.bve.offspring.gen = NULL,
  offspring.bve.offspring.database = NULL,
  offspring.bve.offspring.cohorts = NULL,
  culling.gen = NULL,
  culling.database = NULL,
  culling.cohort = NULL,
  culling.time = Inf,
  culling.name = "Not_named",
  culling.bv1 = 0,
  culling.share1 = 0,
  culling.bv2 = NULL,
  culling.share2 = NULL,
  culling.index = 0,
  culling.single = TRUE,
  culling.all.copy = TRUE,
  calculate.reliability = FALSE,
  selection.m.gen = NULL,
  selection.f.gen = NULL,
  selection.m.database = NULL,
  selection.f.database = NULL,
  selection.m.cohorts = NULL,
  selection.f.cohorts = NULL,
  selection.m.miesenberger = FALSE,
  selection.f.miesenberger = NULL,
  selection.miesenberger.reliability.est = "estimated",
  miesenberger.trafo = 0,
  multiple.bve.weights.m = 1,
  multiple.bve.weights.f = NULL,
  multiple.bve.scale.m = "bv_sd",
  multiple.bve.scale.f = NULL,
  verbose = TRUE,
  bve.parent.mean = FALSE,
  bve.grandparent.mean = FALSE,
  bve.mean.between = "bvepheno",
  bve.direct.est = TRUE,
  bve.pseudo = FALSE,
  bve.pseudo.accuracy = 1,
  miraculix.destroyA = TRUE,
  mas.bve = FALSE,
  mas.markers = NULL,
  mas.number = 5,
  mas.effects = NULL,
  threshold.selection = NULL,
  threshold.sign = "&gt;",
  input.phenotype = "own",
  bve.ignore.traits = NULL,
  bv.ignore.traits = NULL,
  genotyped.database = NULL,
  genotyped.gen = NULL,
  genotyped.cohorts = NULL,
  genotyped.share = 1,
  genotyped.array = 1,
  sex.s = NULL,
  bve.imputation = TRUE,
  bve.imputation.errorrate = 0,
  share.phenotyped = 1,
  avoid.mating.fullsib = FALSE,
  avoid.mating.halfsib = FALSE,
  max.mating.pair = Inf,
  bve.per.sample.sigma.e = TRUE,
  bve.solve = "exact"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>population</code></td>
<td>
<p>Population list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutation.rate</code></td>
<td>
<p>Mutation rate in each marker (default: 10^-8)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remutation.rate</code></td>
<td>
<p>Remutation rate in each marker (default: 10^-8)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recombination.rate</code></td>
<td>
<p>Average number of recombination per 1 length unit (default: 1M)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.m</code></td>
<td>
<p>Selection criteria for male individuals (Set to "random" to randomly select individuals - this happens automatically when no the input in selection.criteria has no input ((usually breeding values)))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.f</code></td>
<td>
<p>Selection criteria for female individuals (default: selection.m , alt: "random", function")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.selection.calculation</code></td>
<td>
<p>If TRUE recalculate breeding values obtained by selection.function.matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.function.matrix</code></td>
<td>
<p>Manuel generation of a temporary selection function (Use BVs instead!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.size</code></td>
<td>
<p>Number of selected individuals for breeding (default: c(0,0) - alt: positive numbers)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.best</code></td>
<td>
<p>Not consider the top individuals of the selected individuals (e.g. to use 2-10 best individuals)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breeding.size</code></td>
<td>
<p>Number of individuals to generate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breeding.sex</code></td>
<td>
<p>Share of female animals (if single value is used for breeding size; default: 0.5)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breeding.sex.random</code></td>
<td>
<p>If TRUE randomly chose sex of new individuals (default: FALSE - use expected values)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relative.selection</code></td>
<td>
<p>Use best.selection.ratio instead!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class.m</code></td>
<td>
<p>Migrationlevels of male individuals to consider for mating process (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class.f</code></td>
<td>
<p>Migrationlevels of female individuals to consider for mating process (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.gen</code></td>
<td>
<p>Generation you want to add the new individuals to (default: New generation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recom.f.indicator</code></td>
<td>
<p>Use step function for recombination map (transform snp.positions if possible instead)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>duplication.rate</code></td>
<td>
<p>Share of recombination points with a duplication (default: 0 - DEACTIVATED)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>duplication.length</code></td>
<td>
<p>Average length of a duplication (Exponentially distributed)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>duplication.recombination</code></td>
<td>
<p>Average number of recombinations per 1 length uit of duplication (default: 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.class</code></td>
<td>
<p>Migration level of newly generated individuals (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve</code></td>
<td>
<p>If TRUE perform a breeding value estimation (default: FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.e</code></td>
<td>
<p>Enviromental variance (default: 100)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.g</code></td>
<td>
<p>Genetic variance (default: 100 - only used if not computed via estimate.sigma.g^2 in der Zuchtwertschaetzung (Default: 100)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.bv.child</code></td>
<td>
<p>(OLD! - use phenotyping.child) Starting phenotypes of newly generated individuals (default: "mean" of both parents, "obs" - regular observation, "zero" - 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phenotyping.child</code></td>
<td>
<p>Starting phenotypes of newly generated individuals (default: "mean" of both parents, "obs" - regular observation, "zero" - 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relationship.matrix</code></td>
<td>
<p>Method to calculate relationship matrix for the breeding value estimation (Default: "vanRaden", alt: "kinship", "CE", "non_stand", "CE2", "CM")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relationship.matrix.ogc</code></td>
<td>
<p>Method to calculate relationship matrix for OGC (Default: "kinship", alt: "vanRaden", "CE", "non_stand", "CE2", "CM")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>computation.A</code></td>
<td>
<p>(OLD! - use relationship.matrix) Method to calculate relationship matrix for the breeding value estimation (Default: "vanRaden", alt: "kinship", "CE", "non_stand", "CE2", "CM")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>computation.A.ogc</code></td>
<td>
<p>(OLD! use relationship.matrix.ogc) Method to calculate pedigree matrix in OGC (Default: "kinship", alt: "vanRaden", "CE", "non_stand", "CE2", "CM")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delete.haplotypes</code></td>
<td>
<p>Generations for with haplotypes of founders can be deleted (only use if storage problem!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delete.individuals</code></td>
<td>
<p>Generations for with individuals are completley deleted (only use if storage problem!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.breeding</code></td>
<td>
<p>Set of targeted matings to perform</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.breeding.best</code></td>
<td>
<p>Perform targeted matings in the group of selected individuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.offspring</code></td>
<td>
<p>Maximum number of offspring per individual (default: c(Inf,Inf) - (m,w))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.litter</code></td>
<td>
<p>Maximum number of offspring per individual (default: c(Inf,Inf) - (m,w))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.breeding.totals</code></td>
<td>
<p>If TRUE store information on selected animals in $info$breeding.totals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forecast.sigma.g</code></td>
<td>
<p>Set FALSE to not estimate sigma.g (Default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple.bve</code></td>
<td>
<p>Way to handle multiple traits in bv/selection (default: "add", alt: "ranking")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.bve.data</code></td>
<td>
<p>If TRUE store information of bve in $info$bve.data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.assignment</code></td>
<td>
<p>Set TRUE for targeted mating of best-best individual till worst-worst (of selected). set to "bestworst" for best-worst mating</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduce.group</code></td>
<td>
<p>(OLD! - use culling modules) Groups of animals for reduce to a new size (by changing class to -1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduce.group.selection</code></td>
<td>
<p>(OLD! - use culling modules) Selection criteria for reduction of groups (cf. selection.m / selection.f - default: "random")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.highest</code></td>
<td>
<p>If 0 individuals with lowest bve are selected as best individuals (default c(1,1) - (m,w))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.criteria</code></td>
<td>
<p>What to use in the selection proces (default: "bve", alt: "bv", "pheno")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>same.sex.activ</code></td>
<td>
<p>If TRUE allow matings of individuals of same sex</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>same.sex.sex</code></td>
<td>
<p>Probability to use female individuals as parents (default: 0.5)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>same.sex.selfing</code></td>
<td>
<p>Set to TRUE to allow for selfing when using same.sex matings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selfing.mating</code></td>
<td>
<p>If TRUE generate new individuals via selfing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selfing.sex</code></td>
<td>
<p>Share of female individuals used for selfing (default: 0.5)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>praeimplantation</code></td>
<td>
<p>Only use matings the lead to a specific genotype in a specific marker</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heritability</code></td>
<td>
<p>Use sigma.e to obtain a certain heritability (default: NULL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeatability</code></td>
<td>
<p>Set this to control the share of the residual variance (sigma.e) that is permanent (there for each observation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.recombination.history</code></td>
<td>
<p>If TRUE store the time point of each recombination event</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>martini.selection</code></td>
<td>
<p>If TRUE use the group of non-selected individuals as second parent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BGLR.bve</code></td>
<td>
<p>If TRUE use BGLR to perform breeding value estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BGLR.model</code></td>
<td>
<p>Select which BGLR model to use (default: "RKHS", alt: "BRR", "BL", "BayesA", "BayesB", "BayesC")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BGLR.burnin</code></td>
<td>
<p>Number of burn-in steps in BGLR (default: 1000)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BGLR.iteration</code></td>
<td>
<p>Number of iterations in BGLR (default: 5000)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BGLR.print</code></td>
<td>
<p>If TRUE set verbose to TRUE in BGLR</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy.individual</code></td>
<td>
<p>If TRUE copy the selected father for a mating</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy.individual.m</code></td>
<td>
<p>If TRUE generate exactly one copy of all selected male in a new cohort (or more by setting breeding.size)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy.individual.f</code></td>
<td>
<p>If TRUE generate exactly one copy of all selected female in a new cohort (or more by setting breeding.size)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dh.mating</code></td>
<td>
<p>If TRUE generate a DH-line in mating process</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dh.sex</code></td>
<td>
<p>Share of DH-lines generated from selected female individuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.observation</code></td>
<td>
<p>Number of phenotypes generated per individuals (influences enviromental variance)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.0isNA</code></td>
<td>
<p>Individuals with phenotype 0 are used as NA in breeding value estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phenotype.bv</code></td>
<td>
<p>If TRUE use phenotype as estimated breeding value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delete.same.origin</code></td>
<td>
<p>If TRUE delete recombination points when genetic origin of adjacent segments is the same</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove.effect.position</code></td>
<td>
<p>If TRUE remove real QTLs in breeding value estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate.u</code></td>
<td>
<p>If TRUE estimate u in breeding value estimation (Y = Xb + Zu + e)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.phenotype.correlation</code></td>
<td>
<p>(OLD! - use new.residual.correlation!) Correlation of the simulated enviromental variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.residual.correlation</code></td>
<td>
<p>Correlation of the simulated enviromental variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.breeding.correlation</code></td>
<td>
<p>Correlation of the simulated genetic variance (child share! heritage is not influenced!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate.add.gen.var</code></td>
<td>
<p>If TRUE estimate additive genetic variance and heritability based on parent model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate.pheno.var</code></td>
<td>
<p>If TRUE estimate total variance in breeding value estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best1.from.group</code></td>
<td>
<p>(OLD!- use selection.m.database) Groups of individuals to consider as First Parent / Father (also female individuals are possible)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best2.from.group</code></td>
<td>
<p>(OLD!- use selection.f.database) Groups of individuals to consider as Second Parent / Mother (also male individuals are possible)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best1.from.cohort</code></td>
<td>
<p>(OLD!- use selection.m.cohorts) Groups of individuals to consider as First Parent / Father (also female individuals are possible)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best2.from.cohort</code></td>
<td>
<p>(OLD! - use selection.f.cohorts) Groups of individuals to consider as Second Parent / Mother (also male individuals are possible)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.class.cohorts</code></td>
<td>
<p>Migration levels of all cohorts selected for reproduction are automatically added to class.m/class.f (default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.comp.times</code></td>
<td>
<p>If TRUE store computation times in $info$comp.times (default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.comp.times.bve</code></td>
<td>
<p>If TRUE store computation times of breeding value estimation in $info$comp.times.bve (default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.comp.times.generation</code></td>
<td>
<p>If TRUE store computation times of mating simulations in $info$comp.times.generation (default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>import.position.calculation</code></td>
<td>
<p>Function to calculate recombination point into adjacent/following SNP</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BGLR.save</code></td>
<td>
<p>Method to use in BGLR (default: "RKHS" - alt: NON currently)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BGLR.save.random</code></td>
<td>
<p>Add random number to store location of internal BGLR computations (only needed when simulating a lot in parallel!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc</code></td>
<td>
<p>If TRUE use optimal genetic contribution theory to perform selection ( This requires the use of the R-package optiSel)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc.target</code></td>
<td>
<p>Target of OGC (default: "min.sKin" - minimize inbreeding; alt: "max.BV" / "min.BV" - maximize genetic gain; both under constrains selected below)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc.uniform</code></td>
<td>
<p>This corresponds to the uniform constrain in optiSel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc.ub</code></td>
<td>
<p>This corresponds to the ub constrain in optiSel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc.lb</code></td>
<td>
<p>This corresponds to the lb constrain in optiSel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc.ub.sKin</code></td>
<td>
<p>This corresponds to the ub.sKin constrain in optiSel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc.lb.BV</code></td>
<td>
<p>This corresponds to the lb.BV constrain in optiSel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc.ub.BV</code></td>
<td>
<p>This corresponds to the ub.BV constrain in optiSel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc.eq.BV</code></td>
<td>
<p>This corresponds to the eq.BV constrain in optiSel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc.ub.sKin.increase</code></td>
<td>
<p>This corresponds to the upper bound (current sKin + ogc.ub.sKin.increase) as ub.sKin in optiSel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ogc.lb.BV.increase</code></td>
<td>
<p>This corresponds to the lower bound (current BV + ogc.lb.BV.increase) as lb.BV in optiSel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>emmreml.bve</code></td>
<td>
<p>If TRUE use REML estimator from R-package EMMREML in breeding value estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rrblup.bve</code></td>
<td>
<p>If TRUE use REML estimator from R-package rrBLUP in breeding value estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sommer.bve</code></td>
<td>
<p>If TRUE use REML estimator from R-package sommer in breeding value estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sommer.multi.bve</code></td>
<td>
<p>Set TRUE to use a mulit-trait model in the R-package sommer for BVE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr.edits</code></td>
<td>
<p>Number of edits to perform per individual</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gene.editing.offspring</code></td>
<td>
<p>If TRUE perform gene editing on newly generated individuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gene.editing.best</code></td>
<td>
<p>If TRUE perform gene editing on selected individuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gene.editing.offspring.sex</code></td>
<td>
<p>Which sex to perform editing on (Default c(TRUE,TRUE), mw)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gene.editing.best.sex</code></td>
<td>
<p>Which sex to perform editing on (Default c(TRUE,TRUE), mw)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gwas.u</code></td>
<td>
<p>If TRUE estimate u via GWAS (relevant for gene editing)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx.residuals</code></td>
<td>
<p>If FALSE calculate the variance for each marker separatly instead of using a set variance (doesnt change order - only p-values)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sequenceZ</code></td>
<td>
<p>Split genomic matric into parts (relevent if high memory usage)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxZ</code></td>
<td>
<p>Number of SNPs to consider in each part of sequenceZ</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxZtotal</code></td>
<td>
<p>Number of matrix entries to consider jointly (maxZ = maxZtotal/number of animals)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delete.sex</code></td>
<td>
<p>Remove all individuals from these sex from generation delete.individuals (default: 1:2 ; note:delete individuals=NULL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gwas.group.standard</code></td>
<td>
<p>If TRUE standardize phenotypes by group mean</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.gwas.used</code></td>
<td>
<p>What y value to use in GWAS study (Default: "pheno", alt: "bv", "bve")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gen.architecture.m</code></td>
<td>
<p>Genetic architecture for male animal (default: 0 - no transformation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gen.architecture.f</code></td>
<td>
<p>Genetic architecture for female animal (default: gen.architecture.m - no transformation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.architecture</code></td>
<td>
<p>List with two vectors containing (A: length of chromosomes, B: position in cM of SNPs)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore</code></td>
<td>
<p>Cores used for parallel computing in compute.snps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore.generation</code></td>
<td>
<p>Number of cores to use in parallel generation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z.integer</code></td>
<td>
<p>If TRUE save Z as a integer in parallel computing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.effect.freq</code></td>
<td>
<p>If TRUE store the allele frequency of effect markers per generation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backend</code></td>
<td>
<p>Chose the used backend (default: "doParallel", alt: "doMPI")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomSeed</code></td>
<td>
<p>Set random seed of the process</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomSeed.generation</code></td>
<td>
<p>Set random seed for parallel generation process</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rprof</code></td>
<td>
<p>Store computation times of each function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miraculix</code></td>
<td>
<p>If TRUE use miraculix to perform computations (ideally already generate population in creating.diploid with this; default: automatic detection from population list)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miraculix.cores</code></td>
<td>
<p>Number of cores used in miraculix applications (default: 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miraculix.mult</code></td>
<td>
<p>If TRUE use miraculix for matrix multiplications even if miraculix is not used for storage</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miraculix.chol</code></td>
<td>
<p>Set to FALSE to deactive miraculix based Cholesky-decomposition (default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.selection.ratio.m</code></td>
<td>
<p>Ratio of the frequency of the selection of the best best animal and the worst best animal (default=1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.selection.ratio.f</code></td>
<td>
<p>Ratio of the frequency of the selection of the best best animal and the worst best animal (default=1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.selection.criteria.m</code></td>
<td>
<p>Criteria to calculate this ratio (default: "bv", alt: "bve", "pheno")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.selection.criteria.f</code></td>
<td>
<p>Criteria to calculate this ratio (default: "bv", alt: "bve", "pheno")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.selection.manual.ratio.m</code></td>
<td>
<p>vector containing probability to draw from for every individual (e.g. c(0.1,0.2,0.7))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.selection.manual.ratio.f</code></td>
<td>
<p>vector containing probability to draw from for every individual (e.g. c(0.1,0.2,0.7))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.selection.manual.reorder</code></td>
<td>
<p>Set to FALSE to not use the order from best to worst selected individual but plain order based on database-order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.class</code></td>
<td>
<p>Consider only animals of those class classes in breeding value estimation (default: NULL - use all)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.generation</code></td>
<td>
<p>Set TRUE to active parallel computing in animal generation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name.cohort</code></td>
<td>
<p>Name of the newly added cohort</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>display.progress</code></td>
<td>
<p>Set FALSE to not display progress bars. Setting verbose to FALSE will automatically deactive progress bars</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>combine</code></td>
<td>
<p>Copy existing individuals (e.g. to merge individuals from different groups in a joined cohort). Individuals to use are used as the first parent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeat.mating</code></td>
<td>
<p>Generate multiple mating from the same dam/sire combination (first column: number of offspring; second column: probability)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeat.mating.copy</code></td>
<td>
<p>Generate multiple copies from a copy action (combine / copy.individuals.m/f) (first column: number of offspring; second column: probability)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeat.mating.fixed</code></td>
<td>
<p>Vector containing number of times each mating is repeated. This will overwrite sampling from repeat.mating / repeat.mating.copy (default: NULL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeat.mating.overwrite</code></td>
<td>
<p>Set to FALSE to not use the current repeat.mating / repeat.mating.copy input as the new standard values (default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.point</code></td>
<td>
<p>Time point at which the new individuals are generated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>creating.type</code></td>
<td>
<p>Technique to generate new individuals (usage in web-based application)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple.observation</code></td>
<td>
<p>Set TRUE to allow for more than one phenotype observation per individual (this will decrease enviromental variance!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.bv.observation</code></td>
<td>
<p>(OLD! - use phenotyping) Quick acces to phenotyping for (all: "all", non-phenotyped: "non_obs", non-phenotyped male: "non_obs_m", non-phenotyped female: "non_obs_f")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.bv.observation.gen</code></td>
<td>
<p>(OLD! use phenotyping.gen) Vector of generation from which to generate additional phenotypes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.bv.observation.cohorts</code></td>
<td>
<p>(OLD! use phenotyping.cohorts)Vector of cohorts from which to generate additional phenotype</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.bv.observation.database</code></td>
<td>
<p>(OLD! use phenotyping.database) Matrix of groups from which to generate additional phenotypes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phenotyping</code></td>
<td>
<p>Quick acces to phenotyping for (all: "all", non-phenotyped: "non_obs", non-phenotyped male: "non_obs_m", non-phenotyped female: "non_obs_f")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phenotyping.gen</code></td>
<td>
<p>Vector of generation from which to generate additional phenotypes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phenotyping.cohorts</code></td>
<td>
<p>Vector of cohorts from which to generate additional phenotype</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phenotyping.database</code></td>
<td>
<p>Matrix of groups from which to generate additional phenotypes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.gen</code></td>
<td>
<p>Generations of individuals to consider in breeding value estimation (default: NULL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.cohorts</code></td>
<td>
<p>Cohorts of individuals to consider in breeding value estimation (default: NULL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.database</code></td>
<td>
<p>Groups of individuals to consider in breeding value estimation (default: NULL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.e.gen</code></td>
<td>
<p>Generations to consider when estimating sigma.e when using hertability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.e.cohorts</code></td>
<td>
<p>Cohorts to consider when estimating sigma.e when using hertability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.e.database</code></td>
<td>
<p>Groups to consider when estimating sigma.e when using hertability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.g.gen</code></td>
<td>
<p>Generations to consider when estimating sigma.g</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.g.cohorts</code></td>
<td>
<p>Cohorts to consider when estimating sigma.g</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.g.database</code></td>
<td>
<p>Groups to consider when estimating sigma.g</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gwas.gen</code></td>
<td>
<p>Generations to consider in GWAS analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gwas.cohorts</code></td>
<td>
<p>Cohorts to consider in GWAS analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gwas.database</code></td>
<td>
<p>Groups to consider in GWAS analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.insert.gen</code></td>
<td>
<p>Generations of individuals to compute breeding values for (default: all groups in bve.database)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.insert.cohorts</code></td>
<td>
<p>Cohorts of individuals to compute breeding values for (default: all groups in bve.database)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.insert.database</code></td>
<td>
<p>Groups of individuals to compute breeding values for (default: all groups in bve.database)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduced.selection.panel.m</code></td>
<td>
<p>Use only a subset of individuals of the potential selected ones ("Split in user-interface")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduced.selection.panel.f</code></td>
<td>
<p>Use only a subset of individuals of the potential selected ones ("Split in user-interface")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breeding.all.combination</code></td>
<td>
<p>Set to TRUE to automatically perform each mating combination possible exactly ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>depth.pedigree</code></td>
<td>
<p>Depth of the pedigree in generations (default: 7)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>depth.pedigree.ogc</code></td>
<td>
<p>Depth of the pedigree in generations (default: 7)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy.individual.keep.bve</code></td>
<td>
<p>Set to FALSE to not keep estimated breeding value in case of use of copy.individuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy.individual.keep.pheno</code></td>
<td>
<p>Set to FALSE to not keep estimated breeding values in case of use of copy.individuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.avoid.duplicates</code></td>
<td>
<p>If set to FALSE multiple generatations of the same individual can be used in the bve (only possible by using copy.individual to generate individuals)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>report.accuracy</code></td>
<td>
<p>Report the accuracy of the breeding value estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>share.genotyped</code></td>
<td>
<p>Share of individuals newly generated individuals that are genotyped</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>singlestep.active</code></td>
<td>
<p>Set TRUE to use single step in breeding value estimation (only implemented for vanRaden- G matrix and without use sequenceZ) (Legarra 2014)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove.non.genotyped</code></td>
<td>
<p>Set to FALSE to manually include non-genotyped individuals in genetic BVE, single-step will deactive this as well</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>added.genotyped</code></td>
<td>
<p>Share of individuals that is additionally genotyped (only for copy.individuals)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast.uhat</code></td>
<td>
<p>Set to FALSE to  derive inverse of A in rrBLUP</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offspring.bve.parents.gen</code></td>
<td>
<p>Generations to consider to derive phenotype from offspring phenotypes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offspring.bve.parents.database</code></td>
<td>
<p>Groups to consider to derive phenotype from offspring phenotypes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offspring.bve.parents.cohorts</code></td>
<td>
<p>Cohorts to consider to derive phenotype from offspring phenotypes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offspring.bve.offspring.gen</code></td>
<td>
<p>Active generations for import of offspring phenotypes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offspring.bve.offspring.database</code></td>
<td>
<p>Active groups for import of offspring phenotypes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offspring.bve.offspring.cohorts</code></td>
<td>
<p>Active cohorts for import of offspring phenotypes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.gen</code></td>
<td>
<p>Generations to consider to culling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.database</code></td>
<td>
<p>Groups to consider to culling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.cohort</code></td>
<td>
<p>Cohort to consider to culling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.time</code></td>
<td>
<p>Age of the individuals at culling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.name</code></td>
<td>
<p>Name of the culling action (user-interface stuff)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.bv1</code></td>
<td>
<p>Reference Breeding value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.share1</code></td>
<td>
<p>Probability of death for individuals with bv1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.bv2</code></td>
<td>
<p>Alternative breeding value (linear extended for other bvs)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.share2</code></td>
<td>
<p>Probability of death for individuals with bv2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.index</code></td>
<td>
<p>Genomic index (default:0 - no genomic impact, use: "lastindex" to use the last selection index applied in selection)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.single</code></td>
<td>
<p>Set to FALSE to not apply the culling module on all individuals of the cohort</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>culling.all.copy</code></td>
<td>
<p>Set to FALSE to not kill copies of the same individual in the culling module</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calculate.reliability</code></td>
<td>
<p>Set TRUE to calculate a reliability when performing Direct-Mixed-Model BVE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.m.gen</code></td>
<td>
<p>Generations available for selection of paternal parent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.f.gen</code></td>
<td>
<p>Generations available for selection of maternal parent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.m.database</code></td>
<td>
<p>Groups available for selection of paternal parent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.f.database</code></td>
<td>
<p>Groups available for selection of maternal parent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.m.cohorts</code></td>
<td>
<p>Cohorts available for selection of paternal parent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.f.cohorts</code></td>
<td>
<p>Cohorts available for selection of maternal parent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.m.miesenberger</code></td>
<td>
<p>Use Weighted selection index according to Miesenberger 1997 for paternal selection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.f.miesenberger</code></td>
<td>
<p>Use Weighted selection index according to Miesenberger 1997 for maternal selection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.miesenberger.reliability.est</code></td>
<td>
<p>If available reliability estimated are used. If not use default:"estimated" (SD BVE / SD Pheno), alt: "heritability", "derived" (cor(BVE,BV)^2) as replacement</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miesenberger.trafo</code></td>
<td>
<p>Ignore all eigenvalues below this threshold and apply dimension reduction (default: 0 - use all)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple.bve.weights.m</code></td>
<td>
<p>Weighting between traits when using "add" (default: 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple.bve.weights.f</code></td>
<td>
<p>Weighting between traits when using "add" (default: same as multiple.bve.weights.m)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple.bve.scale.m</code></td>
<td>
<p>Default: "bv_sd"; Set to "pheno_sd" when using gains per phenotypic SD, "unit" when using gains per unit, "bve" when using estimated breeding values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple.bve.scale.f</code></td>
<td>
<p>Default: "bv_sd"; Set to "pheno_sd" when using gains per phenotypic SD, "unit" when using gains per unit, "bve" when using estimated breeding values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Set to FALSE to not display any prints</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.parent.mean</code></td>
<td>
<p>Set to TRUE to use the average parental performance as the breeding value estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.grandparent.mean</code></td>
<td>
<p>Set to TRUE to use the average grandparental performance as the breeding value estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.mean.between</code></td>
<td>
<p>Select if you want to use the "bve", "bv", "pheno" or "bvepheno" to form the mean (default: "bvepheno" - if available bve, else pheno)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.direct.est</code></td>
<td>
<p>If TRUE predict BVEs in direct estimation according to vanRaden 2008 method 2 (default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.pseudo</code></td>
<td>
<p>If set to TRUE the breeding value estimation will be simulated with resulting accuracy bve.pseudo.accuracy (default: 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.pseudo.accuracy</code></td>
<td>
<p>The accuracy to be obtained in the "pseudo" - breeding value estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miraculix.destroyA</code></td>
<td>
<p>If FALSE A will not be destroyed in the process of inversion (less computing / more memory)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mas.bve</code></td>
<td>
<p>If TRUE use marker assisted selection in the breeding value estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mas.markers</code></td>
<td>
<p>Vector containing markers to be used in marker assisted selection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mas.number</code></td>
<td>
<p>If no markers are provided this nr of markers is selected (if single marker QTL are present highest effect markers are prioritized)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mas.effects</code></td>
<td>
<p>Effects assigned to the MAS markers (Default: estimated via lm())</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold.selection</code></td>
<td>
<p>Minimum value in the selection index selected individuals have to have</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold.sign</code></td>
<td>
<p>Pick all individuals above ("&gt;") the threshold. Alt: ("&lt;", "=", "&lt;=", "&gt;=")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input.phenotype</code></td>
<td>
<p>Select what to use in BVE (default: own phenotype ("own"), offspring phenotype ("off"), their average ("mean") or a weighted average ("weighted"))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.ignore.traits</code></td>
<td>
<p>Vector of traits to ignore in the breeding value estimation (default: NULL, use: "zero" to not consider traits with 0 index weight in multiple.bve.weights.m/.w)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bv.ignore.traits</code></td>
<td>
<p>Vector of traits to ignore in the calculation of the genomic value (default: NULL; Only recommended for high number of traits and experienced users!)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genotyped.database</code></td>
<td>
<p>Groups to generate genotype data (that can be used in a BVE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genotyped.gen</code></td>
<td>
<p>Generations to generate genotype data (that can be used in a BVE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genotyped.cohorts</code></td>
<td>
<p>Cohorts to generate genotype data (that can be used in a BVE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genotyped.share</code></td>
<td>
<p>Share of individuals in genotyped.gen/database/cohort to generate genotype data from (default: 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genotyped.array</code></td>
<td>
<p>Genotyping array used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sex.s</code></td>
<td>
<p>Specify which newly added individuals are male (1) or female (2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.imputation</code></td>
<td>
<p>Set to FALSE to not perform imputation up to the highest marker density of genotyping data that is available</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.imputation.errorrate</code></td>
<td>
<p>Share of errors in the imputation procedure (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>share.phenotyped</code></td>
<td>
<p>Share of the individuals to phenotype</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avoid.mating.fullsib</code></td>
<td>
<p>Set to TRUE to not generate offspring of full siblings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avoid.mating.halfsib</code></td>
<td>
<p>Set to TRUE to not generate offspring from half or full siblings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.mating.pair</code></td>
<td>
<p>Set to the maximum number of matings between two individuals (default: Inf)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.per.sample.sigma.e</code></td>
<td>
<p>Set to FALSE to deactivate the use of a heritablity based on the number of observations generated per sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bve.solve</code></td>
<td>
<p>Provide solver to be used in BVE (default: "exact" solution via inversion, alt: "pcg", function with inputs A, b and output y_hat)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Population-list
</p>


<h3>Examples</h3>

<pre><code class="language-R">population &lt;- creating.diploid(nsnp=1000, nindi=100)
population &lt;- breeding.diploid(population, breeding.size=100, selection.size=c(25,25))
</code></pre>


</div>