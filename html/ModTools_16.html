<div class="container">

<table style="width: 100%;"><tr>
<td>ModTools-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regression and Classification Tools
</h2>

<h3>Description</h3>

<p>There is a rich selection of R packages implementing algorithms for classification and regression tasks out there. The authors legitimately take the liberty to tailor the function interfaces according to their own taste  and needs. For us other users, however, this often results in struggling with user interfaces, some of which are rather weird - to put it mildly - and almost always different in terms of arguments and result structures.
<b>ModTools</b> pursues the goal of offering uniform handling for the most important regression and classification models in applied data analyses.<br>
The function <code>FitMod()</code> is designed as a simple and consistent interface to these original functions while maintaining the flexibility to pass on all possible arguments. <code>print</code>, <code>plot</code>, <code>summary</code> and <code>predict</code> operations can so be carried out following the same logic. The results will again be reshaped to a reasonable standard.
</p>
<p>For all the functions of this package Google styleguides are used as naming rules (in absence of convincing alternatives). The 'BigCamelCase' style has been consequently applied to functions borrowed from contributed R packages as well.
</p>
<p>As always: Feedback, feature requests, bugreports and other suggestions are welcome!
</p>


<h3>Details</h3>

<p>The <code>ModTools::FitMod())</code> function comprises interfaces to the following models:
</p>

<table>
<tr>
<td style="text-align: left;">
<b>Regression</b>:</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
 <code>lm()</code>  </td>
<td style="text-align: left;"> 	 Linear model OLS (<b>base</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>lmrob()</code>  </td>
<td style="text-align: left;"> 	 Robust linear model (<b>robustbase</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>poisson()</code>  </td>
<td style="text-align: left;"> 	GLM model with family <code>poisson</code> (<b>base</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>negbin()</code>  </td>
<td style="text-align: left;"> 	GLM model with family <code>negative.binomial</code> (<b>MASS</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>gamma()</code>  </td>
<td style="text-align: left;"> 		GLM model with family <code>gamma</code> (<b>base</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>tobit()</code>  </td>
<td style="text-align: left;"> 	Tobit model for censored responses (package  <b>AER</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<b>Classification</b>:	</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>lda()</code>  </td>
<td style="text-align: left;"> 	 Linear discriminant analysis (<b>MASS</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>qda()</code>  </td>
<td style="text-align: left;"> 	 Quadratic discriminant analysis (<b>MASS</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>logit()</code>  </td>
<td style="text-align: left;"> 	 Logistic Regression model <code>glm</code>, family <code>binomial(logit)</code>(<b>base</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>multinom()</code>  </td>
<td style="text-align: left;"> 	 Multinomial Regression model (<b>nnet</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>polr()</code>  </td>
<td style="text-align: left;"> 	 Proportional odds model (<b>MASS</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>rpart()</code>  </td>
<td style="text-align: left;"> 	 Regression and classification trees (<b>rpart</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>nnet()</code>  </td>
<td style="text-align: left;"> 	 Neuronal networks (<b>nnet</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>randomForest()</code>   </td>
<td style="text-align: left;"> 	 Random forests (<b>randomForest</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>C5.0()</code>   </td>
<td style="text-align: left;"> 	 C5.0 tree (<b>C50</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>svm()</code>   </td>
<td style="text-align: left;"> 	 Support vector machines (<b>e1071</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>naive_bayes()</code>   </td>
<td style="text-align: left;"> 	 Naive Bayes classificator (<b>naivebayes</b>)</td>
</tr>
<tr>
<td style="text-align: left;">
<code>LogitBoost()</code>  </td>
<td style="text-align: left;"> 	 Logit boost (using decision
  stumps as weak learners) (<b>ModTools</b>)</td>
</tr>
<tr>
<td style="text-align: left;">


















</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"> <b>Preprocess</b>:</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>SplitTrainTest()</code>  </td>
<td style="text-align: left;"> 	Splits a data frame or index vector into a training and a test sample</td>
</tr>
<tr>
<td style="text-align: left;">
<code>OverSample()</code>  </td>
<td style="text-align: left;"> Get balanced datasets by sampling with replacement.</td>
</tr>
<tr>
<td style="text-align: left;">

</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"> <b>Manipulating <code>rpart</code> objects</b>:</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>CP()</code>  </td>
<td style="text-align: left;"> Extract and plot complexity table of an rpart tree.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>Node()</code>  </td>
<td style="text-align: left;"> Accessor to the most important properties of a node, being a split or a leaf.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>Rules()</code>  </td>
<td style="text-align: left;"> Extract the decision rules from top to the end node of an rpart tree.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>LeafRates()</code>  </td>
<td style="text-align: left;"> Returns the misclassification rates in all end nodes.</td>
</tr>
<tr>
<td style="text-align: left;">

</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"> <b>Prediction and Validation</b>:</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>Response()</code>  </td>
<td style="text-align: left;"> Extract the response variable of any model.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>predict()</code>  </td>
<td style="text-align: left;"> 	 Consistent predict for <code>FitMod</code> models</td>
</tr>
<tr>
<td style="text-align: left;">
<code>VarImp()</code>  </td>
<td style="text-align: left;"> 	 Variable importance for most <code>FitMod</code> models</td>
</tr>
<tr>
<td style="text-align: left;">
<code>ROC()</code>  </td>
<td style="text-align: left;"> ROC curves for all dichotomous classification <code>FitMod</code> models	 </td>
</tr>
<tr>
<td style="text-align: left;">
<code>BestCut()</code>  </td>
<td style="text-align: left;"> 	Find the optimal cut for a classification based on the ROC curve.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>PlotLift()</code>  </td>
<td style="text-align: left;"> Produces a lift chart for a binary classification model	 </td>
</tr>
<tr>
<td style="text-align: left;">
<code>TModC()</code>  </td>
<td style="text-align: left;"> Aggregated results for multiple <code>FitMod</code> classification models </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Tune()</code>  </td>
<td style="text-align: left;"> Tuning approaches to find optimal parameters for <code>FitMod</code> classification models.	 </td>
</tr>
<tr>
<td style="text-align: left;">
<code>RobSummary()</code>  </td>
<td style="text-align: left;"> Robust summary for GLM models (poisson).</td>
</tr>
<tr>
<td style="text-align: left;">

</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<b>Tests</b>:	</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">
<code>BreuschPaganTest()</code>  </td>
<td style="text-align: left;"> 	 Breusch-Pagan test against heteroskedasticity.</td>
</tr>
<tr>
<td style="text-align: left;">

</td>
</tr>
</table>
<h3>Warning</h3>

<p>This package is still under development. You should be aware that everything in the package might be subject to change. Backward compatibility is not yet guaranteed. Functions may be deleted or renamed and new syntax may be inconsistent with earlier versions. By release of version 1.0 the "deprecated-defunct process" will be installed.
</p>


<h3>Author(s)</h3>

<p>Andri Signorell<br>
Helsana Versicherungen AG, Health Sciences, Zurich<br>
HWZ University of Applied Sciences in Business Administration Zurich.<br></p>
<p>Includes R source code and/or documentation previously published by (in alphabetical order): <br>
Bernhard Compton, Marcel Dettling, Max Kuhn, Michal Majka, Dan Putler, Jarek Tuszynski, Robin Xavier, Achim Zeileis
</p>
<p>The good things come from all these guys, any problems are likely due to my tweaking.
Thank you all! <br></p>
<p>Maintainer: Andri Signorell &lt;andri@signorell.net&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">
r.swiss &lt;- FitMod(Fertility ~ ., swiss, fitfn="lm")
r.swiss
# PlotTA(r.swiss)
# PlotQQNorm(r.swiss)


## Count models

data(housing, package="MASS")

# poisson count
r.pois &lt;- FitMod(Freq ~ Infl*Type*Cont + Sat, family=poisson, data=housing, fitfn="poisson")

# negative binomial count
r.nb &lt;- FitMod(Freq ~ Infl*Type*Cont + Sat, data=housing, fitfn="negbin")
summary(r.nb)

r.log &lt;- FitMod(log(Freq) ~ Infl*Type*Cont + Sat, data=housing, fitfn="lm")
summary(r.log)

r.ols &lt;- FitMod(Freq ~ Infl*Type*Cont + Sat, data=housing, fitfn="lm")
summary(r.ols)

r.gam &lt;- FitMod(Freq ~ Infl*Type*Cont + Sat, data=housing, fitfn="gamma")
summary(r.gam)

r.gami &lt;- FitMod(Freq ~ Infl*Type*Cont + Sat, data=housing, fitfn="gamma", link="identity")
summary(r.gami)

old &lt;-options(digits=3)
TMod(r.pois, r.nb, r.log, r.ols, r.gam, r.gami)
options(old)


## Ordered Regression

r.polr &lt;- FitMod(Sat ~ Infl + Type + Cont, data=housing, fitfn="polr", weights = Freq)

# multinomial Regression
# r.mult &lt;- FitMod(factor(Sat, ordered=FALSE) ~ Infl + Type + Cont, data=housing,
#                  weights = housing$Freq, fitfn="multinom")


# Regression tree
r.rp &lt;- FitMod(factor(Sat, ordered=FALSE) ~ Infl + Type + Cont, data=housing,
                 weights = housing$Freq, fitfn="rpart")

# compare predictions
d.p &lt;- expand.grid(Infl=levels(housing$Infl), Type=levels(housing$Type), Cont=levels(housing$Cont))
d.p$polr &lt;- predict(r.polr, newdata=d.p)
# ??
# d.p$ols &lt;- factor(round(predict(r.ols, newdata=d.p)^2), labels=levels(housing$Sat))
# d.p$mult &lt;- predict(r.mult, newdata=d.p)
d.p$rp &lt;- predict(r.rp, newdata=d.p, type="class")

d.p


# Classification with 2 classes  ***************

r.pima &lt;- FitMod(diabetes ~ ., d.pima, fitfn="logit")
r.pima
Conf(r.pima)
plot(ROC(r.pima))
OddsRatio(r.pima)


# rpart tree
rp.pima &lt;- FitMod(diabetes ~ ., d.pima, fitfn="rpart")
rp.pima
Conf(rp.pima)
lines(ROC(rp.pima), col=hblue)
# to be improved
plot(rp.pima, col=SetAlpha(c("blue","red"), 0.4), cex=0.7)


# Random Forest
rf.pima &lt;- FitMod(diabetes ~ ., d.pima, method="class", fitfn="randomForest")
rf.pima
Conf(rf.pima)
lines(ROC(r.pima), col=hred)



# more models to compare

d.pim &lt;- SplitTrainTest(d.pima, p = 0.2)
mdiab &lt;- formula(diabetes ~ pregnant + glucose + pressure + triceps
                            + insulin + mass + pedigree + age)

r.glm &lt;- FitMod(mdiab, data=d.pim$train, fitfn="logit")
r.rp &lt;- FitMod(mdiab, data=d.pim$train, fitfn="rpart")
r.rf &lt;- FitMod(mdiab, data=d.pim$train, fitfn="randomForest")
r.svm &lt;- FitMod(mdiab, data=d.pim$train, fitfn="svm")
r.c5 &lt;- FitMod(mdiab, data=d.pim$train, fitfn="C5.0")
r.nn &lt;- FitMod(mdiab, data=d.pim$train, fitfn="nnet")
r.nb &lt;- FitMod(mdiab, data=d.pim$train, fitfn="naive_bayes")
r.lda &lt;- FitMod(mdiab, data=d.pim$train, fitfn="lda")
r.qda &lt;- FitMod(mdiab, data=d.pim$train, fitfn="qda")
r.lb &lt;- FitMod(mdiab, data=d.pim$train, fitfn="lb")

mods &lt;- list(glm=r.glm, rp=r.rp, rf=r.rf, svm=r.svm, c5=r.c5
             , nn=r.nn, nb=r.nb, lda=r.lda, qda=r.qda, lb=r.lb)

# insight in the Regression tree
plot(r.rp, box.palette = as.list(Pal("Helsana", alpha = 0.5)))

# Insample accuracy ...
TModC(mods, ord="auc")
# ... is substantially different from the out-of-bag:
TModC(mods, newdata=d.pim$test, reference=d.pim$test$diabetes, ord="bs")
# C5 and SVM turn out to be show-offs! They overfit quite ordinary
# whereas randomforest and logit keep their promises. ...

sapply(mods, function(z) VarImp(z))


# Multinomial classification problem with n classes  ***************

d.gl &lt;- SplitTrainTest(d.glass, p = 0.2)
mglass &lt;- formula(Type ~ RI + Na + Mg + Al + Si + K + Ca + Ba + Fe)

# *** raises an unclear error in CRAN-Debian tests *** ??
# r.mult &lt;- FitMod(mglass, data=d.gl$train, maxit=600, fitfn="multinom")
r.rp &lt;- FitMod(mglass, data=d.gl$train, fitfn="rpart")
r.rf &lt;- FitMod(mglass, data=d.gl$train, fitfn="randomForest")
r.svm &lt;- FitMod(mglass, data=d.gl$train, fitfn="svm")
r.c5 &lt;- FitMod(mglass, data=d.gl$train, fitfn="C5.0")
r.nn &lt;- FitMod(mglass, data=d.gl$train, fitfn="nnet")
r.nbay &lt;- FitMod(mglass, data=d.gl$train, fitfn="naive_bayes")
r.lda &lt;- FitMod(mglass, data=d.gl$train, fitfn="lda")
# r.qda &lt;- FitMod(mglass, data=d.glass, fitfn="qda")
r.lb &lt;- FitMod(mglass, data=d.gl$train, fitfn="lb")

mods &lt;- list(rp=r.rp, rf=r.rf, svm=r.svm, c5=r.c5,
             nn=r.nn, nbay=r.nbay, lda=r.lda, lb=r.lb)

# confusion matrix and other quality measures can be calculated with Conf()
Conf(r.rf)

# we only extract the general accuracy
sapply(lapply(mods, function(z) Conf(z)), "[[", "acc")

# let's compare r.mult with a model without RI as predictor
# Conf(r.mult)
# Conf(update(r.mult, . ~ . -RI))
</code></pre>


</div>