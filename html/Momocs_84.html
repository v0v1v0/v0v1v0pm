<div class="container">

<table style="width: 100%;"><tr>
<td>Coo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Coo "super" class</h2>

<h3>Description</h3>

<p><code>Coo</code> class is the 'parent' or 'super' class of
<code>Out</code>, <code>Opn</code> and <code>Ldk</code> classes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Coo(...)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>anything and, anyway, this function will simply returns a message.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Useful shortcuts are described below. See <code>browseVignettes("Momocs")</code> for
a detail of the design behind Momocs' classes.
</p>
<p><code>Coo</code> class is the 'parent' class of the following 'child' classes </p>

<ul>
<li> <p><code>Out</code> for closed <b>out</b>lines
</p>
</li>
<li> <p><code>Opn</code> for <b>op</b>e<b>n</b> outlines
</p>
</li>
<li> <p><code>Ldk</code> for configuration of <b>l</b>an<b>d</b>mar<b>k</b>s
</p>
</li>
</ul>
<p>Since all 'child classes' of them handle <code class="reqn">(x; y)</code> coordinates among other generic methods,
but also all have their specificity, this architecture allow to recycle generic methods and
to use specific methods.
</p>
<p>In other words, <code>Out</code>, <code>Opn</code> and <code>Ldk</code> classes
are all, primarily, <code>Coo</code> objects on which we define generic <em>and</em>
specific methods. See their respective help pages for more help.
</p>
<p><code>Coo</code> objects all have the following components:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠$coo⁠</code> which is a list of matrices for coordinates
</p>
</li>
<li> <p><code style="white-space: pre;">⁠$fac⁠</code> a <code>data_frame</code> for covariates (if any). You can provide
this data_frame directly, as long as it has as many rows as there are matrices in <code style="white-space: pre;">⁠$coo⁠</code> (see examples),
or use an helper function such as lf_structure.
</p>
</li>
</ul>
<p>You can access all the methods available for <code>Coo</code> objects
with <code>methods(class=Coo)</code>.
</p>


<h3>Value</h3>

<p>a list of class Coo
</p>


<h3>See Also</h3>

<p>Other classes: 
<code>Coe()</code>,
<code>Ldk()</code>,
<code>OpnCoe()</code>,
<code>Opn()</code>,
<code>OutCoe()</code>,
<code>Out()</code>,
<code>TraCoe()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># to see all methods for Coo objects.
methods(class='Coo')

# to see all methods for Out objects.
methods(class='Out') # same for Opn and Ldk

# Let's take an Out example. But all methods shown here
# work on Ldk (try on 'wings') and on Opn ('olea')
bot

# Primarily a 'Coo' object, but also an 'Out'
class(bot)
inherits(bot, "Coo")
panel(bot)
stack(bot)

# Getters (you can also use it to set data)
bot[1] %&gt;% coo_plot()
bot[1:5] %&gt;% str()

# Setters
bot[1] &lt;- shapes[4]
panel(bot)

bot[1:5] &lt;- shapes[4:8]
panel(bot)

# access the different components
# $coo coordinates
head(bot$coo)
# $fac grouping factors
head(bot$fac)
# or if you know the name of the column of interest
bot$type
# table
table(bot$fac)
# an internal view of an Out object
str(bot)

# subsetting
# see ?filter, ?select, and their 'see also' section for the
# complete list of dplyr-like verbs implemented in Momocs

length(bot) # the number of shapes
names(bot) # access all individual names
bot2 &lt;- bot
names(bot2) &lt;- paste0('newnames', 1:length(bot2)) # define new names

# Add a $fac from scratch
coo &lt;- bot[1:5] # a list of five matrices
length(coo)
sapply(coo, class)

fac &lt;- data.frame(name=letters[1:5], value=c(5:1))
# Then you have to define the subclass using the right builder
# here we have outlines, so we use Out
x &lt;- Out(coo, fac)
x$coo
x$fac
</code></pre>


</div>