<div class="container">

<table style="width: 100%;"><tr>
<td>MonteCarlo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parallized Monte Carlo Simulation</h2>

<h3>Description</h3>

<p><code>MonteCarlo</code> runs a Monte Carlo simulation study for a correctly specified function and the desired parameter grids. 
See details for instructions on the specification of the function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MonteCarlo(func, nrep, param_list, ncpus = 1, max_grid = 1000,
  time_n_test = FALSE, save_res = FALSE, raw = TRUE,
  export_also = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p>The function to be evaluated. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>
<p>An integer that specifies the desired number of Monte Carlo repetitions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param_list</code></td>
<td>
<p>A list whose components are named after the parameters of <code>func</code> and each component is a vector containing the desired grid values for that parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>An integer specifying the number of cpus to be used. Default is <code>ncpus=1</code>. 
For <code>ncpus&gt;1</code> the simulation is parallized automatically using <code>ncpus</code> cpu units.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_grid</code></td>
<td>
<p>Integer that specifies for which grid size to throw an error, if grid becomes to large. Default is <code>max_grid=1000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_n_test</code></td>
<td>
<p>Boolean that specifies whether the required simulation time should be estimated (useful for large simulations or slow functions). 
See details. Default is <code>time_n_test=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_res</code></td>
<td>
<p>Boolean that specifies whether the results of <code>time_n_test</code> should be saved to the current directory. 
Default is <code>save_res=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>
<p>Boolean that specifies whether the output should be averaged over the nrep repetitions. Default is <code>raw=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>export_also</code></td>
<td>
<p>List specifying additional objects that are supposed to be exported to the cluster. 
This allows to export data or to bypass the automatic export of functions. Default is <code>export_also=NULL</code>. See details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The user defined function <code>func</code> handles the generation of data, the application of the method of interest 
and the evaluation of the result for a single repetition and parameter combination. 
MonteCarlo handles the generation of loops over the desired parameter grids and the 
repetition of the Monte Carlo experiment for each of the parameter constellations.
</p>
<p>There are two important formal requirements that <code>func</code> has to fulfill. 
</p>
<p>1. The arguments of <code>func</code> have to be scalar.
</p>
<p>2. The value returned by <code>func</code> has to be list of (unnamed) scalars (The list elements can be named). 
</p>
<p>For the estimation of the required simulation time, 
a separate simulation is run on a reduced grid that only contains the extreme points 
for each parameter, e.g. the smallest and the largest sample size. 
This test simulation is carried out with <code>nrep/10</code> repetitions and the required 
simulation time is estimated by a linear interpolation. Since the computational complexity is
usually a convex function of the sample size and the dimension of the process, this approach 
tends to overestimate the time required. 
</p>
<p><code>export_also</code> allows to export data to the cluster in case parallized computations on a dataset are desired. 
It also allows to bypass the automatic export of functions and packages. 
To manually export a function or dataset or to load a package, pass a list to <code>export_also</code> where the list elements are named
"functions", "data" and/or "packages". For example: <code>export_also=list("functions"=c("function_name_1", "function_name_2"), 
"packages"="package_name", "data"="mtcars"</code>.
</p>


<h3>Value</h3>

<p>A list of type <code>MonteCarlo</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">test_func&lt;-function(n,loc,scale){
 sample&lt;-rnorm(n, loc, scale)
 stat&lt;-sqrt(n)*mean(sample)/sd(sample)
 decision&lt;-abs(stat)&gt;1.96
 return(list("decision"=decision))
}

# Example without parallization
n_grid&lt;-c(50,100,250,500)
loc_grid&lt;-seq(0,1,0.2)
scale_grid&lt;-c(1,2)

param_list=list("n"=n_grid, "loc"=loc_grid, "scale"=scale_grid)
erg&lt;-MonteCarlo(func=test_func, nrep=250, param_list=param_list, ncpus=1)
summary(erg)

rows&lt;-c("n")
cols&lt;-c("loc","scale")
MakeTable(output=erg, rows=rows, cols=cols, digits=2)

# Note that parallized computation is not always faster, 
# due to the computational costs of the overhead 
# that is needed to manage multiple CPUs.

</code></pre>


</div>