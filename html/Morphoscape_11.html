<div class="container">

<table style="width: 100%;"><tr>
<td>generate_weights</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate a matrix containing weight combinations</h2>

<h3>Description</h3>

<p><code>generate_weights()</code> generates a matrix containing weight combinations for a set of variables such that each set of weights sums to 1. This can be supplied to <code>calc_all_lscps</code> to calculate fitness landscapes corresponding to a variety of possible sets of weights for weighting functional characteristics. The weights are generated by partitioning a weight of 1 across however many variables are requested in all possible ways.
</p>


<h3>Usage</h3>

<pre><code class="language-R">generate_weights(step, n, data = NULL, nvar = NULL,
                 varnames = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>

<p><code>numeric</code>. The step size between weight partitions. Only one of <code>step</code> and <code>n</code> can be specified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p><code>numeric</code>. The number of weight partitions between 0-1. Only one of <code>step</code> and <code>n</code> can be specified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an optional <code>fnc_df</code> (the output of <code>as_fnc_df</code>) or <code>kriged_surfaces</code> (the output <code>krige_surf</code>) object. The number of variabes and their names will be extracted from the data as the functional characteristics present in them.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvar</code></td>
<td>

<p>the number of variables across which to allocate the weights. Ignored if <code>data</code> is not <code>NULL</code>. If <code>nvar = NULL</code> and <code>varnames</code> is supplied, the length of <code>varnames</code> will be used for <code>nvar</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varnames</code></td>
<td>

<p>the names of the variables across which to allocate the weights. Ignored if <code>data</code> is not <code>NULL</code>. If <code>varnames = NULL</code> and <code>nvar</code> is supplied, the sequence from 1 to <code>nar</code> will be used for <code>varnames</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>whether to display a message noting the number of sets of weights created.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>generate_weights()</code> works by fining all possible allocations of <code>n</code> objects into <code>nvar</code> bins. When <code>step</code> is supplied, <code>n</code> is computed as <code>round(1/step)</code>, so the resulting weight partitions may not be exactly equal to <code>step</code> when its inverse is not an integer. The larger <code>n</code> is (or the smaller <code>step</code>) is, the more possible allocations will be produced (i.e., and the resulting object will have more rows). The output of <code>generate_weights()</code> can quickly become very large with increasing number of variables, and will make subsequent analyses slow. It is recommended to start with a large <code>step</code> size, or small <code>n</code>, and increment up.
</p>


<h3>Value</h3>

<p>A <code>grid_weights</code> object, which is a matrix with a row for each each set of weights and a column for each variable over which the weights are allocated. The weights in each row will sum to 1.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Allocating 10 partitions of .1 across 3 variables
wmat &lt;- generate_weights(n = 10, nvar = 3)
head(wmat)

# Allocating 5 partitions of .2 across the 4 functional
# characteristics in the warps dataset
data("warps")

warps_fnc &lt;- as_fnc_df(warps)
wmat &lt;- generate_weights(n = 5, data = warps_fnc)
head(wmat)

# Using 'step' for the same result:
wmat &lt;- generate_weights(step = .2, data = warps_fnc)
head(wmat)
</code></pre>


</div>