<div class="container">

<table style="width: 100%;"><tr>
<td>calcPoly</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Calculate polynomial fits over a surface
</h2>

<h3>Description</h3>

<p><code>calcPoly</code> calls on the <code>spatial</code> package to fit rectangular spatial polynomial surface models by least-squares, or GLS. These methods allow the user to test whether data have spatial trends in morphospace. Outputs are a polynomial trend surface, and ANOVA table for the model fit. <code>multiPoly</code> applies <code>calcPoly</code> to a <code>fnc_df</code> with outputs for each trait. For more extensive documentation for model fitting see the <code>spatial</code> package. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">calcPoly(fnc, npoly = 3, fnc.name = NULL, 
         gls.covmod = list(covmod = expcov, d = 0.7, alpha = 0, se = 1), 
         pad = 1.2, resample = 100, range = NULL, verbose = FALSE)
                     
multiPoly(fnc_df, npoly = 3, ...)                     
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fnc</code></td>
<td>

<p>an XYZ dataframe or matrix of a spatially distributed trait.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fnc_df</code></td>
<td>

<p>a functional dataframe from <code>as_fnc_df</code> with colnames corresponding to X,Y and trait names.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npoly</code></td>
<td>

<p>singular numeric. Degree of polynomial to fit ragning from 1-4. For <code>multiPoly</code> this can also be a vector with length equal to the numer of traits in order to specify the degree of polynomial to apply to each trait.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gls.covmod</code></td>
<td>

<p>Optional list of arguments to pass to <code>surf.gls</code> if fitting by generalized least-squares is desired. Defaults to NULL, and fitting is performed by least-squares. See <code>surf.gls</code> and <code>expcov</code> documentation for a full list of arguments and usage.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fnc.name</code></td>
<td>

<p>Optional speficiation of the trait name. Defaults to <code>NULL</code>, and will use column names instead.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pad</code></td>
<td>

<p>Degree by which to extrapolate input data. Defaults to 1.2.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resample</code></td>
<td>

<p>Resampling density. Corresponds to the number of points calculated along both X and   Y axes. Defaults to 100. If no resampling is desired, set <code>reample = NULL</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>

<p>Optional. Manually set X and Y ranges. Input is a 2x2 matrix with rows corresponding to X and Y    ranges respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Optional. Logical. If <code>TRUE</code>, will print ANOVA tables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments to pass onto <code>calcPoly</code> when using <code>multiPoly</code>
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Fits polynomial trend surfaces using the 'spatial' package. First, an <code>npoly</code> polynomial trend surface is fit by least squares using <code>surf.ls</code> or generalized least-squares by <code>surf.gls</code>. GLS is fit by one of three covariance functions, exponential (<code>expcov</code>), gaussian (<code>gaucov</code>) or spherical (<code>sphercov</code>) and requires additional parameters to be passed as a list through <code>gls.covmod</code> (see examples). For a full description of arguments and usage see <code>surf.gls</code> and <code>expcov</code> documentation.
</p>
<p>The surface is then evaluated using <code>trmat</code> within limits set by input data, or manually using <code>range</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>poly_surf</code>, or <code>multi_surf</code> with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fnc.name</code></td>
<td>

<p>name of trait
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poly</code></td>
<td>
<p>Polynomial trend fit output from <code>surf.ls</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>surface</code></td>
<td>
<p>Evaluated trend surface output from <code>trmat</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>Expanded surface in long XZY dataframe format</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>peak</code></td>
<td>
<p>Coordinates and height of the peak of the surface</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Blake V. Dickson</p>


<h3>References</h3>

<p>Dickson, B.V. and Pierce, S.E. (2019), Functional performance of turtle humerus shape across an ecological adaptive landscape. Evolution, 73: 1265-1277. https://doi.org/10.1111/evo.13747
</p>


<h3>See Also</h3>

<p><code>surf.ls</code>, 
<code>surf.gls</code>, 
<code>expcov</code>,
<code>trmat</code>,
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(spatial)

data("warps")
warps_fnc &lt;- as_fnc_df(warps)

# Make single trait dataframe 
hydro_fnc &lt;- data.frame(warps_fnc[ ,1:2], warps_fnc[ ,"hydro"])

polysurf &lt;- calcPoly(hydro_fnc)
summary(polysurf)
plot(polysurf)

# Fit using gls

polysurf &lt;- calcPoly(hydro_fnc, gls.covmod = list(covmod = expcov, d = 0.7, alpha = 0, se = 1))
## Not run: 
summary(polysurf)

## End(Not run)
plot(polysurf)

# Calculate multiple polynomial surfaces

multi_poly &lt;- multiPoly(warps_fnc)
## Not run: 
summary(multi_poly)

## End(Not run)
plot(multi_poly)

# Set manual range

polysurf &lt;- calcPoly(hydro_fnc, range = rbind(range(warps_fnc$x) * 1.2,
                                              range(warps_fnc$y) * 1.4))
                                              
polysurf &lt;- calcPoly(hydro_fnc, range = rbind(c(-0.2, 0.12),
                                              c(-0.06, 0.1)) )
## Not run: 
summary(polysurf)

## End(Not run)                                              
# 
# Adjust polynomial degree

multiPoly(warps_fnc, npoly = 2)

# Specify multiple degrees

multi_poly &lt;- multiPoly(warps_fnc, npoly = c(2,3,4,3))

## Not run: 
summary(polysurf)

## End(Not run)
plot(polysurf)

</code></pre>


</div>