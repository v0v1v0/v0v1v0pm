<div class="container">

<table style="width: 100%;"><tr>
<td>MortCast-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MortCast: Estimation and Projection of Age-Specific Mortality Rates</h2>

<h3>Description</h3>

<p>Age-specific mortality rates are estimated and projected using 
the Kannisto, Lee-Carter and related methods as described in 
Sevcikova et al. (2016) &lt;doi:10.1007/978-3-319-26603-9_15&gt;.
</p>


<h3>Details</h3>

<p>The package implements methodology described in Sevcikova et al. (2016) that is related to 
estimating and predicting age-specific mortality rates. The main functions are:
</p>

<ul>
<li> <p><code>cokannisto</code>: Extrapolates given mortality rates into higher ages
using the Coherent Kannisto method. The original Kannisto method 
(with sex-independent extrapolation) is avalable in the function 
<code>kannisto</code>.
</p>
</li>
<li> <p><code>lileecarter.estimate</code>: Estimates the coherent Lee-Carter parameters
for male and female mortality rates (Li and Lee 2005), i.e. sex-independent parameters <code class="reqn">a_x</code> and <code class="reqn">k_t</code>, and 
the coherent parameter <code class="reqn">b_x</code>. In addition, it 
computes the ultimate <code class="reqn">b^u_x</code> for rotation (Li et al. 2013). 
The underlying sex-independent estimation is implemented in the function <code>leecarter.estimate</code>.
</p>
</li>
<li> <p><code>mortcast</code>: Using estimated coherent Lee-Carter parameters 
and given future sex-specific life expectancies,
it projects age-specific mortality rates, while (by default) rotating the <code class="reqn">b_x</code> 
parameter as described in Li et al. (2013).
</p>
</li>
</ul>
<p>Functions contained in the package can be used to apply Algorithm 2 in 
Sevcikova et al. (2016) as shown in the Example below. It can be used for both, 5-year and 1-year age groups.
</p>
<p>Other methods for forecasting mortality rates are available:
</p>

<ul>
<li> <p><code>pmd</code>: pattern of mortality decline
</p>
</li>
<li> <p><code>mlt</code>: model life tables
</p>
</li>
<li> <p><code>logquad</code>: log-quadratic mortality model 
</p>
</li>
<li> <p><code>mortcast.blend</code>: combining two different methods
</p>
</li>
</ul>
<p>A life table can be constructed using the <code>life.table</code> function.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Nan Li and Patrick Gerland
</p>


<h3>References</h3>

<p>Li, N. and Lee, R. D. (2005). Coherent mortality forecasts for a group of populations: 
An extension of the Lee-Carter method. Demography, 42, 575-594.
</p>
<p>Li, N., Lee, R. D. and Gerland, P. (2013). Extending the Lee-Carter method to model the rotation 
of age patterns of mortality decline for long-term projections. Demography, 50, 2037-2051.
</p>
<p>Sevcikova H., Li N., Kantorova V., Gerland P., Raftery A.E. (2016). 
Age-Specific Mortality and Fertility Rates for Probabilistic Population Projections. 
In: Schoen R. (eds) Dynamic Demographic Analysis. The Springer Series on Demographic Methods
and Population Analysis, vol 39. Springer, Cham. <a href="https://arxiv.org/abs/1503.05215">Earlier version</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># This example applies Algorithm 2 in Sevcikova et al. (2016) 
# on data from WPP2017 for China
#
data(mxM, mxF, e0Fproj, e0Mproj, package = "wpp2017")
country &lt;- "China"

# extract observed mortality rates for male and female
mxm &lt;- subset(mxM, name == country)[,4:16]
mxf &lt;- subset(mxF, name == country)[,4:16]
rownames(mxm) &lt;- rownames(mxf) &lt;- c(0,1, seq(5, 100, by=5))

# Step 1: extrapolate from 100+ to 130+ using Coherent Kannisto
mx130 &lt;- cokannisto(mxm, mxf)
 
# Steps 2-5: estimate coherent Lee-Carter parameters
# (here ax is computed from the last observed period 
# and smoothened over ages)
lc.est &lt;- lileecarter.estimate(mx130$male, mx130$female, 
            ax.index = ncol(mx130$male), ax.smooth = TRUE)
        
# Steps 6-9: project future mortality rates based on future 
# life expectancies from WPP2017
e0f &lt;- as.numeric(subset(e0Fproj, name == country)[-(1:2)])
e0m &lt;- as.numeric(subset(e0Mproj, name == country)[-(1:2)])
names(e0f) &lt;- names(e0m) &lt;- colnames(e0Fproj)[-(1:2)]
pred &lt;- mortcast(e0m, e0f, lc.est)

# plot projection for the first and last future time period
plot(pred$female$mx[,"2015-2020"], type="l", log="y", 
    ylim=range(pred$female$mx, pred$male$mx), xaxt="n",
    ylab="mx", xlab="Age", main=country, col="red")
axis(1, at=1:nrow(pred$female$mx),
    labels=rownames(pred$female$mx))
lines(pred$male$mx[,"2015-2020"], col="blue")
lines(pred$female$mx[,"2095-2100"], col="red", lty=2)
lines(pred$male$mx[,"2095-2100"], col="blue", lty=2)
legend("topleft", legend=c("male 2015-2020", "female 2015-2020",
    "male 2095-2100", "female 2095-2100"), bty="n",
    col=rep(c("blue", "red"),2), lty=c(1,1,2,2))

</code></pre>


</div>