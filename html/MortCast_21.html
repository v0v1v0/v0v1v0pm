<div class="container">

<table style="width: 100%;"><tr>
<td>mortcast.blend</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mortality Prediction by Method Blending</h2>

<h3>Description</h3>

<p>Predict age-specific mortality rates using a blend of two different methods (Coherent Lee-Carter, 
Coherent Pattern Mortality Decline, Log-Quadratic model, or Model Life Tables). Weights can be applied to fine-tune the blending mix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mortcast.blend(
  e0m,
  e0f,
  meth1 = "lc",
  meth2 = "mlt",
  weights = c(1, 0.5),
  nx = 5,
  apply.kannisto = TRUE,
  min.age.groups = 28,
  match.e0 = TRUE,
  keep.lt = FALSE,
  meth1.args = NULL,
  meth2.args = NULL,
  kannisto.args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>e0m</code></td>
<td>
<p>A time series of future male life expectancy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e0f</code></td>
<td>
<p>A time series of future female life expectancy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meth1</code></td>
<td>
<p>Character string giving the name of the first method to blend. It is one of 
“lc”, “pmd”, “mlt” or “logquad”, corresponding to Coherent Lee-Carter (function <code>mortcast</code>), 
Pattern Mortality Decline (function <code>copmd</code>), Log-Quadratic model (function <code>logquadj</code>), and 
Model Life Tables (function <code>mltj</code>), respectively. The “logquad” method can only be used 
with 5-year age groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meth2</code></td>
<td>
<p>Character string giving the name of the second method to blend. 
One of the same choices as <code>meth1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Numeric vector with values between 0 and 1 giving the weight of <code>meth1</code>.
If it is a single value, the same weight is applied for all time periods. 
If it is a vector of size two, it is assumed these are weights for the first and the last
time period. Remaining weights will be interpolated. Note that <code>meth2</code> is weighted 
by <code>1 - weights</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nx</code></td>
<td>
<p>Size of age groups. Should be either 5 or 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>apply.kannisto</code></td>
<td>
<p>Logical. If <code>TRUE</code> and if any of the methods results in less than 
<code>min.age.groups</code> age categories, the coherent Kannisto method (<code>cokannisto</code>) 
is applied to extend the age groups into old ages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.age.groups</code></td>
<td>
<p>Minimum number of age groups. Triggers the application of Kannisto, see above. 
Change the default value if 1-year age groups are used (see Example).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match.e0</code></td>
<td>
<p>Logical. If <code>TRUE</code> the blended mx is scaled so that it matches the input e0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.lt</code></td>
<td>
<p>Logical. If <code>TRUE</code> additional life table columns are kept in the 
resulting object. Only used if <code>match.e0</code> is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meth1.args</code></td>
<td>
<p>List of arguments passed to the function that corresponds to <code>meth1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meth2.args</code></td>
<td>
<p>List of arguments passed to the function that corresponds to <code>meth2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kannisto.args</code></td>
<td>
<p>List of arguments passed to the <code>cokannisto</code> function if Kannisto is applied. 
If 1-year age groups are used various defaults in the Kannisto function need to be changed (see Example).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional life table arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function allows to combine two different methods using given weights.
The weights can change over time - by default they are interpolated from the starting weight 
to the end weight. As the blended mortality rates do not necessarily match the target life expectancy, 
scaling is applied to improve the match, controlled by the <code>match.e0</code> argument. 
The projection is done for both sexes, so that coherent methods can be applied.
</p>


<h3>Value</h3>

<p>List with elements <code>female</code> and <code>male</code>, each of which contains a matrix <code>mx</code>
with the predicted mortality rates. If the result has been scaled (<code>match.e0</code> is <code>TRUE</code>), the element 
<code>mx.rawblend</code> contains the mx before scaling. Also in such a case, if <code>keep.lt</code> is <code>TRUE</code>, it also 
contains matrices <code>sr</code> (survival rates), and life table quantities <code>Lx</code> and <code>lx</code>.
In addition, the return object contains elements <code>meth1res</code> and <code>meth2res</code>
which contain the results of the functions corresponding to the two methods. 
Elements <code>meth1</code> and <code>meth2</code> contain the names of the methods. 
A vector <code>weights</code> contains the final (possibly interpolated) weights.
</p>


<h3>See Also</h3>

<p><code>mortcast</code>, <code>copmd</code>, <code>mltj</code>, <code>logquad</code>,
<code>cokannisto</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(mxM, mxF, e0Fproj, e0Mproj, package = "wpp2017")
country &lt;- "Brazil"
# estimate parameters from historical mortality data
mxm &lt;- subset(mxM, name == country)[,4:16]
mxf &lt;- subset(mxF, name == country)[,4:16]
rownames(mxm) &lt;- rownames(mxf) &lt;- c(0,1, seq(5, 100, by=5))
lcest &lt;- lileecarter.estimate(mxm, mxf)
# project into future
e0f &lt;- subset(e0Fproj, name == country)[-(1:2)]
e0m &lt;- subset(e0Mproj, name == country)[-(1:2)]

# Blend LC and MLT
pred1 &lt;- mortcast.blend(e0m, e0f, meth1 = "lc", meth2 = "mlt",
    meth1.args = list(lc.pars = lcest),
    meth2.args = list(type = "CD_North"),
    weights = c(1,0.25))
    
# Blend PMD and MLT
pred2 &lt;- mortcast.blend(e0m, e0f, meth1 = "pmd", meth2 = "mlt",
    meth1.args = list(mxm0 = mxm[, "2010-2015"],
                      mxf0 = mxf[, "2010-2015"]))
                      
# plot projection by time
plotmx &lt;- function(pred, iage, main) 
    with(pred, {
        # blended projections 
        plot(female$mx[iage,], type="l", 
            ylim=range(meth1res$female$mx[iage,], 
                       meth2res$female$mx[iage,]),
            ylab="female mx", xlab="Time", main=main, col = "red")
        lines(meth1res$female$mx[iage,], lty = 2)
        lines(meth2res$female$mx[iage,], lty = 3)
        legend("topright", legend=c("blend", meth1, meth2),
               lty = 1:3, col = c("red", "black", "black"), bty = "n")
    })
age.group &lt;- 3 # 5-9 years old
par(mfrow=c(1,2))
plotmx(pred1, age.group, "LC-MLT (age 5-9)")
plotmx(pred2, age.group, "PMD-MLT (age 5-9)")

# Blend LC and MLT for 1-year age groups
#########################################
# First interpolate e0 to get 1-year life expectancies (for first five years)
e0m1y &lt;- approx(as.double(e0m[,1:2]), n = 5)$y
e0f1y &lt;- approx(as.double(e0f[,1:2]), n = 5)$y
# derive toy mx in order to get some LC parameters
mxm1y &lt;- mlt(seq(70, 72, length = 4), sex = "male", nx = 1)
mxf1y &lt;- mlt(seq(78, 79, length = 4), sex = "female", nx = 1)
lcest1y &lt;- lileecarter.estimate(mxm1y, mxf1y, nx = 1)

# projections
pred3 &lt;- mortcast.blend(e0m1y, e0f1y, meth1 = "lc", meth2 = "mlt",
    weights = c(1,0.25), min.age.groups = 131, nx = 1, 
    meth1.args = list(lc.pars = lcest1y),
    kannisto.args = list(est.ages = 90:99, proj.ages = 100:130))
    
# plot results
par(mfrow=c(1,1))
plot(0:130, pred3$female$mx[,5], log = "y", type = "l", col = "red")
lines(0:130, pred3$male$mx[,5], col = "blue")

</code></pre>


</div>