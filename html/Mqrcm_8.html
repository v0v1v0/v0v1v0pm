<div class="container">

<table style="width: 100%;"><tr>
<td>iMqr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
M-Quantile Regression Coefficients Modeling
</h2>

<h3>Description</h3>

<p>This function implements Frumento and Salvati's (2020) method for M-quantile regression
coefficients modeling (Mqrcm). M-quantile regression coefficients are described
by parametric functions of the order of the quantile.
</p>


<h3>Usage</h3>

<pre><code class="language-R">iMqr(formula, formula.p = ~ slp(p,3), weights, data, s, 
  psi = "Huber", plim = c(0,1), tol = 1e-6, maxit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>a two-sided formula of the form <code>y ~ x1 + x2 + ...</code>: 
a symbolic description of the M-quantile regression model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula.p</code></td>
<td>

<p>a one-sided formula of the form <code>~ b1(p, ...) + b2(p, ...) + ...</code>, 
describing how M-quantile regression coefficients depend on <kbd>p</kbd>, 
the order of the quantile.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. 
The weights will always be normalized to sum to the sample size. 
This implies that, for example, using double weights will <em>not</em> 
halve the standard errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an optional data frame, list or environment containing the variables in <code>formula</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>an optional 0/1 matrix that permits excluding some model coefficients
(see ‘Examples’).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi</code></td>
<td>
<p>a character string indicating the ‘psi’ function. Currently,
only ‘<code>Huber</code>’ is implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plim</code></td>
<td>
<p>the extremes of the estimation interval. You may want to model the M-quantile
regression coefficients in an interval, say, <code>(a,b)</code> instead of <code>(0,1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>convergence criterion for numerical optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>maximum number of iterations.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A linear model is used to describe the <code>p</code>-th conditional M-quantile:
</p>
<p style="text-align: center;"><code class="reqn">M(p | x) = \beta_0(p) + \beta_1(p)x_1 + \beta_2(p)x_2 + \ldots.</code>
</p>

<p>Assume that each M-quantile regression coefficient can be expressed as a parametric function of <code class="reqn">p</code> of the form:
</p>
<p style="text-align: center;"><code class="reqn">\beta(p | \theta) = \theta_{0} + \theta_1 b_1(p) + \theta_2 b_2(p) + \ldots</code>
</p>

<p>where <code class="reqn">b_1(p), b_2(p, \ldots)</code> are known functions of <code class="reqn">p</code>. 
If <code class="reqn">q</code> is the dimension of 
<code class="reqn">x = (1, x_1, x_2, \ldots)</code> 
and <code class="reqn">k</code> is that of  
<code class="reqn">b(p) = (1, b_1(p), b_2(p), \ldots)</code>, 
the entire M-conditional quantile function is described by a 
<code class="reqn">q \times k</code> matrix <code class="reqn">\theta</code> of model parameters. 
</p>
<p>Users are required to specify two formulas: <code>formula</code> describes the regression model,
while <code>formula.p</code> identifies the 'basis' <code class="reqn">b(p)</code>. 
By default, <code>formula.p = ~ slp(p, k = 3)</code>, a 3rd-degree shifted 
Legendre polynomial (see <code>slp</code>). Any user-defined function <code class="reqn">b(p, \ldots)</code>
can be used, see ‘Examples’.
</p>
<p>Estimation of <code class="reqn">\theta</code> is carried out by minimizing an integrated loss function, 
corresponding to the
integral, over <code class="reqn">p</code>, of the loss function of standard M-quantile regression. This
motivates the acronym <code>iMqr</code> (integrated M-quantile regression). The scale parameter
<code>sigma</code> is estimated as the minimizer of the log-likelihood of a Generalized 
Asymmetric Least Informative distribution (Bianchi et al 2017), and is “modeled”
as a piecewise-constant function of the order of the quantile.
</p>


<h3>Value</h3>

<p>An object of class “<code>iMqr</code>”, a list containing the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a matrix of estimated model parameters describing the fitted M-quantile function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plim</code></td>
<td>
<p>a vector of two elements indicating the range of estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>logical. The convergence status.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.it</code></td>
<td>
<p>the number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj.function</code></td>
<td>
<p>the value of the minimized integrated loss function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>the used ‘<kbd>s</kbd>’ matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi</code></td>
<td>
<p>the used ‘<code>psi</code>’ function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covar</code></td>
<td>
<p>the estimated covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mf</code></td>
<td>
<p>the model frame used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PDF, CDF</code></td>
<td>
<p>the fitted values of the conditional probability density function (<abbr><span class="acronym">PDF</span></abbr>)
and cumulative distribution function (<abbr><span class="acronym">CDF</span></abbr>). The <abbr><span class="acronym">CDF</span></abbr> value should be interpreted as the order
of the M-quantile that corresponds to the observed <code>y</code> variable, while the <abbr><span class="acronym">PDF</span></abbr> is just the first
derivative of the <abbr><span class="acronym">CDF</span></abbr>.</p>
</td>
</tr>
</table>
<p>Use <code>summary.iMqr</code>, <code>plot.iMqr</code>, and <code>predict.iMqr</code>
for summary information, plotting, and predictions from the fitted model.
The generic accessory functions <code>coefficients</code>, <code>formula</code>, <code>terms</code>, 
<code>model.matrix</code>, <code>vcov</code> are available to extract information from the fitted model.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>References</h3>

<p>Frumento, P., Salvati, N. (2020). <em>Parametric modeling of M-quantile regression coefficient functions with application to small area estimation</em>, Journal of the Royal Statistical Society, Series A, 183(1), p. 229-250.
</p>
<p>Bianchi, A., et al. (2018). <em>Estimation and testing in M-quantile regression with application to small area estimation</em>, International Statistical Review, 0(0), p. 1-30.
</p>


<h3>See Also</h3>

<p><code>summary.iMqr</code>, <code>plot.iMqr</code>, <code>predict.iMqr</code>,
for summary, plotting, and prediction, and <code>plf</code> and <code>slp</code> 
that may be used to define <code class="reqn">b(p)</code>
to be a piecewise linear function and a shifted Legendre polynomial basis, respectively.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  ##### Using simulated data in all examples
  ##### NOTE 1: the true quantile and M-quantile functions do not generally coincide
  ##### NOTE 2: the true M-quantile function is usually unknown, even with simulated data
  
  
  ##### Example 1
  
  n &lt;- 250
  x &lt;- runif(n)
  y &lt;- rnorm(n, 1 + x, 1 + x)
  # true quantile function: Q(p | x) = beta0(p) + beta1(p)*x, with 
    # beta0(p) = beta1(p) = 1 + qnorm(p)
                              
  # fit the 'true' model: b(p) = (1 , qnorm(p))
  m1 &lt;- iMqr(y ~ x, formula.p = ~ I(qnorm(p)))
  # the fitted M-quantile regression coefficient functions are
    # beta0(p) = m1$coef[1,1] + m1$coef[1,2]*qnorm(p)
    # beta1(p) = m1$coef[2,1] + m1$coef[2,2]*qnorm(p)
  
  # a basis b(p) = (1, p), i.e., beta(p) is assumed to be a linear function of p
  m2 &lt;- iMqr(y ~ x, formula.p = ~ p)

  # a 'rich' basis b(p) = (1, p, p^2, log(p), log(1 - p))
  m3 &lt;- iMqr(y ~ x, formula.p = ~ p + I(p^2) + I(log(p)) + I(log(1 - p)))

  # 'slp' creates an orthogonal spline basis using shifted Legendre polynomials
  m4 &lt;- iMqr(y ~ x, formula.p = ~ slp(p, k = 3)) # note that this is the default
  
  # 'plf' creates the basis of a piecewise linear function
  m5 &lt;- iMqr(y ~ x, formula.p = ~ plf(p, knots = c(0.1,0.9)))
  
  
  summary(m1)
  summary(m1, p = c(0.25,0.5,0.75))
  par(mfrow = c(1,2)); plot(m1, ask = FALSE)
  # see the documentation for 'summary.iMqr' and 'plot.iMqr'

  

  
  ##### Example 2 ### excluding coefficients
  
  n &lt;- 250
  x &lt;- runif(n)
  qy &lt;- function(p,x){(1 + qnorm(p)) + (1 + log(p))*x}
  # true quantile function: Q(p | x) = beta0(p) + beta1(p)*x, with
    # beta0(p) = 1 + qnorm(p) 
    # beta1(p) = 1 + log(p)
  
  y &lt;- qy(runif(n), x) # to generate y, plug uniform p in qy(p,x) 
  iMqr(y ~ x, formula.p = ~ I(qnorm(p)) + I(log(p)))

  # I would like to exclude log(p) from beta0(p), and qnorm(p) from beta1(p)
  # I set to 0 the corresponding entries of 's'

  s &lt;- rbind(c(1,1,0),c(1,0,1))
  iMqr(y ~ x, formula.p = ~ I(qnorm(p)) + I(log(p)), s = s)
  
</code></pre>


</div>