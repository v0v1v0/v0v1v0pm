<div class="container">

<table style="width: 100%;"><tr>
<td>exprApply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply a function to calls inside an expression</h2>

<h3>Description</h3>

<p>Apply function <code>FUN</code> to each occurence of a call to <code>what()</code> (or 
a symbol <code>what</code>) in an unevaluated expression. It can be used for advanced 
manipulation of expressions.
Intended primarily for internal use.
</p>


<h3>Usage</h3>

<pre><code class="language-R">exprApply(expr, what, FUN, ..., symbols = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>an unevaluated expression. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>character string giving the name of a function. Each call to
<code>what</code> inside <code>expr</code> will be passed to <code>FUN</code>. <code>what</code> 
can be also a character representation of an operator or parenthesis
(including curly and square brackets) as 
these are primitive functions in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.
Set <code>what</code> to <code>NA</code> to match all names.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>a function to be applied. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symbols</code></td>
<td>
<p>logical value controlling whether <code>FUN</code> should be applied
to symbols as well as calls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>FUN</code> is found by a call to <code>match.fun</code> and can be either
a function or a symbol (e.g., a backquoted name) or a character string
specifying a function to be searched for from the environment of the call to
<code>exprApply</code>. 
</p>


<h3>Value</h3>

<p>A (modified) expression.
</p>


<h3>Note</h3>

<p>If <code>expr</code> has a source reference information
(<code>"srcref"</code> attribute), modifications done by <code>exprApply</code> will not be
visible when printed unless <code>srcref</code> is removed. However, <code>exprApply</code>
does remove source reference from any <code>function</code> expression inside
<code>expr</code>.
</p>


<h3>Author(s)</h3>

<p>Kamil Barto≈Ñ</p>


<h3>See Also</h3>

<p>Expression-related functions: <code>substitute</code>, 
<code>expression</code>, <code>quote</code> and <code>bquote</code>.
</p>
<p>Similar function <code>walkCode</code> exists in package <span class="pkg">codetools</span>. 
</p>
<p>Functions useful inside <code>FUN</code>: <code>as.name</code>, <code>as.call</code>,
<code>call</code>, <code>match.call</code> etc.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### simple usage:
# print all Y(...) terms in a formula (note that symbol "Y" is omitted):
# Note: if `print` is defined as S4 "standardGeneric", we need to use 
# 'print.default' rather than 'print', or put the call to 'print' inside a 
# function, i.e. as `function(x) print(x)`:
exprApply(~ X(1) + Y(2 + Y(4)) + N(Y + Y(3)), "Y", print.default)


# replace X() with log(X, base = n)
exprApply(expression(A() + B() + C()), c("A", "B", "C"), function(expr, base) {
    expr[[2]] &lt;- expr[[1]]
    expr[[1]] &lt;- as.name("log")
    expr$base &lt;- base
    expr
}, base = 10)

###
# TASK: fit lm with two poly terms, varying the degree from 1 to 3 in each.
# lm(y ~ poly(X1, degree = a) + poly(X2, degree = b), data = Cement)
# for a = {1,2,3} and b = {1,2,3}

# First we create a wrapper function for lm. Within it, use "exprApply" to add
# "degree" argument to all occurences of "poly()" having "X1" or "X2" as the
# first argument. Values for "degree" are taken from arguments "d1" and "d2"

lmpolywrap &lt;- function(formula, d1 = NA, d2 = NA, ...) { 
    cl &lt;- origCall &lt;- match.call()
    cl[[1]] &lt;- as.name("lm")
    cl$formula &lt;- exprApply(formula, "poly", function(e, degree, x) {
        i &lt;- which(e[[2]] == x)[1]
        if(!is.na(i) &amp;&amp; !is.na(degree[i])) e$degree &lt;- degree[i]
        e
    }, degree = c(d1, d2), x = c("X1", "X2"))
    cl$d1 &lt;- cl$d2 &lt;- NULL
    fit &lt;- eval(cl, parent.frame())
    fit$call &lt;- origCall # replace the stored call
    fit
}

# global model:
fm &lt;- lmpolywrap(y ~ poly(X1) + poly(X2), data = Cement)

# Use "dredge" with argument "varying" to generate calls of all combinations of
# degrees for poly(X1) and poly(X2). Use "fixed = TRUE" to keep all global model
# terms in all models.
# Since "dredge" expects that global model has all the coefficients the 
# submodels can have, which is not the case here, we first generate model calls,
# evaluate them and feed to "model.sel"

modCalls &lt;- dredge(fm, 
    varying = list(d1 = 1:3, d2 = 1:3), 
    fixed = TRUE,
    evaluate = FALSE
)

model.sel(models &lt;- lapply(modCalls, eval))

# Note: to fit *all* submodels replace "fixed = TRUE" with: 
# "subset = (d1==1 || {poly(X1)}) &amp;&amp; (d2==1 || {poly(X2)})"
# This is to avoid fitting 3 identical models when the matching "poly()" term is
# absent.
</code></pre>


</div>