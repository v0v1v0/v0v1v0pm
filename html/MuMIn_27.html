<div class="container">

<table style="width: 100%;"><tr>
<td>get.models</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Retrieve models from selection table</h2>

<h3>Description</h3>

<p>Generate or extract a list of fitted model objects from a 
<code>"model.selection"</code> table or component models from the averaged model
(<code>"averaging"</code> object), optionally using parallel computation in a 
cluster.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get.models(object, subset, cluster = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> object returned by <code>dredge</code>, 
<code>model.sel</code> or <code>model.avg</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>subset of models, an expression evaluated within the model
selection table (see ‘Details’).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p> optionally, a <code>"cluster"</code> object. If it is a valid 
cluster, models are evaluated using parallel computation. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to update the models. For example, one 
may want to fit models with <abbr><span class="acronym">REML</span></abbr> (e.g. argument 
<code>REML = TRUE</code> in some modelling functions) while using 
<abbr><span class="acronym">ML</span></abbr> for model selection.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The argument <code>subset</code> must be explicitely provided. This is to assure that 
a potentially long list of models is not fitted unintentionally. To evaluate all
models, set <code>subset</code> to <code>NA</code> or <code>TRUE</code>. 
</p>
<p>If <code>subset</code> is a character vector, it is interpreted as names of rows to be
selected.
</p>


<h3>Value</h3>

<p><code>list</code> of fitted model objects.
</p>


<h3>Note</h3>

<p><code>"model.selection"</code> tables created by <code>model.sel</code> or averaged models
created by <code>model.avg</code> from a list of model objects (as opposed to those
created with model selection tables) store the component models as part of the
object - in these cases <code>get.models</code>  simply extracts the items from 
these lists. Otherwise the models have to be fitted. Therefore, using 
<code>get.models</code> following <code>dredge</code> is not efficient as the 
requested models are fitted twice. If the number of generated models is 
reasonable, consider using <code>lapply(dredge(..., evaluate = FALSE), eval)</code>, 
which generates a list of all model calls and evaluates them into a list of 
model objects. 
</p>
<p>Alternatively, <code>getCall</code> and <code>eval</code> can be used to compute a model out of the 
<code>"model.selection"</code> table (e.g. <code>eval(getCall(&lt;model.selection&gt;, i))</code>, where 
<code>i</code> is the model index or name). 
</p>
<p><code>pget.models</code> is still available, but is deprecated.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code>dredge</code> and <code>pdredge</code>, <code>model.avg</code>
</p>
<p><code>makeCluster</code> in packages <span class="pkg">parallel</span> and <span class="pkg">snow</span>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Mixed models:


fm2 &lt;- lme(distance ~ age + Sex, data = Orthodont,
    random = ~ 1 | Subject, method = "ML")
ms2 &lt;- dredge(fm2)

# Get top-most models, but fitted by REML:
(confset.d4 &lt;- get.models(ms2, subset = delta &lt; 4, method = "REML"))

## Not run: 
# Get the top model:
get.models(ms2, subset = 1)[[1]]

## End(Not run)


</code></pre>


</div>