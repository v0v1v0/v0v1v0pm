<div class="container">

<table style="width: 100%;"><tr>
<td>model.avg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model averaging</h2>

<h3>Description</h3>

<p>Model averaging based on an information criterion.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
model.avg(object, ..., revised.var = TRUE)

## Default S3 method:
model.avg(object, ..., beta = c("none", "sd", "partial.sd"),
  rank = NULL, rank.args = NULL, revised.var = TRUE,
  dispersion = NULL, ct.args = NULL)

## S3 method for class 'model.selection'
model.avg(object, subset, fit = FALSE, ..., revised.var = TRUE)


</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> a fitted model object or a list of such objects, or a
<code>"model.selection"</code> object. See ‘Details’. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> for default method, more fitted model objects. Otherwise,
arguments that are passed to the default method. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p> indicates whether and how the component models' coefficients 
should be standardized. See the argument's description in 
<code>dredge</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p> optionally, a rank function (returning an information criterion) to
use instead of <code>AICc</code>, e.g. <code>BIC</code> or <code>QAIC</code>, may be
omitted if <code>object</code> is a model list returned by <code>get.models</code>
or a <code>"model.selection"</code> object. See ‘Details’. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank.args</code></td>
<td>
<p> optional <code>list</code> of arguments for the <code>rank</code>
function. If one is an expression, an <code>x</code> within it is substituted
with a current model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>revised.var</code></td>
<td>
<p> logical, indicating whether to use the revised formula for
standard errors. See <code>par.avg</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dispersion</code></td>
<td>
<p> the dispersion parameter for the family used. See
<code>summary.glm</code>. This is used currently only with <code>glm</code>,
is silently ignored otherwise. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ct.args</code></td>
<td>
<p> optional list of arguments to be passed to
<code>coefTable</code> (besides <code>dispersion</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p> see <code>subset</code> method for
<code>"model.selection"</code> object. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p> if <code>TRUE</code>, the component models are fitted using
<code>get.models</code>. See ‘Details’.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>model.avg</code> may be used either with a list of models or directly with a
<code>model.selection</code> object (e.g. returned by <code>dredge</code>). In the
latter case, the models from the model selection table are not evaluated
unless the argument <code>fit</code> is set to <code>TRUE</code> or some additional
arguments are present (such as <code>rank</code> or <code>dispersion</code>). This
results in a much faster calculation, but has certain drawbacks, because the
fitted component model objects are not stored, and some methods (e.g.
<code>predict</code>, <code>fitted</code>, <code>model.matrix</code> or <code>vcov</code>) would not
be available with the returned object. Otherwise, <code>get.models</code> is
called prior to averaging, and ... are passed to it.
</p>
<p>For a list of model types that are accepted see list of
supported models.
</p>
<p><code>rank</code> is found by a call to <code>match.fun</code> and typically is
specified as a function or a symbol or a character string specifying a 
function to be searched for from the environment of the call to lapply. 
<code>rank</code> must be a function able to accept model as a first argument and 
must always return a numeric scalar.
</p>
<p>Several standard methods for fitted model objects exist for class
<code>averaging</code>, including <code>summary</code>,
<code>predict</code>, <code>coef</code>, <code>confint</code>,
<code>formula</code>, and <code>vcov</code>.
</p>
<p><code>coef</code>, <code>vcov</code>, <code>confint</code> and <code>coefTable</code> accept argument
<code>full</code> that if set to <code>TRUE</code>, the full model-averaged coefficients
are returned, rather than subset-averaged ones (when <code>full = FALSE</code>,
being the default).
</p>






<p><code>logLik</code> returns a list of <code>logLik</code> objects
for the component models.
</p>


<h3>Value</h3>

<p>An object of class <code>"averaging"</code> is a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>msTable</code></td>
<td>
<p> a <code>data.frame</code> with log-likelihood, <em>IC</em>, 
Δ_IC and
‘Akaike weights’ for the component models.
Its attribute <code>"term.codes"</code> is a named vector with numerical 
representation of the terms in the row names of <code>msTable</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a <code>matrix</code> of model-averaged coefficients. 
“full”  coefficients in the first row, “subset” coefficients in
the second row. See ‘Note’ </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefArray</code></td>
<td>
<p> a 3-dimensional <code>array</code> of component models' coefficients,
their standard errors and degrees of freedom. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sw</code></td>
<td>
<p> object of class <code>sw</code> containing per-model term 
sum of model weights over all of the models in which the term appears.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p> a formula corresponding to the one that would be used in a 
single model. The formula contains only the averaged (fixed) coefficients.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p> the matched call. </p>
</td>
</tr>
</table>
<p>The object has the following attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>the rank function used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelList</code></td>
<td>
<p> optionally, a list of all component model objects. Only if
the object was created with model objects (and not model selection table).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p> Corresponds to the function argument. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>revised.var</code></td>
<td>
<p> Corresponds to the function argument. </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The ‘subset’ (or ‘conditional’) average only averages over the
models where the parameter appears. An alternative, the ‘full’
average assumes that a variable is included in every model, but in some
models the corresponding coefficient (and its respective variance) is set to
zero.
Unlike the ‘subset average’, it does not have a tendency of
biasing the value away from zero. The ‘full’ average is a type of
shrinkage estimator, and for variables with a weak relationship to the
response it is smaller than ‘subset’ estimators.
</p>
<p>Averaging models with different contrasts for the same factor would yield
nonsense results. Currently, no checking for contrast consistency is done.
</p>
<p><code>print</code> method provides a concise output (similarly as for <code>lm</code>). 
To print more details use <code>summary</code> function, and <code>confint</code>
to get confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>References</h3>

<p>Burnham, K. P. and Anderson, D. R. 2002 <em>Model selection and multimodel
inference: a practical information-theoretic approach</em>. 2nd ed. New York,
Springer-Verlag.
</p>
<p>Lukacs, P. M., Burnham K. P. and Anderson, D. R. 2009 Model selection
bias and Freedman’s paradox. <em>Annals of the Institute of 
Statistical Mathematics</em> <b>62</b>, 117–125.
</p>


<h3>See Also</h3>

<p>See <code>par.avg</code> for more details of model-averaged parameter
calculation.
</p>
<p><code>dredge</code>, <code>get.models</code> <br><code>AICc</code> has examples of averaging models fitted by REML.
</p>
<p><code>modavg</code> in package <span class="pkg">AICcmodavg</span>, and
<code>coef.glmulti</code> in package <span class="pkg">glmulti</span> also perform model
averaging.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Example from Burnham and Anderson (2002), page 100:
fm1 &lt;- lm(y ~ ., data = Cement, na.action = na.fail)
(ms1 &lt;- dredge(fm1))

#models with delta.aicc &lt; 4
summary(model.avg(ms1, subset = delta &lt; 4))

#or as a 95% confidence set:
avgmod.95p &lt;- model.avg(ms1, cumsum(weight) &lt;= .95)
confint(avgmod.95p)

## Not run: 
# The same result, but re-fitting the models via 'get.models'
confset.95p &lt;- get.models(ms1, cumsum(weight) &lt;= .95)
model.avg(confset.95p)

# Force re-fitting the component models
model.avg(ms1, cumsum(weight) &lt;= .95, fit = TRUE)
# Models are also fitted if additional arguments are given
model.avg(ms1, cumsum(weight) &lt;= .95, rank = "AIC")

## End(Not run)

## Not run: 
# using BIC (Schwarz's Bayesian criterion) to rank the models
BIC &lt;- function(x) AIC(x, k = log(length(residuals(x))))
model.avg(confset.95p, rank = BIC)
# the same result, using AIC directly, with argument k
# 'x' in a quoted 'rank' argument is substituted with a model object
# (in this case it does not make much sense as the number of observations is
# common to all models)
model.avg(confset.95p, rank = AIC, rank.args = alist(k = log(length(residuals(x)))))

## End(Not run)

</code></pre>


</div>