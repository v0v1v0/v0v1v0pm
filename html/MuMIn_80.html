<div class="container">

<table style="width: 100%;"><tr>
<td>stdize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Standardize data</h2>

<h3>Description</h3>

<p><code>stdize</code> standardizes variables by centring and scaling.
</p>
<p><code>stdizeFit</code> modifies a model call or existing model to use standardized 
variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
stdize(x, center = TRUE, scale = TRUE, ...)

## S3 method for class 'logical'
stdize(x, binary = c("center", "scale", "binary", "half", "omit"),
  center = TRUE, scale = FALSE, ...)
## also for two-level factors

## S3 method for class 'data.frame'
stdize(x, binary = c("center", "scale", "binary", "half", "omit"),
  center = TRUE, scale = TRUE, omit.cols = NULL, source = NULL,
  prefix = TRUE, append = FALSE, ...)

## S3 method for class 'formula'
stdize(x, data = NULL, response = FALSE,
  binary = c("center", "scale", "binary", "half", "omit"),
  center = TRUE, scale = TRUE, omit.cols = NULL, prefix = TRUE,
  append = FALSE, ...)

stdizeFit(object, newdata, which = c("formula", "subset", "offset", "weights",
	"fixed", "random", "model"), evaluate = TRUE, quote = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric or logical vector, factor, numeric matrix, 
<code>data.frame</code> or a formula. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center, scale</code></td>
<td>
<p> either a logical value or a logical or numeric vector
of length equal to the number of columns of <code>x</code> (see
‘Details’). <code>scale</code> can be also a function to use for
scaling. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binary</code></td>
<td>
<p>specifies how binary variables (logical or two-level factors)
are scaled. Default is to <code>"center"</code> by subtracting the mean
assuming levels are equal to 0 and 1; use <code>"scale"</code> to
both centre and scale by <abbr><span class="acronym">SD</span></abbr>, <code>"binary"</code> to centre to 0 /
1, <code>"half"</code> to centre to -0.5 / 0.5, and <code>"omit"</code> to leave
binary variables unmodified.
This argument has precedence over <code>center</code> and <code>scale</code>, unless
it is set to <code>NA</code> (in which case binary variables are treated like
numeric variables).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>source</code></td>
<td>
<p>a reference <code>data.frame</code>, being a result of previous  
<code>stdize</code>, from which <code>scale</code> and <code>center</code> values are 
taken. Column names are matched. This can be used for scaling new data 
using statistics of another data.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omit.cols</code></td>
<td>
<p> column names or numeric indices of columns that should 
be left unaltered. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p> either a logical value specifying whether the names of
transformed columns should be prefixed, or a two-element character vector
giving the prefixes. The prefixes default to “z.” for scaled and
“c.” for centred variables. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>append</code></td>
<td>
<p> logical, if <code>TRUE</code>, modified columns are appended to the
original data frame. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>logical, stating whether the response should be standardized. By
default, only variables on the right-hand side of the formula are standardized. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> an object coercible to <code>data.frame</code>, containing the
variables in <code>formula</code>. Passed to, and used by <code>model.frame</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a <code>data.frame</code> returned by <code>stdize</code>, to be used 
by the modified model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> for the <code>formula</code> method, additional arguments passed to
<code>model.frame</code>. For other methods, it is silently ignored. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted model object or an expression being a <code>call</code> to
the modelling function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p> a character string naming arguments which should be modified.
This should be all arguments which are evaluated in the <code>data</code>
environment. Can be also <code>TRUE</code> to modify the expression as a
whole. The <code>data</code> argument is additionally replaced with that
passed to <code>stdizeFit</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaluate</code></td>
<td>
<p> if <code>TRUE</code>, the modified call is evaluated and the
fitted model object is returned. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quote</code></td>
<td>
<p> if <code>TRUE</code>, avoids evaluating <code>object</code>. Equivalent to
<code>stdizeFit(quote(expr), ...)</code>. Defaults to <code>NA</code> in which case
<code>object</code> being a call to non-primitive function is quoted. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>stdize</code> resembles <code>scale</code>, but uses special rules
for factors, similarly to <code>standardize</code> in package <span class="pkg">arm</span>.
</p>
<p><code>stdize</code> differs from <code>standardize</code> in that it is used on
data rather than on the fitted model object. The scaled data should afterwards
be passed to the modelling function, instead of the original data.
</p>
<p>Unlike <code>standardize</code>, it applies special ‘binary’ scaling only to
two-level <code>factor</code>s and logical variables, rather than to any variable with
two unique values.
</p>
<p>Variables of only one unique value are unchanged.
</p>
<p>By default, <code>stdize</code> scales by dividing by standard deviation rather than twice
the <abbr><span class="acronym">SD</span></abbr> as <code>standardize</code> does. Scaling by <abbr><span class="acronym">SD</span></abbr> is used 
also on uncentred values, which is different from <code>scale</code> where
root-mean-square is used.
</p>
<p>If <code>center</code> or <code>scale</code> are logical scalars or vectors of length equal
to the number of columns of <code>x</code>, the centring is done by subtracting the
mean (if <code>center</code> corresponding to the column is <code>TRUE</code>), and scaling
is done by dividing the (centred) value by standard deviation (if corresponding
<code>scale</code> is <code>TRUE</code>). 
If <code>center</code> or <code>scale</code> are numeric vectors with length equal 
to the number of columns of <code>x</code> (or numeric scalars for vector methods),
then these are used instead. Any <code>NA</code>s in the numeric vector result in no
centring or scaling on the corresponding column.
</p>
<p>Note that <code>scale = 0</code> is equivalent to no scaling (i.e. <code>scale = 1</code>).
</p>
<p>Binary variables, logical or factors with two levels, are converted to
numeric variables and transformed according to the argument <code>binary</code>,
unless <code>center</code> or <code>scale</code> are explicitly given.
</p>


<h3>Value</h3>

<p><code>stdize</code> returns a vector or object of the same dimensions as <code>x</code>,
where the values are centred and/or scaled. Transformation is carried out
column-wise in <code>data.frame</code>s and matrices. 
</p>
<p>The returned value is compatible with that of <code>scale</code> in that the
numeric centring and scalings used are stored in attributes
<code>"scaled:center"</code> and <code>"scaled:scale"</code> (these can be <code>NA</code> if no
centring or scaling has been done).
</p>
<p><code>stdizeFit</code> returns a modified, fitted model object that uses transformed 
variables from <code>newdata</code>, or, if <code>evaluate</code> is <code>FALSE</code>, an 
unevaluated call where the variable names are replaced to point the transformed 
variables.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>References</h3>

<p>Gelman, A. 2008 Scaling regression inputs by dividing by two standard 
deviations. <em>Statistics in medicine</em> <b>27</b>, 2865–2873.
</p>


<h3>See Also</h3>

<p>Compare with <code>scale</code> and <code>standardize</code> or
<code>rescale</code> (the latter two in package <span class="pkg">arm</span>).
</p>
<p>For typical standardizing, model coefficients transformation may be
easier, see <code>std.coef</code>.
</p>
<p><code>apply</code> and <code>sweep</code> for arbitrary transformations of 
columns in a <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># compare "stdize" and "scale"
nmat &lt;- matrix(runif(15, 0, 10), ncol = 3)

stdize(nmat)
scale(nmat)

rootmeansq &lt;- function(v) {
    v &lt;- v[!is.na(v)]
    sqrt(sum(v^2) / max(1, length(v) - 1L))
}

scale(nmat, center = FALSE)
stdize(nmat, center = FALSE, scale = rootmeansq)

if(require(lme4)) {
# define scale function as twice the SD to reproduce "arm::standardize"
twosd &lt;- function(v) 2 * sd(v, na.rm = TRUE)

# standardize data (scaled variables are prefixed with "z.")
z.CO2 &lt;- stdize(uptake ~ conc + Plant, data = CO2, omit = "Plant", scale = twosd)
summary(z.CO2)


fmz &lt;- stdizeFit(lmer(uptake ~ conc + I(conc^2) + (1 | Plant)), newdata = z.CO2)
# produces:
# lmer(uptake ~ z.conc + I(z.conc^2) + (1 | Plant), data = z.CO2)


## standardize using scale and center from "z.CO2", keeping the original data:
z.CO2a &lt;- stdize(CO2, source = z.CO2, append = TRUE)
# Here, the "subset" expression uses untransformed variable, so we modify only
# "formula" argument, keeping "subset" as-is. For that reason we needed the
# untransformed variables in "newdata".
stdizeFit(lmer(uptake ~ conc + I(conc^2) + (1 | Plant),
    subset = conc &gt; 100,
    ), newdata = z.CO2a, which = "formula", evaluate = FALSE)


# create new data as a sequence along "conc"
newdata &lt;-  data.frame(conc = seq(min(CO2$conc), max(CO2$conc), length = 10))

# scale new data using scale and center of the original scaled data: 
z.newdata &lt;- stdize(newdata, source = z.CO2)


# plot predictions against "conc" on real scale:
plot(newdata$conc, predict(fmz, z.newdata, re.form = NA))


# compare with "arm::standardize"
## Not run: 
library(arm)
fms &lt;- standardize(lmer(uptake ~ conc + I(conc^2) + (1 | Plant), data = CO2))
plot(newdata$conc, predict(fms, z.newdata, re.form = NA))

## End(Not run)
}

</code></pre>


</div>