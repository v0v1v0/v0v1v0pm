<div class="container">

<table style="width: 100%;"><tr>
<td>Weights</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Akaike weights</h2>

<h3>Description</h3>

<p>Calculate, extract or set normalized model likelihoods (‘Akaike weights’).
</p>


<h3>Usage</h3>

<pre><code class="language-R">Weights(x)
Weights(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector of information criterion values such as AIC, or
objects returned by functions like <code>AIC</code>. There are also methods for
extracting ‘Akaike weights’ from <code>"model.selection"</code> or 
<code>"averaging"</code> objects. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>numeric, the new weights for the <code>"averaging"</code> object or
<code>NULL</code> to reset the weights based on the original IC used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The replacement function can assign new weights to an <code>"averaging"</code>
object, affecting coefficient values and order of component models.
</p>


<h3>Value</h3>

<p>For the extractor, a numeric vector of normalized likelihoods.
</p>


<h3>Note</h3>

<p>On assigning new weights, the model order changes accordingly, so assigning
the same weights again will cause incorrect re-calculation of averaged
coefficients. To avoid that, either re-set model weights by assigning <code>NULL</code>,
or use ordered weights.
</p>


<h3>Author(s)</h3>

<p>Kamil Bartoń</p>


<h3>See Also</h3>

<p><code>sw</code>, <code>weighted.mean</code>
</p>
<p><code>armWeights</code>, 
<code>bootWeights</code>, <code>BGWeights</code>, <code>cos2Weights</code>,
<code>jackknifeWeights</code> and <code>stackingWeights</code> can be used to
produce model weights.
</p>
<p><code>weights</code>, which extracts fitting weights from model objects.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
fm1 &lt;- glm(Prop ~ dose, data = Beetle, family = binomial)
fm2 &lt;- update(fm1, . ~ . + I(dose^2))
fm3 &lt;- update(fm1, . ~ log(dose))
fm4 &lt;- update(fm3, . ~ . + I(log(dose)^2))

round(Weights(AICc(fm1, fm2, fm3, fm4)), 3)


am &lt;- model.avg(fm1, fm2, fm3, fm4, rank = AICc)

coef(am)

# Assign equal weights to all models:
Weights(am) &lt;- rep(1, 4) # assigned weights are rescaled to sum to 1
Weights(am)
coef(am)

# Assign dummy weights:
wts &lt;- c(2,1,4,3)
Weights(am) &lt;- wts
coef(am)
# Component models are now sorted according to the new weights.
# The same weights assigned again produce incorrect results!
Weights(am) &lt;- wts
coef(am) # wrong!
#
Weights(am) &lt;- NULL # reset to original model weights
Weights(am) &lt;- wts 
coef(am) # correct

</code></pre>


</div>