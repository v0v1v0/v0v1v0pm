<div class="container">

<table style="width: 100%;"><tr>
<td>MultiFIT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiscale Fisher's Independence Test for Multivariate Dependence</h2>

<h3>Description</h3>

<p>Perform multiscale test of independence for multivariate vectors.
See vignettes for further examples.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MultiFIT(xy, x = NULL, y = NULL, p_star = NULL, R_max = NULL,
  R_star = 1, rank.transform = TRUE, ranking.approximation = FALSE,
  M = 10, apply.stopping.rule = FALSE, alpha = 0.05,
  test.method = "Fisher", correct = TRUE, min.tbl.tot = 25L,
  min.row.tot = 10L, min.col.tot = 10L, p.adjust.methods = c("H",
  "Hcorrected"), compute.all.holm = TRUE, return.all.pvs = TRUE,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xy</code></td>
<td>
<p>A list, whose first element corresponds to the matrix x as below, and
its second element corresponds to the matrix y as below. If <code>xy</code> is not
specified, <code>x</code> and <code>y</code> need to be assigned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A matrix, number of columns = dimension of random vector,
number of rows = number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A matrix, number of columns = dimension of random vector,
number of rows = number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_star</code></td>
<td>
<p>Numeric, cuboids associated with tests whose <code>p</code>-value is below <code>p_star</code>
will be halved and further tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R_max</code></td>
<td>
<p>A positive integer (or Inf), the maximal number of
resolutions to scan (algorithm will stop at a lower resolution if
all tables in it do not meet the criteria specified at <code>min.tbl.tot</code>,
<code>min.row.tot</code> and <code>min.col.tot</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R_star</code></td>
<td>
<p>A positive integer, if set to an integer
between 0 and <code>R_max</code>, all tests up to and including resolution <code>R_star</code>
will be performed (algorithm will stop at a lower resolution than requested if
all tables in it do not meet the criteria specified at <code>min.tbl.tot</code>,
<code>min.row.tot</code> and <code>min.col.tot</code>). For higher resolutions only the children of 
tests with <code>p</code>-value lower than <code>p_star</code> will be considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank.transform</code></td>
<td>
<p>Logical, if <code>TRUE</code>, marginal rank transform is
performed on all margins of <code>x</code> and <code>y</code>. If <code>FALSE</code>, all
margins are scaled to 0-1 scale. When <code>FALSE</code>, the average and top
statistics of the negative logarithm of the <code>p</code>-values are only computed
for the univariate case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranking.approximation</code></td>
<td>
<p>Logical, if <code>FALSE</code>, select only tests with <code>p</code>-values 
more extreme than <code>p_star</code> to halve and further test. FWER control not guaranteed.
If <code>TRUE</code>, choose at each resolution the <code>M</code> tests with the most extreme 
<code>p</code>-values to further halve and test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>A positive integer (or Inf), the number of top ranking
tests to continue to split at each resolution. FWER control not guaranteed 
for this method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>apply.stopping.rule</code></td>
<td>
<p>Logical. If TRUE, an adjusted <code>p</code>-value is computed for each resolution,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric. Threshold below which resolution-specific <code>p</code>-values trigger early stopping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.method</code></td>
<td>
<p>String, choose "Fisher" for Fisher's exact test (slowest), "chi.sq" for
Chi-squared test, "LR" for likelihood-ratio test and "norm.approx" for approximating
the hypergeometric distribution with a normal distribution (fastest).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correct</code></td>
<td>
<p>Logical, if <code>TRUE</code> compute mid-p corrected <code>p</code>-values for
Fisher's exact test, or Yates corrected <code>p</code>-values for the Chi-squared test,
or Williams corrected <code>p</code>-values for the likelihood-ratio test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.tbl.tot</code></td>
<td>
<p>Non-negative integer, the minimal number of observations
per table below which a <code>p</code>-value for a given table will not be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.row.tot</code></td>
<td>
<p>Non-negative integer, the minimal number of observations
for row totals in the 2x2 contingency tables below which a contingency table will not be tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.col.tot</code></td>
<td>
<p>Non-negative integer, the minimal number of observations
for column totals in the 2x2 contingency tables below which a contingency table will not be tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.adjust.methods</code></td>
<td>
<p>String, choose between "H" for Holm, "Hcorrected" for Holm with
the correction as specified in <code>correct</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.all.holm</code></td>
<td>
<p>Logical, if <code>FALSE</code>, only global <code>p</code>-value is
computed (may be a little faster when any tests are performed). If <code>TRUE</code>
adjusted <code>p</code>-values are computed for all tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.all.pvs</code></td>
<td>
<p>Logical, if TRUE, a data frame with all <code>p</code>-values
is returned (not applicable when stopping rule is applied)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>p.values.holistic</code>, a named numerical vector containing the holistic <code>p</code>-values of
for the global null hypothesis (i.e. x independent of y).
</p>
<p><code>p.values.resolution.specific</code>, a named numerical vector containing the 
reslution specific <code>p</code>-values of for the global null hypothesis (i.e. x independent of y).
</p>
<p><code>res.by.res.pvs</code>, a dta frame that contains the raw and Bonferroni adjusted
resolution specific <code>p</code>-values.
</p>
<p><code>all.pvs</code>, a data frame that contains all <code>p</code>-values and adjusted
<code>p</code>-values that are computed. Returned if <code>return.all.pvs</code> is <code>TRUE</code>.
</p>
<p><code>all</code>, a nested list. Each entry is named and contains data about a resolution
that was tested. Each resolution is a list in itself, with <code>cuboids</code>, a summary of
all tested cuboids in a resolution, <code>tables</code>, a summary of all 2x2
contingency tables in a resolution, <code>pv</code>, a numerical vector containing the
<code>p</code>-values from the tests of independence on 2x2 contingency table in <code>tables</code>
that meet the criteria defined by <code>min.tbl.tot</code>, <code>min.row.tot</code> and <code>min.col.tot</code>.
The length of <code>pv</code> is equal to the number of rows of <code>tables</code>. <code>pv.correct</code>,
similar to the above <code>pv</code>, corrected <code>p</code>-values are computed and returned when
<code>correct</code> is <code>TRUE</code>. <code>rank.tests</code>, logical vector that indicates
whether or not a test was ranked among the top <code>M</code> tests in a resolution. The
length of <code>rank.tests</code> is equal to the number of rows of <code>tables</code>. <code>parent.cuboids</code>,
an integer vector, indicating which cuboids in a resolution are associated with
the ranked tests, and will be further halved in the next higher resolution.
<code>parent.tests</code>, a logical vector of the same length as the
number of rows of <code>tables</code>, indicating whether or not a test was chosen as a parent
test (same tests may have multiple children).
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
n = 300
Dx = Dy = 2
x = matrix(0, nrow = n, ncol = Dx)
y = matrix(0, nrow = n, ncol = Dy)
x[,1] = rnorm(n)
x[,2] = runif(n)
y[,1] = rnorm(n)
y[,2] = sin(5 * pi * x[ , 2]) + 1 / 5 * rnorm(n)
fit = MultiFIT(x = x, y = y, verbose = TRUE)
w = MultiSummary(x = x, y = y, fit = fit, alpha = 0.0001)
</code></pre>


</div>