<div class="container">

<table style="width: 100%;"><tr>
<td>two_dist_match</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimal tradeoffs among two distances and exclusion</h2>

<h3>Description</h3>

<p>Explores tradeoffs among three objective functions in
multivariate matching: sums of two different user-specified  covariate
distances within matched pairs, and the number of treated units included in
the match.
</p>


<h3>Usage</h3>

<pre><code class="language-R">two_dist_match(
  dist1_type = "user",
  dist2_type = "user",
  dist1_matrix = NULL,
  data = NULL,
  dist2_matrix = NULL,
  treat_col = NULL,
  dist1_col = NULL,
  dist2_col = NULL,
  exclusion_penalty = c(),
  dist2_penalty = c(),
  marg_bal_col = NULL,
  exact_col = NULL,
  propensity_col = NULL,
  pscore_name = NULL,
  ignore_col = NULL,
  max_unmatched = 0.25,
  caliper_option = NULL,
  tol = 0.01,
  max_iter = 1,
  rho_max_factor = 10,
  max_pareto_search_iter = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dist1_type</code></td>
<td>
<p>One of ("euclidean", "robust_mahalanobis", "user") indicating the
type of distance that are used for the first distance objective functions.
NULL by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist2_type</code></td>
<td>
<p>One of ("euclidean", "robust_mahalanobis", "user")  charactor
indicating the type of distance that are used for the second distance
objective functions. NULL by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist1_matrix</code></td>
<td>
<p>(optional) matrix object that represents the distance
matrix using the first distance measure; <code>dist1_type</code>
must be passed in as "user" if dist1_matrix is non-empty</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>(optional) data frame that contain columns indicating treatment,
outcome and covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist2_matrix</code></td>
<td>
<p>(optional) matrix object that represents the distance
matrix using the second distance measure; <code>dist2_type</code> must be passed
in as "user" if dist2_matrix is non-empty</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treat_col</code></td>
<td>
<p>(optional) character, name of the column indicating
treatment assignment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist1_col</code></td>
<td>
<p>(optional) character vector names of the variables used for
calculating covariate distance using first distance measure specified by
dType</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist2_col</code></td>
<td>
<p>(optional) character vector, names of the variables used for
calculating covariate distance using second distance measure specified by
dType1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclusion_penalty</code></td>
<td>
<p>(optional) numeric vector, penalty values associated
with exclusion. Empty by default, where auto grid search is triggered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist2_penalty</code></td>
<td>
<p>(optional) numeric vector, penalty values associated
with the distance specified by <code>dist2_matrix</code> or <code>dist2_type</code>.
Empty by default, where auto grid search is tiggered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marg_bal_col</code></td>
<td>
<p>(optional) character, column name of the variable on
which to evaluate balance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact_col</code></td>
<td>
<p>(optional) character vector, names of the variables on which
to match exactly; NULL by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propensity_col</code></td>
<td>
<p>character vector, names of columns on which to fit a
propensity score model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pscore_name</code></td>
<td>
<p>(optional) character, name of the column containing fitted
propensity scores; default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_col</code></td>
<td>
<p>(optional) character vector of variable names that should
be ignored when constructing the internal matching. NULL by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_unmatched</code></td>
<td>
<p>(optional) numeric, maximum proportion of unmatched
units that can be accepted; default is 0.25.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>caliper_option</code></td>
<td>
<p>(optional) numeric, the propensity score caliper value
in standard deviations of the estimated propensity scores; default is NULL,
which is no caliper.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>(optional) numeric, tolerance of close match distance;
default is 1e-2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>(optional) integer,  maximum number of iterations to use in
searching for penalty combintions that improve the matching; default is 1,
where the algorithm searches for one round.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho_max_factor</code></td>
<td>
<p>(optional) numeric, the scaling factor used in proposal
for penalties; default is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_pareto_search_iter</code></td>
<td>
<p>(optional) numeric, the number of tries to
search for the tol that yield pareto optimal solutions; default is 5.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Matched designs generated by this function are Pareto optimal for
the three objective functions.  The degree of relative emphasis among the
three objectives in any specific solution is controlled by the penalties,
denoted by Greek letter rho. Larger values for the penalties associated with
the two distances correspond to increased emphasis close matching on these
distances, at the possible cost of excluding more treated units. Additional
details:
</p>

<ul>
<li>
<p> Users may either specify their own distance matrices (specifying
the <code>User</code> option in <code>dist1_type</code> and/or <code>dist2_type</code> and
supplying arguments to
<code>dist1_matrix</code> and/or <code>dist2_matrix</code> respectively) or ask the function
to create Mahalanobis or Euclidean distances on sets of covariates specified
by the <code>dist1_col</code> and <code>dist2_col</code> arguments. If <code>dist1_type</code> or <code>dist2_type</code>
is not specified, if one of these is set to <code>user</code> and the corresponding
<code>dist1_matrix</code> argument is not provided, or if one is NOT set to <code>User</code>
and the corresponding <code>dist1_col</code> argument is not provided, the code would
error out.
</p>
</li>
<li>
<p> User-specified distance matrices passed to <code>dist1_matrix</code> or <code>dist2_matrix</code>
should have row count equal to the number of treated units and column count
equal to the number of controls.
</p>
</li>
<li>
<p> If the <code>caliper_option</code> argument is specified, a
propensity score caliper will be imposed, forbidding matches between units
more than a fixed distance apart on the propensity score.  The caliper will
be based either on a user-fit propensity score, identified in the input
dataframe by argument <code>pscore_name</code>, or by an internally-fit propensity score
based on logistic regression against the variables named in <code>propensity_col</code>.
If <code>caliper_option</code> is non-NULL and neither of the other arguments is
specified an error will result.
</p>
</li>
<li> <p><code>tol</code> controls the precision at which the
objective functions is evaluated. When matching problems are especially large
or complex it may be necessary to increase toleranceOption in order to
prevent integer overflows in the underlying network flow solver; generally
this will be suggested in appropariate warning messages.
</p>
</li>
<li>
<p> While by default
tradeoffs are only assessed at penalty combinations provided by the user, the
user may ask for the algorithm to search over additional penalty values in
order to identify additional Pareto optimal solutions. <code>rho_max_factor</code> is a
multiplier applied to initial penalty values to discover new solutions, and
setting it larger leads to wider exploration; similarly, <code>max_iter</code> controls
how long the exploration routine runs, with larger values leading to more
exploration.
</p>
</li>
</ul>
<h3>Value</h3>

<p>a named list whose elements are:
</p>

<ul>
<li>
<p> "rhoList": list of penalty
combinations for each match
</p>
</li>
<li>
<p> "matchList": list of matches indexed by
number
</p>
</li>
<li>
<p> "treatmentCol": character of treatment variable
</p>
</li>
<li>
<p> "covs":character vector of names of the variables used for calculating within-pair
distance
</p>
</li>
<li>
<p> "exactCovs": character vector of names of variables that we want
exact or close match on
</p>
</li>
<li>
<p> "idMapping": numeric vector of row indices for
each observation in the sorted data frame for internal use
</p>
</li>
<li>
<p> "stats": data
frame of important statistics (total variation distance) for variable on
which marginal balance is measured
</p>
</li>
<li>
<p> "b.var": character, name of variable
on which marginal balance is measured (left NULL since no balance
constraint is imposed here).
</p>
</li>
<li>
<p> "dataTable": data frame sorted by treatment
value
</p>
</li>
<li>
<p> "t": a treatment vector
</p>
</li>
<li>
<p> "df": the original dataframe input by the
user
</p>
</li>
<li>
<p> "pair_cost1": list of pair-wise distance sum using the first
distance measure
</p>
</li>
<li>
<p> "pair_cost2": list of pair-wise distance sum using the
second distance measure
</p>
</li>
<li>
<p> "version": (for internal use) the version of the
matching function called; "Basic" indicates the matching comes from
dist_bal_match and "Advanced" from two_dist_match.
</p>
</li>
<li>
<p> "fDist1": a vector of
values for the first objective function; it corresponds to the pair-wise
distance sum according to the first distance measure.
</p>
</li>
<li>
<p> "fExclude": a
vector of values for the second objective function; it corresponds to the
number of treated units being unmatched.
</p>
</li>
<li>
<p> "fDist2": a vector of values for
the third objective function; it corresponds to the pair-wise distance sum
corresponds to the
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Other main matching function: 
<code>dist_bal_match()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x1 = rnorm(100, 0, 0.5)
x2 = rnorm(100, 0, 0.1)
x3 = rnorm(100, 0, 1)
x4 = rnorm(100, x1, 0.1)
r1ss &lt;- seq(0.1,50, 10)
r2ss &lt;- seq(0.1,50, 10)
x = cbind(x1, x2, x3,x4)
z = sample(c(rep(1, 50), rep(0, 50)))
e1 = rnorm(100, 0, 1.5)
e0 = rnorm(100, 0, 1.5)
y1impute = x1^2 + 0.6*x2^2 + 1 + e1
y0impute = x1^2 + 0.6*x2^2 + e0
treat = (z==1)
y = ifelse(treat, y1impute, y0impute)
names(x) &lt;- c("x1", "x2", "x3", "x4")
df &lt;- data.frame(cbind(z, y, x))
df$x5 &lt;- 1
names(x) &lt;- c("x1", "x2", "x3", "x4")
df &lt;- data.frame(cbind(z, y, x))
df$x5 &lt;- 1
d1 &lt;- as.matrix(dist(df["x1"]))
d2 &lt;- as.matrix(dist(df["x2"]))
idx &lt;- 1:length(z)
treated_units &lt;- idx[z==1]
control_units &lt;- idx[z==0]
d1 &lt;- as.matrix(d1[treated_units, control_units])
d2 &lt;- as.matrix(d2[treated_units, control_units])
match_result_1 &lt;- two_dist_match(data=df, treat_col="z",  dist1_matrix=d1, 
dist1_type= "User", dist2_matrix=d2,
dist2_type="User", marg_bal_col=c("x5"), exclusion_penalty=r1ss, 
dist2_penalty=r2ss,
propensity_col = c("x1"), max_iter = 0,
max_pareto_search_iter = 0) 
</code></pre>


</div>