<div class="container">

<table style="width: 100%;"><tr>
<td>MVN.dat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computation of Normal Scores for Multivariate Data</h2>

<h3>Description</h3>

<p>This function assigns a normal score to binary and ordinal variables using normal quantiles in this appropriate range dictated by marginal proportions; a normal score to count variables based on the equivalence of CDFs of Poisson and normal distribution in the appropriate range dictated by the rate parameters; and a normal score for each continuous measurement by finding the normal root in the Fleishman equation.</p>


<h3>Usage</h3>

<pre><code class="language-R">MVN.dat(ord.info=NULL, nct.info=NULL, count.info=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ord.info</code></td>
<td>
<p>A list containing binary and ordinal data and corresponding marginal probabilities as packaged in <code>ordmps</code>. Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nct.info</code></td>
<td>
<p>A list containing standardized continuous data and corresponding summary statistics for continuous variables as packaged in <code>nctsum</code>. Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count.info</code></td>
<td>
<p>A list containing count data and corresponding rates as packaged in <code>countrate</code>. Default is NULL.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A matrix containing normal scores for each variable input.</p>


<h3>References</h3>

<p>Fleishman A.I. (1978). A method for simulating non-normal distributions. <em>Psychometrika</em>, <b>43(4)</b>, 521-532.
</p>


<h3>See Also</h3>

<p><code>MI</code>, <code>ordmps</code>, <code>nctsum</code>, <code>countrate</code></p>


<h3>Examples</h3>

<pre><code class="language-R">library(PoisBinOrdNonNor)
n&lt;-1e4
lambdas&lt;-list(1)
mps&lt;-list(c(.2, .8))
moms&lt;-list(c(-1, 1, 0, 1))
  
#generate Poisson, ordinal, and continuous data
cmat.star &lt;- find.cor.mat.star(cor.mat = .8 * diag(3) + .2, 
                               no.pois = length(lambdas), 
                               no.ord = length(mps),
                               no.nonn = length(moms), 
                               pois.list = lambdas, 
                               ord.list = mps, 
                               nonn.list = moms)

mydata &lt;- genPBONN(n, 
                   no.pois = length(lambdas), 
                   no.ord = length(mps), 
                   no.nonn = length(moms),
                   cmat.star = cmat.star, 
                   pois.list = lambdas,
                   ord.list = mps, 
                   nonn.list = moms)

#set a sample of each variable to missing
mydata&lt;-apply(mydata, 2, function(x) {
  x[sample(1:n, size=n/10)]&lt;-NA
  return(x)
})

mydata&lt;-data.frame(mydata)

#get information for use in function
count.info&lt;-countrate(count.dat=data.frame(mydata[,c('X1')]))
ord.info&lt;-ordmps(ord.dat=data.frame(mydata[,c('X2')]))
nct.info&lt;-nctsum(nct.dat=data.frame(mydata[,c('X3')]))

mvn.dat&lt;-MVN.dat(ord.info=ord.info,
                 nct.info=nct.info,
                 count.info=count.info) #outputs in order of continuous, ordinal, count
                   
</code></pre>


</div>