<div class="container">

<table style="width: 100%;"><tr>
<td>ideal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a new ideal in Macaulay2</h2>

<h3>Description</h3>

<p>Create a new ideal in Macaulay2
</p>


<h3>Usage</h3>

<pre><code class="language-R">ideal(..., raw_chars = FALSE, code = FALSE)

ideal.(..., raw_chars = FALSE, code = FALSE)

ideal_(x, raw_chars = FALSE, code = FALSE, ...)

ideal_.(x, raw_chars = FALSE, code = FALSE, ...)

## S3 method for class 'm2_ideal'
print(x, ...)

## S3 method for class 'm2_ideal_list'
print(x, ...)

radical(ideal, ring, code = FALSE, ...)

radical.(ideal, ring, code = FALSE, ...)

saturate(I, J, code = FALSE, ...)

saturate.(I, J, code = FALSE, ...)

quotient(I, J, code = FALSE, ...)

quotient.(I, J, code = FALSE, ...)

primary_decomposition(ideal, code = FALSE, ...)

primary_decomposition.(ideal, code = FALSE, ...)

dimension(ideal, code = FALSE, ...)

## S3 method for class 'm2_ideal'
e1 + e2

## S3 method for class 'm2_ideal'
e1 * e2

## S3 method for class 'm2_ideal'
e1 == e2

## S3 method for class 'm2_ideal'
e1 ^ e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw_chars</code></td>
<td>
<p>if <code>TRUE</code>, the character vector will not be parsed by
<code>mp()</code>, saving time (default: <code>FALSE</code>). the down-side is that the
strings must be formated for M2 use directly, as opposed to for <code>mp()</code>.
(e.g. <code>"x*y+3"</code> instead of <code>"x y + 3"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code</code></td>
<td>
<p>return only the M2 code? (default: <code>FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a listing of polynomials. several formats are accepted, see
examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ideal</code></td>
<td>
<p>an ideal object of class <code>m2_ideal</code> or
<code>m2_ideal_pointer</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ring</code></td>
<td>
<p>the referent ring in Macaulay2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I, J</code></td>
<td>
<p>ideals or objects parsable into ideals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e1, e2</code></td>
<td>
<p>ideals for arithmetic</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a reference to a Macaulay2 ideal
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run:  requires Macaulay2


##### basic usage
########################################

ring("x", "y", coefring = "QQ")
ideal("x + y", "x^2 + y^2")



##### different versions of gb
########################################

# standard evaluation version
poly_chars &lt;- c("x + y", "x^2 + y^2")
ideal_(poly_chars)

# reference nonstandard evaluation version
ideal.("x + y", "x^2 + y^2")

# reference standard evaluation version
ideal_.(poly_chars)



##### different inputs to gb
########################################

ideal_(   c("x + y", "x^2 + y^2") )
ideal_(mp(c("x + y", "x^2 + y^2")))
ideal_(list("x + y", "x^2 + y^2") )



##### predicate functions
########################################

I  &lt;- ideal ("x + y", "x^2 + y^2")
I. &lt;- ideal.("x + y", "x^2 + y^2")
is.m2_ideal(I)
is.m2_ideal(I.)
is.m2_ideal_pointer(I)
is.m2_ideal_pointer(I.)



##### ideal radical
########################################

I &lt;- ideal("(x^2 + 1)^2 y", "y + 1")
radical(I)
radical.(I)



##### ideal dimension
########################################

I &lt;- ideal_(c("(x^2 + 1)^2 y", "y + 1"))
dimension(I)

# dimension of a line
ring("x", "y", coefring = "QQ")
I &lt;- ideal("y - (x+1)")
dimension(I)

# dimension of a plane
ring("x", "y", "z", coefring = "QQ")
I &lt;- ideal("z - (x+y+1)")
dimension(I)



##### ideal quotients and saturation
########################################

ring("x", "y", "z", coefring = "QQ")
(I &lt;- ideal("x^2", "y^4", "z + 1"))
(J &lt;- ideal("x^6"))

quotient(I, J)
quotient.(I, J)

saturate(I)
saturate.(I)
saturate(I, J)
saturate(I, mp("x"))
saturate(I, "x")


ring("x", "y", coefring = "QQ")
saturate(ideal("x y"), "x^2")

# saturation removes parts of varieties
# solution over R is x = -1, 0, 1
ring("x", coefring = "QQ")
I &lt;- ideal("(x-1) x (x+1)")
saturate(I, "x") # remove x = 0 from solution
ideal("(x-1) (x+1)")



##### primary decomposition
########################################

ring("x", "y", "z", coefring = "QQ")
I &lt;- ideal("(x^2 + 1) (x^2 + 2)", "y + 1")
primary_decomposition(I)
primary_decomposition.(I)

I &lt;- ideal("x (x + 1)", "y")
primary_decomposition(I)

# variety = z axis union x-y plane
(I &lt;- ideal("x z", "y z"))
dimension(I) # =  max dimension of irreducible components
(Is &lt;- primary_decomposition(I))
dimension(Is)



##### ideal arithmetic
########################################

ring("x", "y", "z", coefring = "RR")

# sums (cox et al., 184)
(I &lt;- ideal("x^2 + y"))
(J &lt;- ideal("z"))
I + J

# products (cox et al., 185)
(I &lt;- ideal("x", "y"))
(J &lt;- ideal("z"))
I * J

# equality
(I &lt;- ideal("x", "y"))
(J &lt;- ideal("z"))
I == J
I == I

# powers
(I &lt;- ideal("x", "y"))
I^3


## End(Not run)
</code></pre>


</div>