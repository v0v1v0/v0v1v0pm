<div class="container">

<table style="width: 100%;"><tr>
<td>gb</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute a Grobner basis with Macaulay2</h2>

<h3>Description</h3>

<p>Compute a Grobner basis with Macaulay2
</p>


<h3>Usage</h3>

<pre><code class="language-R">gb(..., control = list(), raw_chars = FALSE, code = FALSE)

gb.(..., control = list(), raw_chars = FALSE, code = FALSE)

gb_(x, control = list(), raw_chars = FALSE, code = FALSE, ...)

gb_.(x, control = list(), raw_chars = FALSE, code = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of options, see examples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw_chars</code></td>
<td>
<p>if <code>TRUE</code>, the character vector will not be parsed by
<code>mp()</code>, saving time (default: <code>FALSE</code>). the down-side is that the
strings must be formated for M2 use directly, as opposed to for <code>mp()</code>.
(e.g. <code>"x*y+3"</code> instead of <code>"x y + 3"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code</code></td>
<td>
<p>return only the M2 code? (default: <code>FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a character vector of polynomials to be parsed by <code>mp()</code>, a
<code>mpolyList</code> object, an <code>ideal()</code> or pointer to an ideal</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>gb</code> uses nonstandard evaluation; <code>gb_</code> is the standard evaluation
equivalent.
</p>


<h3>Value</h3>

<p>an <code>mpolyList</code> object of class <code>m2_grobner_basis</code> or a
<code>m2_grobner_basis_pointer</code> pointing to the same. See <code>mpolyList()</code>.
</p>


<h3>See Also</h3>

<p><code>mp()</code>, <code>use_ring()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run:  requires Macaulay2


##### basic usage
########################################

# the last ring evaluated is the one used in the computation
ring("t","x","y","z", coefring = "QQ")
gb("t^4 - x", "t^3 - y", "t^2 - z")

# here's the code it's running in M2
gb("t^4 - x", "t^3 - y", "t^2 - z", code = TRUE)



##### different versions of gb
########################################

# standard evaluation version
poly_chars &lt;- c("t^4 - x", "t^3 - y", "t^2 - z")
gb_(poly_chars)

# reference nonstandard evaluation version
gb.("t^4 - x", "t^3 - y", "t^2 - z")

# reference standard evaluation version
gb_.(poly_chars)



##### different inputs to gb
########################################

# ideals can be passed to gb
I &lt;- ideal("t^4 - x", "t^3 - y", "t^2 - z")
gb_(I)

# note that gb() works here, too, since there is only one input
gb(I)

# ideal pointers can be passed to gb
I. &lt;- ideal.("t^4 - x", "t^3 - y", "t^2 - z")
gb_(I.)

# setting raw_chars is a bit faster, because it doesn't use ideal()
gb("t^4 - x", "t^3 - y", "t^2 - z", raw_chars = TRUE, code = TRUE)
gb("t^4 - x", "t^3 - y", "t^2 - z", raw_chars = TRUE)



##### more advanced usage
########################################

# the control argument accepts a named list with additional
# options
gb_(
  c("t^4 - x", "t^3 - y", "t^2 - z"),
  control = list(StopWithMinimalGenerators = TRUE),
  code = TRUE
)

gb_(
  c("t^4 - x", "t^3 - y", "t^2 - z"),
  control = list(StopWithMinimalGenerators = TRUE)
)



##### potential issues
########################################

# when specifying raw_chars, be sure to add asterisks
# between variables to create monomials; that's the M2 way
ring("x", "y", "z", coefring = "QQ")
gb("x y", "x z", "x", raw_chars = TRUE, code = TRUE) # errors without code = TRUE
gb("x*y", "x*z", "x", raw_chars = TRUE, code = TRUE) # correct way
gb("x*y", "x*z", "x", raw_chars = TRUE)










## End(Not run)
</code></pre>


</div>