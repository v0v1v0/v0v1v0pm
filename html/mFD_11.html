<div class="container">

<table style="width: 100%;"><tr>
<td>beta.fd.multidim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Functional beta-Diversity indices for pairs of assemblages in a
multidimensional space</h2>

<h3>Description</h3>

<p>Computes a set of indices of pairwise functional beta-diversity
(dissimilarity and its turnover and nestedness-resultant components) based
on overlap between convex hulls in a multidimensional space. For details
about indices formulas see Villeger <em>et al.</em> (2013). This functions stands
on <code>functional.betapart.core.pairwise</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">beta.fd.multidim(
  sp_faxes_coord,
  asb_sp_occ,
  check_input = TRUE,
  beta_family = "Jaccard",
  details_returned = TRUE,
  betapart_step = TRUE,
  betapart_chullopt = list(conv1 = "Qt", conv2 = "QJ"),
  betapart_para = FALSE,
  betapart_para_opt = betapart::beta.para.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sp_faxes_coord</code></td>
<td>
<p>a matrix with coordinates of species (rows) on
functional axes (columns). Species coordinates have been retrieved thanks
to <code>tr.cont.fspace</code> or <code>quality.fspaces</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asb_sp_occ</code></td>
<td>
<p>a matrix with presence/absence (coded as 0/1)
of species (columns) in a set of assemblages (rows).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_input</code></td>
<td>
<p>a logical value defining whether inputs are
checked before computation of indices. Possible error messages will thus
may be more understandable for the user than R error messages. Default:
<code>check_input = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_family</code></td>
<td>
<p>a character string for the type of beta-diversity
index to use, 'Jaccard' (default) and/or 'Sorensen'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details_returned</code></td>
<td>
<p>a logical value indicating whether the user
wants to details_returned. Details are used in the graphical function
<code>beta.multidim.plot</code> and thus must be kept if the user want to have
graphical outputs for the computed indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betapart_step</code></td>
<td>
<p>a logical value indicating whether the
computation progress should be displayed in the R console. Default:
<code>betapart_step = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betapart_chullopt</code></td>
<td>
<p>a A list of two named vectors of character conv1
and conv2 defining the options that will be used to compute the convex
hulls (through the options of geometry::convhulln function). For further
details  see help of
<code>functional.betapart.core.pairwise</code>.
Default: <code>betapart_chullopt = c(conv1 = 'Qt', conv2 = 'QJ')</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betapart_para</code></td>
<td>
<p>a logical value indicating whether internal
parallelization should be used to compute pairwise dissimilarities.
Default: <code>betapart_para = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betapart_para_opt</code></td>
<td>
<p>a list with details about parallelization.
Default value means those parameters are set according to computer
specifications. <code>nc</code> is the number of cores (default = 4),
<code>type</code> is a character string with code of method used
(default PSOCK), <code>LB</code> is a boolean specifying whether load-balancing
is applied (default is TRUE) and <code>size</code> is a numeric value for number
of tasks performed at each time (default is 1). See help of
<code>functional.betapart.core.pairwise</code> for more
details.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with: </p>
 <ul>
<li> <p><em>pairasb_fbd_indices</em> a list with
for each
index a <em>dist</em> object with values for all pairs of assemblages.
Indices names start with the abbreviation of the type of dissimilarity
index ('jac' for Jaccard-like and 'sor' for Sorensen-like dissimilarity)
and end with abbreviation of component ('diss': dissimilarity, 'turn' its
turnover component, and 'nest' its nestedness-resultant component).
</p>
</li>
<li>
<p> if <em>store_details</em> is TRUE, </p>
</li>
<li> <p><em>details_beta</em> list:
<strong>inputs</strong> a list with <em>sp_faxes_coord</em> and <em>asb_sp_occ</em>
on which indices were computed (required for drawing graphics),
<strong>pool_vertices</strong> a list of vectors (1 per assemblage) with names of
species being vertices of the convex hull shaping all species;
<strong>asb_FRic</strong> a vector with volume of the convex hull shaping each
assemblage (relative to volume filled by all species) ;
<strong>asb_vertices</strong> a list of vectors (1 per assemblage) with names of
species being vertices of the convex hull</p>
</li>
</ul>
<h3>Note</h3>

<p>All assemblages should have a number of species strictly higher than
the number of functional axes.
Computing intersection of convex hulls in space of &gt;5 dimensions is yet
impossible with most computers.
This function uses R libraries 'betapart' (&gt; =1.5.4) for indices
computation.
Indices values are stored as <em>dist</em> objects to optimize memory.
See below example of how merging distance values in a <em>dataframe</em> with
<code>dist.to.df</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastien Villeger and Camille Magneville
</p>


<h3>References</h3>

<p>Villeger <em>et al.</em> (2013) Decomposing functional beta-diversity reveals that
low functional beta-diversity is driven by low functional turnover in
European fish assemblages. <em>Global Ecology and Biogeography</em>, <strong>22</strong>,
671-681.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
 # Load Species*Traits dataframe:
data('fruits_traits', package = 'mFD')

# Load Assemblages*Species dataframe:      
data('baskets_fruits_weights', package = 'mFD') 

# Load Traits categories dataframe:
data('fruits_traits_cat', package = 'mFD') 
 
# Compute functional distance 
sp_dist_fruits &lt;- mFD::funct.dist(sp_tr         = fruits_traits,
                                  tr_cat        = fruits_traits_cat,
                                  metric        = "gower",
                                  scale_euclid  = "scale_center",
                                  ordinal_var   = "classic",
                                  weight_type   = "equal",
                                  stop_if_NA    = TRUE)

# Compute functional spaces quality to retrieve species coordinates matrix:
fspaces_quality_fruits &lt;- mFD::quality.fspaces(
 sp_dist             = sp_dist_fruits, 
 maxdim_pcoa         = 10,
 deviation_weighting = 'absolute',
 fdist_scaling       = FALSE,
 fdendro             = 'average')
 
# Retrieve species coordinates matrix:
sp_faxes_coord_fruits &lt;- fspaces_quality_fruits$details_fspaces$sp_pc_coord

# Get the occurrence dataframe:
asb_sp_fruits_summ &lt;- mFD::asb.sp.summary(asb_sp_w = baskets_fruits_weights) 
asb_sp_fruits_occ &lt;- asb_sp_fruits_summ$'asb_sp_occ'

# Compute beta diversity indices:
beta_fd_fruits &lt;- mFD::beta.fd.multidim(
  sp_faxes_coord   = sp_faxes_coord_fruits[, c('PC1', 'PC2', 'PC3', 'PC4')], 
  asb_sp_occ       = asb_sp_fruits_occ,
  check_input      = TRUE,
  beta_family      = c('Jaccard'),
  details_returned = TRUE)

# merging pairwise beta-diversity indices in a data.frame
dist.to.df(beta_fd_fruits$pairasb_fbd_indices)

## End(Not run)
</code></pre>


</div>