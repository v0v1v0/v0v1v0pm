<div class="container">

<table style="width: 100%;"><tr>
<td>mFilter-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Getting started with the mFilter package
</h2>

<h3>Description</h3>

<p>Getting started with the mFilter package
</p>


<h3>Details</h3>

<p>This package provides some tools for decomposing time series into
trend (smooth) and cyclical (irregular) components. The package implements come commonly used
filters such as the Hodrick-Prescott, Baxter-King and Christiano-Fitzgerald
filter.
</p>
<p>For loading the package, type:
</p>
<p><code>library(mFilter)</code>
</p>
<p>A good place to start learning the package usage is to examine examples for
the <code>mFilter</code> function. At the R prompt, write:
</p>
<p><code>example("mFilter")</code>
</p>
<p>For a full list of functions exported by the package, type:
</p>
<p><code>ls("package:mFilter")</code>
</p>
<p>Each exported function has a corresponding man page (some man pages are
common to more functions). Display it by typing
</p>
<p><code>help(functionName)</code>.
</p>
<p>Almost all filters in this package can be put into the following
framework. Given a time series <code class="reqn">\{x_t\}^T_{t=1}</code> we are interested
in isolating component of <code class="reqn">x_t</code>, denoted <code class="reqn">y_t</code> with period of
oscillations between <code class="reqn">p_l</code> and <code class="reqn">p_u</code>, where <code class="reqn">2
  \le p_l &lt; p_u &lt; \infty</code>.
</p>
<p>Consider the following decomposition of the time series
</p>
<p style="text-align: center;"><code class="reqn">x_t = y_t + \bar{x}_t</code>
</p>

<p>The component <code class="reqn">y_t</code> is assumed to have power only in the frequencies
in the interval <code class="reqn">\{(a,b) \cup (-a,-b)\} \in (-\pi, \pi)</code>. <code class="reqn">a</code>
and <code class="reqn">b</code> are related to <code class="reqn">p_l</code> and <code class="reqn">p_u</code> by
</p>
<p style="text-align: center;"><code class="reqn">a=\frac{2 \pi}{p_u}\ \ \ \ \ {b=\frac{2 \pi}{p_l}}</code>
</p>

<p>If infinite amount of data is available, then we can use the ideal
bandpass filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = B(L)x_t</code>
</p>

<p>where the filter, <code class="reqn">B(L)</code>, is given in terms of the lag operator
<code class="reqn">L</code> and defined as
</p>
<p style="text-align: center;"><code class="reqn">B(L) = \sum^\infty_{j=-\infty} B_j L^j, \ \ \ L^k x_t = x_{t-k}</code>
</p>

<p>The ideal bandpass filter weights are given by
</p>
<p style="text-align: center;"><code class="reqn">B_j = \frac{\sin(jb)-\sin(ja)}{\pi j}</code>
</p>

<p style="text-align: center;"><code class="reqn">B_0=\frac{b-a}{\pi}</code>
</p>

<p>The finite sample approximation to the ideal bandpass filter uses the
alternative filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = \hat{B}(L)x_t=\sum^{n_2}_{j=-n_1}\hat{B}_{t,j} x_{t+j}</code>
</p>

<p>Here the weights, <code class="reqn">\hat{B}_{t,j}</code>, of the approximation is a
solution to
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_{t,j}= \arg \min E \{ (y_t-\hat{y}_t)^2 \}</code>
</p>

<p>The Christiano-Fitzgerald filter is a finite data approximation to the
ideal bandpass filter and minimizes the mean squared error defined in the
above equation.
</p>
<p>Several band-pass approximation strategies can be selected in the
function <code>cffilter</code>. The default setting of <code>cffilter</code> returns
the filtered data <code class="reqn">\hat{y_t}</code> associated with the unrestricted optimal filter
assuming no unit root, no drift and an iid filter.
</p>
<p>If <code>theta</code> is not equal to 1 the series is assumed to follow a
moving average process. The moving average weights are given by <code>theta</code>. The default is
<code>theta=1</code> (iid series). If <code>theta</code><code class="reqn">=(\theta_1, \theta_2, \dots)</code> then
the series is assumed to be
</p>
<p style="text-align: center;"><code class="reqn">x_t = \mu + 1_{root} x_{t-1} + \theta_1 e_t + \theta_2 e_{t-1} + \dots</code>
</p>

<p>where <code class="reqn">1_{root}=1</code> if the option <code>root=1</code> and <code class="reqn">1_{root}=0</code>
if the option <code>root=0</code>, and <code class="reqn">e_t</code> is a white noise.
</p>
<p>The Baxter-King filter is a finite data approximation to the
ideal bandpass filter with following moving average weights
</p>
<p style="text-align: center;"><code class="reqn">y_t = \hat{B}(L)x_t=\sum^{n}_{j=-n}\hat{B}_{j} x_{t+j}=\hat{B}_0
  x_t + \sum^{n}_{j=1} \hat{B}_j (x_{t-j}+x_{t+j})</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_j=B_j-\frac{1}{2n+1}\sum^{n}_{j=-n} B_{j}</code>
</p>

<p>The Hodrick-Prescott filter obtains the filter weights <code class="reqn">\hat{B}_j</code>
as a solution to
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_{j}= \arg \min E \{ (y_t-\hat{y}_t)^2 \} = \arg \min
\left\{ \sum^{T}_{t=1}(y_t-\hat{y}_{t})^2 + \lambda\sum^{T-1}_{t=2}(\hat{y}_{t+1}-2\hat{y}_{t}+\hat{y}_{t-1})^2 \right\}</code>
</p>

<p>The Hodrick-Prescott filter is a finite data approximation with
following moving average weights
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_j=\frac{1}{2\pi}\int^{\pi}_{-\pi}
\frac{4\lambda(1-\cos(\omega))^2}{1+4\lambda(1-\cos(\omega))^2}e^{i \omega
j}  d \omega</code>
</p>

<p>The digital version of the Butterworth highpass filter is described by the
rational polynomial expression (the filter's z-transform)
</p>
<p style="text-align: center;"><code class="reqn">\frac{\lambda(1-z)^n(1-z^{-1})^n}{(1+z)^n(1+z^{-1})^n+\lambda(1-z)^n(1-z^{-1})^n}</code>
</p>

<p>The time domain version can be obtained by substituting <code class="reqn">z</code> for the
lag operator <code class="reqn">L</code>.
</p>
<p>Pollock (2000) derives a specialized finite-sample version of the Butterworth
filter on the basis of signal extraction theory. Let <code class="reqn">s_t</code> be the
trend and <code class="reqn">c_t</code> cyclical component of <code class="reqn">y_t</code>, then these
components are extracted as
</p>
<p style="text-align: center;"><code class="reqn">y_t=s_t+c_t=\frac{(1+L)^n}{(1-L)^d}\nu_t+(1-L)^{n-d}\varepsilon_t</code>
</p>

<p>where <code class="reqn">\nu_t \sim N(0,\sigma_\nu^2)</code> and <code class="reqn">\varepsilon_t \sim
  N(0,\sigma_\varepsilon^2)</code>.
</p>
<p>Let <code class="reqn">T</code> be even and define <code class="reqn">n_1=T/p_u</code> and <code class="reqn">n_2=T/p_l</code>. The
trigonometric regression filter is based on the following relation
</p>
<p style="text-align: center;"><code class="reqn">{y}_t=\sum^{n_1}_{j=n_2}\left\{ a_j \cos(\omega_j t) + b_j
    \sin(\omega_j t) \right\}</code>
</p>

<p>where <code class="reqn">a_j</code> and <code class="reqn">b_j</code> are the coefficients obtained by
regressing <code class="reqn">x_t</code> on the indicated sine and cosine
functions. Specifically,
</p>
<p><code class="reqn">a_j=\frac{T}{2}\sum^{T}_{t=1}\cos(\omega_j t) x_t,\ \ \ </code>   for
<code class="reqn">j=1,\dots,T/2-1</code>
</p>
<p><code class="reqn">a_j=\frac{T}{2}\sum^{T}_{t=1}\cos(\pi t) x_t,\ \ \ </code>    for <code class="reqn">j=T/2</code>
</p>
<p>and
</p>
<p><code class="reqn">b_j=\frac{T}{2}\sum^{T}_{t=1}\sin(\omega_j t) x_t,\ \ \ </code>    for
<code class="reqn">j=1,\dots,T/2-1</code>
</p>
<p><code class="reqn">b_j=\frac{T}{2}\sum^{T}_{t=1}\sin(\pi t) x_t,\ \ \ </code>   for <code class="reqn">j=T/2</code>
</p>
<p>Let <code class="reqn">\hat{B}(L) x_t</code> be the trigonometric regression filter. It can
be showed that <code class="reqn">\hat{B}(1)=0</code>, so that <code class="reqn">\hat{B}(L)</code> has a unit
root for <code class="reqn">t=1,2,\dots,T</code>. Also, when <code class="reqn">\hat{B}(L)</code> is symmetric,
it has a second unit root in the middle of the data for
<code class="reqn">t</code>. Therefore it is important to drift adjust data before it is
filtered with a trigonometric regression filter.
</p>
<p>If <code>drift=TRUE</code> the drift adjusted series is obtained as
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_{t}=x_t-t\left(\frac{x_{T}-x_{1}}{T-1}\right), \ \ t=0,1,\dots,T-1</code>
</p>

<p>where <code class="reqn">\tilde{x}_{t}</code> is the undrifted series.
</p>


<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>References</h3>

<p>M. Baxter and R.G. King. Measuring business cycles: Approximate bandpass
filters. The Review of Economics and Statistics, 81(4):575-93, 1999.
</p>
<p>L. Christiano and T.J. Fitzgerald. The bandpass filter. International Economic
Review, 44(2):435-65, 2003.
</p>
<p>J. D. Hamilton. <em>Time series analysis.</em> Princeton, 1994.
</p>
<p>R.J. Hodrick and E.C. Prescott. Postwar US business cycles: an empirical
investigation. Journal of Money, Credit, and Banking, 29(1):1-16, 1997.
</p>
<p>R.G. King and S.T. Rebelo. Low frequency filtering and real business cycles.
Journal of Economic Dynamics and Control, 17(1-2):207-31, 1993.
</p>
<p>D.S.G. Pollock. Trend estimation and de-trending via rational square-wave
filters. Journal of Econometrics, 99:317-334, 2000.
</p>


<h3>See Also</h3>

<p><code>mFilter-methods</code> for listing all currently
available <code>mFilter</code> methods. For help on common interface function
"<code>mFilter</code>", <code>mFilter</code>. For individual filter function
usage, <code>bwfilter</code>, <code>bkfilter</code>,
<code>cffilter</code>, <code>hpfilter</code>, <code>trfilter</code>.
</p>


</div>