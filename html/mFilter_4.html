<div class="container">

<table style="width: 100%;"><tr>
<td>cffilter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Christiano-Fitzgerald filter of a time series
</h2>

<h3>Description</h3>

<p>This function implements the Christiano-Fitzgerald approximation to
the ideal band pass filter for a time series. The function computes cyclical
and trend components of the time series using several band-pass
approximation strategies.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cffilter(x,pl=NULL,pu=NULL,root=FALSE,drift=FALSE,
         type=c("asymmetric","symmetric","fixed","baxter-king","trigonometric"),
	 nfix=NULL,theta=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a regular time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>the filter type,
<code>"asymmetric"</code>, asymmetric Christiano-Fitzgerald filter
(default),
<code>"symmetric"</code>, symmetric Christiano-Fitzgerald filter
<code>"fixed"</code>, fixed length Christiano-Fitzgerald filter,
<code>"baxter-king"</code>, Baxter-King fixed length symmetric filter,
<code>"trigonometric"</code>, trigonometric regression filter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pl</code></td>
<td>
<p>minimum period of oscillation of desired component (pl&lt;=2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pu</code></td>
<td>
<p>maximum period of oscillation of desired component (2&lt;=pl&lt;pu&lt;infinity).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>
<p>logical, <code>FALSE</code> if no unit root in time series
(default),  <code>TRUE</code> if unit root in time series. The
<code>root</code> option has no effect if <code>type</code> is
<code>"baxter-king"</code> or <code>"trigonometric"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drift</code></td>
<td>
<p>logical, <code>FALSE</code> if no drift in time series
(default),  <code>TRUE</code> if drift in time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfix</code></td>
<td>
<p>sets fixed lead/lag length or order of the filter with
<code>"baxter-king"</code> and <code>"fixed"</code>. The <code>nfix</code> option sets
the order of the filter by 2*nfix+1. The default is <code>nfix=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>moving average coefficients for time series model: x(t) =
mu + root*x(t-1) + theta(1)*e(t) + theta(2)*e(t-1) + ..., where e(t)
is a white noise.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Almost all filters in this package can be put into the
following framework. Given a time series <code class="reqn">\{x_t\}^T_{t=1}</code> we are
interested in isolating component of <code class="reqn">x_t</code>, denoted <code class="reqn">y_t</code> with
period of oscillations between <code class="reqn">p_l</code> and <code class="reqn">p_u</code>, where <code class="reqn">2
  \le p_l &lt; p_u &lt; \infty</code>.
</p>
<p>Consider the following decomposition of the time series
</p>
<p style="text-align: center;"><code class="reqn">x_t = y_t + \bar{x}_t</code>
</p>

<p>The component <code class="reqn">y_t</code> is assumed to have power only in the frequencies
in the interval <code class="reqn">\{(a,b) \cup (-a,-b)\} \in (-\pi, \pi)</code>. <code class="reqn">a</code>
and <code class="reqn">b</code> are related to <code class="reqn">p_l</code> and <code class="reqn">p_u</code> by
</p>
<p style="text-align: center;"><code class="reqn">a=\frac{2 \pi}{p_u}\ \ \ \ \ {b=\frac{2 \pi}{p_l}}</code>
</p>

<p>If infinite amount of data is available, then we can use the ideal
bandpass filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = B(L)x_t</code>
</p>

<p>where the filter, <code class="reqn">B(L)</code>, is given in terms of the lag operator
<code class="reqn">L</code> and defined as
</p>
<p style="text-align: center;"><code class="reqn">B(L) = \sum^\infty_{j=-\infty} B_j L^j, \ \ \ L^k x_t = x_{t-k}</code>
</p>

<p>The ideal bandpass filter weights are given by
</p>
<p style="text-align: center;"><code class="reqn">B_j = \frac{\sin(jb)-\sin(ja)}{\pi j}</code>
</p>

<p style="text-align: center;"><code class="reqn">B_0=\frac{b-a}{\pi}</code>
</p>

<p>The finite sample approximation to the ideal bandpass filter uses the
alternative filter
</p>
<p style="text-align: center;"><code class="reqn">y_t = \hat{B}(L)x_t=\sum^{n_2}_{j=-n_1}\hat{B}_{t,j} x_{t+j}</code>
</p>

<p>Here the weights, <code class="reqn">\hat{B}_{t,j}</code>, of the approximation is a
solution to
</p>
<p style="text-align: center;"><code class="reqn">\hat{B}_{t,j}= \arg \min E \{ (y_t-\hat{y}_t)^2 \}</code>
</p>

<p>The Christiano-Fitzgerald filter is a finite data approximation to the
ideal bandpass filter and minimizes the mean squared error defined in the
above equation.
</p>
<p>Several band-pass approximation strategies can be selected in the
function <code>cffilter</code>. The default setting of <code>cffilter</code> returns
the filtered data <code class="reqn">\hat{y_t}</code> associated with the unrestricted optimal filter
assuming no unit root, no drift and an iid filter.
</p>
<p>If <code>theta</code> is not equal to 1 the series is assumed to follow a
moving average process. The moving average weights are given by <code>theta</code>. The default is
<code>theta=1</code> (iid series). If <code>theta</code><code class="reqn">=(\theta_1, \theta_2, \dots)</code> then
the series is assumed to be
</p>
<p style="text-align: center;"><code class="reqn">x_t = \mu + 1_{root} x_{t-1} + \theta_1 e_t + \theta_2 e_{t-1} + \dots</code>
</p>

<p>where <code class="reqn">1_{root}=1</code> if the option <code>root=1</code> and <code class="reqn">1_{root}=0</code>
if the option <code>root=0</code>, and <code class="reqn">e_t</code> is a white noise.
</p>
<p>If <code>drift=TRUE</code> the drift adjusted series is obtained as
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_{t}=x_t-t\left(\frac{x_{T}-x_{1}}{T-1}\right), \ \ t=0,1,\dots,T-1</code>
</p>

<p>where <code class="reqn">\tilde{x}_{t}</code> is the undrifted series.
</p>


<h3>Value</h3>

<p>A "<code>mFilter</code>" object (see <code>mFilter</code>).
</p>


<h3>Author(s)</h3>

<p>Mehmet Balcilar, <a href="mailto:mehmet@mbalcilar.net">mehmet@mbalcilar.net</a>
</p>


<h3>References</h3>

<p>M. Baxter and R.G. King. Measuring business cycles: Approximate bandpass
filters. The Review of Economics and Statistics, 81(4):575-93, 1999.
</p>
<p>L. Christiano and T.J. Fitzgerald. The bandpass filter. International Economic
Review, 44(2):435-65, 2003.
</p>
<p>J. D. Hamilton. <em>Time series analysis.</em> Princeton, 1994.
</p>
<p>R.J. Hodrick and E.C. Prescott. Postwar US business cycles: an empirical
investigation. Journal of Money, Credit, and Banking, 29(1):1-16, 1997.
</p>
<p>R.G. King and S.T. Rebelo. Low frequency filtering and real business cycles.
Journal of Economic Dynamics and Control, 17(1-2):207-31, 1993.
</p>
<p>D.S.G. Pollock. Trend estimation and de-trending via rational square-wave
filters. Journal of Econometrics, 99:317-334, 2000.
</p>


<h3>See Also</h3>

<p><code>mFilter</code>, <code>bwfilter</code>, <code>bkfilter</code>,
<code>hpfilter</code>, <code>trfilter</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## library(mFilter)

data(unemp)

opar &lt;- par(no.readonly=TRUE)

unemp.cf &lt;- cffilter(unemp)
plot(unemp.cf)
unemp.cf1 &lt;- cffilter(unemp, drift=TRUE, root=TRUE)
unemp.cf2 &lt;- cffilter(unemp, pl=8,pu=40,drift=TRUE, root=TRUE)
unemp.cf3 &lt;- cffilter(unemp, pl=2,pu=60,drift=TRUE, root=TRUE)
unemp.cf4 &lt;- cffilter(unemp, pl=2,pu=40,drift=TRUE, root=TRUE,theta=c(.1,.4))

par(mfrow=c(2,1),mar=c(3,3,2,1),cex=.8)
plot(unemp.cf1$x,
main="Christiano-Fitzgerald filter of unemployment: Trend \n root=TRUE,drift=TRUE",
col=1, ylab="")
lines(unemp.cf1$trend,col=2)
lines(unemp.cf2$trend,col=3)
lines(unemp.cf3$trend,col=4)
lines(unemp.cf4$trend,col=5)
legend("topleft",legend=c("series", "pl=2, pu=32", "pl=8, pu=40", "pl=2, pu=60",
"pl=2, pu=40, theta=.1,.4"), col=1:5, lty=rep(1,5), ncol=1)

plot(unemp.cf1$cycle,
main="Christiano-Fitzgerald filter of unemployment: Cycle \n root=TRUE,drift=TRUE",
col=2, ylab="", ylim=range(unemp.cf3$cycle))
lines(unemp.cf2$cycle,col=3)
lines(unemp.cf3$cycle,col=4)
lines(unemp.cf4$cycle,col=5)
## legend("topleft",legend=c("pl=2, pu=32", "pl=8, pu=40", "pl=2, pu=60",
## "pl=2, pu=40, theta=.1,.4"), col=2:5, lty=rep(1,4), ncol=2)

par(opar)
</code></pre>


</div>