<div class="container">

<table style="width: 100%;"><tr>
<td>ImapCon</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>An IMAP Connection Class</h2>

<h3>Description</h3>

<p>Configure an IMAP connection using the <code>ImapCon</code> <code>R6</code>
class.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ImapCon-new"><code>ImapCon$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_url"><code>ImapCon$reset_url()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_username"><code>ImapCon$reset_username()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_use_ssl"><code>ImapCon$reset_use_ssl()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_verbose"><code>ImapCon$reset_verbose()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_buffersize"><code>ImapCon$reset_buffersize()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_timeout_ms"><code>ImapCon$reset_timeout_ms()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_password"><code>ImapCon$reset_password()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_xoauth2_bearer"><code>ImapCon$reset_xoauth2_bearer()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-list_mail_folders"><code>ImapCon$list_mail_folders()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-select_folder"><code>ImapCon$select_folder()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-examine_folder"><code>ImapCon$examine_folder()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-create_folder"><code>ImapCon$create_folder()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-rename_folder"><code>ImapCon$rename_folder()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-list_flags"><code>ImapCon$list_flags()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search"><code>ImapCon$search()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_larger_than"><code>ImapCon$search_larger_than()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_smaller_than"><code>ImapCon$search_smaller_than()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_before"><code>ImapCon$search_before()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_since"><code>ImapCon$search_since()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_on"><code>ImapCon$search_on()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_period"><code>ImapCon$search_period()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_sent_before"><code>ImapCon$search_sent_before()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_sent_since"><code>ImapCon$search_sent_since()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_sent_on"><code>ImapCon$search_sent_on()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_sent_period"><code>ImapCon$search_sent_period()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_flag"><code>ImapCon$search_flag()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_older_than"><code>ImapCon$search_older_than()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_younger_than"><code>ImapCon$search_younger_than()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_string"><code>ImapCon$search_string()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_body"><code>ImapCon$fetch_body()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_header"><code>ImapCon$fetch_header()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_metadata"><code>ImapCon$fetch_metadata()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_text"><code>ImapCon$fetch_text()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-copy_msg"><code>ImapCon$copy_msg()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-move_msg"><code>ImapCon$move_msg()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-esearch_count"><code>ImapCon$esearch_count()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-delete_msg"><code>ImapCon$delete_msg()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-expunge"><code>ImapCon$expunge()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-esearch_min_id"><code>ImapCon$esearch_min_id()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-esearch_max_id"><code>ImapCon$esearch_max_id()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-add_flags"><code>ImapCon$add_flags()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-replace_flags"><code>ImapCon$replace_flags()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-remove_flags"><code>ImapCon$remove_flags()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-get_attachments"><code>ImapCon$get_attachments()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_attachments_list"><code>ImapCon$fetch_attachments_list()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_attachments"><code>ImapCon$fetch_attachments()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-clone"><code>ImapCon$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-ImapCon-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Configure and create a new IMAP connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$new(
  url,
  username,
  password = NULL,
  xoauth2_bearer = NULL,
  use_ssl = TRUE,
  verbose = FALSE,
  buffersize = 16000,
  timeout_ms = 0,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt>
<dd>
<p>A character string containing the IMAP server address</p>
</dd>
<dt><code>username</code></dt>
<dd>
<p>A character string containing the username.</p>
</dd>
<dt><code>password</code></dt>
<dd>
<p>A character string containing the user's password.</p>
</dd>
<dt><code>xoauth2_bearer</code></dt>
<dd>
<p>A character string containing the oauth2 bearer token.</p>
</dd>
<dt><code>use_ssl</code></dt>
<dd>
<p>A logical indicating the use or not of Secure Sockets Layer
encryption when connecting to the IMAP server. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>If <code>FALSE</code>, mutes the flow of information between the
server and the client. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>buffersize</code></dt>
<dd>
<p>The size in bytes for the receive buffer. Default is
16000 bytes or 16kb, which means it will use the libcurl's default value.
According to the libcurl's documentation, the maximum buffersize is 512kb
(or 512000 bytes), but any number passed to <code>buffersize</code> is treated
as a request, not an order.</p>
</dd>
<dt><code>timeout_ms</code></dt>
<dd>
<p>Time in milliseconds (ms) to wait for the execution or
re-execution of a command. Default is 0, which means that no timeout limit is
set.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Further curl parameters (see <code>curl::curl_options</code>) that
can be used with the IMAP protocol. Only for advanced users.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new 'ImapCon' object.
</p>


<hr>
<a id="method-ImapCon-reset_url"></a>



<h4>Method <code>reset_url()</code>
</h4>

<p>Reset the previously informed url
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_url(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>A character string containing a new url to be set.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ImapCon-reset_username"></a>



<h4>Method <code>reset_username()</code>
</h4>

<p>Reset the previously informed username
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_username(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>A character string containing a new username to be set.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ImapCon-reset_use_ssl"></a>



<h4>Method <code>reset_use_ssl()</code>
</h4>

<p>Reset the previously informed use_ssl parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_use_ssl(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>A logical indicating the use or not of Secure Sockets Layer
encryption when connecting to the IMAP server. Default is <code>TRUE</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ImapCon-reset_verbose"></a>



<h4>Method <code>reset_verbose()</code>
</h4>

<p>Reset the previously informed verbose parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_verbose(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>If <code>FALSE</code>, mutes the flow of information between the
server and the client.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ImapCon-reset_buffersize"></a>



<h4>Method <code>reset_buffersize()</code>
</h4>

<p>Reset the previously informed buffersize parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_buffersize(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>The size in bytes for the receive buffer. Default is
16000 bytes or 16kb, which means it will use the libcurl's default value.
According to the libcurl's documentation, the maximum buffersize is 512kb
(or 512000 bytes), but any number passed to <code>buffersize</code> is treated
as a request, not an order.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ImapCon-reset_timeout_ms"></a>



<h4>Method <code>reset_timeout_ms()</code>
</h4>

<p>Reset the previously informed buffersize parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_timeout_ms(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>Time in milliseconds (ms) to wait for the execution or
re-execution of a command. Default is 0, which means that no timeout limit is
set.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ImapCon-reset_password"></a>



<h4>Method <code>reset_password()</code>
</h4>

<p>Reset the previously informed password
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_password(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>A character string containing the user's password.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ImapCon-reset_xoauth2_bearer"></a>



<h4>Method <code>reset_xoauth2_bearer()</code>
</h4>

<p>Reset the previously informed oauth2 bearer token
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_xoauth2_bearer(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>A character string containing the oauth2 bearer token.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ImapCon-list_server_capabilities"></a>



<h4>Method <code>list_server_capabilities()</code>
</h4>

<p>List the server's IMAP capabilities.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$list_server_capabilities(retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A character <code>vector</code> containing the server's IMAP capabilities.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
cap &lt;- con$list_server_capabilities()
cap
}
</pre>
</div>


<hr>
<a id="method-ImapCon-list_mail_folders"></a>



<h4>Method <code>list_mail_folders()</code>
</h4>

<p>List mail folders in a mailbox.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$list_mail_folders(retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> containing the mail folder names and their inherent
structure.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
folders &lt;- con$list_mail_folders()
folders
}
</pre>
</div>


<hr>
<a id="method-ImapCon-select_folder"></a>



<h4>Method <code>select_folder()</code>
</h4>

<p>Select a mail folder.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$select_folder(name, mute = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>A string containing the name of an existing mail folder on the
user's mailbox.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> containing the mail folder names and their inherent
structure.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_mail_folder(name = "INBOX")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-examine_folder"></a>



<h4>Method <code>examine_folder()</code>
</h4>

<p>Examine the number of messages in a mail folder.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$examine_folder(name = NULL, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>A <code>character</code> string containing the name of an existing
mail folder on the user's mailbox. If no name is passed, the command
will be executed using the previously selected mail folder name.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>vector</code> (with names <code>"EXISTS"</code> and <code>"RECENT"</code>)
containing the number of messages in each category.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
con$examine_folder()

# or directly:
con$examine_folder("Sent")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-create_folder"></a>



<h4>Method <code>create_folder()</code>
</h4>

<p>Create a new mail folder.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$create_folder(name, mute = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>A string containing the name of the new mail folder to be
created.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>TRUE</code> in case the operation is successful.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$create_folder(name = "New Folder Name")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-rename_folder"></a>



<h4>Method <code>rename_folder()</code>
</h4>

<p>Rename a mail folder.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$rename_folder(
  name = NULL,
  new_name,
  reselect = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>A string containing the name of the new mail folder to be
renamed. If no name is passed, the command will be executed using the
previously selected mail folder name.</p>
</dd>
<dt><code>new_name</code></dt>
<dd>
<p>A string containing the new name to be assigned.</p>
</dd>
<dt><code>reselect</code></dt>
<dd>
<p>A logical. If <code>TRUE</code>, calls
<code>select_folder(name = to_folder)</code> under the hood before returning
the output. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>TRUE</code> in case the operation is successful.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "Folder A")
con$rename_folder(new_name = "Folder B")
# or directly:
con$rename_folder(name = "Folder A", new_name = "Folder B")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-list_flags"></a>



<h4>Method <code>list_flags()</code>
</h4>

<p>List flags in a selected mail folder
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$list_flags(retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>TRUE</code> in case the operation is successful.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
con$list_flags()
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search"></a>



<h4>Method <code>search()</code>
</h4>

<p>Execute a custom search
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search(
  request,
  negate = FALSE,
  use_uid = FALSE,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt>
<dd>
<p>A string directly specifying what to search or
constructed by a combination of relational-operator-helper-functions <code>OR</code>
and <code>AND</code>, and criteria helper functions such as
<code>before</code>, <code>since</code>, <code>on</code>,
<code>sent_before</code>, <code>sent_since</code>, <code>sent_on</code>,
<code>flag</code>, <code>string</code>, <code>smaller_than</code>,
<code>larger_than</code>, <code>younger_than</code>, or
<code>younger_than</code>.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERIA". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> containing the flags (<code>character vector</code>),
the permanent flags (<code>character vector</code>), and an indication if custom
flags are allowed by the server (<code>logical vector</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# ex1
con$search(OR(before(date_char = "17-Apr-2015"),
              string(expr = "John", where = "FROM")))

# ex2
con$search(AND(smaller_than(size = "512000"),
               string(expr = "John", where = "FROM"),
               string(expr = "@ksu.edu", where = "CC")))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_larger_than"></a>



<h4>Method <code>search_larger_than()</code>
</h4>

<p>Search by size (LARGER)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_larger_than(
  size,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>size</code></dt>
<dd>
<p>An integer specifying the size in bytes to be used as the
search criterion.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# search for messages with size larger than 512Kb
con$search_larger_than(size = 512000))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_smaller_than"></a>



<h4>Method <code>search_smaller_than()</code>
</h4>

<p>Search by size (SMALLER)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_smaller_than(
  size,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>size</code></dt>
<dd>
<p>An integer specifying the size in bytes to be used as the
search criterion.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for messages with size smaller than 512Kb
con$search_smaller_than(size = 512000))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_before"></a>



<h4>Method <code>search_before()</code>
</h4>

<p>Search by internal date (BEFORE)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_before(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt>
<dd>
<p>A <code>character string</code> with format "DD-Mon-YYYY", e.g.
"01-Apr-2019". We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_before(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_since"></a>



<h4>Method <code>search_since()</code>
</h4>

<p>Search by internal date (SINCE)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_since(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt>
<dd>
<p>A <code>character string</code> with format "DD-Mon-YYYY", e.g.
"01-Apr-2019". We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.
<code>POSIX*</code> like objects, since IMAP servers use this uncommon date format.
<code>POSIX*</code> like, since IMAP servers like this not so common date format.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for messages with date since "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_since(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_on"></a>



<h4>Method <code>search_on()</code>
</h4>

<p>Search by internal date (ON)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_on(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt>
<dd>
<p>A <code>character string</code> with format "DD-Mon-YYYY", e.g.
"01-Apr-2019". We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for messages received on date "02-Jan-2020", presenting the
#... results as unique identifiers (UID)
con$search_on(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_period"></a>



<h4>Method <code>search_period()</code>
</h4>

<p>Search by internal date (Period)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_period(
  since_date_char,
  before_date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>since_date_char</code></dt>
<dd>
<p>A <code>character string</code> with format "DD-Mon-YYYY", e.g.
"01-Apr-2019". We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>before_date_char</code></dt>
<dd>
<p>A <code>character string</code> with format "DD-Mon-YYYY", e.g.
"01-Apr-2019". We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages in the mail folder, EXCEPT (negate = TRUE) by
#... those received between the dates "02-Jan-2020" and "22-Mar-2020"
con$search_period(since_date_char = "02-Jan-2020",
                  before_date_char = "22-Mar-2020",
                  negate = TRUE))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_sent_before"></a>



<h4>Method <code>search_sent_before()</code>
</h4>

<p>Search by origination date  (RFC 2822 Header - SENT BEFORE)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_sent_before(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt>
<dd>
<p>A <code>character string</code> with format "DD-Mon-YYYY", e.g.
"01-Apr-2019". We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_sent_before(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_sent_since"></a>



<h4>Method <code>search_sent_since()</code>
</h4>

<p>Search by origination date (RFC 2822 Header - SENT SINCE)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_sent_since(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt>
<dd>
<p>A <code>character string</code> with format "DD-Mon-YYYY", e.g.
"01-Apr-2019". We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_sent_since(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_sent_on"></a>



<h4>Method <code>search_sent_on()</code>
</h4>

<p>Search by origination date (RFC 2822 Header - SENT ON)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_sent_on(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt>
<dd>
<p>A <code>character string</code> with format "DD-Mon-YYYY", e.g.
"01-Apr-2019". We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for messages received on date "02-Jan-2020", presenting the
#... results as unique identifiers (UID)
con$search_sent_on(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_sent_period"></a>



<h4>Method <code>search_sent_period()</code>
</h4>

<p>Search by origination date (RFC 2822 Header - SENT Period)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_sent_period(
  since_date_char,
  before_date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>since_date_char</code></dt>
<dd>
<p>A <code>character string</code> with format "DD-Mon-YYYY", e.g.
"01-Apr-2019". We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>before_date_char</code></dt>
<dd>
<p>A <code>character string</code> with format "DD-Mon-YYYY", e.g.
"01-Apr-2019". We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages in the mail folder, EXCEPT (negate = TRUE) by
#... those received between the dates "02-Jan-2020" and "22-Mar-2020"
con$search_sent_period(since_date_char = "02-Jan-2020",
                  before_date_char = "22-Mar-2020",
                  negate = TRUE))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_flag"></a>



<h4>Method <code>search_flag()</code>
</h4>

<p>Search by flag(s)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_flag(
  name,
  negate = FALSE,
  use_uid = FALSE,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>A string containing one or more flags to search for. Use
<a href="#method-list_flags"><code>ImapCon$list_flags()</code></a> to list the flags
in a selected mail folder.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages in the mail folder that are marked as "SEEN" AND
#.. "ANSWERED"
con$search_flag(name = c("SEEN", "ANSWERED"))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_older_than"></a>



<h4>Method <code>search_older_than()</code>
</h4>

<p>Search WITHIN a specific time (OLDER)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_older_than(
  seconds,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>seconds</code></dt>
<dd>
<p>An integer specifying the number of seconds to be used as
the search criterion.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (not older than 3600 seconds)
con$search_older_than(seconds = 3600, negate = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_younger_than"></a>



<h4>Method <code>search_younger_than()</code>
</h4>

<p>Search WITHIN a specific time (YOUNGER)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_younger_than(
  seconds,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>seconds</code></dt>
<dd>
<p>An integer specifying the number of seconds to be used as
the search criterion.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (younger than 3600 seconds)
con$search_younger_than(seconds = 3600)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_string"></a>



<h4>Method <code>search_string()</code>
</h4>

<p>Search by string or expression
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_string(
  expr,
  where,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expr</code></dt>
<dd>
<p>A character string specifying the word or expression to search
for in messages.</p>
</dd>
<dt><code>where</code></dt>
<dd>
<p>A mandatory character string specifying in which
message's Section or Header Field to search for the provided string.</p>
</dd>
<dt><code>negate</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the search and seeks for "NOT SEARCH
CRITERION". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt>
<dd>
<p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt>
<dd>
<p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (younger than 3600 seconds)
con$search_string(expr = "@k-state.edu", where = "FROM")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_body"></a>



<h4>Method <code>fetch_body()</code>
</h4>

<p>Fetch message body (message's full content)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_body(
  msg_id,
  use_uid = FALSE,
  mime_level = NULL,
  peek = TRUE,
  partial = NULL,
  write_to_disk = FALSE,
  keep_in_mem = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>mime_level</code></dt>
<dd>
<p>An <code>integer</code> specifying MIME multipart to fetch from
the message's body. Default is <code>NULL</code>, which retrieves the full body content.</p>
</dd>
<dt><code>peek</code></dt>
<dd>
<p>If <code>TRUE</code>, it does not mark messages as "read" after
fetching. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>partial</code></dt>
<dd>
<p><code>NULL</code> or a character string with format
"startchar.endchar" indicating the size (in characters) of a message slice
to fetch. Default is <code>NULL</code>, which will fetch the full specified content.</p>
</dd>
<dt><code>write_to_disk</code></dt>
<dd>
<p>If <code>TRUE</code>, writes the fetched content of each message
to a text file in a local folder inside the working directory, also
returning the results with <code>invisible()</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>keep_in_mem</code></dt>
<dd>
<p>If <code>TRUE</code>, keeps a copy of each fetch result while
the operation is being performed with <code>write_to_disk = TRUE</code>. Default
is <code>FALSE</code>, and it can only be set <code>TRUE</code> when
<code>write_to_disk = TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. It provides a confirmation message if the
command is successfully executed. It is only effective when <code>write_to_disk = TRUE</code>
and <code>keep_in_mem = FALSE</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents or a logical if
<code>write_to_disk = TRUE</code> and <code>keep_in_mem = FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and fetch the results (saving to disk) using the pipe
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_body(write_to_disk = TRUE, keep_in_mem = FALSE)

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")

con$fetch_body(msg = res, write_to_disk = TRUE, keep_in_mem = FALSE)

}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_header"></a>



<h4>Method <code>fetch_header()</code>
</h4>

<p>Fetch message header
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_header(
  msg_id,
  use_uid = FALSE,
  fields = NULL,
  negate_fields = FALSE,
  peek = TRUE,
  partial = NULL,
  write_to_disk = FALSE,
  keep_in_mem = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>fields</code></dt>
<dd>
<p>An optional <code>character vector</code> specifying which field(s)
will be fetched from the message's header. If none is specified, it will
fetch the full header.</p>
</dd>
<dt><code>negate_fields</code></dt>
<dd>
<p>If <code>TRUE</code>, negates the operation and seeks for
"NOT in the field". Default is <code>FALSE</code>.</p>
</dd>
<dt><code>peek</code></dt>
<dd>
<p>If <code>TRUE</code>, it does not mark messages as "read" after
fetching. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>partial</code></dt>
<dd>
<p><code>NULL</code> or a character string with format
"startchar.endchar" indicating the size (in characters) of a message slice
to fetch. Default is <code>NULL</code>, which will fetch the full specified content.</p>
</dd>
<dt><code>write_to_disk</code></dt>
<dd>
<p>If <code>TRUE</code>, writes the fetched content of each message
to a text file in a local folder inside the working directory, also
returning the results with <code>invisible()</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>keep_in_mem</code></dt>
<dd>
<p>If <code>TRUE</code>, keeps a copy of each fetch result while
the operation is being performed with <code>write_to_disk = TRUE</code>. Default
is <code>FALSE</code>, and it can only be set <code>TRUE</code> when
<code>write_to_disk = TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. It provides a confirmation message if the
command is successfully executed. It is only effective when <code>write_to_disk = TRUE</code>
and <code>keep_in_mem = FALSE</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents or a logical if
<code>write_to_disk = TRUE</code> and <code>keep_in_mem = FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and fetch the results (also saving to disk) using the pipe
out &lt;- con$search_string(expr = "@k-state.edu", where = "CC") %&gt;%
  con$fetch_header()

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "CC")
out &lt;- con$fetch_header()

}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_metadata"></a>



<h4>Method <code>fetch_metadata()</code>
</h4>

<p>Fetch message metadata
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_metadata(
  msg_id,
  use_uid = FALSE,
  attribute = NULL,
  write_to_disk = FALSE,
  keep_in_mem = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>attribute</code></dt>
<dd>
<p>An optional <code>character vector</code> specifying one or more
attributes of the metadata of a message to fetch. See metadata_options.</p>
</dd>
<dt><code>write_to_disk</code></dt>
<dd>
<p>If <code>TRUE</code>, writes the fetched content of each message
to a text file in a local folder inside the working directory, also
returning the results with <code>invisible()</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>keep_in_mem</code></dt>
<dd>
<p>If <code>TRUE</code>, keeps a copy of each fetch result while
the operation is being performed with <code>write_to_disk = TRUE</code>. Default
is <code>FALSE</code>, and it can only be set <code>TRUE</code> when
<code>write_to_disk = TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. It provides a confirmation message if the
command is successfully executed. It is only effective when <code>write_to_disk = TRUE</code>
and <code>keep_in_mem = FALSE</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
<dt><code>peek</code></dt>
<dd>
<p>If <code>TRUE</code>, it does not mark messages as "read" after
fetching. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>partial</code></dt>
<dd>
<p><code>NULL</code> or a character string with format
"startchar.endchar" indicating the size (in characters) of a message slice
to fetch. Default is <code>NULL</code>, which will fetch the full specified content.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents or a logical if
<code>write_to_disk = TRUE</code> and <code>keep_in_mem = FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and fetch the results using the pipe
out &lt;- con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_metadata()

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
out &lt;- con$fetch_metadata(msg = res)

}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_text"></a>



<h4>Method <code>fetch_text()</code>
</h4>

<p>Fetch message text
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_text(
  msg_id,
  use_uid = FALSE,
  peek = TRUE,
  partial = NULL,
  write_to_disk = FALSE,
  keep_in_mem = TRUE,
  mute = FALSE,
  base64_decode = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>peek</code></dt>
<dd>
<p>If <code>TRUE</code>, it does not mark messages as "read" after
fetching. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>partial</code></dt>
<dd>
<p><code>NULL</code> or a character string with format
"startchar.endchar" indicating the size (in characters) of a message slice
to fetch. Default is <code>NULL</code>, which will fetch the full specified content.</p>
</dd>
<dt><code>write_to_disk</code></dt>
<dd>
<p>If <code>TRUE</code>, writes the fetched content of each message
to a text file in a local folder inside the working directory, also
returning the results with <code>invisible()</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>keep_in_mem</code></dt>
<dd>
<p>If <code>TRUE</code>, keeps a copy of each fetch result while
the operation is being performed with <code>write_to_disk = TRUE</code>. Default
is <code>FALSE</code>, and it can only be set <code>TRUE</code> when
<code>write_to_disk = TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. It provides a confirmation message if the
command is successfully executed. It is only effective when <code>write_to_disk = TRUE</code>
and <code>keep_in_mem = FALSE</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>base64_decode</code></dt>
<dd>
<p>If <code>TRUE</code>, tries to guess and decode the fetched
text from base64 format to <code>character</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents or a logical if
<code>write_to_disk = TRUE</code> and <code>keep_in_mem = FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and partially fetch the results using the pipe
# first 200 characters, writing to disk, silence results in the console
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_text(partial = "0.200",
                 write_to_disk = TRUE,
                 keep_in_mem = FALSE)

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$fetch_text(msg = res,
               partial = "0.200",
               write_to_disk = TRUE,
               keep_in_mem = FALSE)

}
</pre>
</div>


<hr>
<a id="method-ImapCon-copy_msg"></a>



<h4>Method <code>copy_msg()</code>
</h4>

<p>Copy message(s) between the selected folder and another one
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$copy_msg(
  msg_id,
  use_uid = FALSE,
  to_folder,
  reselect = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>to_folder</code></dt>
<dd>
<p>A <code>character</code> string specifying the folder to which
the messages will be copied.</p>
</dd>
<dt><code>reselect</code></dt>
<dd>
<p>A logical. If <code>TRUE</code>, calls
<a href="#method-select_folder"><code>ImapCon$select_folder(name = to_folder)</code></a>
under the hood before returning the output. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and copy the results to another folder
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$copy(to_folder = "Sent")

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$copy(msg = res, to_folder = "Sent")

}
</pre>
</div>


<hr>
<a id="method-ImapCon-move_msg"></a>



<h4>Method <code>move_msg()</code>
</h4>

<p>Move message(s) between the selected folder and another one
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$move_msg(
  msg_id,
  use_uid = FALSE,
  to_folder,
  reselect = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>to_folder</code></dt>
<dd>
<p>A <code>character</code> string specifying the folder to which
the messages will be copied.</p>
</dd>
<dt><code>reselect</code></dt>
<dd>
<p>A logical. If <code>TRUE</code>, calls
<a href="#method-select_folder"><code>ImapCon$select_folder(name = to_folder)</code></a>
under the hood before returning the output. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and copy the results to another folder
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$move(to_folder = "Sent")

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$move(msg = res, to_folder = "Sent")

}
</pre>
</div>


<hr>
<a id="method-ImapCon-esearch_count"></a>



<h4>Method <code>esearch_count()</code>
</h4>

<p>Count the number of messages with a specific flag(s) in a
folder (depend on ESEARCH capability)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$esearch_count(flag, use_uid = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>flag</code></dt>
<dd>
<p>A mandatory parameter that specifies one or more flags as a
filter to the counting operation. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A numeric <code>vector</code> of length <code>1</code> containing the number
of messages in the folder that meet the specified criteria.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# count the number of messages marked as "Flagged" and "Answered"
con$esearch_count(flag = c("Flagged", "Answered"))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-delete_msg"></a>



<h4>Method <code>delete_msg()</code>
</h4>

<p>Delete message(s) in the selected mail folder
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$delete_msg(msg_id, use_uid = FALSE, mute = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# delete
con$delete_msg(flag = c("Flagged", "Answered"))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-expunge"></a>



<h4>Method <code>expunge()</code>
</h4>

<p>Permanently removes all or specific messages marked as deleted from the selected folder
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$expunge(msg_uid = NULL, mute = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_uid</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more messages UIDs.
Only UIDs are allowed in this operation (note the "u" in msg_<em>u</em>id).</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>TRUE</code> if the operation is successful.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# count the number of messages marked as "Flagged" and "Answered"
con$esearch_count(flag = c("Flagged", "Answered"))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-esearch_min_id"></a>



<h4>Method <code>esearch_min_id()</code>
</h4>

<p>Search the minimum message id in the selected mail folder
(depend on ESEARCH capability)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$esearch_min_id(flag, use_uid = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>flag</code></dt>
<dd>
<p>A mandatory parameter that specifies one or more flags as a
filter to the searching operation. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A numeric <code>vector</code> of length <code>1</code> containing the minimum
message id in the folder.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# Search the minimum id of messages marked as "Answered"
con$esearch_min_id(flag = "Answered")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-esearch_max_id"></a>



<h4>Method <code>esearch_max_id()</code>
</h4>

<p>Search the maximum message id in the selected mail folder
(depend on ESEARCH capability)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$esearch_max_id(flag, use_uid = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>flag</code></dt>
<dd>
<p>A mandatory parameter that specifies one or more flags as a
filter to the searching operation. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A numeric <code>vector</code> of length <code>1</code> containing the maximum
message id in the folder.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# Search the minimum id of messages marked as "Seen"
con$esearch_max_id(flag = "Seen")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-add_flags"></a>



<h4>Method <code>add_flags()</code>
</h4>

<p>Add flags to one or more messages
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$add_flags(
  msg_id,
  use_uid = FALSE,
  flags_to_set,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flags_to_set</code></dt>
<dd>
<p>A <code>character vector</code> containing one or more flag
names to add to the specified message ids. If the flag to be set is a
system flag, such as <code>\SEEN</code>, <code>\ANSWERED</code>, the name should be
preceded by two backslashes <code>\</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# Add the "\Seen" permanent flag to the messages received in the last hour
con$search_younger_than(seconds = 3600) %&gt;% # depends on the WITHIN extension
  con$add_flags(flags_to_set = "\\Seen")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-replace_flags"></a>



<h4>Method <code>replace_flags()</code>
</h4>

<p>Replace the current flags of one or more messages
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$replace_flags(
  msg_id,
  use_uid = FALSE,
  flags_to_set,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flags_to_set</code></dt>
<dd>
<p>A <code>character vector</code> containing one or more flag
names that will replace the current ones. If the flag to be set is a
system flag, such as <code>\SEEN</code>, <code>\ANSWERED</code>, the name should be
preceded by two backslashes <code>\</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# Replace the current flags of the messages in the search results for the
#.. flags "\UNSEEN" and "\Flagged"
con$search_since(date_char = "20-Aug-2020") %&gt;%
  con$replace_flags(flags_to_set = c("\\UNSEEN", "\\Flagged")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-remove_flags"></a>



<h4>Method <code>remove_flags()</code>
</h4>

<p>Remove flag(s) of one or more messages
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$remove_flags(
  msg_id,
  use_uid = FALSE,
  flags_to_unset,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flags_to_unset</code></dt>
<dd>
<p>A <code>character vector</code> containing one or more
flag names that will be unset (removed). If the flag to be removed is a
system flag, such as <code>\SEEN</code>, <code>\ANSWERED</code>, the name should be
preceded by two backslashes <code>\</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# Remove the the "\SEEN" flag from the messages in the search result
con$search_since(date_char = "20-Aug-2020") %&gt;%
  con$remove_flags(flags_to_unset = "\\UNSEEN")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-get_attachments"></a>



<h4>Method <code>get_attachments()</code>
</h4>

<p>Extract attached file(s) from fetched message(s)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$get_attachments(
  msg_list,
  content_disposition = "both",
  override = FALSE,
  mute = FALSE,
  as_is = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_list</code></dt>
<dd>
<p>A <code>list</code> with the body or text content of the messages
fetched with <a href="#method-fetch_body"><code>ImapCon$fetch_body()</code></a> or
<a href="#method-fetch_text"><code>ImapCon$fetch_text()</code></a>.</p>
</dd>
<dt><code>content_disposition</code></dt>
<dd>
<p>A <code>string</code> indicating which type of
"Content-Disposition" attachments should be retrieved. Default is
<code>"both"</code>, which retrieves regular attachments ("Content-Disposition:
attachment") and  inline attachments ("Content-Disposition: inline").</p>
</dd>
<dt><code>override</code></dt>
<dd>
<p>A <code>logical</code>. Provides a confirmation message if the
command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>as_is</code></dt>
<dd>
<p>If <code>TRUE</code> then write out attachments without base64
decoding. Default is <code>FALSE</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>TRUE</code> if the operation is successful. The files are saved
locally.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# example 1
con$select_folder(name = "INBOX")
con$search_string(expr = "@gmail", where = "CC") %&gt;%
  con$fetch_text(write_to_disk = TRUE) %&gt;% # saving the message's content as txt files
  con$get_attachments()

# example 2
res &lt;- con$search_string(expr = "@gmail", where = "CC") %&gt;%
out &lt;- con$fetch_body(msg = res)
con$get_attachments(msg_list = out)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_attachments_list"></a>



<h4>Method <code>fetch_attachments_list()</code>
</h4>

<p>Fetch attachments' list
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_attachments_list(msg_id, use_uid = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and fetch the attachments' list of the messages
out &lt; con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_attachments_list()
out

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
out &lt;- con$fetch_attachments_list(msg = res)
out

}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_attachments"></a>



<h4>Method <code>fetch_attachments()</code>
</h4>

<p>Fetch message attachments
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_attachments(
  msg_id,
  use_uid = FALSE,
  content_disposition = "both",
  override = FALSE,
  mute = FALSE,
  retries = 1,
  as_is = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt>
<dd>
<p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt>
<dd>
<p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>content_disposition</code></dt>
<dd>
<p>A <code>string</code> indicating which type of
"Content-Disposition" attachments should be retrieved. The options are
<code>both</code>, <code>attachment</code>, and <code>inline</code>. Default is
<code>"both"</code>, which retrieves regular attachments ("Content-Disposition:
attachment") and  inline attachments ("Content-Disposition: inline").</p>
</dd>
<dt><code>override</code></dt>
<dd>
<p>A <code>logical</code>. Provides a confirmation message if the
command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>mute</code></dt>
<dd>
<p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt>
<dd>
<p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
<dt><code>as_is</code></dt>
<dd>
<p>If <code>TRUE</code> then write out attachments without base64
decoding. Default is <code>FALSE</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and fetch the attachments' list of the messages
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_attachments() # the attachments will be downloaded to disk


# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$fetch_attachments(msg = res)

}
</pre>
</div>


<hr>
<a id="method-ImapCon-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Note</h3>

<p><a href="#method-new"><code>ImapCon$new()</code></a>: The <code>configure_imap</code>
should be preferred instead of <code>ImapCon$new()</code>.
</p>
<p><a href="#method-search"><code>ImapCon$search()</code></a>: IMAP queries follows
Polish notation, i.e. operators such as <code>OR</code> come before arguments,
e.g. "OR argument1 argument2". Therefore, the relational-operator-helper-functions
in this package should be used like the following examples:
<code>OR(before("17-Apr-2015"), string("FROM", "John"))</code>. Even though there
is no "AND" operator in IMAP, this package adds a helper function
<code>AND</code> to indicate multiples arguments that must be searched
together, e.g. <code>AND(since("01-Jul-2018"), smaller_than(16000))</code>.
</p>
<p><a href="#method-sent_before"><code>ImapCon$sent_before()</code></a>: Search
operations that use the origination/RFC-2822 Header date
tend to be "slower" than those that use the internal date. Although the
overhead is minimum, the difference is due to the fact that the internal date
is kept on a database, while the origination date has to be retrieved from
inside the message. Therefore, the server needs to access each message when
executing this type of search. Despite this fact, both dates tend to be the
same.
</p>
<p><a href="#method-search_sent_since"><code>ImapCon$search_sent_since()</code></a>: Search
operations that use the origination/RFC-2822 Header date
tend to be "slower" than those that use the internal date. Although the
overhead is minimum, the difference is due to the fact that the internal date
is kept on a database, while the origination date has to be retrieved from
inside the message. Therefore, the server needs to access each message when
executing this type of search. Despite this fact, both dates tend to be the
same.
</p>
<p><a href="#method-search_sent_on"><code>ImapCon$search_sent_on()</code></a>: Search
operations that use the origination/RFC-2822 Header date
tend to be "slower" than those that use the internal date. Although the
overhead is minimum, the difference is due to the fact that the internal date
is kept on a database, while the origination date has to be retrieved from
inside the message. Therefore, the server needs to access each message when
executing this type of search. Despite this fact, both dates tend to be the
same.
</p>
<p><a href="#method-search_sent_period"><code>ImapCon$search_sent_period()</code></a>: Search
operations that use the origination/RFC-2822 Header date
tend to be "slower" than those that use the internal date. Although the
overhead is minimum, the difference is due to the fact that the internal date
is kept on a database, while the origination date has to be retrieved from
inside the message. Therefore, the server needs to access each message when
executing this type of search. Despite this fact, both dates tend to be the
same.
</p>
<p><a href="#method-search_older_than"><code>ImapCon$search_older_than()</code></a>:
To be able to use this functionality, the server must support the
<code>WITHIN</code> capability. You can check it by running
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.
</p>
<p><a href="#method-search_older_than"><code>ImapCon$search_older_than()</code></a>:
To be able to use this functionality, the server must support the
<code>WITHIN</code> capability. You can check it by running
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.
</p>
<p><a href="#method-search_string"><code>ImapCon$search_string()</code></a>: Using
<code>where = "TEXT"</code>, may produce unexpected results since it
will perform the search on raw data, i.e. the searched expression may be
truncated by special formating characters such as <code>\r\n</code> for example.
It is recommended to perform this type of search using <code>where = "BODY"</code>,
instead of <code>"TEXT"</code> (<cite>Heinlein, P. and Hartleben, P. (2008)</cite>).
</p>
<p><a href="#method-esearch_count"><code>ImapCon$esearch_count()</code></a>: This
operation depends on the <code>ESEARCH</code> extension.
</p>
<p><a href="#method-esearch_min_id"><code>ImapCon$esearch_min_id()</code></a>: This
operation depends on the <code>ESEARCH</code> extension.
</p>
<p><a href="#method-esearch_max_id"><code>ImapCon$esearch_max_id()</code></a>: This
operation depends on the <code>ESEARCH</code> extension.
</p>
<p><a href="#method-add_flags"><code>ImapCon$add_flags()</code></a>: Unlike the
search operations, the add/replace/delete flags operations
demand system flag names to be preceded by two backslashes <code>"\\"</code>.
</p>
<p><a href="#method-add_flags"><code>ImapCon$add_flags()</code></a>: <code>add_flags</code>,
<code>remove_flags</code>, and <code>replace_flags</code> accept not only flags but
also keywords (any word not beginning with two backslashes) which are
custom flags defined by the user.
</p>
<p><a href="#method-replace_flags"><code>ImapCon$replace_flags()</code></a>: Unlike the
search operations, the add/replace/delete flags operations
demand system flag names to be preceded by two backslashes <code>"\\"</code>.
</p>
<p><a href="#method-replace_flags"><code>ImapCon$replace_flags()</code></a>: <code>add_flags</code>,
<code>remove_flags</code>, and <code>replace_flags</code> accept not only flags but
also keywords (any word not beginning with two backslashes) which are
custom flags defined by the user.
</p>
<p><a href="#method-remove_flags"><code>ImapCon$remove_flags()</code></a>: Unlike the
search operations, the add/replace/delete flags operations
demand system flag names to be preceded by two backslashes <code>"\\"</code>.
</p>
<p><a href="#method-remove_flags"><code>ImapCon$remove_flags()</code></a>: <code>add_flags</code>,
<code>remove_flags</code>, and <code>replace_flags</code> accept not only flags but
also keywords (any word not beginning with two backslashes) which are
custom flags defined by the user.
</p>
<p><a href="#method-get_attachments"><code>ImapCon$get_attachments()</code></a>:
This method is to be used after the body or the
text part of one or more messages were fetched. This makes sense if the
user is interested in keeping the message content (body or text) besides
downloading the message attachments. Nonetheless, this is not the
recommended approach if the user is only interested in downloading the files
as the previous fetching operation will probably be costly. In this last
case, the recommendation is to use
<a href="#method-fetch_attachments"><code>ImapCon$fetch_attachments()</code></a> as
it will only fetch the attachment part.
</p>
<p><a href="#method-get_attachments"><code>ImapCon$get_attachments()</code></a>: All
attachments will be stored in a folder labeled with the message id
inside the <code>working directory &gt; servername &gt; foldername</code>.
This function currently handles only attachments
encoded as <code>base64</code> text. It tries to guess all file extensions while
decoding the text, but it may not be possible to do so in some circumstances.
If it happens, you can try to change the file extension directly by renaming
the file.
</p>
<p><a href="#method-get_attachments"><code>ImapCon$get_attachments()</code></a>: The
"Content-Disposition" header specifies if the multipart electronic
messages will be presented as a main document with a list of separate
attachments ("Content-Disposition: attachment") or as a single document
with the various parts displayed inline. The first requires positive action
on the part of the recipient (downloading the file, for example) whereas inline
components are displayed automatically when the message is viewed
(<cite>Troost, R., Dorner, S., and K. Moore, Ed. (1997)</cite>). You can choose
to download <code>both</code>, or only one type of attachment, using the
argument <code>content_disposition</code>.
</p>
<p><a href="#method-fetch_attachments"><code>ImapCon$fetch_attachments()</code></a>: All
attachments will be stored in a folder labeled with the message id
inside the <code>working directory &gt; servername &gt; foldername</code>.
This function currently handles only attachments
encoded as <code>base64</code> text. It tries to guess all file extensions while
decoding the text, but it may not be possible to do so in some circumstances.
If it happens, you can try to change the file extension directly by renaming
the file.
</p>
<p><a href="#method-fetch_attachments"><code>ImapCon$fetch_attachments()</code></a>: The
"Content-Disposition" header specifies if the multipart electronic
messages will be presented as a main document with a list of separate
attachments ("Content-Disposition: attachment") or as a single document
with the various parts displayed inline. The first requires positive action
on the part of the recipient (downloading the file, for example) whereas inline
components are displayed automatically when the message is viewed
(<cite>Troost, R., Dorner, S., and K. Moore, Ed. (1997)</cite>). You can choose
to download <code>both</code>, or only one type of attachment, using the
argument <code>content_disposition</code>.
</p>


<h3>References</h3>

<p><a href="#method-search_string"><code>ImapCon$search_string()</code></a>:
Heinlein, P. and Hartleben, P. (2008). The Book of IMAP: Building a
Mail Server with Courier and Cyrus. No Starch Press. ISBN 978-1-59327-177-0.
</p>
<p><a href="#method-get_attachments"><code>ImapCon$get_attachments()</code></a>:
Troost, R., Dorner, S., and K. Moore (1997), Communicating
Presentation Information in Internet Messages: The Content-Disposition
Header Field, RFC 2183, August 1997, https://www.rfc-editor.org/rfc/rfc2183.
</p>
<p><a href="#method-fetch_attachments"><code>ImapCon$fetch_attachments()</code></a>:
Troost, R., Dorner, S., and K. Moore (1997), Communicating
Presentation Information in Internet Messages: The Content-Disposition
Header Field, RFC 2183, DOI 10.17487/RFC2183, August 1997,
https://www.rfc-editor.org/rfc/rfc2183.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code>AND()</code>,
<code>OR()</code>,
<code>before()</code>,
<code>flag()</code>,
<code>larger_than()</code>,
<code>older_than()</code>,
<code>on()</code>,
<code>sent_before()</code>,
<code>sent_on()</code>,
<code>sent_since()</code>,
<code>since()</code>,
<code>smaller_than()</code>,
<code>string()</code>,
<code>younger_than()</code>
</p>
<p>Other attachments: 
<code>list_attachments()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# w/ Plain authentication
con &lt;- configure_imap(
  url="imaps://outlook.office365.com",
  username="user@agency.gov.br",
  password=rstudioapi::askForPassword(),
  verbose = TRUE)

# OR
con &lt;- ImapCon$new(
  url="imaps://outlook.office365.com",
  username="user@agency.gov.br",
  password=rstudioapi::askForPassword(),
  verbose = TRUE)

# w/ OAuth2.0 authentication
con &lt;- configure_imap(
  url="imaps://outlook.office365.com",
  username="user@agency.gov.br",
  verbose = TRUE,
  xoauth2_bearer = "XX.Ya9...")

# OR
con &lt;- ImapCon$new(
  url="imaps://outlook.office365.com",
  username="user@agency.gov.br",
  verbose = TRUE,
  xoauth2_bearer = "XX.Ya9...")


## End(Not run)



## ------------------------------------------------
## Method `ImapCon$list_server_capabilities`
## ------------------------------------------------

## Not run: 
cap &lt;- con$list_server_capabilities()
cap

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$list_mail_folders`
## ------------------------------------------------

## Not run: 
folders &lt;- con$list_mail_folders()
folders

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$select_folder`
## ------------------------------------------------

## Not run: 
con$select_mail_folder(name = "INBOX")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$examine_folder`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
con$examine_folder()

# or directly:
con$examine_folder("Sent")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$create_folder`
## ------------------------------------------------

## Not run: 
con$create_folder(name = "New Folder Name")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$rename_folder`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "Folder A")
con$rename_folder(new_name = "Folder B")
# or directly:
con$rename_folder(name = "Folder A", new_name = "Folder B")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$list_flags`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
con$list_flags()

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# ex1
con$search(OR(before(date_char = "17-Apr-2015"),
              string(expr = "John", where = "FROM")))

# ex2
con$search(AND(smaller_than(size = "512000"),
               string(expr = "John", where = "FROM"),
               string(expr = "@ksu.edu", where = "CC")))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_larger_than`
## ------------------------------------------------

## Not run: 
# search for messages with size larger than 512Kb
con$search_larger_than(size = 512000))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_smaller_than`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for messages with size smaller than 512Kb
con$search_smaller_than(size = 512000))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_before`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_before(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_since`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for messages with date since "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_since(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_on`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for messages received on date "02-Jan-2020", presenting the
#... results as unique identifiers (UID)
con$search_on(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_period`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages in the mail folder, EXCEPT (negate = TRUE) by
#... those received between the dates "02-Jan-2020" and "22-Mar-2020"
con$search_period(since_date_char = "02-Jan-2020",
                  before_date_char = "22-Mar-2020",
                  negate = TRUE))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_sent_before`
## ------------------------------------------------

## Not run: 
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_sent_before(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_sent_since`
## ------------------------------------------------

## Not run: 
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_sent_since(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_sent_on`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for messages received on date "02-Jan-2020", presenting the
#... results as unique identifiers (UID)
con$search_sent_on(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_sent_period`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages in the mail folder, EXCEPT (negate = TRUE) by
#... those received between the dates "02-Jan-2020" and "22-Mar-2020"
con$search_sent_period(since_date_char = "02-Jan-2020",
                  before_date_char = "22-Mar-2020",
                  negate = TRUE))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_flag`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages in the mail folder that are marked as "SEEN" AND
#.. "ANSWERED"
con$search_flag(name = c("SEEN", "ANSWERED"))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_older_than`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (not older than 3600 seconds)
con$search_older_than(seconds = 3600, negate = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_younger_than`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (younger than 3600 seconds)
con$search_younger_than(seconds = 3600)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_string`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (younger than 3600 seconds)
con$search_string(expr = "@k-state.edu", where = "FROM")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_body`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and fetch the results (saving to disk) using the pipe
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_body(write_to_disk = TRUE, keep_in_mem = FALSE)

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")

con$fetch_body(msg = res, write_to_disk = TRUE, keep_in_mem = FALSE)


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_header`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and fetch the results (also saving to disk) using the pipe
out &lt;- con$search_string(expr = "@k-state.edu", where = "CC") %&gt;%
  con$fetch_header()

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "CC")
out &lt;- con$fetch_header()


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_metadata`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and fetch the results using the pipe
out &lt;- con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_metadata()

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
out &lt;- con$fetch_metadata(msg = res)


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_text`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and partially fetch the results using the pipe
# first 200 characters, writing to disk, silence results in the console
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_text(partial = "0.200",
                 write_to_disk = TRUE,
                 keep_in_mem = FALSE)

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$fetch_text(msg = res,
               partial = "0.200",
               write_to_disk = TRUE,
               keep_in_mem = FALSE)


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$copy_msg`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and copy the results to another folder
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$copy(to_folder = "Sent")

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$copy(msg = res, to_folder = "Sent")


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$move_msg`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and copy the results to another folder
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$move(to_folder = "Sent")

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$move(msg = res, to_folder = "Sent")


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$esearch_count`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# count the number of messages marked as "Flagged" and "Answered"
con$esearch_count(flag = c("Flagged", "Answered"))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$delete_msg`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# delete
con$delete_msg(flag = c("Flagged", "Answered"))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$expunge`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# count the number of messages marked as "Flagged" and "Answered"
con$esearch_count(flag = c("Flagged", "Answered"))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$esearch_min_id`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# Search the minimum id of messages marked as "Answered"
con$esearch_min_id(flag = "Answered")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$esearch_max_id`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# Search the minimum id of messages marked as "Seen"
con$esearch_max_id(flag = "Seen")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$add_flags`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# Add the "\Seen" permanent flag to the messages received in the last hour
con$search_younger_than(seconds = 3600) %&gt;% # depends on the WITHIN extension
  con$add_flags(flags_to_set = "\\Seen")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$replace_flags`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# Replace the current flags of the messages in the search results for the
#.. flags "\UNSEEN" and "\Flagged"
con$search_since(date_char = "20-Aug-2020") %&gt;%
  con$replace_flags(flags_to_set = c("\\UNSEEN", "\\Flagged")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$remove_flags`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# Remove the the "\SEEN" flag from the messages in the search result
con$search_since(date_char = "20-Aug-2020") %&gt;%
  con$remove_flags(flags_to_unset = "\\UNSEEN")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$get_attachments`
## ------------------------------------------------

## Not run: 
# example 1
con$select_folder(name = "INBOX")
con$search_string(expr = "@gmail", where = "CC") %&gt;%
  con$fetch_text(write_to_disk = TRUE) %&gt;% # saving the message's content as txt files
  con$get_attachments()

# example 2
res &lt;- con$search_string(expr = "@gmail", where = "CC") %&gt;%
out &lt;- con$fetch_body(msg = res)
con$get_attachments(msg_list = out)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_attachments_list`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and fetch the attachments' list of the messages
out &lt; con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_attachments_list()
out

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
out &lt;- con$fetch_attachments_list(msg = res)
out


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_attachments`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and fetch the attachments' list of the messages
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_attachments() # the attachments will be downloaded to disk


# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$fetch_attachments(msg = res)


## End(Not run)
</code></pre>


</div>