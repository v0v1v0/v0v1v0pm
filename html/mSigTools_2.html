<div class="container">

<table style="width: 100%;"><tr>
<td>match_two_sig_sets</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find an optimal matching between two sets of signatures subject to a maximum distance.</h2>

<h3>Description</h3>

<p>Find an optimal matching between two sets of signatures subject to a maximum distance.
</p>


<h3>Usage</h3>

<pre><code class="language-R">match_two_sig_sets(
  x1,
  x2,
  method = "cosine",
  convert.sim.to.dist = function(x) {
     return(1 - x)
 },
  cutoff = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>A numerical-matrix-like object with columns as signatures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2</code></td>
<td>
<p>A numerical-matrix-like object with columns as signatures.
Needs to have the same number of rows as <code>x1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>As for the <code>distance</code> function in package
<code>philenropy</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convert.sim.to.dist</code></td>
<td>
<p>If <code>method</code> specifies a similarity
rather than a distance, use this function to convert the
similarity to a distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>A maximum distance or minimum similarity over which to
pair signatures between <code>x1</code> and <code>x2</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Match signatures between <code>x1</code> and <code>x2</code>
using the function
<code>solve_LSAP</code>, which uses the
"Hungarian" (a.k.a "Kuhnâ€“Munkres") algorithm
<a href="https://en.wikipedia.org/wiki/Hungarian_algorithm">https://en.wikipedia.org/wiki/Hungarian_algorithm</a>,
which optimizes the total cost associated with the links
between nodes.
This function generates a distance matrix between the two
sets of signatures using <code>method</code> and, if necessary,
<code>convert.sim.to.dist</code>.
It then sets distances &gt; <code>cutoff</code> to very large values and
then applies <code>solve_LSAP</code> to the resulting
matrix to compute a matching between
<code>x1</code> and <code>x2</code> that minimizes the sum of the
distances.
</p>


<h3>Value</h3>

<p>A list with the elements
</p>

<ul>
<li> <p><code>table</code> Table of extracted signatures that matched a reference
signature. Each row contains the extracted signature name,
the reference
signature name, and the distance of the match.
</p>
</li>
<li> <p><code>orig.matrix</code> The matrix of numeric distances between
<code>x1</code> and <code>x2</code>.
</p>
</li>
<li> <p><code>modified.matrix</code> The argument <code>orig.matrix</code>
with distances &gt;
<code>cutoff</code> changed to very large values.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">ex.sigs &lt;- matrix(c(0.2, 0.8, 0.3, 0.7, 0.6, 0.4), nrow = 2)
colnames(ex.sigs) &lt;- c("ex1", "ex2", "ex3")
ref.sigs &lt;- matrix(c(0.21, 0.79, 0.19, 0.81), nrow = 2)
colnames(ref.sigs) &lt;- c("ref1", "ref2")
match_two_sig_sets(ex.sigs, ref.sigs, cutoff = .9)

</code></pre>


</div>