<div class="container">

<table style="width: 100%;"><tr>
<td>dlyWeaGenPoints</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Daily Weather Generator</h2>

<h3>Description</h3>

<p>Generates quasi-daily time series from the monthly mean values of temperature, precipitation and
sunshine data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dlyWeaGenPoints(
  temp,
  prec,
  bsdf,
  year = 2000,
  aprchTEMP = c("hip", "tsi", "const"),
  aprchPREC = c("tsi", "hip", "const"),
  aprchBSDF = c("hip", "const"),
  dvTEMP = rep(0.7, 12),
  dvPREC = rep(0.7, 12),
  argCkd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>temp</code></td>
<td>
<p>'numeric' R object with one-year time series of monthly mean air temperature (in °C)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prec</code></td>
<td>
<p>'numeric' R object with one-year time series of monthly precipitation sum (in mm)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bsdf</code></td>
<td>
<p>'numeric' R object with one-year time series of monthly mean relative sunshine duration (dimensionless)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>year</code></td>
<td>
<p>'numeric' vector with values of the year (using astronomical year numbering)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aprchTEMP</code></td>
<td>
<p>'character' vector of length 1 that indicates the scheme used to generate daily values of the
daily mean air temperature for a specific year. Valid values are as follows: <br>
(a) <code>'hip'</code> -
this scheme applies the mean-preserving 'harmonic' interpolation method of Epstein (1991) to the values of
monthly mean air temperature in order to generate daily values; <br>
(b) <code>'tsi'</code> -
this scheme uses an iterative interpolation technique (Lüdeke et al. 1994) to time series of the monthly mean
air temperature, in order to generate a synthetic time series of the selected meteorological variable at a
temporal resolution that is higher than the daily scale; finally, this synthetic time series is upscaled to a
daily resolution; <br>
(c) <code>'const'</code> -
this scheme is assumed that values of the daily mean air temperature are constant within each month.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aprchPREC</code></td>
<td>
<p>'character' vector of length 1 that indicates the scheme to generate daily values of the
daily precipitation sum. Valid values are as follows: <br>
(a) <code>'tsi'</code> -
this scheme uses an iterative interpolation technique (Lüdeke et al. 1994) to time series of the monthly mean
precipitation intensity, in order to generate a synthetic time series of the selected meteorological variable
at a temporal resolution that is higher than the daily scale; finally, this synthetic time series is upscaled
to a daily resolution; <br>
(b) <code>'hip'</code> -
this scheme applies the mean-preserving 'harmonic' interpolation method of Epstein (1991) to the values of
monthly mean precipitation intensity in order to generate daily values; <br>
(c) <code>'const'</code> -
this scheme is assumed that values of the daily precipitation sum are constant within each month (the monthly
precipitation sum is divided equally across each day of the month).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aprchBSDF</code></td>
<td>
<p>'character' vector of length 1 that indicates the scheme used to generate daily values of the
daily fractional sunshine duration for a specific year. Valid values are as follows: <br>
(a) <code>'hip'</code> -
this scheme applies the mean-preserving 'harmonic' interpolation method of Epstein (1991) to the values of
monthly mean relative sunshine duration in order to generate daily values; <br>
(b) <code>'const'</code> -
this scheme is assumed that values of the daily relative sunshine duration are constant within each month.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dvTEMP</code></td>
<td>
<p>'numeric' vector of length 12 with monthly values of the damping variable for the air temperature
data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dvPREC</code></td>
<td>
<p>'numeric' vector of length 12 with monthly values of the damping variable for the precipitation data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argCkd</code></td>
<td>
<p>'logical' scalar that indicates whether or not the checking and correction of arguments can be
omitted.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For relative sunshine duration and air temperature, it is recommended the 'harmonic' interpolation
technique (<code>'hip'</code>) described by Epstein (1991), with a correction of physically impossible values. This
technique can also be used to values of the mean precipitation intensity, however, in the case of
precipitation, the temporal scaling (<code>'tsi'</code>) using an iterative interpolation technique described by
Lüdeke et al. (1994) is recommended, with a damping variable of 0.7 for each month. The damping variable can
be set separately for each month and must be between 0 and 1. This iterative scheme can also be applied to
monthly mean data of air temperature. Furthermore, for all three climate variables, it is possible to ignore
intra-month variability. For this, the setting <code>'const'</code> must be used.
</p>


<h3>Value</h3>

<p>A list with three 365- or 366-column matrices that contain quasi-daily time series for the three basic
climate variables:
</p>

<ul>
<li>
<p><code>TEMP</code>: daily mean air temperature (in °C)
</p>
</li>
<li>
<p><code>PREC</code>: daily precipitation sum (in mm)
</p>
</li>
<li>
<p><code>BSDF</code>: daily fractional sunshine duration (dimensionless)
</p>
</li>
</ul>
<h3>Note</h3>

<p>As with any point function, a set of basic input data is defined here. In this case, they are as follows:
<code>'temp'</code> (one-year time series of monthly mean air temperature), <code>'prec'</code> (one-year time series
of monthly precipitation sum), and <code>'bsdf'</code> (one-year time series of monthly mean relative sunshine
duration.) The objects <code>'temp'</code>, <code>'prec'</code> and <code>'bsdf'</code> must be either vectors of length 12 or
12-column matrices. The first dimensions of these matrices have to be the same length. The function
automatically converts vectors into single-row matrices during the error handling, and then uses these
matrices. The first dimensions of these matrices determines the number of rows in the result matrix. In the
case of arguments that do not affect the course of the calculation procedure or the structure of the return
object, scalar values (i.e., 'numeric' vector of length 1) may also be allowed. In this case, it is as
follow: <code>'year'</code> (year using astronomical year numbering). This scalar is converted to a vector by the
function during the error handling, and this vector is applied in the further calculations. If these data are
stored in vectors of length at least 2, their length must be the same size of first dimension of the matrices
containing the basic data.
</p>


<h3>References</h3>

<p><cite>Epstein ES (1991) On Obtaining Daily Climatological Values from Monthly Means. J Clim 4(3):365–368.
<a href="https://doi.org/10.1175/1520-0442%281991%29004%3C0365%3AOODCVF%3E2.0.CO%3B2">doi:10.1175/1520-0442(1991)004&lt;0365:OODCVF&gt;2.0.CO;2</a></cite>
</p>
<p><cite>Lüdeke MKB, Badeck FW, Otto RD, Häger C, Dönges S, Kindermann J, Würth G, Lang T, Jäkel U, Klaudius A,
Ramge P, Habermehl S, Kohlmaier GH (1994) The Frankfurt Biosphere Model: A global process-oriented model of
seasonal and long-term CO2 exchange between terrestrial ecosystems and the atmosphere. I. Model description
and illustrative results for cold deciduous and boreal forests. Clim Res 4(2):143-166. <a href="https://doi.org/10.3354/cr004143">doi:10.3354/cr004143</a></cite>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(graphics)

# Loading mandatory data for the Example 'Points'
data(inp_exPoints)

with(inp_exPoints, {
# Generate quasi-daily time series for basic climate variables with default settings,
# at a grid cell near Szeged, Hungary (46.3N, 20.2E) (for the normal period 1981-2010)
year &lt;- trunc(mean(seq(1981, 2010)))
wea01 &lt;- dlyWeaGenPoints(colMeans(temp), colMeans(prec), colMeans(bsdf), year = year)

# Modify the daily weather data generation techniques
# To temperature data, apply the iterative interpolation technique with basic settings
# To precipitation data, change the value of the damping variable, over the whole year
# To sunshine data, assume that its values are constant within each month
wea02 &lt;- dlyWeaGenPoints(colMeans(temp), colMeans(prec), colMeans(bsdf), aprchTEMP = "tsi",
    aprchBSDF = "const", dvPREC = rep(0.6, 12), year = year)

# Check the differences
vars &lt;- c("TEMP", "PREC", "BSDF")
lbls &lt;- list(expression(italic(T[a])~(~degree*C)), expression(italic(P[n])~(mm)),
    expression(italic(S[f])~(unitless)))
ys &lt;- c(20, 2.5, 0.6)
ats &lt;- list(seq(-4, 24, 4), seq(0, 3, 0.5), seq(0., 0.8, 0.2))
cols &lt;- c("black", "green")
opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(3, 1))
for (i in 1 : length(vars)) {
  par(mar = c(2, 5, 1, 1))
  matplot(t(rbind(wea01[[vars[i]]], wea02[[vars[i]]])), type = "l", lwd = 2, col = cols,
      xaxt = "n", xlab = NA, ylab = NA, axes = FALSE)
  axis(side = 1, las = 1, tck = -0.03, labels = NA, at = seq(-60, 720, 30))
  axis(side = 2, las = 1, tck = -0.03, labels = NA, at = ats[[i]])
  axis(side = 2, las = 1, lwd = 0, line = -0.4, cex.axis = 1.6, at = ats[[i]])
  if (i == length(vars)) {
    axis(side = 1, las = 1, lwd = 0, line = -0.4, at = seq(-60, 720, 30), cex.axis = 1.6)
  }
  mtext(side = 2, lbls[[i]], line = 3, cex = 1.1)
  legend(1, ys[i], legend = c("default", "modified"), col = cols, lty = 1 : 2, lwd = 2, xpd = TRUE)
}
par(opar)
})

</code></pre>


</div>