<div class="container">

<table style="width: 100%;"><tr>
<td>to_long</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert data to long or to wide form</h2>

<h3>Description</h3>

<p><code>to_long</code> increases number of rows in the dataset and reduce number of
columns. <code>to_wide</code> makes invert transformation. You can use cols for
selecting variables in the arguments. See examples.
</p>


<h3>Usage</h3>

<pre><code class="language-R">to_long(
  data,
  columns = NULL,
  keep = NULL,
  names_in = "variable",
  values_in = "value",
  drop_na = FALSE,
  names_factor = TRUE,
  value_factor = FALSE,
  ...
)

to_wide(
  data,
  keep = NULL,
  names_in = variable,
  values_in = value,
  fun = identity,
  sep = "_",
  fill = NA,
  missing_comb = c("none", "rows", "columns", "all"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame to convert</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns</code></td>
<td>
<p>unquoted names of variables for stacking. When missing, we
will stack all columns outside <code>keep</code> columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>unquoted names of columns which will be kept as is, e. g. only
recycled or deduplicated. If missing, it is all columns except stacked or
unstacked. If <code>FALSE</code> then nothing will be kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names_in</code></td>
<td>
<p>name of the stacked variable names column. The default name
is 'variable'. It is quoted in the <code>to_long</code> and unquoted in <code>to_wide</code>. If
<code>FALSE</code> in the <code>to_wide</code> than nothing will be widening.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values_in</code></td>
<td>
<p>name(-s) of the stacked data values column(s). The default
name is 'value'. Multiple names can be provided here for the case when
<code>columns</code> is a list, though note well that the names provided in
<code>columns</code> take precedence. It is quoted in the <code>to_long</code> and unqoted in <code>to_wide</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop_na</code></td>
<td>
<p>If TRUE, NA values will be removed from the stacked data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names_factor</code></td>
<td>
<p>If TRUE, the column with names will be converted to
factor, else it will be a character column. TRUE by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value_factor</code></td>
<td>
<p>If TRUE, the value column will be converted to factor,
else the stacked values type is left unchanged. FALSE by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed to <code>data.table::melt</code>/<code>data.table::dcast</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>Should the data be aggregated before casting? By default, it is
<code>identity</code> - no aggregation. To use multiple aggregation functions, pass a
list; see Examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>Character vector of length 1, indicating the separating character
in variable names generated during casting. Default is "_".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>Value with which to fill missing cells. <code>NA</code> by default. If <code>fun</code> is
present, takes the value by applying the function on a 0-length vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_comb</code></td>
<td>
<p>One of "none" (the default), "rows" - include missing
combinations in rows, "columns" - include missing combinations in columns,
and "all" include all missing combinations.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>data.table in the wide or long form.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(iris)

# 'to_long'

long_iris = iris %&gt;%
    to_long(keep = Species)

long_iris

iris_with_stat = long_iris %&gt;%
    take(mean = mean(value),
         sd = sd(value),
         n = .N*1.0,
         by = .(Species, variable)
    ) %&gt;%
    to_long(columns = c(mean, sd, n), names_in = "stat")

# 'to_wide' - table with multiple stats
iris_with_stat %&gt;%
    to_wide()


iris_with_stat %&gt;%
    to_wide(names_in = c(variable, stat))

iris_with_stat %&gt;%
    to_wide(names_in = c(variable, Species))

# 'to_wide' - aggregation function
long_iris %&gt;%
    to_wide(fun = list(Mean = mean, SD = sd, N = length))

# multiple variables
iris %&gt;%
    to_long(list(Sepal = cols("^Sepal"), Petal = cols("^Petal"))) %&gt;%
    let(
        variable = factor(variable, levels = 1:2, labels = c("Length", "Width"))
    ) %&gt;%
    to_wide(values_in = c(Sepal, Petal))

# '%to%' selector - example from tidyr::pivot_longer

data(anscombe)
anscombe %&gt;%
    to_long(
        list(x = x1 %to% x4, y = y1 %to% y4),
        names_in = "set"
    )

######################################
## Examples from data.table melt/dcast
######################################

set.seed(45)
DT = data.table(
    i_1 = c(1:5, NA)*1.0,
    i_2 = c(NA,6,7,8,9,10)*1.0,
    f_1 = factor(sample(c(letters[1:3], NA), 6, TRUE)),
    f_2 = factor(c("z", "a", "x", "c", "x", "x"), ordered=TRUE),
    c_1 = sample(c(letters[1:3], NA), 6, TRUE),
    d_1 = as.Date(c(1:3,NA,4:5), origin="2013-09-01"),
    d_2 = as.Date(6:1, origin="2012-01-01")
)

# id, values as character/integer/numeric vectors

to_long(DT, f_1, keep = 1:2)
to_long(DT, f_1, keep = c(i_1, i_2))
to_long(DT, f_1, keep = i_1 %to% i_2)
to_long(DT, f_1, keep = cols(i_1:i_2), names_factor = FALSE)
to_long(DT, f_1, keep = cols("i_{1:2}"))
to_long(DT, f_1, keep = cols("^i_"))
to_long(DT, f_1, keep = cols("^i_"), names_in = "var", values_in = "val")

col_var = "^i_"
to_long(DT, 3, keep = cols(col_var))

to_long(DT, cols("^f_"), keep = cols("^i_"), value_factor = TRUE)

to_long(mtcars)
to_long(mtcars, keep = am)
to_long(mtcars, columns = c(am, vs, mpg))
to_long(mtcars, columns = c(am, vs, mpg), keep = FALSE)
to_long(DT, keep = f_1, columns = c(i_1, i_2), drop_na = TRUE)
to_long(DT, keep=1:2, columns = list(cols("^f_"), cols("^d_")), value_factor=TRUE)

data("ChickWeight")
names(ChickWeight) = tolower(names(ChickWeight))
DT = to_long(ChickWeight, keep=2:4)

to_wide(DT, keep = time, fun = mean)
to_wide(DT, keep = FALSE, fun = mean)
to_wide(DT, keep = diet, fun = mean)
to_wide(DT, keep = c(diet, chick), names_in = time, missing_comb = "all")
to_wide(DT, keep = c(diet, chick), names_in = time, missing_comb = "all", fill = 0)
to_wide(DT, chick, time, fun = mean)



# using FALSE
DT = data.table(v1 = rep(1:2, each = 6),
                v2 = rep(rep(1:3, 2), each = 2),
                v3 = rep(1:2, 6),
                v4 = rnorm(6))

## for each combination of (v1, v2), add up all values of v4
to_wide(DT,
        cols("^v(1|2)"),
        names_in = FALSE,
        values_in = v4,
        fun = sum
)

# multiple values_in and multiple fun
DT = data.table(x=sample(5,20,TRUE),
                y=sample(2,20,TRUE),
                z=sample(letters[1:2], 20,TRUE),
                d1 = runif(20),
                d2=1L)

# multiple values_in
to_wide(DT,
        keep = c(x, y),
        names_in = z,
        values_in = c(d1, d2),
        fun = sum,
        fill = 0)

# multiple funs
to_wide(DT,
        keep = c(x, y),
        names_in = z,
        values_in = d1,
        fun = list(sum = sum, mean = mean),
        fill = NULL)

# multiple fun and values_in (all combinations)
to_wide(DT,
        keep = c(x, y),
        names_in = z,
        values_in = c(d1, d2),
        fun = list(sum = sum, mean = mean)
)

# multiple fun and values_in (one-to-one)
to_wide(DT,
        keep = c(x, y),
        names_in = z,
        values_in = list(d1, d2),
        fun = list(sum = sum, mean = mean)
)
</code></pre>


</div>