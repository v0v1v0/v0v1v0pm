<div class="container">

<table style="width: 100%;"><tr>
<td>dcast</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert data between wide and long forms.</h2>

<h3>Description</h3>

<p>The <code>dcast</code> formula takes the form <code>LHS ~ RHS</code>, ex: <code>var1 + var2 ~ var3</code>. The
order of entries in the formula is essential. There are two special
variables: <code>.</code> and <code>...</code>. <code>.</code> represents no variable; <code>...</code> represents all
variables not otherwise mentioned in formula. LHS variable values will be in
rows. RHS variables values will become column names.
<code>fun.aggregate(value.var)</code> will be cell values. For details see
dcast and melt.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dcast(
  data,
  formula,
  fun.aggregate = NULL,
  sep = "_",
  ...,
  margins = NULL,
  subset = NULL,
  fill = NULL,
  drop = TRUE,
  value.var = guess(data),
  verbose = getOption("datatable.verbose")
)

melt(
  data,
  id.vars,
  measure.vars,
  variable.name = "variable",
  value.name = "value",
  ...,
  na.rm = FALSE,
  variable.factor = TRUE,
  value.factor = FALSE,
  verbose = getOption("datatable.verbose")
)

guess(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.table/data.frame. <code>data.frame</code> will be automatically
converted to data.table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula of the form LHS ~ RHS to cast. For details see dcast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.aggregate</code></td>
<td>
<p>Should the data be aggregated before casting? If the
formula doesn't identify a single observation for each cell, then
aggregation defaults to length with a message.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>Character vector of length 1, indicating the separating character
in variable names generated during casting. Default is _ for backwards
compatibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any other arguments that may be passed to the aggregating function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margins</code></td>
<td>
<p>For details see dcast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>Specified if casting should be done on a subset of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>Value with which to fill missing cells. If fun.aggregate is
present, takes the value by applying the function on a 0-length vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>FALSE will cast by including all missing combinations. c(FALSE,
TRUE) will only include all missing combinations of formula LHS. And
c(TRUE, FALSE) will only include all missing combinations of formula RHS.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value.var</code></td>
<td>
<p>Name of the column whose values will be filled to cast.
Function 'guess()' tries to, well, guess this column automatically, if none
is provided. It is possible to cast multiple 'value.varâ€œ columns
simultaneously. For details see dcast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>For details see dcast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id.vars</code></td>
<td>
<p>vector of id variables. Can be integer (corresponding id
column numbers) or character (id column names) vector. If missing, all
non-measure columns will be assigned to it. If integer, must be positive;
see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measure.vars</code></td>
<td>
<p>Measure variables for melting. Can be missing, vector,
list, or pattern-based. For details see dcast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variable.name</code></td>
<td>
<p>name for the measured variable names column. The default name is 'variable'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value.name</code></td>
<td>
<p>name for the molten data values column(s). The default name
is 'value'. Multiple names can be provided here for the case when
measure.vars is a list, though note well that the names provided in
measure.vars take precedence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>If TRUE, NA values will be removed from the molten data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variable.factor</code></td>
<td>
<p>If TRUE, the variable column will be converted to
factor, else it will be a character column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value.factor</code></td>
<td>
<p>If TRUE, the value column will be converted to factor,
else the molten value type is left unchanged.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>data.table
</p>


<h3>Author(s)</h3>

<p>Matt Dowle <a href="mailto:mattjdowle@gmail.com">mattjdowle@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># examples from 'tidyr' package
stocks = data.frame(
    time = as.Date('2009-01-01') + 0:9,
    X = rnorm(10, 0, 1),
    Y = rnorm(10, 0, 2),
    Z = rnorm(10, 0, 4)
)
stocksm = stocks %&gt;%
    melt(id.vars = "time", variable.name = "stock", value.name = "price")
stocksm %&gt;% dcast(time ~ stock)
stocksm %&gt;% dcast(stock ~ time)

# dcast and melt are complements
df = data.frame(x = c("a", "b"), y = c(3, 4), z = c(5, 6))
df %&gt;%
    dcast(z ~ x, value.var = "y") %&gt;%
    melt(id.vars = "z", variable.name = "x", value.name = "y", na.rm = TRUE)
</code></pre>


</div>