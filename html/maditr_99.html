<div class="container">

<table style="width: 100%;"><tr>
<td>let_if</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Modify, aggregate, select or filter data.frame/data.table</h2>

<h3>Description</h3>


<ul>
<li> <p><code>let</code> adds new variables or modify existing variables. 'let_if' make
the same thing on the subset of rows.
</p>
</li>
<li> <p><code>take/take_if</code> aggregate data or aggregate subset of the data.
</p>
</li>
<li> <p><code>let_all</code> applies expressions to all variables in the dataset. It is also
possible to modify the subset of the variables.
</p>
</li>
<li> <p><code>take_all</code> aggregates all variables in the dataset. It is also possible
to aggregate the subset of the variables.
</p>
</li>
</ul>
<div class="sourceCode"></div>
<p>All functions return <code>data.table</code>. Expression in the 'take_all' and
'let_all' can use predefined variables: '.x' is a value of current variable ,
'.name' is a name of the variable and '.index' is sequential number of the
variable. '.value' is is an alias to '.x'.
</p>

<ul>
<li>
<p> Add new variables: <code>let(mtcars, new_var = 42, new_var2 = new_var*hp)</code>
</p>
</li>
<li>
<p> Select variables: <code>take(mtcars, am, vs, mpg)</code>
</p>
</li>
<li>
<p> Aggregate data: <code>take(mtcars, mean_mpg = mean(mpg), by = am)</code>
</p>
</li>
<li>
<p> Aggregate all non-grouping columns: <code>take_all(mtcars, mean = mean(.x), sd = sd(.x), n = .N, by = am)</code>
</p>
</li>
<li>
<p> Aggregate all numeric columns: <code>take_all(iris, if(is.numeric(.x)) mean(.x))</code>
</p>
</li>
<li>
<p> To modify all non-grouping variables:
</p>
</li>
</ul>
<div class="sourceCode"><pre>      iris %&gt;%
         let_all(
             scaled = (.x - mean(.x))/sd(.x),
             by = Species) %&gt;%
          head()
</pre></div>

<ul><li>
<p> Aggregate specific columns: <code>take_all(iris, if(startsWith(.name, "Sepal")) mean(.x))</code>
</p>
</li></ul>
<div class="sourceCode"></div>
<p>You can use 'columns' inside expression in the 'take'/'let'. 'columns' will
be replaced with data.table with selected columns. In 'let' in the
expressions with ':=', 'cols' or '%to%' can be placed in the left part of the
expression. It is usefull for multiple assignment.
There are four ways of column selection:
</p>

<ol>
<li>
<p> Simply by column names
</p>
</li>
<li>
<p> By variable ranges, e. g. vs:carb. Alternatively, you can use '%to%'
instead of colon: 'vs %to% carb'.
</p>
</li>
<li>
<p> With regular expressions. Characters which start with '^' or end with '$'
considered as Perl-style regular expression patterns. For example, '^Petal'
returns all variables started with 'Petal'. 'Width$' returns all variables
which end with 'Width'. Pattern '^.' matches all variables and pattern
'^.*my_str' is equivalent to contains "my_str"'.
</p>
</li>
<li>
<p> By character variables with interpolated parts. Expression in the curly
brackets inside characters will be evaluated in the parent frame with
text_expand. For example, <code style="white-space: pre;">⁠a{1:3}⁠</code> will be transformed to the names 'a1',
'a2', 'a3'. 'cols' is just a shortcut for 'columns'. See examples.
</p>
</li>
</ol>
<h3>Usage</h3>

<pre><code class="language-R">let_if(data, i, ..., by, keyby)

take_if(data, i, ..., by, keyby, .SDcols, autoname = TRUE, fun = NULL)

take(data, ..., by, keyby, .SDcols, autoname = TRUE, fun = NULL)

let(data, ..., by, keyby)

## S3 method for class 'data.frame'
let(data, ..., by, keyby, i)

## S3 method for class 'etable'
let(data, ..., by, keyby, i)

sort_by(data, ..., na.last = FALSE)

let_all(data, ..., by, keyby, .SDcols, suffix = TRUE, sep = "_", i)

take_all(data, ..., by, keyby, .SDcols, suffix = TRUE, sep = "_", i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data.table/data.frame data.frame will be automatically converted
to data.table. <code>let</code> modify data.table object in-place.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>integer/logical vector. Supposed to use to subset/conditional
modifications of <code>data</code>. For details see data.table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>List of variables or name-value pairs of summary/modifications
functions. The name will be the name of the variable in the result. In the
<code>let</code> and <code>take</code> functions we can use <code>a = b</code> or <code>a := b</code> notation. Advantages of <code style="white-space: pre;">⁠:=⁠</code> is parametric assignment, e. g.
<code>(a) := 2</code> create variable with name which are stored in <code>a</code>. In
<code>let</code> <code style="white-space: pre;">⁠:=⁠</code> can be used for multiassignment (<code>c("a", "b")  := list(1,2)</code>). Expression in the 'take_all' and 'let_all' can use predefined
variables: '.x' is a value of current variable, '.name' is a name of
the variable and '.index' is sequential number of the variable. '.value' is
is an alias to '.x'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>unquoted name of grouping variable of list of unquoted names of
grouping variables. For details see data.table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keyby</code></td>
<td>
<p>Same as <code>by</code>, but with an additional <code>setkey()</code> run on the by
columns of the result, for convenience. It is common practice to use
'keyby=' routinely when you wish the result to be sorted. For details see
data.table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.SDcols</code></td>
<td>
<p>Specifies the columns of x to be included in the special
symbol .SD which stands for Subset of data.table. May be character column
names or numeric positions. For details see data.table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autoname</code></td>
<td>
<p>logical. TRUE by default. Should we create names for  unnamed expressions in <code>take</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>Function which will be applied to all variables in <code>take</code>. If
there are no variables in <code>take</code> then it will be applied to all
non-grouping variables in the <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.last</code></td>
<td>
<p>logical. FALSE by default. If TRUE, missing values in the data
are put last; if FALSE, they are put first.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>logical TRUE by default. For 'let_all'/'take_all'. If TRUE than
we append summary name to the end of the variable name. If FALSE summary
name will be added at the begining of the variable name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>character. "_" by default. Separator between the old variables
name and prefix or suffix for 'let_all' and 'take_all'.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>data.table. <code>let</code> returns its result invisibly.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># examples form 'dplyr' package
data(mtcars)

# Newly created variables are available immediately
mtcars %&gt;%
    let(
        cyl2 = cyl * 2,
        cyl4 = cyl2 * 2
    ) %&gt;% head()

# You can also use let() to remove variables and
# modify existing variables
mtcars %&gt;%
    let(
        mpg = NULL,
        disp = disp * 0.0163871 # convert to litres
    ) %&gt;% head()


# window functions are useful for grouped computations
mtcars %&gt;%
    let(rank = rank(-mpg, ties.method = "min"),
        by = cyl) %&gt;%
    head()

# You can drop variables by setting them to NULL
mtcars %&gt;% let(cyl = NULL) %&gt;% head()

# keeps all existing variables
mtcars %&gt;%
    let(displ_l = disp / 61.0237) %&gt;%
    head()

# keeps only the variables you create
mtcars %&gt;%
    take(displ_l = disp / 61.0237)


# can refer to both contextual variables and variable names:
var = 100
mtcars %&gt;%
    let(cyl = cyl * var) %&gt;%
    head()


# A 'take' with summary functions applied without 'by' argument returns an aggregated data
mtcars %&gt;%
    take(mean = mean(disp), n = .N)

# Usually, you'll want to group first
mtcars %&gt;%
    take(mean = mean(disp), n = .N, by = cyl)

# You can group by expressions:
mtcars %&gt;%
    take_all(mean, by = list(vsam = vs + am))

# modify all non-grouping variables in-place
mtcars %&gt;%
    let_all((.x - mean(.x))/sd(.x), by = am) %&gt;%
    head()

# modify all non-grouping variables to new variables
mtcars %&gt;%
    let_all(scaled = (.x - mean(.x))/sd(.x), by = am) %&gt;%
    head()

# conditionally modify all variables
iris %&gt;%
    let_all(mean = if(is.numeric(.x)) mean(.x)) %&gt;%
    head()

# modify all variables conditionally on name
iris %&gt;%
    let_all(
        mean = if(startsWith(.name, "Sepal")) mean(.x),
        median = if(startsWith(.name, "Petal")) median(.x),
        by = Species
    ) %&gt;%
    head()

# aggregation with 'take_all'
mtcars %&gt;%
    take_all(mean = mean(.x), sd = sd(.x), n = .N, by = am)

# conditionally aggregate all variables
iris %&gt;%
    take_all(mean = if(is.numeric(.x)) mean(.x))

# aggregate all variables conditionally on name
iris %&gt;%
    take_all(
        mean = if(startsWith(.name, "Sepal")) mean(.x),
        median = if(startsWith(.name, "Petal")) median(.x),
        by = Species
    )

# parametric evaluation:
var = quote(mean(cyl))
mtcars %&gt;%
    let(mean_cyl = eval(var)) %&gt;%
    head()
take(mtcars, eval(var))

# all together
new_var = "mean_cyl"
mtcars %&gt;%
    let((new_var) := eval(var)) %&gt;%
    head()
take(mtcars, (new_var) := eval(var))

########################################

# variable selection

# range selection
iris %&gt;%
    let(
        avg = rowMeans(Sepal.Length %to% Petal.Width)
    ) %&gt;%
    head()

# multiassignment
iris %&gt;%
    let(
        # starts with Sepal or Petal
        multipled1 %to% multipled4 := cols("^(Sepal|Petal)")*2
    ) %&gt;%
    head()


mtcars %&gt;%
    let(
        # text expansion
        cols("scaled_{names(mtcars)}") := lapply(cols("{names(mtcars)}"), scale)
    ) %&gt;%
    head()

# range selection in 'by'
# range selection  + additional column
mtcars %&gt;%
    take(
        res = sum(cols(mpg, disp %to% drat)),
        by = vs %to% gear
    )

########################################

# examples from data.table
dat = data.table(
    x=rep(c("b","a","c"), each=3),
    y=c(1,3,6),
    v=1:9
)

# basic row subset operations
take_if(dat, 2)                         # 2nd row
take_if(dat, 3:2)                       # 3rd and 2nd row
take_if(dat, order(x))                  # no need for order(dat$x)
take_if(dat, y&gt;2)                       # all rows where dat$y &gt; 2
take_if(dat, y&gt;2 &amp; v&gt;5)                 # compound logical expressions
take_if(dat, !2:4)                      # all rows other than 2:4
take_if(dat, -(2:4))                    # same

# select|compute columns
take(dat, v)                  # v column (as data.table)
take(dat, sum(v))             # return data.table with sum of v (column autonamed 'sum(v)')
take(dat, sv = sum(v))        # same, but column named "sv"
take(dat, v, v*2)             # return two column data.table, v and v*2

# subset rows and select|compute
take_if(dat, 2:3, sum(v))      # sum(v) over rows 2 and 3
take_if(dat, 2:3, sv = sum(v)) # same, but return data.table with column sv

# grouping operations
take(dat, sum(v), by = x)             # ad hoc by, order of groups preserved in result
take(dat, sum(v), keyby = x)          # same, but order the result on by cols


# all together now
take_if(dat, x!="a", sum(v), by=x)                       # get sum(v) by "x" for each x != "a"

# more on special symbols, see also ?"data.table::special-symbols"
take_if(dat, .N)                           # last row
take(dat, .N)                              # total number of rows in DT
take(dat, .N, by=x)                        # number of rows in each group

take(dat, .I[1], by=x)                     # row number in DT corresponding to each group


# add/update/delete by reference
# [] at the end of expression is for autoprinting
let(dat, grp = .GRP, by=x)[]          # add a group counter column
let(dat, z = 42L)[]                   # add new column by reference
let(dat, z = NULL)[]                  # remove column by reference
let_if(dat, x=="a", v = 42L)[]        # subassign to existing v column by reference
let_if(dat, x=="b", v2 = 84L)[]       # subassign to new column by reference (NA padded)

let(dat, m = mean(v), by=x)[]         # add new column by reference by group

# advanced usage
dat = data.table(x=rep(c("b","a","c"), each=3),
                 v=c(1,1,1,2,2,1,1,2,2),
                 y=c(1,3,6),
                 a=1:9,
                 b=9:1)

take(dat, sum(v), by=list(y%%2))              # expressions in by
take(dat, sum(v), by=list(bool = y%%2))       # same, using a named list to change by column name
take_all(dat, sum, by=x)                      # sum of all (other) columns for each group
take(dat,
     MySum=sum(v),
     MyMin=min(v),
     MyMax=max(v),
     by = list(x, y%%2)               # by 2 expressions
)

take(dat, seq = min(a):max(b), by=x)  # j is not limited to just aggregations
dat %&gt;%
    take(V1 = sum(v), by=x) %&gt;%
    take_if(V1&lt;20)                    # compound query

dat %&gt;%
    take(V1 = sum(v), by=x) %&gt;%
    sort_by(-V1) %&gt;%                  # ordering results
    head()


</code></pre>


</div>