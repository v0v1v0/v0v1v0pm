<div class="container">

<table style="width: 100%;"><tr>
<td>latin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Random latin squares</h2>

<h3>Description</h3>

<p>Various functionality for generating random latin squares
</p>


<h3>Usage</h3>

<pre><code class="language-R">incidence(a)
is.incidence(a, include.improper)
is.incidence.improper(a)
unincidence(a)
inc_to_inc(a)
another_latin(a)
another_incidence(i)
rlatin(n,size=NULL,start=NULL,burnin=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>A latin square</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>An incidence array</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n,include.improper,size,start,burnin</code></td>
<td>
<p>Various control arguments;
see details section</p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li>
<p> Function <code>incidence()</code> takes an integer array
(specifically, a latin square) and returns the incidence array as
per Jacobson and Matthew 1996
</p>
</li>
<li>
<p> Function <code>is.incidence()</code> tests for an array being an
incidence array; if argument <code>include.improper</code> is <code>TRUE</code>,
admit an improper array
</p>
</li>
<li>
<p> Function <code>is.incidence.improper()</code> tests for an array
being an improper array
</p>
</li>
<li>
<p> Function <code>unincidence()</code> converts an incidence array to a
latin square
</p>
</li>
<li>
<p> Function <code>another_latin()</code> takes a latin square and
returns a different latin square
</p>
</li>
<li>
<p> Function <code>another_incidence()</code> takes an incidence array
and returns a different incidence array
</p>
</li>
<li>
<p> Function <code>rlatin()</code> generates a (Markov) sequence of
random latin squres, arranged in a 3D array.  Argument <code>n</code>
specifies how many to generate; argument <code>size</code> gives the size
of latin squares generated; argument <code>start</code> gives the start
latin square (it must be latin and is checked with
<code>is.latin()</code>); argument <code>burnin</code> gives the burn-in value
(number of Markov steps to discard).
</p>
<p>Default value of <code>NULL</code> for argument <code>size</code> means to take
the size of argument <code>start</code>; default value of <code>NULL</code> for
argument <code>start</code> means to use <code>circulant(size)</code>
</p>
<p>As a special case, if argument <code>size</code> and <code>start</code> both
take the default value of <code>NULL</code>, then argument <code>n</code> is
interpreted as the size of a single random latin square to be
returned; the other arguments take their default values.  This
ensures that “<code>rlatin(n)</code>” returns a single random
<code class="reqn">n\times n</code> latin square.
</p>
</li>
</ul>
<p>From Jacobson and Matthew 1996, an <code class="reqn">n\times n</code> latin square
LS is equivalent to an <code class="reqn">n\times n\times n</code> array A with
entries 0 or 1; the dimensions of A are identified with the rows,
columns and symbols of LS; a 1 appears in cell <code class="reqn">(r,c,s)</code> of A iffi
the symbol <code class="reqn">s</code> appears in row <code class="reqn">r</code>, column <code class="reqn">s</code> of LS.
Jacobson and Matthew call this an <dfn>incidence cube</dfn>.
</p>
<p>The notation is readily generalized to latin hypercubes and
<code>incidence()</code> is dimensionally vectorized.
</p>
<p>An <dfn>improper</dfn> incidence cube is an incidence cube that includes a
single <code class="reqn">-1</code> entry; all other entries must be 0 or 1; and all line
sums must equal 1.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. T. Jacobson and P. Matthews 1996. “Generating
uniformly distributed random latin squares”.  <em>Journal of
Combinatorial Designs</em>, volume 4, No. 6, pp405–437
</p>


<h3>See Also</h3>

<p><code>is.magic</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
rlatin(5)
rlatin(n=2, size=4, burnin=10)

# An example that allows one to optimize an objective function
# [here f()] over latin squares:
gr &lt;- function(x){ another_latin(matrix(x,7,7)) }
set.seed(0)
index &lt;- sample(49,20)
f &lt;- function(x){ sum(x[index])}
jj &lt;- optim(par=as.vector(latin(7)), fn=f, gr=gr, method="SANN", control=list(maxit=10))
best_latin &lt;- matrix(jj$par,7,7)
print(best_latin)
print(f(best_latin))

#compare starting value:
f(circulant(7))


</code></pre>


</div>