<div class="container">

<table style="width: 100%;"><tr>
<td>is.magichypercube</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>magic hypercubes</h2>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if a hypercube is semimagic, magic, perfect
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.semimagichypercube(a, give.answers=FALSE, func=sum, boolean=FALSE, ...)
is.diagonally.correct(a, give.answers = FALSE, func=sum, boolean=FALSE, ...) 
is.magichypercube(a, give.answers = FALSE, func=sum, boolean=FALSE, ...) 
is.perfect(a, give.answers = FALSE, func=sum, boolean=FALSE)
is.latinhypercube(a, give.answers=FALSE)
is.alicehypercube(a,ndim,give.answers=FALSE, func=sum, boolean=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>The hypercube (array) to be tested</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>give.answers</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to also return
the sums</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p>Function to be applied across each dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndim</code></td>
<td>
<p>In <code>is.alicehypercube()</code>, dimensionality of
subhypercube to take sums over.  See the details section</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boolean</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning that the hypercube is
deemed magic, semimagic, etc, if all applications of <code>func</code>
evaluate to <code>TRUE</code>.  If <code>boolean</code> is <code>FALSE</code>, the
hypercube is magic etc if all applications of <code>func</code> are
identical</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>func()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>(Although apparently non-standard, here a hypercube is defined to have
dimension <code class="reqn">d</code> and order <code class="reqn">n</code>—and thus has <code class="reqn">n^d</code>
elements).
</p>

<ul>
<li>
<p> A <dfn>semimagic hypercube</dfn> has all “rook's move” sums
equal to the magic constant (that is, each <code class="reqn">\sum
    a[i_1,i_2,\ldots,i_{r-1},,i_{r+1}, \ldots,i_d]</code> with <code class="reqn">1\leq r\leq d</code> is equal to the magic constant for all values of the
<code class="reqn">i</code>'s).  In <code>is.semimagichypercube()</code>, if
<code>give.answers</code> is <code>TRUE</code>, the sums returned are in the
form of an array of dimension <code>c(rep(n,d-1),d)</code>.  The first
<code>d-1</code> dimensions are the coordinates of the projection of the
summed elements onto the surface hypercube.  The last dimension
indicates the dimension along which the sum was taken over.
</p>
<p>Optional argument <code>func</code>, defaulting to <code>sum()</code>, indicates
the function to be taken over each of the <code>d</code> dimensions.
Currently requires <code>func</code> to return a scalar.
</p>
</li>
<li>
<p> A <dfn>Latin hypercube</dfn> is one in which each line of elements
whose coordinates differ in only one dimension comprises the numbers
<code class="reqn">1</code> to <code class="reqn">n</code> (or <code class="reqn">0</code> to <code class="reqn">n-1</code>), not necessarily in
that order.  Each integer thus appears <code class="reqn">n^{d-1}</code> times.
</p>
</li>
<li>
<p> A <dfn>magic hypercube</dfn> is a semimagic hypercube with the
additional requirement that all <code class="reqn">2^{d-1}</code> long (ie
extreme point-to-extreme point) diagonals sum correctly.  Correct
diagonal summation is tested by <code>is.diagonally.correct()</code>; by
specifying a function other than <code>sum()</code>, criteria other than
the diagonals returning the correct sum may be tested.
</p>
</li>
<li>
<p> An <dfn>Alice hypercube</dfn> is a different generalization of a
semimagic square to higher dimensions.  It is named for A. M. Hankin
(“Alice”), who originally suggested it.
</p>
<p>A semimagic hypercube has all one-dimensional subhypercubes (ie
lines) summing correctly.  An Alice hypercube is one in which all
<code>ndim</code>-dimensional subhypercubes have the same sum, where
<code>ndim</code> is a fixed integer argument.  Thus, if <code>a</code> is a
hypercube of size <code class="reqn">n^d</code>, <code>is.alicehypercube(a,ndim)</code>
returns <code>TRUE</code> if all <code>n^{d-ndim}</code> subhypercubes have the
same sum.
</p>
<p>For example, if <code>a</code> is four-dimensional with dimension
<code class="reqn">5\times 5\times 5\times 5</code> then
<code>is.alicehypercube(a,1)</code> is <code>TRUE</code> if and only if <code>a</code>
is a semimagic hypercube: all <code class="reqn">{4\choose 1}5^3=500</code>
one-dimensional subhypercubes have the same sum.  Then
<code>is.alicehypercube(a,2)</code> is <code>TRUE</code> if all 2-dimensional
subhypercubes (ie all <code class="reqn">{4\choose 2}\times 5^2=150</code> of
the <code class="reqn">5\times 5</code> squares, for example <code>a[,2,4,]</code> and
<code>a[1,1,,]</code>) have the same sum.  Then
<code>is.alicehypercube(a,3)</code> means that all 3d subhypercubes (ie
all <code class="reqn">{4\choose 3}\times 5^1=20</code> of the <code class="reqn">5\times
    5\times 5</code> cubes, for example <code>a[,,1,]</code> and
<code>a[4,,,]</code>) have the same sum.  For any hypercube <code>a</code>,
<code>is.alicehypercube(a,dim(a))</code> returns <code>TRUE</code>.
</p>
<p>A semimagic hypercube is an Alice hypercube for any value of
<code>ndim</code>.
</p>
</li>
<li>
<p> A <dfn>perfect magic hypercube</dfn> (use <code>is.perfect()</code>) is
a magic hypercube with all nonbroken diagonals summing correctly.
This is a seriously restrictive requirement for high dimensional
hypercubes.  As yet, this function does not take a
<code>give.answers</code> argument.
</p>
</li>
<li>
<p> A <dfn>pandiagonal magic hypercube</dfn>, also <dfn>Nasik
hypercube</dfn> (or sometimes just a <dfn>perfect hypercube</dfn>) is a
semimagic hypercube with all diagonals, including broken diagonals,
summing correctly.  This is not implemented.  </p>
</li>
</ul>
<p>The terminology in this area is pretty confusing.  
</p>
<p>In <code>is.magichypercube()</code>, if argument <code>give.answers=TRUE</code>
then a list is returned.  The first element of this list is Boolean
with <code>TRUE</code> if the array is a magic hypercube.  The second
element and third elements are answers
from<code>is.semimagichypercube()</code> and <code>is.diagonally.correct()</code>
respectively.
</p>
<p>In <code>is.diagonally.correct()</code>, if argument
<code>give.answers=TRUE</code>, the function also returns an array of
dimension <code>c(q,rep(2,d))</code> (that is, <code class="reqn">q\times 2^d</code>
elements), where <code class="reqn">q</code> is the length of <code>func()</code> applied to a
long diagonal of <code>a</code> (if <code class="reqn">q=1</code>, the first dimension is
dropped).  If <code class="reqn">q=1</code>, then in dimension <code>d</code> having index 1
means <code>func()</code> is applied to elements of <code>a</code> with the
<code class="reqn">d^{\rm th}</code> dimension running over <code>1:n</code>; index 2
means to run over <code>n:1</code>.  If <code class="reqn">q&gt;1</code>, the index of the first
dimension gives the index of <code>func()</code>, and subsequent dimensions
have indices of 1 or 2 as above and are interpreted in the same way.
</p>
<p>An example of a function for which these two are not identical is
given below.
</p>
<p>If <code>func=f</code> where <code>f</code> is a function returning a vector of
length <code>i</code>, <code>is.diagonally.correct()</code> returns an array
<code>out</code> of dimension <code>c(i,rep(2,d))</code>, with
<code>out[,i_1,i_2,...,i_d]</code> being <code>f(x)</code> where <code>x</code> is the
appropriate long diagonal.  Thus the <code class="reqn">2^d</code> equalities
<code>out[,i_1,i_2,...,i_d]==out[,3-i_1,3-i_2,...,3-i_d]</code> hold if and
only if <code>identical(f(x),f(rev(x)))</code> is <code>TRUE</code> for each long
diagonal (a condition met, for example, by <code>sum()</code> but not by the
identity function or <code>function(x){x[1]}</code>).
</p>


<h3>Note</h3>

<p>On this page, “subhypercube” is restricted to
rectangularly-oriented subarrays; see the note at <code>subhypercubes</code>.
</p>
<p>Not all subhypercubes of a magic hypercube are necessarily magic! (for
example, consider a 5-dimensional magic hypercube <code>a</code>.  The square
<code>b</code> defined by <code>a[1,1,1,,]</code> might not be magic: the diagonals
of <code>b</code> are not covered by the definition of a magic hypercube).
Some subhypercubes of a magic hypercube are not even semimagic: see
below for an example.
</p>
<p>Even in three dimensions, being perfect is pretty bad.  Consider a
<code class="reqn">5\times5\times 5</code> (ie three dimensional), cube.  Say
<code>a=magiccube.2np1(2)</code>.  Then the square defined by
<code>sapply(1:n,function(i){a[,i,6-i]}, simplify=TRUE)</code>, which is a
subhypercube of <code>a</code>, is not even semimagic: the rowsums are
incorrect (the colsums must sum correctly because <code>a</code> is magic).
Note that the diagonals of this square are two of the “extreme
point-to-point” diagonals of <code>a</code>.
</p>
<p>A <dfn>pandiagonal magic hypercube</dfn> (or sometimes just a <dfn>perfect
hypercube</dfn>) is semimagic and in addition the sums of all diagonals,
including broken diagonals, are correct.  This is one seriously bad-ass
requirement.  I reckon that is a total of <code class="reqn">\frac{1}{2}\left(
3^d-1\right)\cdot n^{d-1}</code> correct summations.  This
is not coded up yet; I can't see how to do it in anything like a
vectorized manner.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>R. K. S. Hankin 2005.  “Recreational mathematics with R:
introducing the <span class="pkg">magic</span> package”.  R news, 5(1)
</p>
</li>
<li>
<p>Richards 1980. “Generalized magic cubes”.
<em>Mathematics Magazine</em>, volume 53, number 2, (March).
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>is.magic</code>, <code>allsubhypercubes</code>, <code>hendricks</code></p>


<h3>Examples</h3>

<pre><code class="language-R">library(abind)
is.semimagichypercube(magiccube.2np1(1))
is.semimagichypercube(magichypercube.4n(1,d=4))

is.perfect(magichypercube.4n(1,d=4))

# Now try an array with minmax(dim(a))==FALSE:
a &lt;- abind(magiccube.2np1(1),magiccube.2np1(1),along=2)
is.semimagichypercube(a,g=TRUE)$rook.sums

# is.semimagichypercube() takes further arguments:
mymax &lt;- function(x,UP){max(c(x,UP))}
not_mag  &lt;- array(1:81,rep(3,4))
is.semimagichypercube(not_mag,func=mymax,UP=80)  # FALSE
is.semimagichypercube(not_mag,func=mymax,UP=81)  # TRUE


a2 &lt;- magichypercube.4n(m=1,d=4)
is.diagonally.correct(a2)
is.diagonally.correct(a2,g=TRUE)$diag.sums

## To extract corner elements (note func(1:n) != func(n:1)):
is.diagonally.correct(a2,func=function(x){x[1]},g=TRUE)$diag.sums 


#Now for a subhypercube of a magic hypercube that is not semimagic:
is.magic(allsubhypercubes(magiccube.2np1(1))[[10]])

data(hendricks)
is.perfect(hendricks)


#note that Hendricks's magic cube also has many broken diagonals summing
#correctly:

a &lt;- allsubhypercubes(hendricks)
ld &lt;- function(a){length(dim(a))}

jj &lt;- unlist(lapply(a,ld))
f &lt;- function(i){is.perfect(a[[which(jj==2)[i]]])}
all(sapply(1:sum(jj==2),f))

#but this is NOT enough to ensure that it is pandiagonal (but I
#think hendricks is pandiagonal).


is.alicehypercube(magichypercube.4n(1,d=5),4,give.answers=TRUE)

</code></pre>


</div>