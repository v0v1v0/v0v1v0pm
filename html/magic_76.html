<div class="container">

<table style="width: 100%;"><tr>
<td>as.standard</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Standard form for magic squares</h2>

<h3>Description</h3>

<p>Transforms a magic square or magic hypercube into
Frenicle's standard form
</p>


<h3>Usage</h3>

<pre><code class="language-R">as.standard(a, toroidal = FALSE, one_minus=FALSE)
is.standard(a, toroidal = FALSE, one_minus=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Magic square or hypercube (array) to be tested or
transformed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toroidal</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to use
Frenicle's method, and <code>TRUE</code> meaning to use additional
transformations appropriate to toroidal connectivity</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>one_minus</code></td>
<td>
<p>Boolean, with  <code>TRUE</code> meaning to use the
transformation <code class="reqn">x\longrightarrow n^2+1-x</code> if
appropriate, 
and default <code>FALSE</code> meaning not to use this</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a square, <code>as.standard()</code> transforms a magic square into
Frenicle's standard form.  The four numbers at each of
the four corners are determined.  First, the square is rotated so the
smallest of the four is at the upper left.  Then, element <code>[1,2]</code>
is compared with element<code>[2,1]</code> and, if it is larger, the transpose
is taken.
</p>
<p>Thus all eight rotated and transposed versions of a magic square have
the same standard form.
</p>
<p>The square returned by <code>magic()</code> is in standard form.
</p>
<p>For hypercubes, the algorithm is generalized.  First, the hypercube is
reflected so that <code>a[1,1,...,1,1]</code> is the smallest of the <code class="reqn">2^d</code>
corner elements (eg <code>a[1,n,1,...,1,1]</code>).
</p>
<p>Next, <code>aperm()</code> is called so that
</p>
<p><code>a[1,1,...,1,2] &lt; a[1,1,...,2,1] &lt; ... &lt; a[2,1,...,1,1]</code>.
</p>
<p>Note that the inequalities are strict as hypercubes are assumed to be
normal.  As of version 1.3-1, <code>as.standard()</code> will accept arrays of
any dimension (ie arrays <code>a</code> with <code>minmax(dim(a))==FALSE</code> will
be handled sensibly).
</p>
<p>An array with any dimension of extent zero is in standard form by
definition; dimensions of length one are dropped.
</p>
<p>If argument <code>toroidal</code> is <code>TRUE</code>, then the array <code>a</code> is
translated using <code>ashift()</code> so that <code>a[1,1,...,1] == min(a)</code>.
Such translations preserve the properties of semimagicness and
pandiagonalness (but not magicness or associativity).
</p>
<p>It is easier (for me at least) to visualise this by considering
two-dimensional arrays, tiling the plane with copies of <code>a</code>.
</p>
<p>Next, the array is shifted so that <code>a[2,1,1,...,1] &lt;
  a[dim(a)[1],1,1,...,1]</code> and <code>a[1,2,1,..,1] &lt;
  a[1,dim(a)[2],1,...,1]</code> and so on.
</p>
<p>Then <code>aperm()</code> is called as per the non-toroidal case above.
</p>
<p><code>is.standard()</code> returns <code>TRUE</code> if the magic square or
hypercube is in standard form.  <code>is.standard()</code> and
<code>as.standard()</code> check for neither magicness nor normality (use
<code>is.magic</code> and <code>is.normal</code> for this).
</p>


<h3>Note</h3>

<p>There does not appear to be a way to make the third letter of
“Frenicle” have an acute accent, as it should do.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code>magic</code>, <code>eq</code></p>


<h3>Examples</h3>

<pre><code class="language-R">is.standard(magic.2np1(4))
as.standard(magic.4n(3))

as.standard(magichypercube.4n(1,5))

##non-square arrays:
as.standard(magic(7)[1:3,])


## Toroidal transforms preserve pandiagonalness:
is.pandiagonal(as.standard(hudson(11)))


## but not magicness:
is.magic(as.standard(magic(10),TRUE))


</code></pre>


</div>