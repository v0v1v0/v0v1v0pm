<div class="container">

<table style="width: 100%;"><tr>
<td>is.magic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Various tests for the magicness of a square</h2>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if the square is magic, semimagic, panmagic, associative,
normal.  If argument <code>give.answers</code> is <code>TRUE</code>, also returns
additional information about the sums.
</p>


<h3>Usage</h3>

<pre><code class="language-R">is.magic(m, give.answers = FALSE, func=sum, boolean=FALSE) 
is.panmagic(m, give.answers = FALSE, func=sum, boolean=FALSE) 
is.pandiagonal(m, give.answers = FALSE, func=sum, boolean=FALSE) 
is.semimagic(m, give.answers = FALSE, func=sum, boolean=FALSE) 
is.semimagic.default(m)
is.associative(m)
is.normal(m)
is.sparse(m)
is.mostperfect(m,give.answers=FALSE)
is.2x2.correct(m,give.answers=FALSE)
is.bree.correct(m,give.answers=FALSE)
is.latin(m,give.answers=FALSE)
is.antimagic(m, give.answers = FALSE, func=sum) 
is.totally.antimagic(m, give.answers = FALSE, func=sum)
is.heterosquare(m, func=sum) 
is.totally.heterosquare(m, func=sum)
is.sam(m)
is.stam(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The square to be tested</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>give.answers</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning return additional
information about the sums (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p>A function that is evaluated for each row, column, and
unbroken diagonal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boolean</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning that the square is
deemed magic, semimagic, etc, if all applications of <code>func</code>
evaluate to <code>TRUE</code>.  If <code>boolean</code> is <code>FALSE</code>, square
<code>m</code> is magic etc if all applications of <code>func</code> are
identical</p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li>
<p> A <dfn>semimagic square</dfn> is one all of whose row sums equal
all its columnwise sums (ie the magic constant).
</p>
</li>
<li>
<p> A <dfn>magic square</dfn> is a semimagic square with the sum of
both unbroken diagonals equal to the magic constant.
</p>
</li>
<li>
<p> A <dfn>panmagic square</dfn> is a magic square all of whose broken
diagonals sum to the magic constant.  Ollerenshaw calls this a
“pandiagonal” square.
</p>
</li>
<li>
<p> A <dfn>most-perfect</dfn> square has all 2-by-2 arrays anywhere
within the square summing to <code class="reqn">2S</code> where <code class="reqn">S=n^2+1</code>; and all
pairs of integers <code class="reqn">n/2</code> distant along the same major (NW-SE)
diagonal sum to <code class="reqn">S</code> (note that the <code class="reqn">S</code> used here differs
from Ollerenshaw's because her squares are numbered starting at
zero).  The first condition is tested by <code>is.2x2.correct()</code> and
the second by <code>is.bree.correct()</code>.
</p>
<p>All most-perfect squares are panmagic.
</p>
</li>
<li>
<p> A <dfn>normal square</dfn> is one that contains <code class="reqn">n^2</code>
consecutive integers (typically starting at 0 or 1).
</p>
</li>
<li>
<p> A <dfn>sparse</dfn> matrix is one whose nonzero entries are
consecutive integers, starting at 1.
</p>
</li>
<li>
<p> An <dfn>associative square</dfn> (also <dfn>regular square</dfn>) is a magic square in which
<code class="reqn">a_{i,j}+a_{n+1-i,n+1-j}=n^2+1</code>.
Note that an associative semimagic square is magic; see also
<code>is.square.palindromic()</code>.  The definition extends to magic
hypercubes: a hypercube <code>a</code> is associative if <code>a+arev(a)</code>
is constant.
</p>
</li>
<li>
<p> An <dfn>ultramagic square</dfn> is pandiagonal and associative.
</p>
</li>
<li>
<p> A <dfn>latin square</dfn> of size <code class="reqn">n\times n</code> is one in
which each column and each row comprises the integers 1 to n (not
necessarily in that order).  Function <code>is.latin()</code> is a wrapper
for <code>is.latinhypercube()</code> because there is no natural way to
present the extra information given when <code>give.answers</code> is
<code>TRUE</code> in a manner consistent with the other functions
documented here.
</p>
</li>
<li>
<p> An <dfn>antimagic square</dfn> is one whose row sums and column
sums are consecutive integers; a <dfn>totally antimagic square</dfn> is
one whose row sums, column sums, and two unbroken diagonals are
consecutive integers.  Observe that an antimagic square is not
necessarily totally antimagic, and vice-versa.
</p>
</li>
<li>
<p> A <dfn>heterosquare</dfn> has all rowsums and column sums
distinct; a <dfn>totally heterosquare</dfn> [NB nonstandard terminology]
has all rowsums, columnsums, and two long diagonals distinct.
</p>
</li>
<li>
<p> A square is <dfn>sam</dfn> (or <dfn>SAM</dfn>) if it is sparse and
antimagic; it is  <dfn>stam</dfn> (or <dfn>STAM</dfn>) if it is sparse and
totally antimagic.  See documentation at <code>SAM</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Returns <code>TRUE</code> if the square is semimagic, etc. and <code>FALSE</code>
if not.
</p>
<p>If <code>give.answers</code> is taken as an argument and is <code>TRUE</code>,
return a list of at least five elements.  The first element of the
list is the answer: it is <code>TRUE</code> if the square is (semimagic,
magic, panmagic) and <code>FALSE</code> otherwise.  Elements 2-5 give the
result of a call to <code>allsums()</code>, viz: rowwise and columnwise
sums; and broken major (ie NW-SE) and minor (ie NE-SW) diagonal sums.
</p>
<p>Function <code>is.bree.correct()</code> also returns the sums of
elements distant <code class="reqn">n/2</code> along a major diagonal
(<code>diag.sums</code>); and function <code>is.2x2.correct()</code> returns the
sum of each <code class="reqn">2\times 2</code> submatrix (<code>tbt.sums</code>); for
other size windows use <code>subsums()</code> directly.
Function <code>is.mostperfect()</code> returns both of these.
</p>
<p>Function <code>is.semimagic.default()</code> returns <code>TRUE</code> if the
argument is semimagic [with respect to <code>sum()</code>] using a faster
method than <code>is.semimagic()</code>.
</p>


<h3>Note</h3>

<p>Functions that take a <code>func</code> argument apply that function to each
row, column, and diagonal as necessary.  If <code>func</code> takes its
default value of <code>sum()</code>, the sum will be returned; if
<code>prod()</code>, the product will be returned, and so on.  There are
many choices for this argument that produce interesting tests;
consider <code>func=max</code>, for example.  With this, a “magic”
square is one whose row, sum and (unbroken) diagonals have identical
maxima.  Thus <code>diag(5)</code> is magic with respect to <code>max()</code>,
but <code>diag(6)</code> isn't.
</p>
<p>Argument <code>boolean</code> is designed for use with non-default values
for the <code>func</code> argument; for example, a latin square is semimagic
with respect to <code>func=function(x){all(diff(sort(x))==1)}</code>.
</p>
<p>Function <code>is.magic()</code> is vectorized; if a list is supplied, the
defaults are assumed.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://mathworld.wolfram.com/MagicSquare.html">https://mathworld.wolfram.com/MagicSquare.html</a></p>


<h3>See Also</h3>

<p><code>minmax</code>,<code>is.perfect</code>,<code>is.semimagichypercube</code>,<code>sam</code></p>


<h3>Examples</h3>

<pre><code class="language-R">is.magic(magic(4))

is.magic(diag(7),func=max)  # TRUE
is.magic(diag(8),func=max)  # FALSE

stopifnot(is.magic(magic(3:8)))

is.panmagic(panmagic.4())
is.panmagic(panmagic.8())

data(Ollerenshaw)
is.mostperfect(Ollerenshaw)

proper.magic &lt;- function(m){is.magic(m) &amp; is.normal(m)}
proper.magic(magic(20))
</code></pre>


</div>