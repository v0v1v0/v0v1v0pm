<div class="container">

<table style="width: 100%;"><tr>
<td>magic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Creates magic squares</h2>

<h3>Description</h3>

<p>Creates normal magic squares of any order <code class="reqn">&gt;2</code>.  Uses
the appropriate method depending on n modulo 4.
</p>


<h3>Usage</h3>

<pre><code class="language-R">magic(n)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Order of magic square.  If a vector, return a list whose
<code class="reqn">i</code>-th element is a magic square of order <code>n[i]</code></p>
</td>
</tr></table>
<h3>Details</h3>

<p>Calls either <code>magic.2np1()</code>, <code>magic.4n()</code>,
or <code>magic.4np2()</code> depending on the value of <code>n</code>.  Returns a
magic square in standard format (compare the <code>magic.2np1()</code> et seq,
which return the square as generated by the direct algorithm).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>William H. Benson and Oswald Jacoby.  <em>New recreations with
magic squares</em>. Dover 1976.
</p>


<h3>See Also</h3>

<p><code>magic.2np1</code>, <code>magic.prime</code>,
<code>magic.4np2</code>,
<code>magic.4n</code>,<code>lozenge</code>,
<code>as.standard</code>, <code>force.integer</code></p>


<h3>Examples</h3>

<pre><code class="language-R">magic(6)
all(is.magic(magic(3:10)))

## The first eigenvalue of a magic square is equal to the magic constant:
eigen(magic(10),FALSE,TRUE)$values[1] - magic.constant(10)

## The sum of the eigenvalues of a magic square after the first is zero:
sum(eigen(magic(10),FALSE,TRUE)$values[2:10])



</code></pre>


</div>