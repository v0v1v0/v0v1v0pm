<div class="container">

<table style="width: 100%;"><tr>
<td>magbin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
2D Binning Routines
</h2>

<h3>Description</h3>

<p>Allows for 2D binning (counts) and summary statistics on 2D bins (medians etc).
</p>


<h3>Usage</h3>

<pre><code class="language-R">magbin(x, y, z = NULL, xlim = NULL, ylim = NULL, zlim = NULL, Nbin = 50, step = NULL,
  log = '', unlog = log, clustering = 10, dustlim = 0.1, shape = "hex",
  plot = TRUE, colramp = hcl.colors(21), colstretch = "lin", sizestretch = "lin",
  colref = "count", sizeref = "none", funstat = function(x) median(x, na.rm=TRUE),
  direction = 'h', offset = 0, jitterseed = 666, projden = FALSE, projsig = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Numeric vector or matrix/data.frame; x values to 2D bin. If x is a two (or more) column matrix or data.frame and y/z is missing as an argument, then the first column is used for x and the second/third column for y/z.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>Numeric vector; the y coordinates of points in the plot, optional if <span class="option">x</span> is an appropriate structure.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>

<p>Numeric vector; the z coordinates of points in the plot (optional), optional if <span class="option">x</span> is an appropriate structure.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>

<p>Numeric vector; the x limits to use for the data. Default of NULL calculates the range based on the provided <span class="option">x</span> data vector. If length equals 1 then the argument is taken to mean the sigma range to select for plotting and the clipping is done by <code>magclip</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>

<p>Numeric vector; the y limits to use for the data. Default of NULL calculates the range based on the provided <span class="option">y</span> data vector. If length equals 1 then the argument is taken to mean the sigma range to select for plotting and the clipping is done by <code>magclip</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlim</code></td>
<td>

<p>Numeric vector; the z limits to use for the data. Default of NULL calculates the range based on the provided <span class="option">z</span> data vector. If length equals 1 then the argument is taken to mean the sigma range to select for plotting and the clipping is done by <code>magclip</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nbin</code></td>
<td>

<p>Integer vector; The number of bins to (approximately) split the x/y axes into. If length 1 then this value is used by both (default is 50 bin in x/y), if length 2 then Nbin[1] is used for the x-axis and Nbin[2] is used for the y-axis.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>

<p>Numeric vector; grid steps in x and y directions. If NULL then this is c(diff(xlim), diff(ylim))/Nbin. If length 1, then this value is repeated. Overrides <span class="option">Nbin</span> if supplied.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>

<p>Character scalar; log axis arguments to be passed to used. E.g. use 'x', 'y', 'xy' or 'yx' as appropriate. Default ‚Äù assumes no logging of any axes. For convenience you can specify the 'z' axis too, which somewhat replaces the <span class="option">colstretch</span> argument. Note that in all cases the <span class="option">x</span>/<span class="option">y</span>/<span class="option">z</span> data is explictly logged, which means the plotting window does not know it is in logged space (via the par()$xlag and par()$ylog structures). This means is you want to add points etc to the plot you will need to apply log10 yourself, so a point with coordinates [10^2,10^-3] should be plotted at [2,-3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unlog</code></td>
<td>

<p>Character scalar; determines if x/y axis labels should be unlogged (z is ignored here). By default inherits <span class="option">log</span>, since that is usually what you would want.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering</code></td>
<td>

<p>Numeric scalar; excess counts in densist bin relative to Uniform data. This is to optimise the binning, so can probably be ignored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dustlim</code></td>
<td>

<p>Numeric scalar; if between 0 and 1 then the 2D bin count quantile to switch to showing the individual points (which visually look like 'dust'), if larger than 1 then the exact counts threshold. If this is NA or 0 then all cells are shown.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>

<p>Character scalar; type of binning, either hex/hexagon; sq/square; tri/triangle or trihex. 'trihex' is a triangle tessellation that is also arranged to have hexagonal packing (so 6 triangles can form a hexagon).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>

<p>Logical; create a plot? If FALSE then just the binning output list is created.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colramp</code></td>
<td>

<p>Vector; a colour scaling to use. Must be a vector and not a function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colstretch</code></td>
<td>

<p>Character scalar; colour stretch, either linear (lin, default) or logarithmic (log, good for large dynamic ranges).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sizestretch</code></td>
<td>

<p>Character scalar; size stretch, either linear (lin, default) or logarithmic (log, good for large dynamic ranges).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colref</code></td>
<td>

<p>Character scalar; colour reference for call, either it should be based on the counts (count, default) or the z-axis statistic (zstat)?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sizeref</code></td>
<td>

<p>Character scalar; size reference for call, either it should be ignored (none, so all are the same size and closely packed), based on the counts (count) or the z-axis statistic (zstat)?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>funstat</code></td>
<td>

<p>Function; function to use to compute a statistic over the <span class="option">z</span> axis. The default is <code>median</code>, but other good options might be <code>mean</code>, <code>sd</code>, <code>mad</code>. Note, to change default arguments you might need to send through a new function, e.g. <span class="option">funstat</span> = function(x) median(x, na.rm=TRUE) and similar, but if you are happy with the defaults then you can use the simpler <span class="option">funstat</span> = mean etc.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>

<p>Character scalar;  should there be a shape side aligned horizontally ('h', the default) or vertically ('v')? This is only relevant for hexagon and triangle bin shapes, and has the effect of leading the eye differently with some scatter structures.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>

<p>Numeric/character scalar; only relevant for <span class="option">shape</span>='sq' or <span class="option">shape</span>='tri'. Either a numeric value specifying the offset (relative to <span class="option">step</span>) to apply to alternating rows (<span class="option">direction</span>='h') or columns (<span class="option">direction</span>='v'); or 'jitter' which means the rows or columns are randomly jittered (only used for <span class="option">shape</span>='sq' bins. This option is useful for visually breaking up strong patterns in certain types of data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitterseed</code></td>
<td>

<p>Integer scalar; the random seed to use for jittering (means you can recreate your plots exactly if the seed is the same). This argument is only used for <span class="option">shape</span>='sq' bins.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>projden</code></td>
<td>

<p>Logical; do you want projected density PDFs to be displayed above and to the side of the standard <code>plot.magbin</code> plot? If so you also need to pass the same <span class="option">xdata</span> and <span class="option">ydata</span> that you originally sent to <code>magbin</code>, since this is not stored in the object output from <code>magbin</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>projsig</code></td>
<td>

<p>Logical; if <span class="option">projden</span> = TRUE then this will optionally add lines to show the pseudo 1-sigma range (15.9% to 84.1% quantiles).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Dots to be passed to <code>magplot</code>, <code>magmap</code> and <code>magbar</code>. Relevant arguments are matched, so look in those functions for optional arguments to pass.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Mostly run for the side effect of making a nice plot, but the output bin statistics might also be useful.
</p>
<p>Re performance, <code>magbin</code> works pretty well on a modern computer for up to ~1e6 points, taking only a few seconds to run usually. Beyond this you might need to carefully tune the performance with <span class="option">clutering</span> otherwise it might run very slower and/or you run out of memory.
</p>


<h3>Value</h3>

<p>List of class 'magbin' containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>bins </code></td>
<td>
<p>Bin x / y / count / and zstat info</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dust </code></td>
<td>
<p>Dust x / y / z info</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>Links input <span class="option">x</span> and <span class="option">y</span> data to the nearest grid cell by row number of <span class="option">bins</span></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim </code></td>
<td>
<p>x limits</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim </code></td>
<td>
<p>y limits</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step </code></td>
<td>
<p><span class="option">step</span> size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dustlim</code></td>
<td>
<p><span class="option">dustlim</span></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>
<p><span class="option">shape</span></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p><span class="option">direction</span></p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>plot.magbin</code>, <code>maghist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(666)
xydata = cbind(rnorm(1e4), rnorm(1e4))
magbin(xydata, shape='hexagon') #default
magbin(xydata, shape='hexagon', Nbin=25) #A bit coarser
magbin(xydata, shape='square')
magbin(xydata, shape='triangle')
magbin(xydata, shape='trihex')
magbin(xydata, shape='hexagon', direction='v')
magbin(xydata, shape='triangle', direction='v')
magbin(xydata, shape='trihex', direction='v')

magbin(xydata, shape='hexagon', step=c(0.2,0.4)) #different aspect ratio hexagons

magbin(xydata, z=xydata[,1]^2-xydata[,2]^2, colref='zstat', sizeref='count')

magbin(xydata, z=xydata[,1]^2-xydata[,2]^2, colref='zstat', sizeref='count',
funstat=mad)
magbin(xydata, z=xydata[,1]^2-xydata[,2]^2, colref='zstat', sizeref='count',
funstat=function(x){quantile(x,0.9)})

xydata = cbind(10^rnorm(1e4), 10^rnorm(1e4))
magbin(xydata, log='xy')
magbin(xydata, z=xydata[,1]*xydata[,2], colref='zstat', sizeref='count',
log='xyz')
magbin(xydata, log='xy', unlog='xy', xlim=3, ylim=3)
</code></pre>


</div>