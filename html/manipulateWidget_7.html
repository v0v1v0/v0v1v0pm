<div class="container">

<table style="width: 100%;"><tr>
<td>manipulateWidget</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add Controls to Interactive Plots</h2>

<h3>Description</h3>

<p>This function permits to add controls to an interactive plot created with
packages like <code>dygraphs</code>, <code>highcharter</code> or <code>plotly</code> in order
to change the input data or the parameters of the plot.
</p>
<p>Technically, the function starts a shiny gadget. The R session is bloqued
until the user clicks on "cancel" or "done". If he clicks on "done", then the
the function returns the last displayed plot so the user can modify it and/or
save it.
</p>


<h3>Usage</h3>

<pre><code class="language-R">manipulateWidget(
  .expr,
  ...,
  .updateBtn = FALSE,
  .saveBtn = TRUE,
  .exportBtn = TRUE,
  .exportType = c("html2canvas", "webshot"),
  .viewer = c("pane", "window", "browser"),
  .compare = NULL,
  .compareOpts = compareOptions(),
  .translations = mwTranslations(),
  .return = function(widget, envs) {     widget },
  .width = NULL,
  .height = NULL,
  .runApp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.expr</code></td>
<td>
<p>expression to evaluate that returns an interactive plot of class
<code>htmlwidget</code>. This expression is re-evaluated each time a control is
modified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>One or more named control arguments created with functions
<code>mwSlider</code>, <code>mwText</code>, etc. The name of each control
is the name of the variable the controls modifies in the expression. One
can also create a group of inputs by passing a list of such control
arguments. for instance <code>mygroup = list(txt = mwText(""), nb =
mwNumeric(0))</code> creates a group of inputs named mygroup with two inputs
named "txt" and "nb".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.updateBtn</code></td>
<td>
<p>Should an update button be added to the controls ? If
<code>TRUE</code>, then the graphic is updated only when the user clicks on the
update button.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.saveBtn</code></td>
<td>
<p>Should an save button be added to the controls ? For saving output as html. Does not work in RStudio Viewer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.exportBtn</code></td>
<td>
<p>Should an export button be added to the controls ? For saving output as png. Does not work in RStudio Viewer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.exportType</code></td>
<td>
<p><code>.exportBtn</code>, using <code>html2canvas</code> (default) and keeping current zoom, ... or using <code>webshot</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.viewer</code></td>
<td>
<p>Controls where the gadget should be displayed. <code>"pane"</code>
corresponds to the Rstudio viewer, <code>"window"</code> to a dialog window, and
<code>"browser"</code> to an external web browser.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.compare</code></td>
<td>
<p>Sometimes one wants to compare the same chart but with two
different sets of parameters. This is the purpose of this argument. It can
be a character vector of input names or a named list whose names are the
names of the inputs that should vary between the two charts. Each element
of the list must be a vector or a list of length equal to the number of
charts with the initial values of the corresponding parameter for each
chart. It can also be <code>NULL</code>. In this case, the parameter is
initialized with the default value for the two charts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.compareOpts</code></td>
<td>
<p>List of options created <code>compareOptions</code>.
These options indicate the number of charts to create and their disposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.translations</code></td>
<td>
<p>List of translation strings created with function
<code>mwTranslations</code>. Used to translate UI titles and labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.return</code></td>
<td>
<p>A function that can be used to modify the output of
<code>manipulateWidget</code>. It must take two parameters: the first one is the
final widget, the second one is a list of environments containing the input
values of each individual widget. The length of this list is one if .compare
is null, two or more if it has been defined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.width</code></td>
<td>
<p>Width of the UI. Used only on Rmarkdown documents with option
<code>runtime: shiny</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.height</code></td>
<td>
<p>Height of the UI. Used only on Rmarkdown documents with option
<code>runtime: shiny</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.runApp</code></td>
<td>
<p>(advanced usage) If true, a shiny gadget is started. If false,
the function returns a <code>MWController</code> object. This object can be
used to check with command line instructions the behavior of the application.
(See help page of <code>MWController</code>). Notice that this parameter is
always false in a non-interactive session (for instance when running tests of
a package).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The result of the expression evaluated with the last values of the controls.
It should be an object of class <code>htmlWidget</code>.
</p>


<h3>Advanced Usage</h3>

<p>The "normal" use of the function is to provide an expression that always
return an <code>htmlwidget</code>. In such case, every time the user changes the
value of an input, the current widget is destroyed and a new one is created
and rendered.
</p>
<p>Some packages provide functions to update a widget that has already been
rendered. This is the case for instance for package <code>leaflet</code> with the
function <code>leafletProxy</code>. To use such functions,
<code>manipulateWidget</code> evaluates the parameter <code>.expr</code> with four extra
variables:
</p>

<ul>
<li>
<p><code>.initial</code>:
<code>TRUE</code> if the expression is evaluated for the first time and then
the widget has not been rendered yet, <code>FALSE</code> if the widget has
already been rendered.

</p>
</li>
<li>
<p><code>.session</code>:
A shiny session object.

</p>
</li>
<li>
<p><code>.output</code>:
ID of the output in the shiny interface.

</p>
</li>
<li>
<p><code>.id</code>:
Id of the chart. It can be used in comparison mode to make further
customization without the need to create additional input controls.

</p>
</li>
</ul>
<p>You can take a look at the last example to see how to use these two
variables to update a leaflet widget.
</p>


<h3>Modify the returned widget</h3>

<p>In some specific situations, a developer may want to use
<code>manipulateWidget</code> in a function that waits the user to click on the
"Done" button and modifies the widget returned by <code>manipulateWidget</code>.
In such situation, parameter <code>.return</code> should be used so that
<code>manipulateWidget</code> is the last function called. Indeed, if other code
is present after, the custom function will act very weird in a Rmarkdown
document with "runtime: shiny".
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Basic example with fake data
if (require(dygraphs)) {
  mydata &lt;- data.frame(period = 1:100, value = rnorm(100))
  manipulateWidget(dygraph(mydata[range[1]:range[2], ], main = title),
                   range = mwSlider(1, 100, c(1, 100)),
                   title = mwText("Fictive time series"))
}

# Let use manipulateWidget to explore the evolution of energy consumption in
# the world
data("worldEnergyUse")

if (require(plotly)) {
  # Function that generates a chart representing the evolution of energy
  # consumption per country. Creating a function is not necessary. We do it
  # for clarity and reuse in the different examples.
  plotEnergyUse &lt;- function(Country, Period, lwd = 2, col = "gray") {
    dataset &lt;- subset(
      worldEnergyUse,
      country == Country &amp; year &gt;= Period[1] &amp; year &lt;= Period[2]
    )
    plot_ly(dataset) %&gt;%
      add_lines(~year, ~energy_used, line = list(width = lwd, color = col)) %&gt;%
      layout(title = paste("Energy used in", Country))
  }

  # Launch the interactive visualisation
  manipulateWidget(
    plotEnergyUse(Country, Period),
    Period = mwSlider(1960, 2014, c(1960, 2014)),
    Country = mwSelect(sort(unique(worldEnergyUse$country)), "United States")
  )

  # Directly start comparison mode
  manipulateWidget(
    plotEnergyUse(Country, Period),
    Period = mwSlider(1960, 2014, c(1960, 2014)),
    Country = mwSelect(sort(unique(worldEnergyUse$country))),
    .compare = list(Country = c("United States", "China")),
    .compareOpts = compareOptions(ncol = 2)
  )

  # Dynamic input parameters
  #-------------------------
  # The arguments of an input can depend on the values of other inputs.
  # In this example, when the user changes the region, the choices of input
  # "Country" are updated with the countries of that region.

  # First we create a list that contains for each region the countries in that
  # retion
  refRegions &lt;- by(worldEnergyUse$country, worldEnergyUse$region,
                   function(x) as.character(sort(unique(x))))

  manipulateWidget(
    plotEnergyUse(Country, Period),
    Period = mwSlider(1960, 2014, c(1960, 2014)),
    Region = mwSelect(sort(unique(worldEnergyUse$region))),
    Country = mwSelect(choices = refRegions[[Region]])
  )

  # Grouping inputs
  #----------------
  # Inputs can be visually grouped with function mwGroup()
  manipulateWidget(
    plotEnergyUse(Country, Period, lwd, col),
    Period = mwSlider(1960, 2014, c(1960, 2014)),
    Country = mwSelect(sort(unique(worldEnergyUse$country)), "United States"),
    `Graphical Parameters` = mwGroup(
      lwd = mwSlider(1,10, 2, label = "Line Width"),
      col = mwSelect(choices = c("gray", "black", "red"))
    )
  )

  # Conditional inputs
  #-------------------
  # Inputs can be displayed or hidden depending on the state of other inputs.
  # In this example, user can choose to display the level of aggregation
  # (region or country). Depending on the choixe, the application displays
  # input Region or input Country.
  plotEnergyUseRegion &lt;- function(Region, Period, lwd = 2, col = "gray") {
    dataset &lt;- subset(
      worldEnergyUse,
      region == Region &amp; year &gt;= Period[1] &amp; year &lt;= Period[2]
    )
    dataset &lt;- aggregate(energy_used ~ year, sum, data = dataset)

    plot_ly(dataset) %&gt;%
      add_lines(~year, ~energy_used, line = list(width = lwd, color = col)) %&gt;%
      layout(title = paste("Energy used in", Region))
  }

  manipulateWidget(
    {
      if (Level == "Region") {
        plotEnergyUseRegion(Region, Period)
      } else {
        plotEnergyUse(Country, Period)
      }
    },
    Period = mwSlider(1960, 2014, c(1960, 2014)),
    Level = mwSelect(c("Region", "Country")),
    Region = mwSelect(sort(unique(worldEnergyUse$region)),
                      .display = Level == "Region"),
    Country = mwSelect(sort(unique(worldEnergyUse$country)),
                       .display = Level == "Country")
  )

}

# Advanced Usage
# --------------
# When .expr is evaluated with tehnical variables:
# .initial: is it the first evaluation?
# .outputId: integer representing the id of the chart
# .output: shiny output id
# .session: shiny session
# They can be used to update an already rendered widget instead of replacing
# it each time an input value is modified.
#
# In this example, we represent on a map, the energy use of countries.
# When the user changes an input, the map is not redrawn. Only the circle
# markers are updated.
if (require(leaflet)) {
  plotMap &lt;- function(Year, MaxRadius = 30, .initial, .session, .output) {
    dataset &lt;- subset(worldEnergyUse, year == Year)
    radius &lt;- sqrt(dataset$energy_used) /
      max(sqrt(worldEnergyUse$energy_used), na.rm = TRUE) * MaxRadius

    if (.initial) { # map has not been rendered yet
      map &lt;- leaflet() %&gt;% addTiles()
    } else { # map already rendered
      map &lt;- leafletProxy(.output, .session) %&gt;% clearMarkers()
    }

    map %&gt;% addCircleMarkers(dataset$long, dataset$lat, radius = radius,
                             color = "gray", weight = 0, fillOpacity = 0.7)
  }

  manipulateWidget(
    plotMap(Year, MaxRadius, .initial, .session, .output),
    Year = mwSlider(1960, 2014, 2014),
    MaxRadius = mwSlider(10, 50, 20)
  )
}
</code></pre>


</div>