<div class="container">

<table style="width: 100%;"><tr>
<td>indirect_i</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Indirect Effect (No
Bootstrapping)</h2>

<h3>Description</h3>

<p>It computes an indirect
effect, optionally conditional on the
value(s) of moderator(s) if present.
</p>


<h3>Usage</h3>

<pre><code class="language-R">indirect_i(
  x,
  y,
  m = NULL,
  fit = NULL,
  est = NULL,
  implied_stats = NULL,
  wvalues = NULL,
  standardized_x = FALSE,
  standardized_y = FALSE,
  computation_digits = 5,
  prods = NULL,
  get_prods_only = FALSE,
  data = NULL,
  expand = TRUE,
  warn = TRUE,
  allow_mixing_lav_and_obs = TRUE,
  group = NULL,
  est_vcov = NULL,
  df_residual = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Character. The name of the
predictor at the start of the path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Character. The name of the
outcome variable at the end of the
path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>A vector of the variable
names of the mediator(s). The path
goes from the first mediator
successively to the last mediator. If
<code>NULL</code>, the default, the path goes
from <code>x</code> to <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>The fit object. Currently
only supports lavaan::lavaan
objects. Support for lists of <code>lm()</code>
output is implemented by high level
functions such as <code>indirect_effect()</code>
and <code>cond_indirect_effects()</code>.
It can also be
a <code>lavaan.mi</code> object
returned by
<code>semTools::runMI()</code> or
its wrapper, such as <code>semTools::sem.mi()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est</code></td>
<td>
<p>The output of
<code>lavaan::parameterEstimates()</code>. If
<code>NULL</code>, the default, it will be
generated from <code>fit</code>. If supplied,
<code>fit</code> will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>implied_stats</code></td>
<td>
<p>Implied means,
variances, and covariances of
observed variables and latent
variables (if any), of the form of
the output of <code>lavaan::lavInspect()</code>
with <code>what</code> set to <code>"implied"</code>, but
with means extracted with <code>what</code> set
to <code>"mean.ov"</code> and <code>"mean.lv"</code>. The
standard deviations are extracted
from this object for standardization.
Default is <code>NULL</code>, and implied
statistics will be computed from
<code>fit</code> if required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wvalues</code></td>
<td>
<p>A numeric vector of
named elements. The names are the
variable names of the moderators, and
the values are the values to which
the moderators will be set to.
Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized_x</code></td>
<td>
<p>Logical.
Whether <code>x</code> will be standardized.
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized_y</code></td>
<td>
<p>Logical.
Whether <code>y</code> will be standardized.
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>computation_digits</code></td>
<td>
<p>The number
of digits in storing the computation
in text. Default is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prods</code></td>
<td>
<p>The product terms found.
For internal use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>get_prods_only</code></td>
<td>
<p>IF <code>TRUE</code>, will
quit early and return the product
terms found. The results can be
passed to the <code>prod</code> argument when
calling this function. Default is
<code>FALSE</code>. For internal use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame (optional). If
supplied, it will be used to identify
the product terms. For internal use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand</code></td>
<td>
<p>Whether products of
more than two terms will be searched.
<code>TRUE</code> by default. For internal use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>If <code>TRUE</code>, the default,
the function will warn against
possible misspecification, such as
not setting the value of a moderator
which moderate one of the component
path. Set this to <code>FALSE</code> will
suppress these warnings. Suppress
them only when the moderators are
omitted intentionally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow_mixing_lav_and_obs</code></td>
<td>
<p>If
<code>TRUE</code>, it accepts a path with both
latent variables and observed
variables. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Either the group number
as appeared in the <code>summary()</code>
or <code>lavaan::parameterEstimates()</code>
output of an <code>lavaan</code>-class object,
or the group label as used in
the <code>lavaan</code>-class object.
Used only when the number of
groups is greater than one. Default
is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est_vcov</code></td>
<td>
<p>A list of
variance-covariance matrix of
estimates, one for each response
variable (<code>y</code>-variable). Used only
for models fitted by <code>stats::lm()</code>
for now. It is used to compute the
standard error for a path with no
mediator, and both <code>x</code> and <code>y</code> are
not standardized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df_residual</code></td>
<td>
<p>A numeric
vector of the residual degrees of
freedom for the model of each
response variable (<code>y</code>-variable).
Used only for models fitted by
<code>stats::lm()</code> for now. It is used to
compute the <em>p</em>-value and confidence
interval for a path with no mediator
and both <code>x</code> and <code>y</code> are not
standardized.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is a low-level
function called by
<code>indirect_effect()</code>,
<code>cond_indirect_effects()</code>, and
<code>cond_indirect()</code>, which call this
function multiple times if bootstrap
confidence interval is requested.
</p>
<p>This function usually should not be
used directly. It is exported for
advanced users and developers
</p>


<h3>Value</h3>

<p>It returns an
<code>indirect</code>-class object. This class
has the following methods:
<code>coef.indirect()</code>,
<code>print.indirect()</code>. The
<code>confint.indirect()</code> method is used
only when called by <code>cond_indirect()</code>
or <code>cond_indirect_effects()</code>.
</p>


<h3>See Also</h3>

<p><code>indirect_effect()</code>,
<code>cond_indirect_effects()</code>, and
<code>cond_indirect()</code>, the high level
functions that should usually be
used.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ a1 * x   + b1 * w1 + d1 * x:w1
m2 ~ a2 * m1  + b2 * w2 + d2 * m1:w2
m3 ~ a3 * m2  + b3 * w3 + d3 * m2:w3
y  ~ a4 * m3  + b4 * w4 + d4 * m3:w4
"
fit &lt;- sem(mod, dat, meanstructure = TRUE,
           fixed.x = FALSE, se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

wvalues &lt;- c(w1 = 5, w2 = 4, w3 = 2, w4 = 3)

# Compute the conditional indirect effect by indirect_i()
indirect_1 &lt;- indirect_i(x = "x", y = "y", m = c("m1", "m2", "m3"), fit = fit,
                       wvalues = wvalues)

# Manually compute the conditional indirect effect
indirect_2 &lt;- (est[est$label == "a1", "est"] +
                wvalues["w1"] * est[est$label == "d1", "est"]) *
              (est[est$label == "a2", "est"] +
                wvalues["w2"] * est[est$label == "d2", "est"]) *
              (est[est$label == "a3", "est"] +
                wvalues["w3"] * est[est$label == "d3", "est"]) *
              (est[est$label == "a4", "est"] +
                wvalues["w4"] * est[est$label == "d4", "est"])
# They should be the same
coef(indirect_1)
indirect_2

</code></pre>


</div>