<div class="container">

<table style="width: 100%;"><tr>
<td>lm2list</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Join 'lm()' Output to Form an
'lm_list'-Class Object</h2>

<h3>Description</h3>

<p>The resulting model can
be used by <code>indirect_effect()</code>,
<code>cond_indirect_effects()</code>, or
<code>cond_indirect()</code> as a path method,
as if fitted by <code>lavaan::sem()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lm2list(...)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>The <code>lm()</code> outputs to be
grouped in a list.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>If a path model with
mediation and/or moderation is fitted
by a set of regression models using
<code>lm()</code>, this function can combine
them to an object of the class
<code>lm_list</code> that represents a path
model, as one fitted by structural
equation model functions such as
<code>lavaan::sem()</code>. This class of object
can be used by some functions, such
as <code>indirect_effect()</code>,
<code>cond_indirect_effects()</code>, and
<code>cond_indirect()</code> as if they were the
output of fitting a path model, with
the regression coefficients treated
as path coefficients.
</p>
<p>The regression outputs to be combined
need to meet the following
requirements:
</p>

<ul>
<li>
<p> All models must be connected to at
least one another model. That is, a
regression model must either have (a)
at least on predictor that is the
outcome variable of another model, or
(b) its outcome variable the
predictor of another model.
</p>
</li>
<li>
<p> All models must be fitted to the
same sample. This implies that the
sample size must be the same in all
analysis.
</p>
</li>
</ul>
<h3>Value</h3>

<p>It returns an <code>lm_list</code>-class
object that forms a path model
represented by a set of regression
models. This class has a <code>summary</code>
method that shows the summary of
each regression model stored (see
<code>summary.lm_list()</code>), and a <code>print</code>
method that prints the models stored
(see <code>print.lm_list()</code>).
</p>


<h3>See Also</h3>

<p><code>summary.lm_list()</code> and
<code>print.lm_list()</code> for related
methods, <code>indirect_effect()</code> and
<code>cond_indirect_effects()</code> which
accept <code>lm_list</code>-class objects as
input.
</p>


<h3>Examples</h3>

<pre><code class="language-R">


data(data_serial_parallel)
lm_m11 &lt;- lm(m11 ~ x + c1 + c2, data_serial_parallel)
lm_m12 &lt;- lm(m12 ~ m11 + x + c1 + c2, data_serial_parallel)
lm_m2 &lt;- lm(m2 ~ x + c1 + c2, data_serial_parallel)
lm_y &lt;- lm(y ~ m11 + m12 + m2 + x + c1 + c2, data_serial_parallel)
# Join them to form a lm_list-class object
lm_serial_parallel &lt;- lm2list(lm_m11, lm_m12, lm_m2, lm_y)
lm_serial_parallel
summary(lm_serial_parallel)

# Compute indirect effect from x to y through m11 and m12
outm11m12 &lt;- cond_indirect(x = "x", y = "y",
                           m = c("m11", "m12"),
                           fit = lm_serial_parallel)
outm11m12
# Compute indirect effect from x to y
# through m11 and m12 with bootstrapping CI
# R should be at least 2000 or even 5000 in read study.
# In real research, parallel and progress can be omitted.
# They are est to TRUE by default.
outm11m12 &lt;- cond_indirect(x = "x", y = "y",
                           m = c("m11", "m12"),
                           fit = lm_serial_parallel,
                           boot_ci = TRUE,
                           R = 100,
                           seed = 1234,
                           parallel = FALSE,
                           progress = FALSE)
outm11m12

</code></pre>


</div>