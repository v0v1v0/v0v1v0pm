<div class="container">

<table style="width: 100%;"><tr>
<td>mod_levels</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create Levels of Moderators</h2>

<h3>Description</h3>

<p>Create levels of
moderators to be used by
<code>indirect_effect()</code>,
<code>cond_indirect_effects()</code>, and
<code>cond_indirect()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mod_levels(
  w,
  fit,
  w_type = c("auto", "numeric", "categorical"),
  w_method = c("sd", "percentile"),
  sd_from_mean = c(-1, 0, 1),
  percentiles = c(0.16, 0.5, 0.84),
  extract_gp_names = TRUE,
  prefix = NULL,
  values = NULL,
  reference_group_label = NULL,
  descending = TRUE
)

mod_levels_list(
  ...,
  fit,
  w_type = "auto",
  w_method = "sd",
  sd_from_mean = NULL,
  percentiles = NULL,
  extract_gp_names = TRUE,
  prefix = NULL,
  descending = TRUE,
  merge = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Character. The names of the moderator. If the moderator is
categorical with 3 or more groups, this is the vector of the
indicator variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>The fit object. Can be a
lavaan::lavaan object or a
list of <code>lm()</code> outputs.
It can also be
a <code>lavaan.mi</code> object
returned by
<code>semTools::runMI()</code> or
its wrapper, such as <code>semTools::sem.mi()</code>.
If it is a single model fitted by
<code>lm()</code>, it will be automatically converted
to a list by <code>lm2list()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_type</code></td>
<td>
<p>Character. Whether the
moderator is a <code>"numeric"</code> variable
or a <code>"categorical"</code> variable. If
<code>"auto"</code>, the function will try to
determine the type automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_method</code></td>
<td>
<p>Character, either
<code>"sd"</code> or <code>"percentile"</code>. If <code>"sd"</code>,
the levels are defined by the
distance from the mean in terms of
standard deviation. if
<code>"percentile"</code>, the levels are
defined in percentiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd_from_mean</code></td>
<td>
<p>A numeric vector.
Specify the distance in standard
deviation from the mean for each
level. Default is <code>c(-1, 0, 1)</code> for
<code>mod_levels()</code>. For
<code>mod_levels_list()</code>, the default is
<code>c(-1, 0, 1)</code> when there is only one
moderator, and <code>c(-1, 1)</code> when there
are more than one moderator. Ignored
if <code>w_method</code> is not equal to <code>"sd"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>percentiles</code></td>
<td>
<p>A numeric vector.
Specify the percentile (in
proportion) for each level. Default
is <code>c(.16, .50, .84)</code> for
<code>mod_levels()</code>, corresponding
approximately to one standard
deviation below mean, mean, and one
standard deviation above mean in a
normal distribution. For
<code>mod_levels_list()</code>, default is
<code>c(.16, .50, .84)</code> if there is one
moderator, and <code>c(.16, .84)</code> when
there are more than one moderator.
Ignored if <code>w_method</code> is not equal to
<code>"percentile"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extract_gp_names</code></td>
<td>
<p>Logical. If
<code>TRUE</code>, the default, the function
will try to determine the name of
each group from the variable names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p>Character. If
<code>extract_gp_names</code> is <code>TRUE</code> and
<code>prefix</code> is supplied, it will be
removed from the variable names to
create the group names. Default is
<code>NULL</code>, and the function will try to
determine the prefix automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>For numeric moderators,
a numeric vector. These are the
values to be used and will override
other options. For categorical
moderators, a named list of numeric
vector, each vector has length equal
to the number of indicator variables.
If the vector is named, the names
will be used to label the values. For
example, if set to <code style="white-space: pre;">⁠list(gp1 = c(0, 0), gp3 = c(0, 1)⁠</code>, two levels will
be returned, one named <code>gp1</code> with the
indicator variables equal to 0 and 0,
the other named <code>gp3</code> with the
indicator variables equal to 0 and 1.
Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference_group_label</code></td>
<td>
<p>For
categorical moderator, if the label
for the reference group (group with
all indicators equal to zero) cannot
be determined, the default label is
<code>"Reference"</code>. To change it, set
<code>reference_group_label</code> to the
desired label. Ignored if <code>values</code> is
set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>descending</code></td>
<td>
<p>If <code>TRUE</code>
(default), the rows are sorted in
descending order for numerical
moderators: The highest value on the
first row and the lowest values on
the last row. For user supplied
values, the first value is on the
last row and the last value is on the
first row. If <code>FALSE</code>, the rows are
sorted in ascending order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>The names of moderators
variables. For a categorical
variable, it should be a vector of
variable names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge</code></td>
<td>
<p>If <code>TRUE</code>,
<code>mod_levels_list()</code> will call
<code>merge_mod_levels()</code> and return the
merged levels. Default is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It creates values of a
moderator that can be used to compute
conditional effect or conditional
indirect effect. By default, for a
numeric moderator, it uses one
standard deviation below mean, mean,
and one standard deviation above
mean. The percentiles of these three
levels in a normal distribution
(16th, 50th, and 84th) can also be
used. For categorical variable, it
will simply collect the unique
categories in the data.
</p>
<p>The generated levels are then used by
<code>cond_indirect()</code> and
<code>cond_indirect_effects()</code>.
</p>
<p>If a model has more than one
moderator, <code>mod_levels_list()</code> can be
used to generate combinations of
levels. The output can then passed to
<code>cond_indirect_effects()</code> to compute
the conditional effects or
conditional indirect effects for all
the combinations.
</p>


<h3>Value</h3>

<p><code>mod_levels()</code> returns a
<code>wlevels</code>-class object which is a
data frame with additional attributes
about the levels.
</p>
<p><code>mod_levels_list()</code> returns a list of
<code>wlevels</code>-class objects, or a
<code>wlevels</code>-class object which is a
data frame of the merged levels if
<code>merge = TRUE</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>mod_levels()</code>: Generate
levels for one moderator.
</p>
</li>
<li> <p><code>mod_levels_list()</code>: Generate
levels for several moderators.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>cond_indirect_effects()</code> for computing conditional
indiret effects; <code>merge_mod_levels()</code> for merging
levels of moderators.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(lavaan)
data(data_med_mod_ab)
dat &lt;- data_med_mod_ab
# Form the levels from a list of lm() outputs
lm_m &lt;- lm(m ~ x*w1 + c1 + c2, dat)
lm_y &lt;- lm(y ~ m*w2 + x + w1 + c1 + c2, dat)
lm_out &lt;- lm2list(lm_m, lm_y)
w1_levels &lt;- mod_levels(lm_out, w = "w1")
w1_levels
w2_levels &lt;- mod_levels(lm_out, w = "w2")
w2_levels
# Indirect effect from x to y through m, at the first levels of w1 and w2
cond_indirect(x = "x", y = "y", m = "m",
              fit = lm_out,
              wvalues = c(w1 = w1_levels$w1[1],
                          w2 = w2_levels$w2[1]))
# Can form the levels based on percentiles
w1_levels2 &lt;- mod_levels(lm_out, w = "w1", w_method = "percentile")
w1_levels2
# Form the levels from a lavaan output
# Compute the product terms before fitting the model
dat$mw2 &lt;- dat$m * dat$w2
mod &lt;-
"
m ~ x + w1 + x:w1 + c1 + c2
y ~ m + x + w1 + w2 + mw2 + c1 + c2
"
fit &lt;- sem(mod, dat, fixed.x = FALSE)
cond_indirect(x = "x", y = "y", m = "m",
              fit = fit,
              wvalues = c(w1 = w1_levels$w1[1],
                          w2 = w2_levels$w2[1]))
# Can pass all levels to cond_indirect_effects()
# First merge the levels by merge_mod_levels()
w1w2_levels &lt;- merge_mod_levels(w1_levels, w2_levels)
cond_indirect_effects(x = "x", y = "y", m = "m",
                      fit = fit,
                      wlevels = w1w2_levels)




# mod_levels_list() forms a combinations of levels in one call
# It returns a list, by default.
# Form the levels from a list of lm() outputs
# "merge = TRUE" is optional. cond_indirect_effects will merge the levels
# automatically.
w1w2_levels &lt;- mod_levels_list("w1", "w2", fit = fit, merge = TRUE)
w1w2_levels
cond_indirect_effects(x = "x", y = "y", m = "m",
                      fit = fit, wlevels = w1w2_levels)
# Can work without merge = TRUE:
w1w2_levels &lt;- mod_levels_list("w1", "w2", fit = fit)
w1w2_levels
cond_indirect_effects(x = "x", y = "y", m = "m",
                      fit = fit, wlevels = w1w2_levels)


</code></pre>


</div>