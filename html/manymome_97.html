<div class="container">

<table style="width: 100%;"><tr>
<td>pseudo_johnson_neyman</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pseudo Johnson-Neyman Probing</h2>

<h3>Description</h3>

<p>Use the pseudo
Johnson-Neyman approach (Hayes, 2022)
to find the range of values of a
moderator in which the conditional
effect is not significant.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pseudo_johnson_neyman(
  object = NULL,
  w_lower = NULL,
  w_upper = NULL,
  optimize_method = c("uniroot", "optimize"),
  extendInt = c("no", "yes", "downX", "upX"),
  tol = .Machine$double.eps^0.25,
  level = 0.95
)

johnson_neyman(
  object = NULL,
  w_lower = NULL,
  w_upper = NULL,
  optimize_method = c("uniroot", "optimize"),
  extendInt = c("no", "yes", "downX", "upX"),
  tol = .Machine$double.eps^0.25,
  level = 0.95
)

## S3 method for class 'pseudo_johnson_neyman'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A
<code>cond_indirect_effects</code>-class object,
which is the output of <code>cond_indirect_effects()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_lower</code></td>
<td>
<p>The smallest value of
the moderator when doing the search.
If set to <code style="white-space: pre;">⁠NULL,⁠</code> the default, it
will be 10 standard deviations
below mean, which should be small
enough.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_upper</code></td>
<td>
<p>The largest value of
the moderator when doing the search.
If set to <code style="white-space: pre;">⁠NULL,⁠</code> the default, it
will be 10 standard deviations
above mean, which should be large
enough.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimize_method</code></td>
<td>
<p>The optimization
method to be used. Either
<code>"uniroot"</code> (the default) or
<code>"optimize"</code>, corresponding to
<code>stats::uniroot()</code> and
<code>stats::optimize()</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extendInt</code></td>
<td>
<p>Used by
<code>stats::uniroot()</code>. If <code>"no"</code>, then
search will be conducted strictly
within <code>c(w_lower, w_upper)</code>. Otherwise,
the range is extended based on this
argument if the solution is not found.
Please refer to <code>stats::uniroot()</code>
for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance level used
by both <code>stats::uniroot()</code> and
<code>stats::optimize()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>The level of confidence
of the confidence level. One minus
this level is the level of significance.
Default is .95, equivalent to a
level of significance of .05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The output of
<code>pseudo_johnson_neyman()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits to
display. Default is 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments. Not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function uses the
pseudo Johnson-Neyman approach
proposed by Hayes (2022) to find the
values of a moderator at which a
conditional effect is
"nearly just significant" based on
confidence interval. If an effect is
moderated, there will be two such
points (though one can be very large
or small) forming a range.
The conditional effect
is not significant within this range,
and significant outside this range,
based on the confidence interval.
</p>
<p>This function receives the output
of <code>cond_indirect_effects()</code>
and search for, within
a specific range, the two values of
the moderator at which
the conditional effect is "nearly just significant",
that is, the confidence interval
"nearly touches" zero.
</p>
<p>Note that numerical method is used
to find the points. Therefore,
strictly speaking, the effects at
the end points are still either
significant or not significant, even
if the confidence limit is very close
to zero.
</p>
<p>Though numerical method is used,
if the test is conducted using the
standard error (see below), the result is
equivalent to the (true)
Johnson-Neyman (1936) probing.
The function <code>johnson_neyman()</code> is
just an alias to <code>pseudo_johnson_neyman()</code>,
with the name consistent with what
it does in this special case.
</p>


<h4>Supported Methods</h4>

<p>This function supports models fitted
by <code>lm()</code>, <code>lavaan::sem()</code>,
and <code>semTools::sem.mi()</code>. This function
also supports both bootstrapping
and Monte Carlo confidence intervals.
It also supports conditional
direct paths (no mediator) and
conditional indirect paths (with one
or more mediator), with <code>x</code> and/or
<code>y</code> standardized.
</p>



<h4>Requirements</h4>

<p>To be eligible for using this function,
one of these conditions must be met:
</p>

<ul>
<li>
<p> One form of confidence intervals
(e.g, bootstrapping or Monte Carlo)
must has been requested (e.g.,
setting <code>boot_ci = TRUE</code> or
<code>mc_ci = TRUE</code>) when calling
<code>cond_indirect_effects()</code>.
</p>
</li>
<li>
<p> Tests can be done using stored
standard errors: A path with no
mediator and both the <code>x</code>- and
<code>y</code>-variables are not standardized.
</p>
</li>
</ul>
<p>For pre-computed confidence intervals,
the confidence level of the confidence
intervals adopted when calling
<code>cond_indirect_effects()</code> will be used
by this function.
</p>
<p>For tests conducted by standard
errors, the argument <code>level</code> is used
to control the level of significance.
</p>



<h4>Possible failures</h4>

<p>Even if a path has only one moderator,
it is possible that no solution, or
more than one solution, is/are found
if the relation between this moderator
and the conditional effect is not linear.
</p>
<p>Solution may also be not found if
the conditional effect is significant
over a wide range of value of the
moderator.
</p>
<p>It is advised to use <code>plot_effect_vs_w()</code>
to examine the relation between the
effect and the moderator first before
calling this function.
</p>



<h4>Speed</h4>

<p>Note that, for conditional indirect
effects, the search can be slow
because the confidence interval needs
to be recomputed for each new value
of the moderator.
</p>



<h4>Limitations</h4>


<ul>
<li>
<p> This function currently only supports
a path with only one moderator,
</p>
</li>
<li>
<p> This function does not yet support
multigroup models.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A list of the class <code>pseudo_johnson_neyman</code>
(with a print method, <code>print.pseudo_johnson_neyman()</code>).
It has these major elements:
</p>

<ul>
<li> <p><code>cond_effects</code>: An output of
<code>cond_indirect_effects()</code> for the
two levels of the moderator found.
</p>
</li>
<li> <p><code>w_min_valid</code>: Logical. If <code>TRUE</code>,
the conditional effect is just
significant at the lower level of
the moderator found,
and so is significant below this point.
If <code>FALSE</code>, then the lower level of
the moderator found is just the
lower bound of the range searched,
that is, <code>w_lower</code>.
</p>
</li>
<li> <p><code>w_max_valid</code>: Logical. If <code>TRUE</code>,
the conditional effect is just
significant at the higher level of
the moderator found,
and so is significant above this point.
If <code>FALSE</code>, then the higher level of
the moderator found is just the
upper bound of the range searched,
that is, <code>w_upper</code>.
</p>
</li>
</ul>
<h3>Methods (by generic)</h3>


<ul><li> <p><code>print(pseudo_johnson_neyman)</code>: Print
method for output of <code>pseudo_johnson_neyman()</code>.
</p>
</li></ul>
<h3>References</h3>

<p>Johnson, P. O., &amp; Neyman, J. (1936). Test of certain linear hypotheses and their application to some educational problems. <em>Statistical Research Memoirs, 1</em>, 57–93.
</p>
<p>Hayes, A. F. (2022). <em>Introduction to mediation, moderation, and conditional process analysis: A regression-based approach</em> (Third edition). The Guilford Press.
</p>


<h3>See Also</h3>

<p><code>cond_indirect_effects()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(lavaan)

dat &lt;- data_med_mod_a
dat$wx &lt;- dat$x * dat$w
mod &lt;-
"
m ~ x + w + wx
y ~ m + x
"
fit &lt;- sem(mod, dat)

# In real research, R should be 2000 or even 5000
# In real research, no need to set parallel and progress to FALSE
# Parallel processing is enabled by default and
# progress is displayed by default.
boot_out &lt;- do_boot(fit,
                    R = 50,
                    seed = 4314,
                    parallel = FALSE,
                    progress = FALSE)
out &lt;- cond_indirect_effects(x = "x", y = "y", m = "m",
                             wlevels = "w",
                             fit = fit,
                             boot_ci = TRUE,
                             boot_out = boot_out)

# Visualize the relation first
plot_effect_vs_w(out)

out_jn &lt;- pseudo_johnson_neyman(out)
out_jn

# Plot the range
plot_effect_vs_w(out_jn$cond_effects)

</code></pre>


</div>