<div class="container">

<table style="width: 100%;"><tr>
<td>make_learning</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Making learning models on networks</h2>

<h3>Description</h3>

<p>These functions allow learning games to be played upon networks.
</p>

<ul>
<li> <p><code>play_learning()</code> plays a DeGroot learning model upon a network.
</p>
</li>
<li> <p><code>play_segregation()</code> plays a Schelling segregation model upon a network.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">play_learning(.data, beliefs, steps, epsilon = 5e-04)

play_segregation(
  .data,
  attribute,
  heterophily = 0,
  who_moves = c("ordered", "random", "most_dissatisfied"),
  choice_function = c("satisficing", "optimising", "minimising"),
  steps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li>
<p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li>
<p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li>
<p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li>
<p> network, from the <code>{network}</code> package
</p>
</li>
<li>
<p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beliefs</code></td>
<td>
<p>A vector indicating the probabilities nodes
put on some outcome being 'true'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>The number of steps forward in learning.
By default the number of nodes in the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>The maximum difference in beliefs accepted
for convergence to a consensus.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attribute</code></td>
<td>
<p>A string naming some nodal attribute in the network.
Currently only tested for binary attributes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heterophily</code></td>
<td>
<p>A score ranging between -1 and 1 as a threshold for
how heterophilous nodes will accept their neighbours to be.
A single proportion means this threshold is shared by all nodes,
but it can also be a vector the same length of the nodes in the network
for issuing different thresholds to different nodes.
By default this is 0, meaning nodes will be dissatisfied if more than half
of their neighbours differ on the given attribute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>who_moves</code></td>
<td>
<p>One of the following options:
"ordered" (the default) checks each node in turn for whether they are
dissatisfied and there is an available space that they can move to,
"random" will check a node at random,
and "most_dissatisfied" will check (one of) the most dissatisfied nodes first.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choice_function</code></td>
<td>
<p>One of the following options:
"satisficing" (the default) will move the node to any coordinates that satisfy
their heterophily threshold,
"optimising" will move the node to coordinates that are most homophilous,
and "minimising" distance will move the node to the next nearest unoccupied coordinates.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p>Other makes: 
<code>make_cran</code>,
<code>make_create</code>,
<code>make_ego</code>,
<code>make_explicit</code>,
<code>make_motifs</code>,
<code>make_play</code>,
<code>make_random</code>,
<code>make_read</code>,
<code>make_stochastic</code>,
<code>make_write</code>
</p>
<p>Other models: 
<code>make_play</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  play_learning(ison_networkers, 
      rbinom(net_nodes(ison_networkers),1,prob = 0.25))
  startValues &lt;- rbinom(100,1,prob = 0.5)
  startValues[sample(seq_len(100), round(100*0.2))] &lt;- NA
  latticeEg &lt;- create_lattice(100)
  latticeEg &lt;- add_node_attribute(latticeEg, "startValues", startValues)
  latticeEg
  play_segregation(latticeEg, "startValues", 0.5)
  # graphr(latticeEg, node_color = "startValues", node_size = 5) + 
  # graphr(play_segregation(latticeEg, "startValues", 0.2), 
  #            node_color = "startValues", node_size = 5)
</code></pre>


</div>