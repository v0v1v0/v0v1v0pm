<div class="container">

<table style="width: 100%;"><tr>
<td>member_community_hier</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hierarchical community partitioning algorithms</h2>

<h3>Description</h3>

<p>These functions offer algorithms for hierarchically clustering
networks into communities. Since all of the following are hierarchical,
their dendrograms can be plotted:
</p>

<ul>
<li> <p><code>node_in_betweenness()</code> is a hierarchical, decomposition algorithm
where edges are removed in decreasing order of the number of
shortest paths passing through the edge.
</p>
</li>
<li> <p><code>node_in_greedy()</code> is a hierarchical, agglomerative algorithm,
that tries to optimize modularity in a greedy manner.
</p>
</li>
<li> <p><code>node_in_eigen()</code> is a top-down, hierarchical algorithm.
</p>
</li>
<li> <p><code>node_in_walktrap()</code> is a hierarchical, agglomerative algorithm based on random walks.
</p>
</li>
</ul>
<p>The different algorithms offer various advantages in terms of computation time,
availability on different types of networks, ability to maximise modularity,
and their logic or domain of inspiration.
</p>


<h3>Usage</h3>

<pre><code class="language-R">node_in_betweenness(.data)

node_in_greedy(.data)

node_in_eigen(.data)

node_in_walktrap(.data, times = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li>
<p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li>
<p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li>
<p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li>
<p> network, from the <code>{network}</code> package
</p>
</li>
<li>
<p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Integer indicating number of simulations/walks used.
By default, <code>times=50</code>.</p>
</td>
</tr>
</table>
<h3>Edge-betweenness</h3>

<p>This is motivated by the idea that edges connecting different groups
are more likely to lie on multiple shortest paths when they are the
only option to go from one group to another.
This method yields good results but is very slow because of
the computational complexity of edge-betweenness calculations and
the betweenness scores have to be re-calculated after every edge removal.
Networks of ~700 nodes and ~3500 ties are around the upper size limit
that are feasible with this approach.
</p>


<h3>Fast-greedy</h3>

<p>Initially, each node is assigned a separate community.
Communities are then merged iteratively such that each merge
yields the largest increase in the current value of modularity,
until no further increases to the modularity are possible.
The method is fast and recommended as a first approximation
because it has no parameters to tune.
However, it is known to suffer from a resolution limit.
</p>


<h3>Leading eigenvector</h3>

<p>In each step, the network is bifurcated such that modularity increases most.
The splits are determined according to the leading eigenvector of the modularity matrix.
A stopping condition prevents tightly connected groups from being split further.
Note that due to the eigenvector calculations involved,
this algorithm will perform poorly on degenerate networks,
but will likely obtain a higher modularity than fast-greedy (at some cost of speed).
</p>


<h3>Walktrap</h3>

<p>The general idea is that random walks on a network are more likely to stay
within the same community because few edges lead outside a community.
By repeating random walks of 4 steps many times,
information about the hierarchical merging of communities is collected.
</p>


<h3>References</h3>



<h4>On edge-betweenness community detection</h4>

<p>Newman, Mark, and Michelle Girvan. 2004.
"Finding and evaluating community structure in networks."
<em>Physical Review E</em> 69: 026113.
<a href="https://doi.org/10.1103/PhysRevE.69.026113">doi:10.1103/PhysRevE.69.026113</a>
</p>



<h4>On fast-greedy community detection</h4>

<p>Clauset, Aaron, Mark E.J. Newman, and Cristopher Moore. 2004.
"Finding community structure in very large networks."
<em>Physical Review E</em>, 70: 066111.
<a href="https://doi.org/10.1103/PhysRevE.70.066111">doi:10.1103/PhysRevE.70.066111</a>
</p>



<h4>On leading eigenvector community detection</h4>

<p>Newman, Mark E.J. 2006.
"Finding community structure using the eigenvectors of matrices"
<em>Physical Review E</em> 74:036104.
<a href="https://doi.org/10.1103/PhysRevE.74.036104">doi:10.1103/PhysRevE.74.036104</a>
</p>



<h4>On walktrap community detection</h4>

<p>Pons, Pascal, and Matthieu Latapy. 2005.
"Computing communities in large networks using random walks".
1-20.
<a href="https://doi.org/10.48550/arXiv.physics/0512106">doi:10.48550/arXiv.physics/0512106</a>
</p>



<h3>See Also</h3>

<p>Other memberships: 
<code>mark_core</code>,
<code>member_brokerage</code>,
<code>member_cliques</code>,
<code>member_community_non</code>,
<code>member_components</code>,
<code>member_equivalence</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">node_in_betweenness(ison_adolescents)
if(require("ggdendro", quietly = TRUE)){
plot(node_in_betweenness(ison_adolescents))
}
node_in_greedy(ison_adolescents)
node_in_eigen(ison_adolescents)
node_in_walktrap(ison_adolescents)
</code></pre>


</div>