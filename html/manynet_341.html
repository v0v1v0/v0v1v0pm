<div class="container">

<table style="width: 100%;"><tr>
<td>mark_core</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Core-periphery clustering algorithms</h2>

<h3>Description</h3>

<p>These functions identify nodes belonging to (some level of) the core of a network:
</p>

<ul>
<li> <p><code>node_is_core()</code> assigns nodes to either the core or periphery.
</p>
</li>
<li> <p><code>node_coreness()</code> assigns nodes to their level of k-coreness.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">node_is_core(.data, method = c("degree", "eigenvector"))

node_coreness(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li>
<p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li>
<p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li>
<p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li>
<p> network, from the <code>{network}</code> package
</p>
</li>
<li>
<p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Which method to use to identify cores and periphery.
By default this is "degree",
which relies on the heuristic that high degree nodes are more likely to be in the core.
An alternative is "eigenvector", which instead begins with high eigenvector nodes.
Other methods, such as a genetic algorithm, CONCOR, and Rombach-Porter,
can be added if there is interest.</p>
</td>
</tr>
</table>
<h3>Core-periphery</h3>

<p>This function is used to identify which nodes should belong to the core,
and which to the periphery.
It seeks to minimize the following quantity:
</p>
<p style="text-align: center;"><code class="reqn">Z(S_1) = \sum_{(i&lt;j)\in S_1} \textbf{I}_{\{A_{ij}=0\}} + \sum_{(i&lt;j)\notin S_1} \textbf{I}_{\{A_{ij}=1\}}</code>
</p>

<p>where nodes <code class="reqn">\{i,j,...,n\}</code> are ordered in descending degree,
<code class="reqn">A</code> is the adjacency matrix,
and the indicator function is 1 if the predicate is true or 0 otherwise.
Note that minimising this quantity maximises density in the core block
and minimises density in the periphery block;
it ignores ties between these blocks.
</p>


<h3>References</h3>



<h4>On core-periphery partitioning</h4>

<p>Borgatti, Stephen P., &amp; Everett, Martin G. 1999.
Models of core /periphery structures.
<em>Social Networks</em>, 21, 375–395.
<a href="https://doi.org/10.1016/S0378-8733%2899%2900019-2">doi:10.1016/S0378-8733(99)00019-2</a>
</p>
<p>Lip, Sean Z. W. 2011.
“A Fast Algorithm for the Discrete Core/Periphery Bipartitioning Problem.”
<a href="https://doi.org/10.48550/arXiv.1102.5511">doi:10.48550/arXiv.1102.5511</a>
</p>



<h3>See Also</h3>

<p>Other memberships: 
<code>member_brokerage</code>,
<code>member_cliques</code>,
<code>member_community_hier</code>,
<code>member_community_non</code>,
<code>member_components</code>,
<code>member_equivalence</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">node_is_core(ison_adolescents)
#ison_adolescents %&gt;% 
#   mutate(corep = node_is_core()) %&gt;% 
#   graphr(node_color = "corep")
node_coreness(ison_adolescents)
</code></pre>


</div>