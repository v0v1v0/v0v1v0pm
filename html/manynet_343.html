<div class="container">

<table style="width: 100%;"><tr>
<td>measure_central_degree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Measures of degree-like centrality and centralisation</h2>

<h3>Description</h3>

<p>These functions calculate common degree-related centrality measures for one- and two-mode networks:
</p>

<ul>
<li> <p><code>node_degree()</code> measures the degree centrality of nodes in an unweighted network,
or weighted degree/strength of nodes in a weighted network;
there are several related shortcut functions:
</p>

<ul>
<li> <p><code>node_deg()</code> returns the unnormalised results.
</p>
</li>
<li> <p><code>node_indegree()</code> returns the <code>direction = 'in'</code> results.
</p>
</li>
<li> <p><code>node_outdegree()</code> returns the <code>direction = 'out'</code> results.
</p>
</li>
</ul>
</li>
<li> <p><code>node_multidegree()</code> measures the ratio between types of ties in a multiplex network.
</p>
</li>
<li> <p><code>node_posneg()</code> measures the PN (positive-negative) centrality of a signed network.
</p>
</li>
<li> <p><code>node_leverage()</code> measures the leverage centrality of nodes in a network.
</p>
</li>
<li> <p><code>tie_degree()</code> measures the degree centrality of ties in a network
</p>
</li>
<li> <p><code>net_degree()</code> measures a network's degree centralization;
there are several related shortcut functions:
</p>

<ul>
<li> <p><code>net_indegree()</code> returns the <code>direction = 'out'</code> results.
</p>
</li>
<li> <p><code>net_outdegree()</code> returns the <code>direction = 'out'</code> results.
</p>
</li>
</ul>
</li>
</ul>
<p>All measures attempt to use as much information as they are offered,
including whether the networks are directed, weighted, or multimodal.
If this would produce unintended results,
first transform the salient properties using e.g. <code>to_undirected()</code> functions.
All centrality and centralization measures return normalized measures by default,
including for two-mode networks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">node_degree(
  .data,
  normalized = TRUE,
  alpha = 1,
  direction = c("all", "out", "in")
)

node_deg(.data, alpha = 0, direction = c("all", "out", "in"))

node_outdegree(.data, normalized = TRUE, alpha = 0)

node_indegree(.data, normalized = TRUE, alpha = 0)

node_multidegree(.data, tie1, tie2)

node_posneg(.data)

node_leverage(.data)

tie_degree(.data, normalized = TRUE)

net_degree(.data, normalized = TRUE, direction = c("all", "out", "in"))

net_outdegree(.data, normalized = TRUE)

net_indegree(.data, normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li>
<p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li>
<p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li>
<p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li>
<p> network, from the <code>{network}</code> package
</p>
</li>
<li>
<p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric scalar, the positive tuning parameter introduced in
Opsahl et al (2010) for trading off between degree and strength centrality measures.
By default, <code>alpha = 0</code>, which ignores tie weights and the measure is solely based
upon degree (the number of ties).
<code>alpha = 1</code> ignores the number of ties and provides the sum of the tie weights
as strength centrality.
Values between 0 and 1 reflect different trade-offs in the relative contributions of
degree and strength to the final outcome, with 0.5 as the middle ground.
Values above 1 penalise for the number of ties.
Of two nodes with the same sum of tie weights, the node with fewer ties will obtain
the higher score.
This argument is ignored except in the case of a weighted network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>Character string, “out” bases the measure on outgoing ties,
“in” on incoming ties, and "all" on either/the sum of the two.
For two-mode networks, "all" uses as numerator the sum of differences
between the maximum centrality score for the mode
against all other centrality scores in the network,
whereas "in" uses as numerator the sum of differences
between the maximum centrality score for the mode
against only the centrality scores of the other nodes in that mode.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tie1</code></td>
<td>
<p>Character string indicating the first uniplex network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tie2</code></td>
<td>
<p>Character string indicating the second uniplex network.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A single centralization score if the object was one-mode,
and two centralization scores if the object was two-mode.
</p>
<p>Depending on how and what kind of an object is passed to the function,
the function will return a <code>tidygraph</code> object where the nodes have been updated
</p>


<h3>Leverage centrality</h3>

<p>Leverage centrality concerns the degree of a node compared with that of its
neighbours, <code class="reqn">J</code>:
</p>
<p style="text-align: center;"><code class="reqn">C_L(i) = \frac{1}{deg(i)} \sum_{j \in J(i)} \frac{deg(i) - deg(j)}{deg(i) + deg(j)}</code>
</p>



<h3>References</h3>



<h4>On multimodal centrality</h4>

<p>Faust, Katherine. 1997.
"Centrality in affiliation networks."
<em>Social Networks</em> 19(2): 157-191.
<a href="https://doi.org/10.1016/S0378-8733%2896%2900300-0">doi:10.1016/S0378-8733(96)00300-0</a>
</p>
<p>Borgatti, Stephen P., and Martin G. Everett. 1997.
"Network analysis of 2-mode data."
<em>Social Networks</em> 19(3): 243-270.
<a href="https://doi.org/10.1016/S0378-8733%2896%2900301-2">doi:10.1016/S0378-8733(96)00301-2</a>
</p>
<p>Borgatti, Stephen P., and Daniel S. Halgin. 2011.
"Analyzing affiliation networks."
In <em>The SAGE Handbook of Social Network Analysis</em>,
edited by John Scott and Peter J. Carrington, 417–33.
London, UK: Sage.
<a href="https://doi.org/10.4135/9781446294413.n28">doi:10.4135/9781446294413.n28</a>
</p>



<h4>On strength centrality</h4>

<p>Opsahl, Tore, Filip Agneessens, and John Skvoretz. 2010.
"Node centrality in weighted networks: Generalizing degree and shortest paths."
<em>Social Networks</em> 32, 245-251.
<a href="https://doi.org/10.1016/j.socnet.2010.03.006">doi:10.1016/j.socnet.2010.03.006</a>
</p>



<h4>On signed centrality</h4>

<p>Everett, Martin G., and Stephen P. Borgatti. 2014.
“Networks Containing Negative Ties.”
<em>Social Networks</em> 38:111–20.
<a href="https://doi.org/10.1016/j.socnet.2014.03.005">doi:10.1016/j.socnet.2014.03.005</a>
</p>



<h4>On leverage centrality</h4>

<p>Joyce, Karen E., Paul J. Laurienti, Jonathan H. Burdette, and Satoru Hayasaka. 2010.
"A New Measure of Centrality for Brain Networks".
<em>PLoS ONE</em> 5(8): e12200.
<a href="https://doi.org/10.1371/journal.pone.0012200">doi:10.1371/journal.pone.0012200</a>
</p>



<h3>See Also</h3>

<p><code>to_undirected()</code> for removing edge directions
and <code>to_unweighted()</code> for removing weights from a graph.
</p>
<p>Other centrality: 
<code>measure_central_between</code>,
<code>measure_central_close</code>,
<code>measure_central_eigen</code>
</p>
<p>Other measures: 
<code>measure_attributes</code>,
<code>measure_central_between</code>,
<code>measure_central_close</code>,
<code>measure_central_eigen</code>,
<code>measure_closure</code>,
<code>measure_cohesion</code>,
<code>measure_diffusion_infection</code>,
<code>measure_diffusion_net</code>,
<code>measure_diffusion_node</code>,
<code>measure_features</code>,
<code>measure_heterogeneity</code>,
<code>measure_hierarchy</code>,
<code>measure_holes</code>,
<code>measure_periods</code>,
<code>measure_properties</code>,
<code>member_diffusion</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">node_degree(ison_southern_women)
tie_degree(ison_adolescents)
net_degree(ison_southern_women, direction = "in")
</code></pre>


</div>