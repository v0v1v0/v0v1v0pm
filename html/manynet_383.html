<div class="container">

<table style="width: 100%;"><tr>
<td>member_equivalence</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Equivalence clustering algorithms</h2>

<h3>Description</h3>

<p>These functions combine an appropriate <code style="white-space: pre;">⁠node_by_*()⁠</code> function
together with methods for calculating the hierarchical clusters
provided by a certain distance calculation.
</p>

<ul><li> <p><code>node_in_equivalence()</code> assigns nodes membership based on their equivalence
with respective to some census/class.
The following functions call this function, together with an appropriate census.
</p>

<ul>
<li> <p><code>node_in_structural()</code> assigns nodes membership based on their
having equivalent ties to the same other nodes.
</p>
</li>
<li> <p><code>node_in_regular()</code> assigns nodes membership based on their
having equivalent patterns of ties.
</p>
</li>
<li> <p><code>node_in_automorphic()</code> assigns nodes membership based on their
having equivalent distances to other nodes.
</p>
</li>
</ul>
</li></ul>
<p>A <code>plot()</code> method exists for investigating the dendrogram
of the hierarchical cluster and showing the returned cluster
assignment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">node_in_equivalence(
  .data,
  census,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)

node_in_structural(
  .data,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)

node_in_regular(
  .data,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)

node_in_automorphic(
  .data,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li>
<p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li>
<p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li>
<p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li>
<p> network, from the <code>{network}</code> package
</p>
</li>
<li>
<p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>census</code></td>
<td>
<p>A matrix returned by a <code style="white-space: pre;">⁠node_by_*()⁠</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Typically a character string indicating which method
should be used to select the number of clusters to return.
By default <code>"silhouette"</code>, other options include <code>"elbow"</code> and <code>"strict"</code>.
<code>"strict"</code> returns classes with members only when strictly equivalent.
<code>"silhouette"</code> and <code>"elbow"</code> select classes based on the distance between
clusters or between nodes within a cluster.
Fewer, identifiable letters, e.g. <code>"e"</code> for elbow, is sufficient.
Alternatively, if <code>k</code> is passed an integer, e.g. <code>k = 3</code>,
then all selection routines are skipped in favour of this number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Character string indicating whether clusters should be
clustered hierarchically (<code>"hierarchical"</code>) or
through convergence of correlations (<code>"concor"</code>).
Fewer, identifiable letters, e.g. <code>"c"</code> for CONCOR, is sufficient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>Character string indicating which distance metric
to pass on to <code>stats::dist</code>.
By default <code>"euclidean"</code>, but other options include
<code>"maximum"</code>, <code>"manhattan"</code>, <code>"canberra"</code>, <code>"binary"</code>, and <code>"minkowski"</code>.
Fewer, identifiable letters, e.g. <code>"e"</code> for Euclidean, is sufficient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>Integer indicating the maximum number of (k) clusters
to evaluate.
Ignored when <code>k = "strict"</code> or a discrete number is given for <code>k</code>.</p>
</td>
</tr>
</table>
<h3>Source</h3>

<p><a href="https://github.com/aslez/concoR">https://github.com/aslez/concoR</a>
</p>


<h3>See Also</h3>

<p>Other memberships: 
<code>mark_core</code>,
<code>member_brokerage</code>,
<code>member_cliques</code>,
<code>member_community_hier</code>,
<code>member_community_non</code>,
<code>member_components</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
(nse &lt;- node_in_structural(ison_algebra))
if(require("ggdendro", quietly = TRUE)){
plot(nse)
}


(nre &lt;- node_in_regular(ison_southern_women,
  cluster = "concor"))
if(require("ggdendro", quietly = TRUE)){
plot(nre)
}


if(require("sna", quietly = TRUE)){
(nae &lt;- node_in_automorphic(ison_southern_women,
  k = "elbow"))
}
if(require("ggdendro", quietly = TRUE)){
plot(nae)
}

</code></pre>


</div>