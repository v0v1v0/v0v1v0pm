<div class="container">

<table style="width: 100%;"><tr>
<td>measure_diffusion_node</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Measures of nodes in a diffusion</h2>

<h3>Description</h3>

<p>These functions allow measurement of various features of
a diffusion process:
</p>

<ul>
<li> <p><code>node_adoption_time()</code>: Measures the number of time steps until
nodes adopt/become infected
</p>
</li>
<li> <p><code>node_thresholds()</code>: Measures nodes' thresholds from the amount
of exposure they had when they became infected
</p>
</li>
<li> <p><code>node_infection_length()</code>: Measures the average length nodes that become
infected remain infected in a compartmental model with recovery
</p>
</li>
<li> <p><code>node_exposure()</code>: Measures how many exposures nodes have to
a given mark
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">node_adoption_time(diff_model)

node_thresholds(diff_model, normalized = TRUE, lag = 1)

node_recovery(diff_model)

node_exposure(.data, mark, time = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>diff_model</code></td>
<td>
<p>A valid network diffusion model,
as created by <code>as_diffusion()</code> or <code>play_diffusion()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag</code></td>
<td>
<p>The number of time steps back upon which the thresholds are
inferred.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li>
<p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li>
<p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li>
<p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li>
<p> network, from the <code>{network}</code> package
</p>
</li>
<li>
<p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mark</code></td>
<td>
<p>A valid 'node_mark' object or
logical vector (TRUE/FALSE) of length equal to
the number of nodes in the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>A time point until which infections/adoptions should be
identified. By default <code>time = 0</code>.</p>
</td>
</tr>
</table>
<h3>Adoption time</h3>

<p><code>node_adoption_time()</code> measures the time units it took
until each node became infected.
Note that an adoption time of 0 indicates that this was a seed node.
</p>


<h3>Thresholds</h3>

<p><code>node_thresholds()</code> infers nodes' thresholds based on how much
exposure they had when they were infected.
This inference is of course imperfect,
especially where there is a sudden increase in exposure,
but it can be used heuristically.
In a threshold model,
nodes activate when <code class="reqn">\sum_{j:\text{active}} w_{ji} \geq \theta_i</code>,
where <code class="reqn">w</code> is some (potentially weighted) matrix,
<code class="reqn">j</code> are some already activated nodes,
and <code class="reqn">theta</code> is some pre-defined threshold value.
Where a fractional threshold is used, the equation is
<code class="reqn">\frac{\sum_{j:\text{active}} w_{ji}}{\sum_{j} w_{ji}} \geq \theta_i</code>.
That is, <code class="reqn">theta</code> is now a proportion,
and works regardless of whether <code class="reqn">w</code> is weighted or not.
</p>


<h3>Infection length</h3>

<p><code>node_infection_length()</code> measures the average length of time that nodes
that become infected remain infected in a compartmental model with recovery.
Infections that are not concluded by the end of the study period are
calculated as infinite.
</p>


<h3>Exposure</h3>

<p><code>node_exposure()</code> calculates the number of infected/adopting nodes
to which each susceptible node is exposed.
It usually expects network data and
an index or mark (TRUE/FALSE) vector of those nodes which are currently infected,
but if a diff_model is supplied instead it will return
nodes exposure at <code class="reqn">t = 0</code>.
</p>


<h3>References</h3>



<h4>On diffusion measures</h4>

<p>Valente, Tom W. 1995. <em>Network models of the diffusion of innovations</em>
(2nd ed.). Cresskill N.J.: Hampton Press.
</p>



<h3>See Also</h3>

<p>Other measures: 
<code>measure_attributes</code>,
<code>measure_central_between</code>,
<code>measure_central_close</code>,
<code>measure_central_degree</code>,
<code>measure_central_eigen</code>,
<code>measure_closure</code>,
<code>measure_cohesion</code>,
<code>measure_diffusion_infection</code>,
<code>measure_diffusion_net</code>,
<code>measure_features</code>,
<code>measure_heterogeneity</code>,
<code>measure_hierarchy</code>,
<code>measure_holes</code>,
<code>measure_periods</code>,
<code>measure_properties</code>,
<code>member_diffusion</code>
</p>
<p>Other diffusion: 
<code>make_play</code>,
<code>measure_diffusion_infection</code>,
<code>measure_diffusion_net</code>,
<code>member_diffusion</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  smeg &lt;- generate_smallworld(15, 0.025)
  smeg_diff &lt;- play_diffusion(smeg, recovery = 0.2)
  plot(smeg_diff)
  # To measure when nodes adopted a diffusion/were infected
  (times &lt;- node_adoption_time(smeg_diff))
  # To infer nodes' thresholds
  node_thresholds(smeg_diff)
  # To measure how long each node remains infected for
  node_recovery(smeg_diff)
  # To measure how much exposure nodes have to a given mark
  node_exposure(smeg, mark = c(1,3))
  node_exposure(smeg_diff)
</code></pre>


</div>