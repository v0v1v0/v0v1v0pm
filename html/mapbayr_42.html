<div class="container">

<table style="width: 100%;"><tr>
<td>mapbayest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate parameters (maximum a posteriori)</h2>

<h3>Description</h3>

<p>The main function of the mapbayr package. Performs a <em>maximum a posteriori</em> Bayesian estimation of parameters, from a mrgsolve model object and a dataset containing information about administrations and observed concentrations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mapbayest(
  x,
  data = NULL,
  method = c("L-BFGS-B", "newuoa"),
  hessian = stats::optimHess,
  select_eta = NULL,
  lambda = 1,
  lloq = NULL,
  force_initial_eta = NULL,
  quantile_bound = 0.001,
  control = list(),
  check = TRUE,
  verbose = TRUE,
  progress = TRUE,
  reset = 50,
  output = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the model object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>NMTRAN-like data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>optimization method; the default is <code>"L-BFGS-B"</code> (from <code>stat::optim()</code>), alternatively <code>"newuoa"</code> for <code>minqa::newuoa()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>function used to compute the Hessian and variance-covariance matrix with (default is <code>stats::optimHess</code>, alternatively use <code>nlmixr::nlmixrHess</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select_eta</code></td>
<td>
<p>a vector of numeric values, the numbers of the ETAs to be estimated (default is <code>NULL</code>, all ETAs non-equal to zero)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>a numeric value, the weight applied to the model prior (default is 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lloq</code></td>
<td>
<p>a numeric value, the lower limit of quantification. If not NULL, <code>LLOQ</code> and <code>BLQ</code> (below limit of quantification) variables will be added to the data. The related records will be censored with the M3 method. Ignored if <code>LLOQ</code> already in the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force_initial_eta</code></td>
<td>
<p>a vector of numeric values to start the estimation from (default to 0 for "L-BFGS-B")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantile_bound</code></td>
<td>
<p>a numeric value representing the quantile of the normal distribution admitted to define the bounds for L-BFGS-B (default is 0.001, i.e. 0.1%)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list passed to the optimizer (see <code>stats::optim()</code> or  <code>minqa::newuoa()</code> documentation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>check model code for mapbayr specification (a logical, default is <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>print a message whenever optimization is reset (a logical, default is <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>print a progress bar (a logical, default is <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reset</code></td>
<td>
<p>maximum allowed reset of the optimizer with new initial eta values if numerical difficulties, or with new bounds (L-BFGS-B) if estimate equal to a bound. (a numeric, default is 50)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>if <code>NULL</code> (the default) a mapbayests object is returned; if <code>df</code> a <em>mapbay_tab</em> dataframe is returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for compatibility (not used)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a mapbayests object. Basically a list containing:
</p>

<ul>
<li>
<p> model: the model object
</p>
</li>
<li>
<p> arg.ofv.optim, arg.ofv.fix, arg.ofv.id: arguments passed to the optimization function. Useful for debugging but not relevant for a basic usage. Access to the data with <code>get_data(x)</code>
</p>
</li>
<li>
<p> opt.value: the original output of the optimization function
</p>
</li>
<li>
<p> final_eta: a list of individual vectors of final estimates. Access it with <code>x$final_eta</code> or <code>get_eta(x)</code>.
</p>
</li>
<li>
<p> covariance: a list of individual variance-covariance matrix of estimation. Access it with <code>x$covariance</code> or <code>get_cov(x)</code>.
</p>
</li>
<li>
<p> mapbay_tab: an output table containing the results of your estimations (data, IPRED, PRED, covariates, captured items, ETA etc...). Access it with <code>x$mapbay_tab</code>, <code>as.data.frame(x)</code> or <code>as_tibble(x)</code>.
</p>
</li>
<li>
<p> information: run times and package versions.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>hist.mapbayests</code>
</p>
<p><code>plot.mapbayests</code>
</p>
<p><code>use_posterior</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># First, code a model
code1 &lt;- "$PARAM ETA1 = 0, ETA2 = 0,
KA = 0.5, TVCL = 1.1, TVV = 23.3
$OMEGA 0.41 0.32
$SIGMA 0.04 0
$CMT DEPOT CENT
$PK
double CL=TVCL*exp(ETA1+ETA(1));
double V=TVV*exp(ETA2+ETA(2)) ;
$ERROR
double DV=CENT/V*(1+EPS(1))+EPS(2);
$PKMODEL ncmt = 1, depot = TRUE
$CAPTURE DV CL
"

my_model &lt;- mrgsolve::mcode("my_model", code1)
# Then, import your data
my_data &lt;- data.frame(ID = 1, TIME = c(0, 1.1, 5.2, 12.3), EVID = c(1,0,0,0), AMT = c(500, 0,0,0),
 CMT = c(1,2,2,2), DV = c(0, 15.1, 29.5, 22.3))
print(my_data)

# And estimate
my_est &lt;- mapbayest(x = my_model, data = my_data)
print(my_est)
# see also plot(my_est) and hist(my_est)

# Use your estimation
get_eta(my_est)
get_param(my_est)
as.data.frame(my_est)
use_posterior(my_est)

</code></pre>


</div>