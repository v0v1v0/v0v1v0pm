<div class="container">

<table style="width: 100%;"><tr>
<td>add_heatmap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add Heatmap</h2>

<h3>Description</h3>

<p>The Heatmap Layer can be used to visualise spatial distribution of data.
It implements Gaussian Kernel Density Estimation to render the heatmaps.
</p>


<h3>Usage</h3>

<pre><code class="language-R">add_heatmap(
  map,
  data = get_map_data(map),
  lon = NULL,
  lat = NULL,
  polyline = NULL,
  weight = NULL,
  colour_range = NULL,
  radius_pixels = 30,
  intensity = 1,
  threshold = 0.05,
  layer_id = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>a mapdeck map object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lon</code></td>
<td>
<p>column containing longitude values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lat</code></td>
<td>
<p>column containing latitude values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polyline</code></td>
<td>
<p>optional column of <code>data</code> containing the polylines, if using encoded polylines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>the weight of each value. Default 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colour_range</code></td>
<td>
<p>vector of 6 hex colours</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius_pixels</code></td>
<td>
<p>Radius of the circle in pixels, to which the weight of an object is distributed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intensity</code></td>
<td>
<p>Value that is multiplied with the total weight at a pixel to
obtain the final weight. A value larger than 1 biases the output color towards
the higher end of the spectrum, and a value less than 1 biases the output
color towards the lower end of the spectrum</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>The HeatmapLayer reduces the opacity of the pixels with relatively
low weight to create a fading effect at the edge.
A larger threshold smoothens the boundaries of color blobs, while making pixels
with low relative weight harder to spot (due to low alpha value).
Threshold is defined as the ratio of the fading weight to the max weight, between 0 and 1.
For example, 0.1 affects all pixels with weight under 10% of the max.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>add_heatmap</code> supports POINT and MULTIPOINT sf objects
</p>


<h3>note</h3>

<p>The current version of this layer is supported only for WebGL2 enabled browswers
So you may find it doesn't render in the RStudio viewer.
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for heatmap
</p>
<p>list(
intensity = 0,
threshold = 0,
radius_pixels = 0
)
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

df &lt;- read.csv(paste0(
'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/',
'examples/3d-heatmap/heatmap-data.csv'
))

df &lt;- df[ !is.na(df$lng), ]
df$weight &lt;- sample(1:10, size = nrow(df), replace = TRUE)

mapdeck( style = mapdeck_style('dark'), pitch = 45 ) %&gt;%
add_heatmap(
  data = df
  , lat = "lat"
  , lon = "lng"
  , weight = "weight",
  , layer_id = "heatmap_layer"
)

## as an sf object
library(sfheaders)
sf &lt;- sfheaders::sf_point( df, x = "lng", y = "lat")

mapdeck( style = mapdeck_style('dark'), pitch = 45 ) %&gt;%
add_heatmap(
  data = sf
  , weight = "weight",
  , layer_id = "heatmap_layer"
)



</code></pre>


</div>