<div class="container">

<table style="width: 100%;"><tr>
<td>estimate_shift</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimating range shifts</h2>

<h3>Description</h3>

<p>Estimation and helper functions for nls fit of migration model
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimate_shift(T, X, Y, n.clust = 2, p.m0 = NULL, dt0 = min(5,
  diff(range(T))/20), method = c("ar", "like")[1], CI = TRUE, nboot = 100,
  model = NULL, area.direct = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>
<p>time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>x coordinate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>y coordinate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.clust</code></td>
<td>
<p>the number of ranges to estimate.  Two is relatively easy and robust, and three works fairly will (with good initial guesses).  More can be prohibitively slow.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.m0</code></td>
<td>
<p>initial parameter guesses - a named vector with (e.g.) elements x1, x2, y1, y2, t1, dt.  It helps if this is close - the output of <code>quickfit</code> can be helpful, as can plotting the curve and using <code>locator</code>. If left as NULL, the function will make some guesses for you - starting with <code>quickfit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt0</code></td>
<td>
<p>initial guess for duration of migration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>one of 'ar' or 'like' (case insenstive), whether or not to use the AR equivalence method (faster, needs regular data - with some tolerance for gaps) or Likelihood method, which is slower but robust for irregular data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CI</code></td>
<td>
<p>whether or not to estimate confidence intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboot</code></td>
<td>
<p>number of bootstraps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>one of "MWN", "MOU" or "MOUF" (case insensitive).  By default, the algorithm selects the best one according to AIC using the <code>selectModel</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>area.direct</code></td>
<td>
<p>passed as direct argument to getArea</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This algorithm minimizes the square of the distance of the locations from a double-headed hockeystick curve, then estimates the times scale using the ARMA/AR models.  Confidence intervals are obtained by bootstrapping the data and reestimating. See example and vignette for implementation.
</p>


<h3>Value</h3>

<p>a list with the following elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>T,X,Y</code></td>
<td>
<p>Longitude coordinate with NA at prediction times</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.hat</code></td>
<td>
<p>Point estimates of parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.CI</code></td>
<td>
<p>Data frame of parameter estimates with (approximate) confidence intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>One of "wn", "ou" or "ouf" - the selected model for the residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>The hessian of the mean parameters.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># load simulated tracks
data(SimulatedTracks)

# white noise fit
MWN.fit &lt;- with(MWN.sim, estimate_shift(T=T, X=X, Y=Y))
summary(MWN.fit)
plot(MWN.fit)

if(interactive()){
# OUF fit
MOUF.fit &lt;- with(MOUF.sim.random, 
                estimate_shift(T=T, X=X, Y=Y, 
                               model = "ouf", 
                               method = "like"))
summary(MOUF.fit)
plot(MOUF.fit)

# Three range fit:
# it is helpful to have some initital values for these parameters 
# because the automated quickfit() method is unreliable for three ranges
# in the example, we set a seed that seems to work
# set.seed(1976)

 MOU.3range.fit &lt;- with(MOU.3range, 
                       estimate_shift(T=T, X=X, Y=Y, 
                                      model = "ou", 
                                      method = "ar", 
                                      n.clust = 3))
 summary(MOU.3range.fit)
 plot(MOU.3range.fit)
}
</code></pre>


</div>