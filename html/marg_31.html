<div class="container">

<table style="width: 100%;"><tr>
<td>rsm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit a Regression-Scale Model
</h2>

<h3>Description</h3>

<p>Produces an object of class <code>rsm</code> which is a regression-scale
model fit of the data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rsm(formula = formula(data), family = gaussian, 
    data = sys.frame(sys.parent()), dispersion = NULL, 
    weights = NULL, subset = NULL, na.action = na.fail, 
    offset = NULL, method = "rsm.surv", 
    control = glm.control(maxit=100, trace=FALSE), 
    model = FALSE, x = FALSE, y = TRUE, contrasts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>a formula expression as for other linear regression models, of the 
form <code>response ~ predictors</code> where the predictors are 
separated  by suitable operators.  See the documentation of 
<code>lm</code> and <code>formula</code> for details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>a <code>family.rsm</code> object, i.e. a list of functions and
expressions characterizing the error distribution.  Families
supported are <code>gaussian</code>, <code>student</code> (Student's t),
<code>extreme</code> (Gumbel or extreme value), <code>logistic</code>,
<code>logWeibull</code>, <code>logExponential</code>, <code>logRayleigh</code>
and <code>Huber</code> (Huber's least favourable).  These represent
calls to the corresponding generator functions.  The calls to
<code>gaussian</code>, <code>extreme</code>, <code>logistic</code>,
<code>logWeibull</code>, <code>logExponential</code> and <code>logRayleigh</code>
can be given without parentheses.  The functions <code>student</code>
and <code>Huber</code> may take as argument respectively the degrees
of freedom (<code>df</code>) and the tuning constant
(<code>k</code>).  Users can construct their own
families, as long as they have components compatible with those
given in <code>rsm.distributions</code>.  The demonstration file
‘<span class="file">margdemo.R</span>’ that ships with the package 
shows how to create a new generator function.  The default is
<code>gaussian</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an optional data frame in which to interpret the variables 
occurring in the model formula, or in the <code>subset</code> and the 
<code>weights</code> arguments.  If this is missing, then the variables 
in the formula should be on the search list. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dispersion</code></td>
<td>

<p>if <code>NULL</code>, the scale parameter is taken to be unknown.  If 
known, the numerical value can be passed.  The default is 
<code>NULL</code>.  Huber's least favourable distribution represents a 
special case.  If <code>dispersion</code> is <code>NULL</code>, the maximum 
likelihood estimate is computed, while if <code>TRUE</code> the 
<abbr><span class="acronym">MAD</span></abbr> estimate is calculated and the scale parameter fixed 
to this value in subsequent computations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>the optional weights for the fitting criterion.  If supplied, the
response variable and the covariates are multiplied by the weights
in the <abbr><span class="acronym">IRLS</span></abbr> algorithm.  The length of the <code>weights</code>
argument must be the same as the number of observations.  The 
weights must be nonnegative and it is strongly recommended that 
they be strictly positive, since zero weights are ambiguous, 
compared to use of the <code>subset</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>

<p>expression saying which subset of the rows of the data should be 
used in the fit.  This can be a logical vector (which is 
replicated to have length equal to the number of observations), or 
a numeric vector indicating which observation numbers are to be 
included, or a character vector of the row names to be included.  
All observations are included by default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>a function to filter missing data.  This is applied to the model 
frame after any <code>subset</code> argument has been used.  The 
default (with <code>na.fail</code>) is to create an error if any missing 
value is found.  A possible alternative is <code>na.omit</code>, which 
deletes observations that contain one or more missing values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>

<p>this can be used to specify an <em>a priori</em> known component to
be included in the linear predictor during fitting.  An 
<code>offset</code> term can be included in the formula instead or as 
well, and if both are specified their sum is used.  Defaults to
<code>NULL</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>the fitting method to be used; the default is <code>rsm.fit</code>.  The
method <code>model.frame</code> simply returns the model frame.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>a list of iteration and algorithmic constants.  See 
<code>glm.control</code> for their names and default values. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>if <code>TRUE</code>, the model frame is returned; default is 
<code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>if <code>TRUE</code>, the model matrix is returned; default is 
<code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>if <code>TRUE</code>, the response variable is returned; default is 
<code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>

<p>a list of contrasts to be used for some or all of the factors
appearing as variables in the model formula.  The names of the 
list should be the names of the corresponding variables, and the 
elements should either be contrast-type matrices (matrices with 
as many rows as levels of the factor and with columns linearly 
independent of each other and of a column of one's), or else 
they should be functions that compute such contrast matrices.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model is fitted using <em>Iteratively Reweighted Least 
Squares</em>, <abbr><span class="acronym">IRLS</span></abbr> for short (<cite>Green, 1984</cite>, 
<cite>Jorgensen, 1984</cite>).  The working response and iterative 
weights are computed using the functions contained in the 
<code>family.rsm</code> object.  
</p>
<p>The two workhorses of <code>rsm</code> are <code>rsm.fit</code> and 
<code>rsm.surv</code>, which expect an <code>X</code> and <code>Y</code> 
argument rather then a formula.  The first function is used for the 
families <code>student</code> with <code>df</code> <code class="reqn">&lt;</code> 3 and 
<code>Huber</code>; 
the second one, based on the <code>survreg.fit</code> 
routine for fitting parametric survival models, is used in case of 
<code>extreme</code>, <code>logistic</code>, <code>logWeibull</code>, 
<code>logExponential</code>, <code>logRayleigh</code> and <code>student</code> (with 
<code>df</code> &gt; 2) error distributions.  In the presence of a 
user-defined error distribution the <code>rsm.fit</code> routine is used.
The <code>rsm.null</code> function is invoked to fit an empty (null)
model.
</p>
<p>The details are given in <cite>Brazzale (2000, Section 6.3.1)</cite>.
</p>


<h3>Value</h3>

<p>an object of class <code>rsm</code> is returned which inherits from 
<code>glm</code> and <code>lm</code>.  See <code>rsm.object</code> for details.
</p>
<p>The output can be examined by <code>print</code>, 
<code>summary</code>, <code>rsm.diag.plots</code> and 
<code>anova</code>.  Components can be extracted using 
<code>fitted</code>, <code>residuals</code>, 
<code>formula</code> and <code>family</code>.  It can 
be modified using <code>update</code>. It has most of the 
components of a <code>glm</code> object, with a few more.  Use 
<code>rsm.object</code> for further details.
</p>


<h3>Note</h3>

<p>In case of <code>extreme</code>, <code>logistic</code>, <code>logWeibull</code>,
<code>logExponential</code>, <code>logRayleigh</code> and <code>student</code> (with
<code>df</code> &gt; 2) error distributions, both methods,
<code>rsm.fit</code> (default choice) and
<code>rsm.surv</code>, can be used to fit the model.
There are, however, examples where one of the two algorithms (most 
likely the one invoked by <code>rsm.surv</code>) breaks 
down.  If this is the case, try and refit the model with the 
alternative choice.  
</p>









<p>The message <code>"negative iterative weights returned!"</code> is 
returned if some of the iterative weights (<code>q2</code> component of 
the fitted <code>rsm</code> object) are negative.  These would be used by 
default by the <code>rsm.diag</code> routine for the definition of 
residuals and regression diagnostics.  In order to avoid missing 
values (<code>NA</code>s), the default weighting scheme <code>"observed"</code> 
automatically switches to <code>"score"</code> unless otherwise specified.
</p>


<h3>References</h3>

<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.
</p>
<p>Green, P. J. (1984) Iteratively reweighted least squares for maximum 
likelihood estimation, and some robust and resistant alternatives 
(with Discussion).  <em>J. R. Statist. Soc. </em> B, <b>46</b>, 
149–192.
</p>
<p>Jorgensen, B. (1984) The delta algorithm and GLIM.  <em>Int. Stat.
Rev.</em>, <b>52</b>, 283–300.
</p>


<h3>See Also</h3>

<p><code>rsm.object</code>, <code>rsm.fit</code>, 
<code>rsm.surv</code>, <code>rsm.null</code>,
<code>rsm.families</code>  
</p>


<h3>Examples</h3>

<pre><code class="language-R">## House Price Data
data(houses)
houses.rsm &lt;- rsm(price ~ ., family = student(5), data = houses)
## model fit including all covariates
houses.rsm &lt;- rsm(price ~ ., family = student(5), data = houses, 
                  method = "rsm.fit", control = glm.control(trace = TRUE))
## prints information about the iterative procedure at each iteration
update(houses.rsm, ~ . - bdroom + offset(7 * bdroom))
## "bdroom" is included as offset variable with fixed (= 7) coefficient

## Sea Level Data
data(venice)
attach(venice)
Year &lt;- 1:51/51
venice.2.rsm &lt;- rsm(sea ~ Year + I(Year^2), family = extreme)
## quadratic model fitted to sea level data
venice.1.rsm &lt;- update(venice.2.rsm, ~. - I(Year^2))
## linear model fit
##
c11 &lt;- cos(2*pi*1:51/11) ; s11 &lt;- sin(2*pi*1:51/11)
c19 &lt;- cos(2*pi*1:51/18.62) ; s19 &lt;- sin(2*pi*1:51/18.62)
venice.rsm &lt;- rsm(sea ~ Year + I(Year^2) + c11 + s11 + c19 + s19, 
                  family = extreme)
## includes 18.62-year astronomical tidal cycle and 11-year sunspot cycle
venice.11.rsm &lt;- rsm(sea ~ Year + I(Year^2) + c11 + s11, family = extreme)
venice.19.rsm &lt;- rsm(sea ~ Year + I(Year^2) + c19 + s19, family = extreme)
## includes either astronomical cycle
##
## comparison of linear, quadratic and periodic (11-year, 19-year) models 
plot(year, sea, ylab = "sea level") 
lines(year, fitted(venice.1.rsm))
lines(year, fitted(venice.2.rsm), col="red")
lines(year, fitted(venice.11.rsm), col="blue")
lines(year, fitted(venice.19.rsm), col="green")
##
detach()

## Darwin's Data on Growth Rates of Plants
data(darwin)
darwin.rsm &lt;- rsm(cross - self ~ pot - 1, family  =  student(3), 
                  data = darwin)
## Maximum likelihood estimates
darwin.rsm &lt;- rsm(cross - self ~ pot - 1, family = Huber, data = darwin)
## M-estimates
</code></pre>


</div>