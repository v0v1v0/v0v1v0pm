<div class="container">

<table style="width: 100%;"><tr>
<td>cond.rsm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Approximate Conditional Inference in Regression-Scale Models
</h2>

<h3>Description</h3>

<p>Performs approximate conditional inference on a scalar parameter of 
interest in regression-scale models.  The output is stored in an 
object of class <code>marg</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'rsm'
cond(object, offset, formula = NULL, family = NULL, 
     dispersion = NULL, data = sys.frame(sys.parent()), pts = 20, 
     n = max(100, 2*pts), tms = 0.6, from = NULL, to = NULL, 
     control = glm.control(...), trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>a <code>rsm</code> object; for instance the result of a call to 
<code>rsm</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>

<p>either the covariate occurring in the model formula whose 
coefficient represents the parameter of interest or <code>scale</code> 
if the parameter of interest is the scale parameter.  In the first 
case, the variable may be numerical or a two-level factor.  In case
of a two-level factor, it must be coded by contrasts and not as two
dummy variables.  Can also be a call to a mathematical function 
(such as <code>exp</code>, <code>sin</code>, ...) or to a mathematical 
operator (<code>^</code>, <code>/</code>, ...) applied to a numerical 
variable.  The call must always agree with the label used to identify
the corresponding parameter in the <code>rsm</code> object passed through
the <code>object</code> argument or defined by <code>formula</code> and 
<code>family</code>.  Beware that the label includes the identity 
function <code>I()</code> if an arithmetic operator was used.  Other 
function types (e.g. <code>factor</code>) and interactions are not 
admitted.  If interest focuses on the scale parameter, it must not
be fixed in <code>object</code> or when using the <code>dispersion</code> 
argument in case no <code>rsm</code> object is supplied. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>a formula expression (only if no <code>rsm</code> object is defined).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>a <code>family.rsm</code> object defining the error distribution (only if
no <code>rsm</code> object is defined).  See <code>rsm.families</code> 
for the families supported. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dispersion</code></td>
<td>

<p>argument only to be used if no <code>rsm</code> object is defined.  If 
<code>NULL</code>, the scale parameter is taken to be unknown.  If known,
the numerical value can be passed.  The default is <code>NULL</code>.  
Huber's least favourable error distribution represents a special 
case.  If <code>dispersion</code> is <code>NULL</code>,  the maximum likelihood
estimate is computed, while if <code>TRUE</code> the <abbr><span class="acronym">MAD</span></abbr> 
estimate is calculated and the scale parameter fixed to this value
in subsequent computations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an optional data frame in which to interpret the variables 
occurring in the formula (only if no <code>rsm</code> object is defined).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pts</code></td>
<td>

<p>number of output points (minimum 10) that are calculated exactly; 
the default is 20. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>approximate number of output points (minimum 50) produced by the 
spline interpolation.  The default is the maximum between 100 and 
twice <code>pts</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tms</code></td>
<td>

<p>defines the range <abbr><span class="acronym">MLE</span></abbr> +/- <code>tms</code> * <abbr><span class="acronym">s.e.</span></abbr> 
where cubic spline interpolation is replaced by polynomial 
interpolation.  The default is 0.6.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>

<p>starting value of the sequence that contains the values of the 
parameter of interest for which output points are calculated 
exactly.  The default is <abbr><span class="acronym">MLE</span></abbr> - 3.5 * <abbr><span class="acronym">s.e.</span></abbr>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>

<p>ending value of the sequence that contains the values of the 
parameter of interest for which output points are calculated 
exactly.  The default is <abbr><span class="acronym">MLE</span></abbr> + 3.5 * <abbr><span class="acronym">s.e</span></abbr>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>a list of iteration and algorithmic constants that control the 
<code>rsm</code> fit.  See <code>glm.control</code> for their names and
default values.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>

<p>if <code>TRUE</code>, iteration numbers will be printed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments, such as <code>weights</code>, <code>subset</code>, 
<code>control</code> etc. used by the <code>rsm</code> fitting routine if the 
<code>rsm</code> object is defined through <code>formula</code> and
<code>family</code>.  See <code>rsm</code> for their definition and use.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is a method for the generic function <code>cond</code>
for class <code>rsm</code>.  It can be invoked by calling <code>cond</code> for 
an object of the appropriate class, or directly by calling 
<code>cond.rsm</code> regardless of the class of the object.  
<code>cond.rsm</code> has also to be used if the <code>rsm</code> object is not 
provided throught the <code>object</code> argument but specified by 
<code>formula</code> and <code>family</code>.
</p>
<p>The function <code>cond.rsm</code> implements several small sample 
asymptotic methods for approximate conditional inference in 
regression-scale models.  Approximations for both the modified/marginal 
log likelihood function and approximate conditional/marginal tail 
probabilities are 
available (see <code>marg.object</code> for details).  Attention is
restricted to a scalar parameter of interest, either a regression 
coefficient or the scale parameter.  In the first case, the 
associated covariate may be either numerical or a two-level factor. 
</p>
<p>Approximate conditional (or equivalently marginal) inference is performed 
by either updating a 
fitted regression-scale model or defining the model formula and 
family.  All approximations are calculated exactly for <code>pts</code> 
equally spaced points ranging from <code>from</code> to <code>to</code>.  A 
spline interpolation is used to extend them over the whole interval 
of interest, except for the range of values defined by <abbr><span class="acronym">MLE</span></abbr>
+/- <code>tms</code> * <abbr><span class="acronym">s.e.</span></abbr> where the spline interpolation is 
replaced by a higher order polynomial interpolation.  This is done 
in order to avoid numerical instabilities which are likely to occur
for values of the parameter of interest close to the <abbr><span class="acronym">MLE</span></abbr>.  
Results 
are stored in an object of class <code>marg</code>.  Method functions 
like <code>print</code>, <code>summary</code> and 
<code>plot</code> can be used to examine the output or 
represent it graphically.  Components can be extracted using 
<code>coef</code>, <code>formula</code> and 
<code>family</code>.
</p>
<p>Main references for the methods considered are the papers by 
<cite>Barndorff-Nielsen (1991)</cite>, <cite>DiCiccio, Field and Fraser 
(1990)</cite> and <cite>DiCiccio and Field (1991)</cite>.  The theory and 
statistics used are summarized in <cite>Brazzale (2000, Chapters 2 
and 3)</cite>.  More details of the implementation are given in 
<cite>Brazzale (1999; 2000, Section 6.3.1)</cite>.
</p>


<h3>Value</h3>

<p>The returned value is an object of class <code>marg</code>; see 
<code>marg.object</code> for details.
</p>


<h3>Note</h3>

<p>If the parameter of interest is the scale parameter, all calculations
are performed on the logarithmic scale, though most results are 
reported on the original scale.  
</p>
<p>In rare occasions, <code>cond.rsm</code> dumps because of non-convergence 
of the function <code>rsm</code> which is used to refit the model 
for a fixed value of the parameter of interest.  This happens for 
instance if this value is too extreme.  The arguments <code>from</code> 
and <code>to</code> may then be used to limit the default range of 
<abbr><span class="acronym">MLE</span></abbr> +/- 3.5 * <abbr><span class="acronym">s.e.</span></abbr>  A further possibility is to
fine-tuning the constants (number of iterations, convergence
threshold) that control the <code>rsm</code> fit through the 
<code>control</code> argument. 
</p>
<p><code>cond.rsm</code> may also dump if the estimate of the parameter of 
interest is large (tipically &gt; 400) in absolute value.  This may be 
avoided by reparametrizing the model.
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. E. (1991) Modified signed log likelihood ratio.
<em>Biometrika</em>, <b>78</b>, 557–564.
</p>
<p>Brazzale, A. R. (1999) Approximate conditional inference for logistic
and loglinear models.  <em>J. Comput. Graph. Statist.</em>, <b>8</b>,
653–661.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.
</p>
<p>DiCiccio, T. J., Field, C. A. and Fraser, D. A. S. (1990) 
Approximations of marginal tail probabilities and inference for 
scalar parameters.  <em>Biometrika</em>, <b>77</b>, 77–95.
</p>
<p>DiCiccio, T. J. and Field, C. A. (1991) An accurate method for
approximate conditional and Bayesian inference about linear 
regression models from censored data.  <em>Biometrika</em>, <b>78</b>,
903–910.
</p>


<h3>See Also</h3>

<p><code>marg.object</code>, <code>summary.marg</code>,
<code>plot.marg</code>, <code>rsm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Sea Level Data
data(venice)
attach(venice)
Year &lt;- 1:51/51
c11 &lt;- cos(2*pi*1:51/11) ; s11 &lt;- sin(2*pi*1:51/11)
c19 &lt;- cos(2*pi*1:51/18.62) ; s19 &lt;- sin(2*pi*1:51/18.62)
##
## quadratic model fitted to the sea level, includes 18.62-year 
## astronomical tidal cycle and 11-year sunspot cycle
venice.rsm &lt;- rsm(sea ~ Year + I(Year^2) + c11 + s11 + c19 + s19, 
                  family = extreme)
names(coef(venice.rsm))
## "(Intercept)"  "Year"  "I(Year^2)"  "c11"  "s11"  "c19"  "s19"      
##
## variable of interest: quadratic term
venice.marg &lt;- cond(venice.rsm, I(Year^2))
##
detach()

## House Price Data
data(houses)
houses.rsm &lt;- rsm(price ~ ., family = student(5), data = houses)
##
## parameter of interest: scale parameter
houses.marg &lt;- cond(houses.rsm, scale)
</code></pre>


</div>