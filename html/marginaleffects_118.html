<div class="container">

<table style="width: 100%;"><tr>
<td>hypotheses</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>(Non-)Linear Tests for Null Hypotheses, Joint Hypotheses, Equivalence, Non Superiority, and Non Inferiority</h2>

<h3>Description</h3>

<p>Uncertainty estimates are calculated as first-order approximate standard errors for linear or non-linear functions of a vector of random variables with known or estimated covariance matrix. In that sense, <code>hypotheses</code> emulates the behavior of the excellent and well-established car::deltaMethod and car::linearHypothesis functions, but it supports more models; requires fewer dependencies; expands the range of tests to equivalence and superiority/inferiority; and offers convenience features like robust standard errors.
</p>
<p>To learn more, read the hypothesis tests vignette, visit the
package website, or scroll down this page for a full list of vignettes:
</p>

<ul>
<li> <p><a href="https://marginaleffects.com/vignettes/hypothesis.html">https://marginaleffects.com/vignettes/hypothesis.html</a>
</p>
</li>
<li> <p><a href="https://marginaleffects.com/">https://marginaleffects.com/</a>
</p>
</li>
</ul>
<p>Warning #1: Tests are conducted directly on the scale defined by the <code>type</code> argument. For some models, it can make sense to conduct hypothesis or equivalence tests on the <code>"link"</code> scale instead of the <code>"response"</code> scale which is often the default.
</p>
<p>Warning #2: For hypothesis tests on objects produced by the <code>marginaleffects</code> package, it is safer to use the <code>hypothesis</code> argument of the original function.  Using <code>hypotheses()</code> may not work in certain environments, in lists, or when working programmatically with *apply style functions.
</p>
<p>Warning #3: The tests assume that the <code>hypothesis</code> expression is (approximately) normally distributed, which for non-linear functions of the parameters may not be realistic. More reliable confidence intervals can be obtained using the <code>inferences()</code> function with <code>method = "boot"</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hypotheses(
  model,
  hypothesis = NULL,
  vcov = NULL,
  conf_level = 0.95,
  df = NULL,
  equivalence = NULL,
  joint = FALSE,
  joint_test = "f",
  numderiv = "fdforward",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Model object or object generated by the <code>comparisons()</code>, <code>slopes()</code>, or <code>predictions()</code> functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a numeric value, vector, or matrix; a string equation; string; a formula, or a function.
</p>

<ul>
<li>
<p> Numeric:
</p>

<ul>
<li>
<p> Single value: the null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li>
<p> Vector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the <code>hypothesis</code> argument.
</p>
</li>
<li>
<p> Matrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.
</p>
</li>
</ul>
</li>
<li>
<p> String equation to specify linear or non-linear hypothesis tests. If the <code>term</code> column uniquely identifies rows, terms can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">⁠b*⁠</code> wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">⁠b* / b1 = 1⁠</code>
</p>
</li>
</ul>
</li>
<li>
<p> String:
</p>

<ul>
<li>
<p> "pairwise": pairwise differences between estimates in each row.
</p>
</li>
<li>
<p> "reference": differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li>
<p> "sequential": difference between an estimate and the estimate in the next row.
</p>
</li>
<li>
<p> "meandev": difference between an estimate and the mean of all estimates.
</p>
</li>
<li>
<p> "meanotherdev": difference between an estimate and the mean of all other estimates, excluding the current one.
</p>
</li>
<li>
<p> "revpairwise", "revreference", "revsequential": inverse of the corresponding hypotheses, as described above.
</p>
</li>
</ul>
</li>
<li>
<p> Formula:
</p>

<ul>
<li> <p><code>comparison ~ pairs | group</code>
</p>
</li>
<li>
<p> Left-hand side determines the type of comparison to conduct: <code>difference</code> or <code>ratio</code>. If the left-hand side is empty, <code>difference</code> is chosen.
</p>
</li>
<li>
<p> Right-hand side determines the pairs of estimates to compare: <code>reference</code>, <code>sequential</code>, or <code>meandev</code>
</p>
</li>
<li>
<p> Optional: Users can supply grouping variables after a vertical bar to conduct comparisons withing subsets.
</p>
</li>
<li>
<p> Examples:
</p>

<ul>
<li> <p><code>~ reference</code>
</p>
</li>
<li> <p><code>ratio ~ pairwise</code>
</p>
</li>
<li> <p><code>difference ~ pairwise | groupid</code>
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p> Function:
</p>

<ul>
<li>
<p> Accepts an argument <code>x</code>: object produced by a <code>marginaleffects</code> function or a data frame with column <code>rowid</code> and <code>estimate</code>
</p>
</li>
<li>
<p> Returns a data frame with columns <code>term</code> and <code>estimate</code> (mandatory) and <code>rowid</code> (optional).
</p>
</li>
<li>
<p> The function can also accept optional input arguments: <code>newdata</code>, <code>by</code>, <code>draws</code>.
</p>
</li>
<li>
<p> This function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use <code>posterior_draws()</code> to extract and manipulate the draws directly.
</p>
</li>
</ul>
</li>
<li>
<p> See the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li>
<p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li>
<p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li>
<p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li>
<p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li>
<p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li>
<p> Mixed-Models degrees of freedom: "satterthwaite", "kenward-roger"
</p>
</li>
<li>
<p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li>
</ul>
</li>
<li>
<p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li>
<p> Square covariance matrix
</p>
</li>
<li>
<p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Degrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and <code>Inf</code>. When using <code>joint_test="f"</code>, the <code>df</code> argument should be a numeric vector of length 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>joint</code></td>
<td>
<p>Joint test of statistical significance. The null hypothesis value can be set using the <code>hypothesis</code> argument.
</p>

<ul>
<li>
<p> FALSE: Hypotheses are not tested jointly.
</p>
</li>
<li>
<p> TRUE: All parameters are tested jointly.
</p>
</li>
<li>
<p> String: A regular expression to match parameters to be tested jointly. <code>grep(joint, perl = TRUE)</code>
</p>
</li>
<li>
<p> Character vector of parameter names to be tested. Characters refer to the names of the vector returned by <code>coef(object)</code>.
</p>
</li>
<li>
<p> Integer vector of indices. Which parameters positions to test jointly.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>joint_test</code></td>
<td>
<p>A character string specifying the type of test, either "f" or "chisq". The null hypothesis is set by the <code>hypothesis</code> argument, with default null equal to 0 for all parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numderiv</code></td>
<td>
<p>string or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.
</p>

<ul>
<li>
<p> "fdforward": finite difference method with forward differences
</p>
</li>
<li>
<p> "fdcenter": finite difference method with central differences (default)
</p>
</li>
<li>
<p> "richardson": Richardson extrapolation method
</p>
</li>
<li>
<p> Extra arguments can be specified by passing a list to the <code>numDeriv</code> argument, with the name of the method first and named arguments following, ex: <code>numderiv=list("fdcenter", eps = 1e-5)</code>. When an unknown argument is used, <code>marginaleffects</code> prints the list of valid arguments for each method.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the "Model-Specific Arguments" section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td>
</tr>
</table>
<h3>Joint hypothesis tests</h3>

<p>The test statistic for the joint Wald test is calculated as (R * theta_hat - r)' * inv(R * V_hat * R') * (R * theta_hat - r) / Q,
where theta_hat is the vector of estimated parameters, V_hat is the estimated covariance matrix, R is a Q x P matrix for testing Q hypotheses on P parameters,
r is a Q x 1 vector for the null hypothesis, and Q is the number of rows in R. If the test is a Chi-squared test, the test statistic is not normalized.
</p>
<p>The p-value is then calculated based on either the F-distribution (for F-test) or the Chi-squared distribution (for Chi-squared test).
For the F-test, the degrees of freedom are Q and (n - P), where n is the sample size and P is the number of parameters.
For the Chi-squared test, the degrees of freedom are Q.
</p>


<h3>Equivalence, Inferiority, Superiority</h3>

<p><code class="reqn">\theta</code> is an estimate, <code class="reqn">\sigma_\theta</code> its estimated standard error, and <code class="reqn">[a, b]</code> are the bounds of the interval supplied to the <code>equivalence</code> argument.
</p>
<p>Non-inferiority:
</p>

<ul>
<li> <p><code class="reqn">H_0</code>: <code class="reqn">\theta \leq a</code>
</p>
</li>
<li> <p><code class="reqn">H_1</code>: <code class="reqn">\theta &gt; a</code>
</p>
</li>
<li> <p><code class="reqn">t=(\theta - a)/\sigma_\theta</code>
</p>
</li>
<li>
<p> p: Upper-tail probability
</p>
</li>
</ul>
<p>Non-superiority:
</p>

<ul>
<li> <p><code class="reqn">H_0</code>: <code class="reqn">\theta \geq b</code>
</p>
</li>
<li> <p><code class="reqn">H_1</code>: <code class="reqn">\theta &lt; b</code>
</p>
</li>
<li> <p><code class="reqn">t=(\theta - b)/\sigma_\theta</code>
</p>
</li>
<li>
<p> p: Lower-tail probability
</p>
</li>
</ul>
<p>Equivalence: Two One-Sided Tests (TOST)
</p>

<ul><li>
<p> p: Maximum of the non-inferiority and non-superiority p values.
</p>
</li></ul>
<p>Thanks to Russell V. Lenth for the excellent <code>emmeans</code> package and documentation which inspired this feature.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(marginaleffects)
mod &lt;- lm(mpg ~ hp + wt + factor(cyl), data = mtcars)

hypotheses(mod)

# Test of equality between coefficients
hypotheses(mod, hypothesis = "hp = wt")

# Non-linear function
hypotheses(mod, hypothesis = "exp(hp + wt) = 0.1")

# Robust standard errors
hypotheses(mod, hypothesis = "hp = wt", vcov = "HC3")

# b1, b2, ... shortcuts can be used to identify the position of the
# parameters of interest in the output of
hypotheses(mod, hypothesis = "b2 = b3")

# wildcard
hypotheses(mod, hypothesis = "b* / b2 = 1")

# term names with special characters have to be enclosed in backticks
hypotheses(mod, hypothesis = "`factor(cyl)6` = `factor(cyl)8`")

mod2 &lt;- lm(mpg ~ hp * drat, data = mtcars)
hypotheses(mod2, hypothesis = "`hp:drat` = drat")

# predictions(), comparisons(), and slopes()
mod &lt;- glm(am ~ hp + mpg, data = mtcars, family = binomial)
cmp &lt;- comparisons(mod, newdata = "mean")
hypotheses(cmp, hypothesis = "b1 = b2")

mfx &lt;- slopes(mod, newdata = "mean")
hypotheses(cmp, hypothesis = "b2 = 0.2")

pre &lt;- predictions(mod, newdata = datagrid(hp = 110, mpg = c(30, 35)))
hypotheses(pre, hypothesis = "b1 = b2")

# The `hypothesis` argument can be used to compute standard errors for fitted values
mod &lt;- glm(am ~ hp + mpg, data = mtcars, family = binomial)

f &lt;- function(x) predict(x, type = "link", newdata = mtcars)
p &lt;- hypotheses(mod, hypothesis = f)
head(p)

f &lt;- function(x) predict(x, type = "response", newdata = mtcars)
p &lt;- hypotheses(mod, hypothesis = f)
head(p)

# Complex aggregation
# Step 1: Collapse predicted probabilities by outcome level, for each individual
# Step 2: Take the mean of the collapsed probabilities by group and `cyl`
library(dplyr)
library(MASS)
library(dplyr)

dat &lt;- transform(mtcars, gear = factor(gear))
mod &lt;- polr(gear ~ factor(cyl) + hp, dat)

aggregation_fun &lt;- function(x) {
    predictions(x, vcov = FALSE) |&gt;
        mutate(group = ifelse(group %in% c("3", "4"), "3 &amp; 4", "5")) |&gt;
        summarize(estimate = sum(estimate), .by = c("rowid", "cyl", "group")) |&gt;
        summarize(estimate = mean(estimate), .by = c("cyl", "group")) |&gt;
        rename(term = cyl)
}

hypotheses(mod, hypothesis = aggregation_fun)

# Equivalence, non-inferiority, and non-superiority tests
mod &lt;- lm(mpg ~ hp + factor(gear), data = mtcars)
p &lt;- predictions(mod, newdata = "median")
hypotheses(p, equivalence = c(17, 18))

mfx &lt;- avg_slopes(mod, variables = "hp")
hypotheses(mfx, equivalence = c(-.1, .1))

cmp &lt;- avg_comparisons(mod, variables = "gear", hypothesis = "pairwise")
hypotheses(cmp, equivalence = c(0, 10))

# joint hypotheses: character vector
model &lt;- lm(mpg ~ as.factor(cyl) * hp, data = mtcars)
hypotheses(model, joint = c("as.factor(cyl)6:hp", "as.factor(cyl)8:hp"))

# joint hypotheses: regular expression
hypotheses(model, joint = "cyl")

# joint hypotheses: integer indices
hypotheses(model, joint = 2:3)

# joint hypotheses: different null hypotheses
hypotheses(model, joint = 2:3, hypothesis = 1)
hypotheses(model, joint = 2:3, hypothesis = 1:2)

# joint hypotheses: marginaleffects object
cmp &lt;- avg_comparisons(model)
hypotheses(cmp, joint = "cyl")

</code></pre>


</div>