<div class="container">

<table style="width: 100%;"><tr>
<td>sanitize_model_specific.glimML</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Method to raise model-specific warnings and errors</h2>

<h3>Description</h3>

<p>Method to raise model-specific warnings and errors
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'glimML'
sanitize_model_specific(model, ...)

## S3 method for class 'betareg'
sanitize_model_specific(model, ...)

sanitize_model_specific(model, ...)

## Default S3 method:
sanitize_model_specific(
  model,
  vcov = NULL,
  calling_function = "marginaleffects",
  ...
)

## S3 method for class 'brmsfit'
sanitize_model_specific(model, ...)

## S3 method for class 'bart'
sanitize_model_specific(model, ...)

## S3 method for class 'glmmTMB'
sanitize_model_specific(model, vcov = TRUE, re.form = NULL, ...)

## S3 method for class 'merMod'
sanitize_model_specific(model, re.form = NULL, ...)

## S3 method for class 'mblogit'
sanitize_model_specific(model, calling_function = "marginaleffects", ...)

## S3 method for class 'mlogit'
sanitize_model_specific(model, newdata, ...)

## S3 method for class 'clm'
sanitize_model_specific(model, ...)

## S3 method for class 'plm'
sanitize_model_specific(model, ...)

## S3 method for class 'plm'
sanitize_model_specific(model, ...)

## S3 method for class 'rqs'
sanitize_model_specific(model, ...)

## S3 method for class 'svyolr'
sanitize_model_specific(model, wts = FALSE, by = FALSE, ...)

## S3 method for class 'svyglm'
sanitize_model_specific(model, wts = FALSE, by = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Model object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the "Model-Specific Arguments" section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li>
<p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li>
<p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li>
<p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li>
<p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li>
<p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li>
<p> Mixed-Models degrees of freedom: "satterthwaite", "kenward-roger"
</p>
</li>
<li>
<p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li>
</ul>
</li>
<li>
<p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li>
<p> Square covariance matrix
</p>
</li>
<li>
<p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Grid of predictor values at which we evaluate the slopes.
</p>

<ul>
<li>
<p> Warning: Please avoid modifying your dataset between fitting the model and calling a <code>marginaleffects</code> function. This can sometimes lead to unexpected results.
</p>
</li>
<li> <p><code>NULL</code> (default): Unit-level slopes for each observed value in the dataset (empirical distribution). The dataset is retrieved using <code>insight::get_data()</code>, which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.
</p>
</li>
<li> <p><code>datagrid()</code> call to specify a custom grid of regressors. For example:
</p>

<ul>
<li> <p><code>newdata = datagrid(cyl = c(4, 6))</code>: <code>cyl</code> variable equal to 4 and 6 and other regressors fixed at their means or modes.
</p>
</li>
<li>
<p> See the Examples section and the <code>datagrid()</code> documentation.
</p>
</li>
</ul>
</li>
<li> <p><code>subset()</code> call with a single argument to select a subset of the dataset used to fit the model, ex: <code>newdata = subset(treatment == 1)</code>
</p>
</li>
<li> <p><code>dplyr::filter()</code> call with a single argument to select a subset of the dataset used to fit the model, ex: <code>newdata = filter(treatment == 1)</code>
</p>
</li>
<li>
<p> string:
</p>

<ul>
<li>
<p> "mean": Slopes evaluated when each predictor is held at its mean or mode.
</p>
</li>
<li>
<p> "median": Slopes evaluated when each predictor is held at its median or mode.
</p>
</li>
<li>
<p> "balanced": Slopes evaluated on a balanced grid with every combination of categories and numeric variables held at their means.
</p>
</li>
<li>
<p> "tukey": Slopes evaluated at Tukey's 5 numbers.
</p>
</li>
<li>
<p> "grid": Slopes evaluated on a grid of representative numbers (Tukey's 5 numbers and unique values of categorical predictors).
</p>
</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wts</code></td>
<td>
<p>logical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">⁠avg_*()⁠</code> or with the <code>by</code> argument, and not unit-level estimates. See <code>?weighted.mean</code>
</p>

<ul>
<li>
<p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li>
<p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li>
<li>
<p> FALSE: Equal weights.
</p>
</li>
<li>
<p> TRUE: Extract weights from the fitted object with <code>insight::find_weights()</code> and use them when taking weighted averages of estimates. Warning: <code>newdata=datagrid()</code> returns a single average weight, which is equivalent to using <code>wts=FALSE</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li>
<p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li>
<p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li>
<p> See examples below.
</p>
</li>
<li>
<p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A warning, an error, or nothing
</p>


</div>