<div class="container">

<table style="width: 100%;"><tr>
<td>datagrid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Data grids</h2>

<h3>Description</h3>

<p>Generate a data grid of user-specified values for use in the <code>newdata</code> argument of the <code>predictions()</code>, <code>comparisons()</code>, and <code>slopes()</code> functions. This is useful to define where in the predictor space we want to evaluate the quantities of interest. Ex: the predicted outcome or slope for a 37 year old college graduate.
</p>


<h3>Usage</h3>

<pre><code class="language-R">datagrid(
  ...,
  model = NULL,
  newdata = NULL,
  by = NULL,
  grid_type = "mean_or_mode",
  response = FALSE,
  FUN_character = NULL,
  FUN_factor = NULL,
  FUN_logical = NULL,
  FUN_numeric = NULL,
  FUN_integer = NULL,
  FUN_binary = NULL,
  FUN_other = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>named arguments with vectors of values or functions for user-specified variables.
</p>

<ul>
<li>
<p> Functions are applied to the variable in the <code>model</code> dataset or <code>newdata</code>, and must return a vector of the appropriate type.
</p>
</li>
<li>
<p> Character vectors are automatically transformed to factors if necessary.
+The output will include all combinations of these variables (see Examples below.)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Model object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>data.frame (one and only one of the <code>model</code> and <code>newdata</code> arguments can be used.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>character vector with grouping variables within which <code style="white-space: pre;">⁠FUN_*⁠</code> functions are applied to create "sub-grids" with unspecified variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_type</code></td>
<td>
<p>character. Determines the functions to apply to each variable. The defaults can be overridden by defining individual variables explicitly in <code>...</code>, or by supplying a function to one of the <code style="white-space: pre;">⁠FUN_*⁠</code> arguments.
</p>

<ul>
<li>
<p> "mean_or_mode": Character, factor, logical, and binary variables are set to their modes. Numeric, integer, and other variables are set to their means.
</p>
</li>
<li>
<p> "balanced": Each unique level of character, factor, logical, and binary variables are preserved. Numeric, integer, and other variables are set to their means. Warning: When there are many variables and many levels per variable, a balanced grid can be very large. In those cases, it is better to use <code>grid_type="mean_or_mode"</code> and to specify the unique levels of a subset of named variables explicitly.
</p>
</li>
<li>
<p> "counterfactual": the entire dataset is duplicated for each combination of the variable values specified in <code>...</code>. Variables not explicitly supplied to <code>datagrid()</code> are set to their observed values in the original dataset.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>Logical should the response variable be included in the grid, even if it is not specified explicitly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN_character</code></td>
<td>
<p>the function to be applied to character variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN_factor</code></td>
<td>
<p>the function to be applied to factor variables. This only applies if the variable in the original data is a factor. For variables converted to factor in a model-fitting formula, for example, <code>FUN_character</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN_logical</code></td>
<td>
<p>the function to be applied to logical variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN_numeric</code></td>
<td>
<p>the function to be applied to numeric variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN_integer</code></td>
<td>
<p>the function to be applied to integer variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN_binary</code></td>
<td>
<p>the function to be applied to binary variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN_other</code></td>
<td>
<p>the function to be applied to other variable types.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>datagrid</code> is used in a <code>predictions()</code>, <code>comparisons()</code>, or <code>slopes()</code> call as the
<code>newdata</code> argument, the model is automatically inserted in the <code>model</code> argument of <code>datagrid()</code>
call, and users do not need to specify either the <code>model</code> or <code>newdata</code> arguments. The same behavior will occur when the value supplied to <code style="white-space: pre;">⁠newdata=⁠</code> is a function call which starts with "datagrid". This is intended to allow users to create convenience shortcuts like:
</p>
<pre>
library(marginaleffects)
mod &lt;- lm(mpg ~ am + vs + factor(cyl) + hp, mtcars)
datagrid_bal &lt;- function(...) datagrid(..., grid_type = "balanced")
predictions(model, newdata = datagrid_bal(cyl = 4))
</pre>
<p>If users supply a model, the data used to fit that model is retrieved using
the <code>insight::get_data</code> function.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> in which each row corresponds to one combination of the named
predictors supplied by the user via the <code>...</code> dots. Variables which are not
explicitly defined are held at their mean or mode.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The output only has 2 rows, and all the variables except `hp` are at their
# mean or mode.
datagrid(newdata = mtcars, hp = c(100, 110))

# We get the same result by feeding a model instead of a data.frame
mod &lt;- lm(mpg ~ hp, mtcars)
datagrid(model = mod, hp = c(100, 110))

# Use in `marginaleffects` to compute "Typical Marginal Effects". When used
# in `slopes()` or `predictions()` we do not need to specify the
#`model` or `newdata` arguments.
slopes(mod, newdata = datagrid(hp = c(100, 110)))

# datagrid accepts functions
datagrid(hp = range, cyl = unique, newdata = mtcars)
comparisons(mod, newdata = datagrid(hp = fivenum))

# The full dataset is duplicated with each observation given counterfactual
# values of 100 and 110 for the `hp` variable. The original `mtcars` includes
# 32 rows, so the resulting dataset includes 64 rows.
dg &lt;- datagrid(newdata = mtcars, hp = c(100, 110), grid_type = "counterfactual")
nrow(dg)

# We get the same result by feeding a model instead of a data.frame
mod &lt;- lm(mpg ~ hp, mtcars)
dg &lt;- datagrid(model = mod, hp = c(100, 110), grid_type = "counterfactual")
nrow(dg)
</code></pre>


</div>