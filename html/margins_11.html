<div class="container">

<table style="width: 100%;"><tr>
<td>dydx</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Marginal Effect of a Given Variable</h2>

<h3>Description</h3>

<p>Differentiate an Estimated Model Function with Respect to One Variable, or calculate a discrete difference (“first difference”) as appropriate.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dydx(data, model, variable, ...)

## Default S3 method:
dydx(
  data,
  model,
  variable,
  type = c("response", "link"),
  change = c("dydx", "minmax", "iqr", "sd"),
  eps = 1e-07,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'factor'
dydx(
  data,
  model,
  variable,
  type = c("response", "link"),
  fwrap = FALSE,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'ordered'
dydx(
  data,
  model,
  variable,
  type = c("response", "link"),
  fwrap = FALSE,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'logical'
dydx(
  data,
  model,
  variable,
  type = c("response", "link"),
  as.data.frame = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The dataset on which to to calculate <code class="reqn">\hat{y}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>The model object to pass to <code>prediction</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variable</code></td>
<td>
<p>A character string specifying the variable to calculate the derivative or discrete change for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of prediction. Default is “response”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>change</code></td>
<td>
<p>For numeric variables, a character string specifying the type of change to express. The default is the numerical approximation of the derivative. Alternative values are occasionally desired quantities: “minmax” (the discrete change moving from <code>min(x)</code> to <code>max(x)</code>), “iqr” (the move from the 1st quartile to 3rd quartile of <code>x</code>), or “sd” (the change from <code>mean(x) - sd(x)</code> to <code>mean(x) + sd(x)</code>), or a two-element numeric vector expressing values of the variable to calculate the prediction for (and difference the associated predictions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>If <code>change == "dydx"</code> (the default), the value of the step <code class="reqn">\epsilon</code> to use in calculation of the numerical derivative for numeric variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.data.frame</code></td>
<td>
<p>A logical indicating whether to return a data frame (the default) or a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fwrap</code></td>
<td>
<p>A logical specifying how to name factor columns in the response.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions provide a simple interface to the calculation of marginal effects for specific variables used in a model, and are the workhorse functions called internally by <code>marginal_effects</code>.
</p>
<p><code>dydx</code> is an S3 generic with classes implemented for specific variable types. S3 method dispatch, somewhat atypically, is based upon the class of <code>data[[variable]]</code>.
</p>
<p>For numeric (and integer) variables, the method calculates an instantaneous marginal effect using a simple “central difference” numerical differentiation:
</p>
<p style="text-align: center;"><code class="reqn">\frac{f(x + \frac{1}{2}h) - f(x - \frac{1}{2}h)}{dh}</code>
</p>
<p>, where (<code class="reqn">h = \max(|x|, 1) \sqrt{\epsilon}</code> and the value of <code class="reqn">\epsilon</code> is given by argument <code>eps</code>. This procedure is subject to change in the future.
</p>
<p>For factor variables (or character variables, which are implicitly coerced to factors by modelling functions), discrete first-differences in predicted outcomes are reported instead (i.e., change in predicted outcome when factor is set to a given level minus the predicted outcome when the factor is set to its baseline level). These are sometimes called “partial effects”. If you want to use numerical differentiation for factor variables (which you probably do not want to do), enter them into the original modelling function as numeric values rather than factors.
</p>
<p>For ordered factor variables, the same approach as factors is used. This may contradict the output of modelling function summaries, which rely on <code>options("contrasts")</code> to determine the contrasts to use (the default being <code>contr.poly</code> rather than <code>contr.treatment</code>, the latter being used normally for unordered factors).
</p>
<p>For logical variables, the same approach as factors is used, but always moving from <code>FALSE</code> to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A data frame, typically with one column unless the variable is a factor with more than two levels. The names of the marginal effect columns begin with “dydx_” to distinguish them from the substantive variables of the same names.
</p>


<h3>References</h3>

<p>Miranda, Mario J. and Paul L. Fackler. 2002. <em>Applied Computational Economics and Finance</em>. p. 103.
</p>
<p>Greene, William H. 2012. <em>Econometric Analysis</em>. 7th edition. pp. 733–741.
</p>
<p>Cameron, A. Colin and Pravin K. Trivedi. 2010. <em>Microeconometric Using Stata</em>. Revised edition. pp. 106–108, 343–356, 476–478.
</p>


<h3>See Also</h3>

<p><code>marginal_effects</code>, <code>margins</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require("datasets")
x &lt;- lm(mpg ~ cyl * hp + wt, data = head(mtcars))
# marginal effect (numerical derivative)
dydx(head(mtcars), x, "hp")

# other discrete differences
## change from min(mtcars$hp) to max(mtcars$hp)
dydx(head(mtcars), x, "hp", change = "minmax")
## change from 1st quartile to 3rd quartile
dydx(head(mtcars), x, "hp", change = "iqr")
## change from mean(mtcars$hp) +/- sd(mtcars$hp)
dydx(head(mtcars), x, "hp", change = "sd")
## change between arbitrary values of mtcars$hp
dydx(head(mtcars), x, "hp", change = c(75,150))

# factor variables
mtcars[["cyl"]] &lt;- factor(mtcars$cyl)
x &lt;- lm(mpg ~ cyl, data = head(mtcars))
dydx(head(mtcars), x, "cyl")

</code></pre>


</div>