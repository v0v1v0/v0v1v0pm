<div class="container">

<table style="width: 100%;"><tr>
<td>marginal_effects</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Differentiate a Model Object with Respect to All (or Specified) Variables</h2>

<h3>Description</h3>

<p>Extract marginal effects from a model object, conditional on data, using <code>dydx</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">marginal_effects(model, data, variables = NULL, ...)

## S3 method for class 'margins'
marginal_effects(model, data, variables = NULL, ...)

## S3 method for class 'clm'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = NULL,
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)

## Default S3 method:
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  as.data.frame = TRUE,
  varslist = NULL,
  ...
)

## S3 method for class 'glm'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'lm'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'loess'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  as.data.frame = TRUE,
  varslist = NULL,
  ...
)

## S3 method for class 'merMod'
marginal_effects(
  model,
  data = find_data(model),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  as.data.frame = TRUE,
  varslist = NULL,
  ...
)

## S3 method for class 'lmerMod'
marginal_effects(
  model,
  data = find_data(model),
  variables = NULL,
  type = c("response", "link"),
  eps = 1e-07,
  as.data.frame = TRUE,
  varslist = NULL,
  ...
)

## S3 method for class 'multinom'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = NULL,
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'nnet'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = NULL,
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)

## S3 method for class 'polr'
marginal_effects(
  model,
  data = find_data(model, parent.frame()),
  variables = NULL,
  type = NULL,
  eps = 1e-07,
  varslist = NULL,
  as.data.frame = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A model object, perhaps returned by <code>lm</code> or <code>glm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame over which to calculate marginal effects. This is optional, but may be required when the underlying modelling function sets <code>model = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variables</code></td>
<td>
<p>A character vector with the names of variables for which to compute the marginal effects. The default (<code>NULL</code>) returns marginal effects for all variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to methods, and onward to <code>dydx</code> methods and possibly further to <code>prediction</code> methods. This can be useful, for example, for setting <code>type</code> (predicted value type), <code>eps</code> (precision), or <code>category</code> (category for multi-category outcome models), etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A character string indicating the type of marginal effects to estimate. Mostly relevant for non-linear models, where the reasonable options are “response” (the default) or “link” (i.e., on the scale of the linear predictor in a GLM).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>A numeric value specifying the “step” to use when calculating numerical derivatives. By default this is the smallest floating point value that can be represented on the present architecture.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varslist</code></td>
<td>
<p>A list structure used internally by <code>margins</code>. Users should not set this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.data.frame</code></td>
<td>
<p>A logical indicating whether to return a data frame (the default) or a matrix.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Users likely want to use the fully featured <code>margins</code> function rather than <code>marginal_effects</code>, which merely performs estimation of the marginal effects but simply returns a data frame. <code>margins</code>, by contrast, does some convenient packaging around these results and supports additional functionality, like variance estimation and counterfactual estimation procedures. The methods for this function provide lower-level functionality that extracts unit-specific marginal effects from an estimated model with respect to <em>all</em> variables specified in <code>data</code> (or the subset specified in <code>variables</code>) and returns a data frame. See <code>dydx</code> for computational details. Note that for factor and logical class variables, discrete changes in the outcome are reported rather than instantaneous marginal effects.
</p>
<p>Methods are currently implemented for the following object classes:
</p>

<ul>
<li> <p>“betareg”, see <code>betareg</code>
</p>
</li>
<li> <p>“glm”, see <code>glm</code>, <code>glm.nb</code>
</p>
</li>
<li> <p>“ivreg”, see <code>ivreg</code>
</p>
</li>
<li> <p>“lm”, see <code>lm</code>
</p>
</li>
<li> <p>“loess”, see <code>loess</code>
</p>
</li>
<li> <p>“merMod”, see <code>lmer</code>, <code>glmer</code>
</p>
</li>
<li> <p>“multinom”, see <code>multinom</code>
</p>
</li>
<li> <p>“nnet”, see <code>nnet</code>
</p>
</li>
<li> <p>“polr”, see <code>polr</code>
</p>
</li>
<li> <p>“svyglm”, see <code>svyglm</code>
</p>
</li>
</ul>
<p>A method is also provided for the object classes “margins” to return a simplified data frame from complete “margins” objects.
</p>


<h3>Value</h3>

<p>An data frame with number of rows equal to <code>nrow(data)</code>, where each row is an observation and each column is the marginal effect of a variable used in the model formula.
</p>


<h3>See Also</h3>

<p><code>dydx</code>, <code>margins</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require("datasets")
x &lt;- lm(mpg ~ cyl * hp + wt, data = mtcars)
marginal_effects(x)

# factor variables report discrete differences
x &lt;- lm(mpg ~ factor(cyl) * factor(am), data = mtcars)
marginal_effects(x)

# get just marginal effects from "margins" object
require('datasets')
m &lt;- margins(lm(mpg ~ hp, data = mtcars[1:10,]))
marginal_effects(m)
marginal_effects(m)

# multi-category outcome
if (requireNamespace("nnet")) {
  data("iris3", package = "datasets")
  ird &lt;- data.frame(rbind(iris3[,,1], iris3[,,2], iris3[,,3]),
                    species = factor(c(rep("s",50), rep("c", 50), rep("v", 50))))
  m &lt;- nnet::nnet(species ~ ., data = ird, size = 2, rang = 0.1,
                  decay = 5e-4, maxit = 200, trace = FALSE)
  marginal_effects(m) # default
  marginal_effects(m, category = "v") # explicit category
}

</code></pre>


</div>