<div class="container">

<table style="width: 100%;"><tr>
<td>cjs_tmb</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting function for CJS models</h2>

<h3>Description</h3>

<p>A function for computing MLEs for a specified Cormack-Jolly-Seber open
population capture-recapture model for processed dataframe <code>x</code> with
user specified formulas in <code>parameters</code> that create list of design
matrices <code>dml</code>. This function can be called directly but is most easily
called from <code>crm</code> that sets up needed arguments.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cjs_tmb(
  x,
  ddl,
  dml,
  model_data = NULL,
  parameters,
  accumulate = TRUE,
  initial = NULL,
  method,
  hessian = FALSE,
  debug = FALSE,
  chunk_size = 1e+07,
  refit,
  itnmax = NULL,
  control = NULL,
  scale,
  crossed = TRUE,
  compile = TRUE,
  extra.args = NULL,
  reml,
  clean = FALSE,
  getreals = FALSE,
  prior = FALSE,
  prior.list = NULL,
  tmbfct = "f1",
  useHess = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>processed dataframe created by process.data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ddl</code></td>
<td>
<p>list of dataframes for design data; created by call to
<code>make.design.data</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dml</code></td>
<td>
<p>list of design matrices created by <code>create.dm</code> from
formula and design data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_data</code></td>
<td>
<p>a list of all the relevant data for fitting the model including
imat, Phi.dm,p.dm,Phi.fixed,p.fixed, and time.intervals. It is used to save values
and avoid accumulation again if the model was re-rerun with an additional call to cjs when
using autoscale or re-starting with initial values.  It is stored with returned model object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>equivalent to <code>model.parameters</code> in <code>crm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accumulate</code></td>
<td>
<p>if TRUE will accumulate capture histories with common
value and with a common design matrix for Phi and p to speed up execution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>list of initial values for parameters if desired; if each is a named vector
from previous run it will match to columns with same name</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method to use for optimization; see <code>optim</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>if TRUE will compute and return the hessian</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>if TRUE will print out information for each iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunk_size</code></td>
<td>
<p>specifies amount of memory to use in accumulating capture
histories; amount used is 8*chunk_size/1e6 MB (default 80MB)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refit</code></td>
<td>
<p>non-zero entry to refit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itnmax</code></td>
<td>
<p>maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>control string for optimization functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>vector of scale values for parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crossed</code></td>
<td>
<p>if TRUE it uses cjs.tpl or cjs_reml.tpl if reml=FALSE or TRUE respectively; if FALSE, then it uses cjsre which can use Gauss-Hermite integration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compile</code></td>
<td>
<p>if TRUE forces re-compilation of tpl file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra.args</code></td>
<td>
<p>optional character string that is passed to admb if use.admb==TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reml</code></td>
<td>
<p>if set to TRUE uses cjs_reml if crossed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clean</code></td>
<td>
<p>if TRUE, deletes the tpl and executable files for amdb if use.admb=T</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getreals</code></td>
<td>
<p>if TRUE, will compute real Phi and p values and std errors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>if TRUE will expect vectors of prior values in list prior.list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.list</code></td>
<td>
<p>which contains for normal distributions 1) mu_phi_prior: vector of mu values for phi_beta, 2) sigma_phi_prior: vector of sigma values for phi_beta,
3) mu_p_prior: vector of mu values for p_beta, 4) sigma_p_prior: vector of sigma values for p_beta, 5) random_mu_phi_prior: vector of mu values for ln sigma of random effects, 
6) random_sigma_phi_prior: vector of sigma values for ln sigma_phi, 7) random_mu_p_prior: vector of mu values for ln sigma_p, 8) random_sigma_p_prior: vector of sigma values for ln sigma_p.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tmbfct</code></td>
<td>
<p>either "f1" - default or "f2" - any random effects treated as fixed effects or "f3" fixed effects fixed at mode and no random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useHess</code></td>
<td>
<p>if TRUE, the TMB hessian function is used for optimization; using hessian is typically slower with many parameters but can result in a better solution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>any remaining arguments are passed to additional parameters
passed to <code>optim</code> or <code>cjs.lnl</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It is easiest to call <code>cjs</code> through the function <code>crm</code>.
Details are explained there.
</p>
<p>Be cautious with this function at present.  It does not include many checks
to make sure values like fixed values will remain in the specified range of
the data.  Normally this would not be a big problem but because
<code>cjs.lnl</code> calls an external FORTRAN subroutine, if it gets a
subscript out of bounds, it will cause R to terminate.  So make sure to save
your workspace frequently if you use this function in its current
implementation.
</p>


<h3>Value</h3>

<p>The resulting value of the function is a list with the class of
crm,cjs such that the generic functions print and coef can be used.
Elements are 1) beta: named vector of parameter estimatesm 2) lnl: -2*log
likelihood, 3) AIC: lnl + 2* number of parameters, 4) convergence: result from <code>optim</code>; if 0 <code>optim</code> thinks it
converged, 5) count:<code>optim</code> results of number of function
evaluations, 6) reals: dataframe of data and real Phi and p estimates for
each animal-occasion excluding those that occurred before release, 7) vcv:var-cov matrix of betas if hessian=TRUE was set.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>Pledger, S., K. H. Pollock, et al. (2003). Open
capture-recapture models with heterogeneity: I. Cormack-Jolly-Seber model.
Biometrics 59(4):786-794.
</p>


</div>