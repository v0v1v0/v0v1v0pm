<div class="container">

<table style="width: 100%;"><tr>
<td>mash</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply mash method to data</h2>

<h3>Description</h3>

<p>Apply mash method to data
</p>


<h3>Usage</h3>

<pre><code class="language-R">mash(
  data,
  Ulist = NULL,
  gridmult = sqrt(2),
  grid = NULL,
  normalizeU = TRUE,
  usepointmass = TRUE,
  g = NULL,
  fixg = FALSE,
  prior = c("nullbiased", "uniform"),
  nullweight = 10,
  optmethod = c("mixSQP", "mixIP", "mixEM", "cxxMixSquarem"),
  control = list(),
  verbose = TRUE,
  add.mem.profile = FALSE,
  algorithm.version = c("Rcpp", "R"),
  pi_thresh = 1e-10,
  A = NULL,
  posterior_samples = 0,
  seed = 123,
  outputlevel = 2,
  output_lfdr = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a mash data object containing the Bhat matrix, standard
errors, alpha value; created using <code>mash_set_data</code> or
<code>mash_set_data_contrast</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ulist</code></td>
<td>
<p>a list of covariance matrices to use
(see <code>normalizeU</code> for rescaling these matrices)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gridmult</code></td>
<td>
<p>scalar indicating factor by which adjacent grid
values should differ; close to 1 for fine grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>vector of grid values to use (scaling factors omega in
paper)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalizeU</code></td>
<td>
<p>whether or not to normalize the U covariances to
have maximum of 1 on diagonal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usepointmass</code></td>
<td>
<p>whether to include a point mass at 0,
corresponding to null in every condition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>the value of g obtained from a previous mash fit - an
alternative to supplying Ulist, grid and usepointmass</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixg</code></td>
<td>
<p>if g is supplied, allows the mixture proportions to be
fixed rather than estimated; e.g., useful for fitting mash to test
data after fitting it to training data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>indicates what penalty to use on the likelihood, if any</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullweight</code></td>
<td>
<p>scalar, the weight put on the prior under
“nullbiased” specification, see “prior”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optmethod</code></td>
<td>
<p>name of optimization method to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control parameters passed to optmethod.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, print progress to R console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.mem.profile</code></td>
<td>
<p>If <code>TRUE</code>, print memory usage to R
console (requires R library 'profmem').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm.version</code></td>
<td>
<p>Indicates whether to use R or Rcpp version</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi_thresh</code></td>
<td>
<p>threshold below which mixture components are
ignored in computing posterior summaries (to speed calculations by
ignoring negligible components)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>the linear transformation matrix, Q x R matrix. This is
used to compute the posterior for Ab.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posterior_samples</code></td>
<td>
<p>the number of samples to be drawn from the
posterior distribution of each effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>A random number seed to use when sampling from the
posteriors. It is used when <code>posterior_samples &gt; 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputlevel</code></td>
<td>
<p>controls amount of computation / output; 1:
output only estimated mixture component proportions, 2: and
posterior estimates, 3: and posterior covariance matrices, 4: and
likelihood matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_lfdr</code></td>
<td>
<p>If <code>output_lfdr = TRUE</code>, output local false
discovery rate estimates. The lfdr tends to be sensitive to
mis-estimated covariance matrices, and generally we do not
recommend using them; we recommend using the local false sign rate
(lfsr) instead, which is always returned, even when
<code>output_lfdr = TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list with elements result, loglik and fitted_g
</p>


<h3>Examples</h3>

<pre><code class="language-R">Bhat     = matrix(rnorm(100),ncol=5) # create some simulated data
Shat     = matrix(rep(1,100),ncol=5)
data     = mash_set_data(Bhat,Shat, alpha=1)
U.c      = cov_canonical(data)
res.mash = mash(data,U.c)

# Run mash with penalty exponent on null term equal to 100.
# See "False disovery rates: a new deal" (M. Stephens 2017),
# supplementary material S.2.5 for more details.
set.seed(1)
simdata = simple_sims(500,5,1)
data    = mash_set_data(simdata$Bhat,simdata$Shat)
U.c     = cov_canonical(data)
res0    = mash(data,U.c)
res1    = mash(data,U.c,prior = "nullbiased",nullweight = 101)
plot(res0$fitted_g$pi,res1$fitted_g$pi,pch = 20)
abline(a = 0,b = 1,col = "skyblue",lty = "dashed")

</code></pre>


</div>