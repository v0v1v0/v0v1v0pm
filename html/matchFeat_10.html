<div class="container">

<table style="width: 100%;"><tr>
<td>objective.gen.fun</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Objective Value in One-To-One Feature Matching with Balanced or Unbalanced Data
</h2>

<h3>Description</h3>

<p>Calculates the objective value in the multidimensional assignment problem with decomposable costs (MDADC). The dissimilarity function used in this problem is the squared Euclidean distance. The data can be balanced OR unbalanced.</p>


<h3>Usage</h3>

<pre><code class="language-R">objective.gen.fun(x, unit, cluster)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>data matrix with feature vectors in rows
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit</code></td>
<td>

<p>vector of unit labels (length should equal number of rows in <code>x</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>

<p>vector of cluster labels (length should equal number of rows in <code>x</code>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See equation (2) in Degras (2022). This function gives the same value as <code>objective.fun</code> when the data are balanced.   
</p>


<h3>Value</h3>

<p>Objective value</p>


<h3>References</h3>

<p>Degras (2022) "Scalable feature matching across large data collections."  
<a href="https://doi.org/10.1080/10618600.2022.2074429">doi:10.1080/10618600.2022.2074429</a>
</p>


<h3>See Also</h3>

<p><code>objective.fun</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(optdigits)
m &lt;- 10
n &lt;- 100

## Balanced example: both 'objective.fun' and 'objective.gen.fun' work
sigma &lt;- matrix(1:m,m,n)
cluster &lt;- rep(1:m,n)
objective.fun(optdigits$x, sigma, optdigits$unit)
objective.gen.fun(optdigits$x, optdigits$unit, cluster)

## Unbalanced example
idx &lt;- 1:999
objective.gen.fun(optdigits$x[idx,], optdigits$unit[idx], cluster[idx])


</code></pre>


</div>