<div class="container">

<table style="width: 100%;"><tr>
<td>match.2x</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Pairwise Interchange Heuristic (2-Assignment-Exchange)
</h2>

<h3>Description</h3>

<p>This function implements the Pairwise Interchange Heuristic for the multidimensional assignment problem with decomposable costs (MDADC).
</p>


<h3>Usage</h3>

<pre><code class="language-R">match.2x(x, sigma = NULL, unit = NULL, w = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data: matrix of dimensions <code class="reqn">(mn,p)</code> or 3D array of dimensions <code class="reqn">(p,m,n)</code> with <code class="reqn">m</code> = number of labels/classes, <code class="reqn">n</code> = number of sample units, and <code class="reqn">p</code> = number of variables)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>permutations: matrix of dimensions <code class="reqn">(m,n)</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit</code></td>
<td>
<p>integer (=number of units) or vector mapping rows of <code>x</code> to sample units (length <code class="reqn">mn</code>). Must be specified only if <code>x</code> is a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>weights for loss function: single positive number, 
<code class="reqn">p</code>-vector of length, or <code class="reqn">(p,p)</code> positive definite matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>tuning parameters</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Use of this function requires to have the GUROBI software and its R interface package installed. Both can be downloaded from <a href="https://www.gurobi.com">https://www.gurobi.com</a> after obtaining a free academic license.  
</p>


<h3>Value</h3>

<p>A list of class <code>matchFeat</code> with components
</p>

<dl>
<dt><code>sigma</code></dt>
<dd>
<p>best assignment as set of permutations (<code class="reqn">(m,n)</code> matrix)</p>
</dd>
<dt><code>cluster</code></dt>
<dd>
<p>best assignment as a cluster membership vector</p>
</dd>
<dt><code>objective</code></dt>
<dd>
<p>minimum objective value</p>
</dd>
<dt><code>mu</code></dt>
<dd>
<p>mean vector for each class/label (<code class="reqn">(p,m)</code> matrix)</p>
</dd>
<dt><code>V</code></dt>
<dd>
<p>covariance matrix for each class/label (<code class="reqn">(p,p,m)</code> array)</p>
</dd>
<dt><code>call</code></dt>
<dd>
<p>function call</p>
</dd>
</dl>
<h3>References</h3>

<p>Degras (2022) "Scalable feature matching across large data collections."  
<a href="https://doi.org/10.1080/10618600.2022.2074429">doi:10.1080/10618600.2022.2074429</a>
</p>


<h3>See Also</h3>

<p><code>match.bca</code>,  <code>match.bca.gen</code>,
<code>match.gaussmix</code>, <code>match.kmeans</code>, 
<code>match.rec</code>, <code>match.template</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (require(gurobi)) {
## Generate small example
  m &lt;- 3  # number of classes
  n &lt;- 10 # number of statistical units 
  p &lt;- 5  # number of variables
  mu &lt;- matrix(rnorm(p*m),p,m) # mean vectors
  sigma &lt;- 0.1
  x &lt;- array(as.vector(mu) + rnorm(p*m*n,sigma), c(p,m,n))

## Match all feature vectors
  result &lt;- match.2x(x)

## Display results 
  result$cost  # objective value = assignment cost
  result$sigma # solution permutations
  xmatched &lt;- array(dim=dim(x)) 
  
## Matched feature vectors
  for (i in 1:n)
	  xmatched[,,i] &lt;- x[,result$sigma[,i],i]
	
}
</code></pre>


</div>