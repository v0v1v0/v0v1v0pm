<div class="container">

<table style="width: 100%;"><tr>
<td>match.bca.gen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Block Coordinate Ascent Method for General (Balanced or Unbalanced) Data
</h2>

<h3>Description</h3>

<p>Solve a feature matching problem by block coordinate ascent
</p>


<h3>Usage</h3>

<pre><code class="language-R">match.bca.gen(x, unit = NULL, cluster = NULL, w = NULL, 
	method = c("cyclical", "random"), control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data matrix (rows=instances, columns=features)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit</code></td>
<td>
<p>vector of unit labels (length = number of rows of <code>x</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>integer specifying the number of classes/clusters to assign the feature vectors to OR integer vector specifiying the initial cluster assignment. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>feature weights in loss function. Can be specified as single positive number, vector, or positive definite matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>sweeping method for block coordinate ascent: <code>cyclical</code> or <code>random</code> (simple random sampling without replacement)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>optional list of tuning parameters</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>cluster</code> is an integer vector, it must have the same length as <code>unit</code> 
and its values must range between 1 and the number of clusters. 
</p>
<p>The list <code>control</code> can contain a field <code>maxit</code>, 
an integer that fixes the maximum number of algorithm iterations.
</p>


<h3>Value</h3>

<p>A list of class <code>matchFeat</code> with components
</p>

<dl>
<dt><code>cluster</code></dt>
<dd>
<p>integer vector of cluster assignments (length = <code>now(x)</code>)</p>
</dd>
<dt><code>objective</code></dt>
<dd>
<p>minimum objective value</p>
</dd>
<dt><code>mu</code></dt>
<dd>
<p>sample mean for each cluster/class (feature-by-cluster matrix)</p>
</dd>
<dt><code>V</code></dt>
<dd>
<p>sample covariance for each cluster/class (feature-by-feature-by-cluster 3D array)</p>
</dd>
<dt><code>size</code></dt>
<dd>
<p>integer vector of cluster sizes</p>
</dd>	
<dt><code>call</code></dt>
<dd>
<p>function call</p>
</dd>
</dl>
<h3>References</h3>

<p>Degras (2022) "Scalable feature matching across large data collections."  
<a href="https://doi.org/10.1080/10618600.2022.2074429">doi:10.1080/10618600.2022.2074429</a> <br>
Wright (2015). Coordinate descent algorithms. 
<a href="https://arxiv.org/abs/1502.04759">https://arxiv.org/abs/1502.04759</a>
</p>


<h3>See Also</h3>

<p><code>match.2x</code>, <code>match.bca</code>, 
<code>match.bca.gen</code>, <code>match.gaussmix</code>, 
<code>match.kmeans</code>, <code>match.rec</code>, <code>match.template</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(optdigits)
nobs &lt;- nrow(optdigits$x) # total number of observations
n &lt;- length(unique(optdigits$unit)) # number of statistical units
rmv &lt;- sample.int(nobs, n-1) # remove (n-1) observations to make data unbalanced
min.m &lt;- max(table(optdigits$unit[-rmv])) # smallest possible number of clusters
# lower values will result in an error message 
m &lt;- min.m
result &lt;- match.bca.gen(optdigits$x[-rmv,], optdigits$unit[-rmv], m)



</code></pre>


</div>