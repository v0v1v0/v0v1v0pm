<div class="container">

<table style="width: 100%;"><tr>
<td>match.rec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Recursive Initialization Method
</h2>

<h3>Description</h3>

<p>RECUR1 algorithm of Bandelt et al (2004) to find starting point in the multidimensional assignment problem with decomposable costs (MDADC)  
</p>


<h3>Usage</h3>

<pre><code class="language-R">match.rec(x, unit = NULL, w = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data: matrix of dimensions <code class="reqn">(mn,p)</code> or 3D array of dimensions <code class="reqn">(p,m,n)</code> with <code class="reqn">m</code> = number of labels/classes, <code class="reqn">n</code> = number of sample units, and <code class="reqn">p</code> = number of variables)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit</code></td>
<td>
<p>integer (=number of units) or vector mapping rows of <code>x</code> to sample units (length <code class="reqn">mn</code>). Must be specified only if <code>x</code> is a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>weights for loss function: single positive number, 
<code class="reqn">p</code>-vector of length, or <code class="reqn">(p,p)</code> positive definite matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>tuning parameters</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of class <code>matchFeat</code> with components
</p>

<dl>
<dt><code>sigma</code></dt>
<dd>
<p>best set of permutations for feature vectors (<code class="reqn">(m,n)</code> matrix)</p>
</dd>
<dt><code>cluster</code></dt>
<dd>
<p>associated clusters (= inverse permutations)</p>
</dd>
<dt><code>cost</code></dt>
<dd>
<p>minimum objective value</p>
</dd>
<dt><code>mu</code></dt>
<dd>
<p>sample mean for each class/label (<code class="reqn">(p,m)</code> matrix)</p>
</dd>
<dt><code>V</code></dt>
<dd>
<p>sample covariance for each class/label (<code class="reqn">(p,m)</code> matrix</p>
</dd>
<dt><code>call</code></dt>
<dd>
<p>function call</p>
</dd>
</dl>
<h3>References</h3>

<p>Degras (2022) "Scalable feature matching across large data collections."  
<a href="https://doi.org/10.1080/10618600.2022.2074429">doi:10.1080/10618600.2022.2074429</a> <br>
Bandelt, Maas, and Spieksma (2004), "Local search heuristics for multi-index assignment problems with decomposable costs." <a href="https://doi.org/10.1057/palgrave.jors.2601723">doi:10.1057/palgrave.jors.2601723</a>
</p>


<h3>See Also</h3>

<p><code>match.2x</code>, <code>match.bca</code>,
<code>match.gaussmix</code>, <code>match.template</code>, 
<code>match.kmeans</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(optdigits)
m &lt;- length(unique(optdigits$label)) # number of classes
n &lt;- nrow(optdigits$x) / m # number of units

## Use function with data in matrix form
fit1 &lt;- match.rec(optdigits$x, unit=n)

## Use function with data in array form
p &lt;- ncol(optdigits$x)
x &lt;- t(optdigits$x)
dim(x) &lt;- c(p,m,n)
fit2 &lt;- match.rec(x)
</code></pre>


</div>