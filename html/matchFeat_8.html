<div class="container">

<table style="width: 100%;"><tr>
<td>match.template</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Template Matching</h2>

<h3>Description</h3>

<p>This function solves the multidimensional assignment problem with decomposable costs (MDADC) by matching the data to a pre-specified set of vectors (the template). The dissimilarity function is the squared Euclidean distance. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">match.template(x, template = 1L, unit = NULL, w = NULL, 
	method = c("hungarian","bruteforce"), equal.variance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data: matrix of dimensions <code class="reqn">mn \times p</code> or 3D array of dimensions <code class="reqn">(p,m,n)</code> with <code class="reqn">m</code> = number of labels/classes, <code class="reqn">n</code> = number of sample units, and <code class="reqn">p</code> = number of variables)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>template</code></td>
<td>
<p>integer (= which sample unit to take as template) or <code class="reqn">(p,m)</code> matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit</code></td>
<td>
<p>integer (=number of units/datasets) or vector mapping rows of <code>x</code> to sample units (length <code class="reqn">mn</code>). Must be specified only if <code>x</code> is a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>weights for the loss function. Can be specified as a <code class="reqn">p</code>-vector of diagonal weights or as a full <code class="reqn">p \times p</code> (positive definite) matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method for the linear assignment problem: <code>hungarian</code> algorithm or <code>bruteforce</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equal.variance</code></td>
<td>
<p>logical; if TRUE, resp. FALSE, return common, resp. label-specific, covariance of matched features</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given <code class="reqn">n</code> datasets or statistical units, each containing <code class="reqn">m</code> feature vectors, the one-to-one matching problem is to find a set of <code class="reqn">n</code> label permutations that produce the best match of feature vectors across units. The objective function to minimize is the sum of squared (Euclidean) distances between all feature vectors having the same (new) label. This amounts to minimizing the sum of the within-label variances.  
</p>
<p>The template-based method consists in relabeling successively each sample unit to best match a template matrix of feature vectors. This method is very fast but its optimization performance is only as good as the template. For best results, the template should be representative of the collected data. 
</p>
<p>If <code>x</code> is a matrix, the rows should be sorted by increasing unit label and  <code>unit</code> should be a nondecreasing sequence of integers, for example <code class="reqn">(1,...,1,2,...,2,...,n,...,n)</code> with each integer <code class="reqn">1,...,n</code> replicated <code class="reqn">m</code> times. 
</p>
<p>The argument <code>w</code> can be specified as a vector of positive numbers (will be recycled to length <code class="reqn">p</code> if needed) or as a positive definite matrix of size <code class="reqn">(p,p)</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>matchFeat</code> with fields 
</p>

<dl>
<dt><code>sigma</code></dt>
<dd>
<p>best assignement as set of permutations (<code class="reqn">m\times n</code> matrix)</p>
</dd>
<dt><code>cluster</code></dt>
<dd>
<p>best assignement as cluster indicators (<code class="reqn">m \times n</code> matrix)</p>
</dd>
<dt><code>objective</code></dt>
<dd>
<p>minimum objective value</p>
</dd>
<dt><code>mu</code></dt>
<dd>
<p>mean vector for each class/label (<code class="reqn">p \times m</code> matrix)</p>
</dd>
<dt><code>V</code></dt>
<dd>
<p>covariance matrix for each class/label (<code class="reqn">p \times p \times m</code> array if <code>equal.variance</code> is FALSE, <code class="reqn">p \times p </code> matrix otherwise</p>
</dd>
<dt><code>call</code></dt>
<dd>
<p>function call</p>
</dd>
</dl>
<h3>References</h3>

<p>Degras (2022) "Scalable feature matching across large data collections."  
<a href="https://doi.org/10.1080/10618600.2022.2074429">doi:10.1080/10618600.2022.2074429</a><br><a href="https://en.wikipedia.org/wiki/Assignment_problem">https://en.wikipedia.org/wiki/Assignment_problem</a><br><a href="https://en.wikipedia.org/wiki/Hungarian_algorithm">https://en.wikipedia.org/wiki/Hungarian_algorithm</a>
</p>


<h3>See Also</h3>

<p><code>match.2x</code>, <code>match.bca</code>, 
<code>match.bca.gen</code>, <code>match.gaussmix</code>, <code>match.kmeans</code>, <code>match.rec</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate data
n &lt;- 10
k &lt;- 3
d &lt;- 5
mu &lt;- matrix(1:k, nrow=d, ncol=k, byrow=TRUE)
sigma &lt;- 0.3
x &lt;- array(mu, c(d,k,n)) + rnorm(d*k*n,sigma)
## Match all feature vectors with first case as template
result &lt;- match.template(x,1)
## Display results 
result$cost # cost function
xmatched &lt;- array(dim=dim(x)) 
# re-arranged (matched) feature vectors
for (i in 1:n)
	xmatched[,,i] &lt;- x[,result$sigma[,i],i]
</code></pre>


</div>