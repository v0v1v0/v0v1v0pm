<div class="container">

<table style="width: 100%;"><tr>
<td>roommate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute matching for one-sided markets</h2>

<h3>Description</h3>

<p>This function computes the Irving (1985) algorithm for finding a stable
matching in a one-sided matching market.
</p>


<h3>Usage</h3>

<pre><code class="language-R">roommate(utils = NULL, pref = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>utils</code></td>
<td>
<p>is a matrix with cardinal utilities for each individual in the
market. If there are <code>n</code> individuals, then this matrix will be of
dimension <code>n-1</code> by <code>n</code>. Column <code>j</code> refers to the payoff that
individual <code>j</code> receives from being matched to individual <code>1, 2,
..., j-1, j+1, ...n</code>. If a square matrix is passed as <code>utils</code>, then
the main diagonal will be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pref</code></td>
<td>
<p>is a matrix with the preference order of each individual in the
market. This argument is only required when <code>utils</code> is not provided.
If there are <code>n</code> individuals, then this matrix will be of dimension
<code>n-1</code> by <code>n</code>. The <code>i,j</code>th element refers to <code>j</code>'s
<code>i</code>th most favorite partner. Preference orders can either be specified
using R-indexing (starting at 1) or C++ indexing (starting at 0). The
matrix <code>pref</code> must be of dimension <code>n-1</code> by <code>n</code>. Otherwise,
the function will throw an error.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Consider the following example: A set of <code>n</code> potential roommates, each
with ranked preferences over all the other potential roommates, are to be
matched to rooms, two roommates per room. A matching is stable if there is no
roommate <code>r1</code> that would rather be matched to some other roommate
<code>d2</code> than to his current roommate <code>r2</code> and the other roommate
<code>d2</code> would rather be matched to <code>r1</code> than to his current roommate
<code>d1</code>.
</p>
<p>The algorithm works in two stages. In the first stage, all participants begin
unmatched, then, in sequence, begin making proposals to other potential roommates,
beginning with their most preferred roommate. If a roommate receives a proposal,
he either accepts it if he has no other proposal which is better, or rejects it
otherwise. If this stage ends with a roommate who has no proposals, then there
is no stable matching and the algorithm terminates.
</p>
<p>In the second stage, the algorithm proceeds by finding and eliminating
rotations. Roughly speaking, a rotation is a sequence of pairs of agents,
such that the first agent in each pair is least preferred by the second
agent in that pair (of all the agents remaining to be matched), the second
agent in each pair is most preferred by the first agent in each pair (of
all the agents remaining to be matched) and the second agent in the
successive pair is the second most preferred agent (of the agents
remaining to be matched) of the first agent in the succeeding
pair, where here 'successive' is taken to mean 'modulo <code>m</code>',
where <code>m</code> is the length of the rotation. Once a rotation has been
identified, it can be eliminated in the following way: For each pair, the
second agent in the pair rejects the first agent in the pair (recall that the
second agent hates the first agent, while the first agent loves the second
agent), and the first agent then proceeds to propose to the second agent
in the succeeding pair. If at any point during this process, an agent
no longer has any agents left to propose to or be proposed to from, then
there is no stable matching and the algorithm terminates.
</p>
<p>Otherwise, at the end, every agent is left proposing to an agent who is also
proposing back to them, which results in a stable matching.
</p>
<p>Note that neither existence nor uniqueness is guaranteed, this algorithm
finds one matching, not all of them. If no matching exists, this function
returns <code>NULL</code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>n</code> corresponding to the matchings that were
formed. E.g. if the <code>4</code>th element of this vector is <code>6</code> then
individual <code>4</code> was matched with individual <code>6</code>. If no stable
matching exists, then this function returns <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># example using cardinal utilities
utils &lt;- matrix(c(
  -1.63, 0.69, -1.38, -0.03,
  2.91, -0.52, 0.52, 0.22,
  0.53, -0.52, -1.18, 0.53
), byrow = TRUE, ncol = 4, nrow = 3)
utils
results &lt;- roommate(utils = utils)
results

# example using preference orders
pref &lt;- matrix(c(
  3, 1, 2, 3,
  4, 3, 4, 2,
  2, 4, 1, 1
), byrow = TRUE, ncol = 4)
pref
results &lt;- roommate(pref = pref)
results
</code></pre>


</div>