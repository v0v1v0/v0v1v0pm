<div class="container">

<table style="width: 100%;"><tr>
<td>match_vec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rename values in a vector based on a dictionary</h2>

<h3>Description</h3>

<p>This function provides an interface for <code>forcats::fct_recode()</code>,
<code>forcats::fct_explicit_na()</code>, and <code>forcats::fct_relevel()</code> in such a way that
a data dictionary can be imported from a data frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">match_vec(
  x = character(),
  dictionary = data.frame(),
  from = 1,
  to = 2,
  quiet = FALSE,
  warn_default = TRUE,
  anchor_regex = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a character or factor vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dictionary</code></td>
<td>
<p>a matrix or data frame defining mis-spelled words or keys
in one column (<code>from</code>) and replacement values (<code>to</code>) in another
column. There are keywords that can be appended to the <code>from</code> column for
addressing default values and missing data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>a column name or position defining words or keys to be replaced</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>a column name or position defining replacement values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>a <code>logical</code> indicating if warnings should be issued if no
replacement is made; if <code>FALSE</code>, these warnings will be disabled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn_default</code></td>
<td>
<p>a <code>logical</code>. When a <code>.default</code> keyword is set and
<code>warn_default = TRUE</code>, a warning will be issued listing the variables
that were changed to the default value. This can be used to update your
dictionary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anchor_regex</code></td>
<td>
<p>a <code>logical</code>. When <code>TRUE</code> (default), any regex within
the keywork</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Keys (<code>from</code> column)</h4>

<p>The <code>from</code> column of the dictionary will contain the keys that you want to
match in your current data set. These are expected to match exactly with
the exception of three reserved keywords that start with a full stop:
</p>

<ul>
<li> <p><code>.regex [pattern]</code>: will replace anything matching <code style="white-space: pre;">⁠[pattern]⁠</code>. <strong>This
is executed before any other replacements are made</strong>. The <code style="white-space: pre;">⁠[pattern]⁠</code>
should be an unquoted, valid, PERL-flavored regular expression. Any
whitespace padding the regular expression is discarded.
</p>
</li>
<li> <p><code>.missing</code>: replaces any missing values (see NOTE)
</p>
</li>
<li> <p><code>.default</code>: replaces <strong>ALL</strong> values that are not defined in the dictionary
and are not missing.
</p>
</li>
</ul>
<h4>Values (<code>to</code> column)</h4>

<p>The values will replace their respective keys exactly as they are presented.
</p>
<p>There is currently one recognised keyword that can be placed in the <code>to</code>
column of your dictionary:
</p>

<ul><li> <p><code>.na</code>: Replace keys with missing data. When used in combination with the
<code>.missing</code> keyword (in column 1), it can allow you to differentiate
between explicit and implicit missing data.
</p>
</li></ul>
<h3>Value</h3>

<p>a vector of the same type as <code>x</code> with mis-spelled labels cleaned.
Note that factors will be arranged by the order presented in the data
dictionary; other levels will appear afterwards.
</p>


<h3>Note</h3>

<p>If there are any missing values in the <code>from</code> column (keys), then they
are automatically converted to the character "NA" with a warning. If you want
to target missing data with your dictionary, use the <code>.missing</code> keyword. The
<code>.regex</code> keyword uses <code>gsub()</code> with the <code>perl = TRUE</code> option for replacement.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code>match_df()</code> for an implementation that acts across
multiple variables in a data frame.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
corrections &lt;- data.frame(
  bad = c("foubar", "foobr", "fubar", "unknown", ".missing"),
  good = c("foobar", "foobar", "foobar", ".na", "missing"),
  stringsAsFactors = FALSE
)
corrections

# create some fake data
my_data &lt;- c(letters[1:5], sample(corrections$bad[-5], 10, replace = TRUE))
my_data[sample(6:15, 2)] &lt;- NA  # with missing elements

match_vec(my_data, corrections)

# You can use regular expressions to simplify your list
corrections &lt;- data.frame(
  bad =  c(".regex f[ou][^m].+?r$", "unknown", ".missing"),
  good = c("foobar",                ".na",     "missing"),
  stringsAsFactors = FALSE
)

# You can also set a default value
corrections_with_default &lt;- rbind(corrections, c(bad = ".default", good = "unknown"))
corrections_with_default

# a warning will be issued about the data that were converted
match_vec(my_data, corrections_with_default)

# use the warn_default = FALSE, if you are absolutely sure you don't want it.
match_vec(my_data, corrections_with_default, warn_default = FALSE)

# The function will give you a warning if the dictionary does not
# match the data
match_vec(letters, corrections)

# The can be used for translating survey output

words &lt;- data.frame(
  option_code = c(".regex ^[yY][eE]?[sS]?",
    ".regex ^[nN][oO]?",
    ".regex ^[uU][nN]?[kK]?",
    ".missing"),
  option_name = c("Yes", "No", ".na", "Missing"),
  stringsAsFactors = FALSE
)
match_vec(c("Y", "Y", NA, "No", "U", "UNK", "N"), words)
</code></pre>


</div>