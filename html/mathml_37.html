<div class="container">

<table style="width: 100%;"><tr>
<td>mathjax</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mathjax output</h2>

<h3>Description</h3>

<p>Mathjax output
</p>


<h3>Usage</h3>

<pre><code class="language-R">mathjax(
  term = quote((a + b)^2L == a^2L + 2L * a * b + b^2L),
  flags = NULL,
  env = globalenv()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>term</code></td>
<td>
<p>an R call or symbol/number. This function translates <em>term</em> into a
LaTeX/MathJax string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flags</code></td>
<td>
<p>(default NULL)
list of flags that control the translation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>(default globalenv())
The R environment in which r_eval is being executed (see vignette for
details, "Ringing back to R").</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In some functions, the Prolog code may ring back R, for example, to
find the names of function arguments. For example (see vignette), when
rendering the call <code>integrate(g, lower=0L, upper=Inf)</code> as Int_0^Inf g(x) dx,
Prolog needs to know that the function g is a function of x. The Prolog rule
then searches for the formalArgs of g in the environment <em>env</em>.
</p>


<h3>Value</h3>

<p>A string with the MathJax representation of <em>term</em>.
</p>


<h3>See Also</h3>

<p><code>mathml()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">mathjax(term=quote((a + b)^2L == a^2L + 2L*a*b + b^2L))

</code></pre>


</div>