<div class="container">

<table style="width: 100%;"><tr>
<td>matrixNormal_Distribution</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Matrix Normal Distribution</h2>

<h3>Description</h3>

<p>Computes the density (<code>dmatnorm</code>), calculates the cumulative distribution function (CDF, <code>pmatnorm</code>), and generates 1 random number (<code>rmatnorm</code>) from the matrix normal: </p>
<p style="text-align: center;"><code class="reqn">A \sim MatNorm_{n,p}(M, U, V) </code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dmatnorm(A, M, U, V, tol = .Machine$double.eps^0.5, log = TRUE)

pmatnorm(
  Lower = -Inf,
  Upper = Inf,
  M,
  U,
  V,
  tol = .Machine$double.eps^0.5,
  keepAttr = TRUE,
  algorithm = mvtnorm::GenzBretz(),
  ...
)

rmatnorm(s = 1, M, U, V, tol = .Machine$double.eps^0.5, method = "chol")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>The numeric n x p matrix that follows the matrix-normal. Value used to calculate the density.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>The mean n x p matrix that is numeric and real. Must contain non-missing values. Parameter of matrix Normal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>The individual scale n x n real positive-definite matrix (rows). Must contain non-missing values. Parameter of matrix Normal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>The parameter scale p x p  real positive-definite matrix (columns). Must contain non-missing values. Parameter of matrix Normal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>A numeric tolerance level used to check if a matrix is symmetric. That is, a matrix is symmetric if the difference between the matrix and its transpose is between -<code>tol</code> and <code>tol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>Logical; if TRUE, the logarithm of the density is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lower</code></td>
<td>
<p>The n x p matrix of lower limits for CDF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Upper</code></td>
<td>
<p>The n x p matrix of upper limits for CDF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepAttr</code></td>
<td>
<p><code>logical</code> indicating if
<code>attributes</code> such as <code>error</code> and <code>msg</code> should be
attached to the return value.  The default, <code>TRUE</code> is back compatible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p> an object of class <code>GenzBretz</code>,
<code>Miwa</code> or <code>TVPACK</code>
specifying both the algorithm to be used as well as
the associated hyper parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional parameters (currently given to <code>GenzBretz</code> for
backward compatibility issues). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>The number of observations desired to simulate from the matrix normal. Defaults to 1. Currently has no effect but acts as a placeholder in future releases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>String specifying the matrix decomposition used to determine the matrix root of the Kronecker product of U and V in <code>rmatnorm</code>. Possible methods are eigenvalue decomposition ("eigen"), singular value decomposition ("svd"), and Cholesky decomposition ("chol"). The Cholesky (the default) is typically fastest, but not by much though. Passed to **mvtnorm**::<code>rmvnorm</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions rely heavily on this following property of matrix normal distribution. Let <code>koch()</code> refer to the Kronecker product of a matrix. For a n x p matrix <em>A</em>,
if  </p>
<p style="text-align: center;"><code class="reqn">A \sim MatNorm(M, U, V),</code>
</p>
<p> then
</p>
<p style="text-align: center;"><code class="reqn"> vec(A) \sim MVN_{np} (M, Sigma = koch(V,U) ).</code>
</p>

<p>Thus, the probability of <code>Lower</code> &lt; <code>A</code> &lt; <code>Upper</code> in the matrix normal can be found by using the CDF of vec(A), which is given by <code>pmvnorm</code> function in <span class="pkg">mvtnorm</span>.  See <code>algorithms</code> and <code>pmvnorm</code> for more information.
</p>
<p>Also, we can simulate a random matrix <em>A</em> from a matrix normal by sampling <em>vec(A)</em> from <code>rmvnorm</code> function in <span class="pkg">mvtnorm</span>. This matrix <em>A</em> takes the rownames from <em>U</em> and the colnames from <em>V</em>.
</p>


<h3>Calculating Matrix Normal Probabilities</h3>

<p>From the <code>mvtnorm</code> package, three algorithms are available for evaluating normal probabilities: </p>

<ul>
<li>
<p> The default is the randomized Quasi-Monte-Carlo procedure by Genz (1992, 1993) and Genz and Bretz (2002) applicable to arbitrary covariance structures and dimensions up to 1000.
</p>
</li>
<li>
<p> For smaller dimensions (up to 20) and non-singular covariance matrices, the algorithm by Miwa et al. (2003) can be used as well.
</p>
</li>
<li>
<p> For two- and three-dimensional problems and semi-infinite integration region, TVPACK implements an interface to the methods described by Genz (2004).
</p>
</li>
</ul>
<p>The <code>...</code> arguments define the hyper-parameters for GenzBertz algorithm:
</p>

<dl>
<dt>maxpts</dt>
<dd>
<p>maximum number of function values as integer. The internal FORTRAN code always uses a minimum number depending on the dimension.Default 25000.</p>
</dd>
<dt>abseps</dt>
<dd>
<p>absolute error tolerance.</p>
</dd>
<dt>releps</dt>
<dd>
<p>relative error tolerance as double.</p>
</dd>
</dl>
<h3>Note</h3>

<p>Ideally, both scale matrices are positive-definite. If they do not appear to be symmetric, the tolerance should be increased. Since symmetry is checked, the 'checkSymmetry' arguments in 'mvtnorm::rmvnorm()' are set to FALSE.
</p>


<h3>References</h3>

<p>Pocuca, N., Gallaugher, M.P., Clark, K.M., &amp; McNicholas, P.D. (2019). Assessing and Visualizing Matrix Variate Normality. Methodology. &lt;https://arxiv.org/abs/1910.02859&gt;
</p>
<p>Gupta, A. K. and D. K. Nagar (1999). Matrix Variate Distributions. Boca Raton: Chapman &amp; Hall/CRC Press.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Data Used
# if( !requireNamespace("datasets", quietly = TRUE)) { install.packages("datasets")} #part of baseR.
A &lt;- datasets::CO2[1:10, 4:5]
M &lt;- cbind(stats::rnorm(10, 435, 296), stats::rnorm(10, 27, 11))
V &lt;- matrix(c(87, 13, 13, 112), nrow = 2, ncol = 2, byrow = TRUE)
V # Right covariance matrix (2 x 2), say the covariance between parameters.
U &lt;- I(10) # Block of left-covariance matrix ( 84 x 84), say the covariance between subjects.

# PDF
dmatnorm(A, M, U, V)
dmatnorm(A, M, U, V, log = FALSE)

# Generating Probability Lower and Upper Bounds (They're matrices )
Lower &lt;- matrix(rep(-1, 20), ncol = 2)
Upper &lt;- matrix(rep(3, 20), ncol = 2)
Lower
Upper
# The probablity that a randomly chosen matrix A is between Lower and Upper
pmatnorm(Lower, Upper, M, U, V)

# CDF
pmatnorm(Lower = -Inf, Upper, M, U, V)
# entire domain = 1
pmatnorm(Lower = -Inf, Upper = Inf, M, U, V)

# Random generation
set.seed(123)
M &lt;- cbind(rnorm(3, 435, 296), rnorm(3, 27, 11))
U &lt;- diag(1, 3)
V &lt;- matrix(c(10, 5, 5, 3), nrow = 2)
rmatnorm(1, M, U, V)

# M has a different sample size than U; will return an error.
## Not run: 
M &lt;- cbind(rnorm(4, 435, 296), rnorm(4, 27, 11))
rmatnorm(M, U, V)

## End(Not run)

</code></pre>


</div>