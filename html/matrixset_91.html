<div class="container">

<table style="width: 100%;"><tr>
<td>subsetting</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Subsetting  matrixsets</h2>

<h3>Description</h3>

<p>Extract parts of a matrixset, where indexes refers to rows and columns.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'matrixset'

  x[
  i = NULL,
  j = NULL,
  matrix = NULL,
  drop = FALSE,
  keep_annotation = TRUE,
  warn_class_change = getOption("matrixset.warn_class_change")
]

## S3 method for class 'row_grouped_ms'

  x[
  i = NULL,
  j = NULL,
  matrix = NULL,
  drop = FALSE,
  keep_annotation = TRUE,
  warn_class_change = getOption("matrixset.warn_class_change")
]

## S3 method for class 'col_grouped_ms'

  x[
  i = NULL,
  j = NULL,
  matrix = NULL,
  drop = FALSE,
  keep_annotation = TRUE,
  warn_class_change = getOption("matrixset.warn_class_change")
]

## S3 method for class 'dual_grouped_ms'

  x[
  i = NULL,
  j = NULL,
  matrix = NULL,
  drop = FALSE,
  keep_annotation = TRUE,
  warn_class_change = getOption("matrixset.warn_class_change")
]

## S3 method for class 'matrixset'
x$matrix

## S3 method for class 'matrixset'
x[[matrix]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>matrixset</code> object from which to extract
element(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i, j</code></td>
<td>
<p>rows (<code>i</code>) and columns (<code>j</code>) to extract from
matrices of <code>x</code>, as indices. These are either <code>numeric</code> or <code>character</code>
values.
</p>
<p>To extract every rows or columns, use <code>i = NULL</code> or <code>j = NULL</code>, which is
the default for both. Note that treating <code>NULL</code> as empty differs from the
usual extraction, where it is treated as <code>integer(0)</code>.
</p>
<p>Numeric values are coerced to integer through <code>as.integer()</code>, which means
they are truncated towards zero.
</p>
<p>Character vectors will be matched to the dimnames of the object.
</p>
<p>Indices an also be logical vectors, stating for each element if it is
extracted (<code>TRUE</code>) or rejected (<code>FALSE</code>). Logical vectors are <em>NOT</em>
recycled, which is an important difference with usual matrix extraction.
It means that the <code>logical</code> vector must match the object dimension in
length.
</p>
<p>Can also be negative integers, in which case they are indices of elements
to leave out of the selection.
</p>
<p>When indexing, a single argument <code>i</code> can be a matrix with two columns.
This is treated as if the first column was the <code>i</code> index and the second
column the <code>j</code> index.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrix</code></td>
<td>
<p>index specifying matrix or matrices to extract.
Index is numeric or character vectors or empty
(<code>NULL</code>). Note that treating <code>NULL</code> as
empty differs from the usual extraction, where it
is treated as <code>integer(0)</code>. Here a
<code>NULL</code> (empty) results in selecting all
matrices.
</p>
<p>See arguments <code style="white-space: pre;">⁠i,j⁠</code>, as the same rules are followed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>If <code>TRUE</code>, the <code>drop</code> option of matrix extraction
is used. See [<code>[</code>()]. Note that the default for
<code>matrixset</code> objects is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_annotation</code></td>
<td>
<p><code>logical</code> specifying if the resulting object
should keep the annotations (meta info, or
traits, as per <code>matrixset</code> notation) as part
of the object. The default (<code>TRUE</code>), combined
with the default <code>drop = FALSE</code>, guarantees that
the resulting object is a <code>matrixset</code> object. If
<code>keep_annotation</code> is <code>FALSE</code>, the resulting
object will be a list of matrix, and a warning
will be issued, unless <code>warn_class_change</code> is
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn_class_change</code></td>
<td>
<p><code>logical</code> that determines if a warning
should be issued when the extraction result is
not a <code>matrixset</code>. The default is to use
the global option <code>"matrixset.warn_class_change"</code>,
which is <code>FALSE</code> by default. If one wants
to silence permanently this warning, this is the
option to change.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Indexes <code>i</code> and <code>j</code> are given as for a regular <code>matrix()</code>
(note however that factors are currently not allowed for indexing).
Which matrices are extracted (all or a subset) is specified via argument
<code>"matrix"</code>.
</p>
<p>Missing values (<code>NA</code>) are not allowed for indexing, as it results in
unknown selection. Character indexes use exact matching, not partial.
</p>
<p>The default arguments for <code>"drop"</code> and <code>"keep_annotation"</code> are
chosen so that the object resulting from the extraction is still a
<code>matrixset</code>.
</p>
<p>Setting <code>"keep_annotation"</code> to <code>FALSE</code> automatically results in a class
change (a list of matrix) and a warning is issued (see argument
<code>warn_class_change</code>, however).
</p>
<p>Setting <code>drop</code> to <code>TRUE</code> may also result to a change of class,
depending on the provided indices (the same way matrix may result to a vector
when <code>drop</code> is <code>TRUE</code>).
</p>
<p>The subsetting operator <code>[[</code> is a convenient wrapper for <code style="white-space: pre;">⁠[(,,matrix)⁠</code>.
</p>
<p>There is no <code>$</code> subsetting operator for the <code>matrixset</code> object.
</p>


<h3>Value</h3>

<p>The resulting object type depends on the subsetting options. By default, a
<code>matrixset</code> object will be returned. This object will have the following
properties:
</p>

<ul>
<li>
<p> Rows and/or columns are a subset of the input (based on what has been
subsetted), but appear in the same order.
</p>
</li>
<li>
<p> Annotations, or traits, are subsetted appropriately.
</p>
</li>
<li>
<p> The number of groups may be reduced.
</p>
</li>
<li>
<p> Currently, attributes are <em>not</em> preserved.
</p>
</li>
</ul>
<p>If <code>keep_annotation</code> is <code>FALSE</code>, the resulting object will be a list.
Typically, it will be a list of <code>matrix</code>, but if <code>drop</code> is <code>TRUE</code>, some
list elements could be vectors.
</p>


<h3>Grouped matrixset</h3>

<p>When subsetting a grouped <code>matrixset</code> (by rows and/or columns), when the
resulting object is still a <code>matrixset</code>, the grouping structure will be
updated based on the resulting data.
</p>


<h3>Examples</h3>

<pre><code class="language-R">lst &lt;- list(a = matrix(1:6, 2, 3), b = matrix(101:106, 2, 3), c = NULL)
rownames(lst$a) &lt;- rownames(lst$b) &lt;- c("r1", "r2")
colnames(lst$a) &lt;- colnames(lst$b) &lt;- c("c1", "c2", "c3")
ri &lt;- data.frame(rowname = c("r1", "r2"), g = 1:2)
ci &lt;- data.frame(colname = c("c1", "c2", "c3"), h = 1:3)
matset &lt;- matrixset(lst, row_info = ri, column_info = ci, row_tag = "foo", column_tag = "bar")

# this doesn't subset anything, just returns matset again
matset[]

# this extracts the first row of every matrix. Note how each matrices is
# still a matrix, so you still end up with a matrixset object. Note also
# that you need placeholder for j and matrix index, even when not provided
matset[1, , ]

# similar idea
matset[,2, ]
matset[1,2,]

# it obviously works with vector indexes
matset[1:2, c(1,3),]

# you can extract the matrices this - even without the 'annoying' warning
matset[, , , keep_annotation = FALSE]
matset[, , , keep_annotation = FALSE, warn_class_change = FALSE]

# extracts subsetted matrices (no annotations)
matset[1, , , keep_annotation = FALSE, warn_class_change = FALSE]

# a bit more in line with how R subsets matrices
matset[1, , , drop = TRUE, warn_class_change = FALSE]

# you can obviously get some of the matrices only
matset[,,1]
matset[c(1,2),,1:2]

# to showcase other kind of indexes. These are all equivalents
matset[1,,]
matset["r1", ,]
matset[c(TRUE, FALSE), ,]
matset[-2, ,] # equivalent because there are only 2 rows

# this is also equivalent
matset[,,1]
matset[[1]]

</code></pre>


</div>