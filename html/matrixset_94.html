<div class="container">

<table style="width: 100%;"><tr>
<td>[&lt;-.matrixset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Replace Parts of a matrixset</h2>

<h3>Description</h3>

<p>Replace whole or parts of some - or all - matrices of a <code>matrixset</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 replacement method for class 'matrixset'
x[i = NULL, j = NULL, matrix = NULL] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>matrixset</code> object from which to replace element(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i, j</code></td>
<td>
<p>Indices specifying elements to replace. Indices are numeric or
character vectors or empty (<code>NULL</code>). Note that treating <code>NULL</code> as empty
differs from the usual replacement, where it is treated as <code>integer(0)</code>.
Here a <code>NULL</code> (empty) results in selecting all rows or columns.
</p>
<div class="sourceCode"><pre>Numeric values are coerced to integer as by [as.integer()] (and hence
truncated towards zero).

Character vectors will be matched to the dimnames of the object.

Can also be logical vectors, indicating elements/slices to replace Such
vectors are **NOT** recycled, which is an important difference with usual
matrix replacement. It means that the logical vector must match the
object dimension in length.

Can also be negative integers, indicating elements/slices to leave out of
the replacement.

When indexing, a single argument `i` can be a matrix with two columns.
This is treated as if the first column was the `i` index and the second
column the `j` index.
</pre></div>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrix</code></td>
<td>
<p>index specifying matrix or matrices to replace. Index is
numeric or character vectors or empty (<code>NULL</code>). Note
that treating <code>NULL</code> as empty differs from the usual
replacement, where it is treated as <code>integer(0)</code>. Here
a <code>NULL</code> (empty) results in replacing all matrices.
</p>
<p>Numeric values are coerced to integer as by <code>as.integer()</code> (and hence
truncated towards zero).
</p>
<p>Character vectors will be matched to the matrix names of the object.
</p>
<p>Can also be logical vectors, indicating elements/slices to replace. Such
vectors are <em>NOT</em> recycled, which is an important difference with usual
matrix replacement. It means that the <code>logical</code> vector must match the
number of matrices in length.
</p>
<p>Can also be negative integers, indicating elements/slices to leave out of
the replacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>object to use as replacement value</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>matrix</code> is left unspecified (or given as <code>NULL</code>), all matrices will be
replaced by <code>value</code>. How replacement exactly occurs depends on <code>value</code> itself.
</p>
<p>If <code>value</code> is a single atomic <code>vector</code> (this excludes lists) or <code>matrix</code>,
relevant subscripts of all requested matrices will be replaced by the same
<code>value</code>. This is conditional to the dimensions being compatible.
</p>
<p>Alternatively, <code>value</code> can be a list of atomic vectors/matrices. If <code>value</code>
has a single element, the same rules as above apply. Otherwise, the length
of <code>value</code> must match the number of matrices for which subscripts have to be
replaced.
</p>
<p>If the list elements are named, the names are matched to the names of the
matrices that need replacement - in which case <code>value</code> needs not to be the
same length.
</p>
<p>A final possibility for <code>value</code> is for it to be <code>NULL</code>. In this case, target
matrices are turned to <code>NULL</code>.
</p>


<h3>Value</h3>

<p>A <code>matrixset</code>, with proper elements replaced.
</p>


<h3>vector <code>value</code>
</h3>

<p>Contrarily to <code>matrix</code> replacement, when submitting an atomic <code>vector</code>
<code>value</code>, dimensions must match exactly.
</p>


<h3>Replacing <code>NULL</code> matrices</h3>

<p>Replacing subscripts of <code>NULL</code> matrices is not possible, unless <code>value</code> is
itself <code>NULL</code>, or a matrix the same dimensions (number of rows and columns)
as <code>x</code>. If <code>x</code> has dimnames, <code>value</code> must have the same dimnames.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># an hypothetical example of students that failed 3 courses and their results
# after remedial class

# you can replace a line for all matrices at once. In the example, the "wrong"
# tag refers to the fact that the 'failure' results do not make sense after
# replacement
student_results_wrong &lt;- student_results
student_results_wrong["student 2",,] &lt;- c(0.81, 0.88, 0.71) # obviously, integer index works too
# note how all matrices had the same replacement
student_results_wrong

# this already makes more sense in the context of the example
student_results[2,,] &lt;- list(c(0,0.45,0.1), c(0.81, 0.88, 0.71))
student_results

# or even these two equivalent commands
student_results["student 2",,"remedial"] &lt;- c(0.77, 0.83, 0.75)
student_results[2,,2] &lt;- matrix(c(0.77, 0.83, 0.75), 1, 3)


</code></pre>


</div>