<div class="container">

<table style="width: 100%;"><tr>
<td>prepare_.FUNdots</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prepare the <code>.FUNdots</code> argument for <code style="white-space: pre;">⁠*apply_byname⁠</code> functions.</h2>

<h3>Description</h3>

<p>This is a helper function for the various <code style="white-space: pre;">⁠*apply_byname⁠</code> functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">prepare_.FUNdots(a, .FUNdots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>the main argument to an <code style="white-space: pre;">⁠*apply_byname⁠</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.FUNdots</code></td>
<td>
<p>a list of additional arguments to be applied to <code>FUN</code> in one of the <code style="white-space: pre;">⁠*apply_byname⁠</code> functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We have four cases between a and any single item of .FUNdots:
</p>

<ul>
<li>
<p> both a and the item of .FUNdots are lists
</p>

<ul>
<li>
<p> if the item of .FUNdots (a list itself) has length different from 1 or length(a), throw an error
</p>
</li>
<li>
<p> if the item of .FUNdots (a list itself) has length 1, replicate the single item to be a list of length = length(a)
</p>
</li>
<li>
<p> if the item of .FUNdots (a list itself) has length = length(a), use the item of .FUNdots as is
</p>
</li>
</ul>
</li>
<li>
<p> a is a list but the item (argument) of .FUNdots is NOT a list
</p>

<ul>
<li>
<p> if the item of .FUNdots (which is not a list) has length != 1, throw an error,
because there is ambiguity how the item of .FUNdots should be treated.
</p>
</li>
<li>
<p> if the item of .FUNdots (which is not a list) has length = 1, replicate that single item to be a list of length = length(a)
</p>
</li>
</ul>
</li>
<li>
<p> a is NOT a list, but the item of .FUNdots IS a list
</p>

<ul><li>
<p> pass the argument along and hope for the best.  This situation is probably an error.  If so, it will become apparent soon.
</p>
</li></ul>
</li>
<li>
<p> neither a nor the item of .FUNdots is a list
</p>

<ul>
<li>
<p> a should have length = 1, but a single matrix reports its length as the number of elements of the matrix.
So, we can't check length in this situation.
</p>
</li>
<li>
<p> the item of .FUNdots is assumed to have length 1 and passed along
</p>
</li>
</ul>
</li>
</ul>
<h3>Value</h3>

<p>a reconfigured version of <code>.FUNdots</code>, ready for use by an <code style="white-space: pre;">⁠*apply_byname⁠</code> function.
</p>

<ul>
<li>
<p> both a and the item of .FUNdots are lists
</p>

<ul>
<li>
<p> if the item of .FUNdots (a list itself) has length different from 1 or length(a), throw an error
</p>
</li>
<li>
<p> if the item of .FUNdots (a list itself) has length 1, replicate the single item to be a list of length = length(a)
</p>
</li>
<li>
<p> if the item of .FUNdots (a list itself) has length = length(a), use the item of .FUNdots as is
</p>
</li>
</ul>
</li>
<li>
<p> a is NOT a list, but the item of .FUNdots IS a list
</p>

<ul><li>
<p> pass the argument along and hope for the best.  This situation is probably an error.
If so, it will become apparent soon.
</p>
</li></ul>
</li>
<li>
<p> a is a list but the item (argument) of .FUNdots is NOT a list
This situation could be ambiguous.
Let's say the list of <code>a</code> values has length 2, and an argument <code>margin = c(1, 2)</code>.
Should <code>margin = 1</code> be applied to <code>a[[1]]</code> and <code>margin = 2</code> be applied to <code>a[[2]]</code>?
Or should <code>margin = c(1, 2)</code> be applied to both <code>a[[1]]</code> and <code>a[[2]]</code>?
This ambiguity should be handled by using the function <code>prep_vector_arg()</code>
within the function that calls <code>unaryapply_byname()</code>.
For an example, see <code>identize_byname()</code>.
When the arguments are coming in from a data frame, there will be no ambiguity,
but the information will not be coming <code>.FUNdots[[i]]</code> as a list.
Optimizing for the data frame case,
this function allows vectors of length equal to the length of the list <code>a</code>,
interpreting such vectors as applying in sequence to each <code>a</code> in turn.
So the algorithm is as follows:
</p>

<ul>
<li>
<p> if a non-NULL item of .FUNdots (which is not a list) has
length other than 1 or length(a), throw an error.
</p>
</li>
<li>
<p> if a non-NULL item of .FUNdots (which is not a list) has length = 1,
replicate that single item to be a list of length = length(a).
</p>
</li>
<li>
<p> if a non-NULL item of .FUNdots (which is not a list) has length = length(a),
leave it as-is.
</p>
</li>
</ul>
</li>
<li>
<p> neither a nor the item of .FUNdots is a list
</p>

<ul>
<li>
<p> a should have length = 1, but a single matrix reports its length as the number of elements of the matrix.
So, we can't check length in this situation.
</p>
</li>
<li>
<p> the item of .FUNdots is assumed to have length 1 and passed along
</p>
</li>
</ul>
</li>
</ul>
</div>