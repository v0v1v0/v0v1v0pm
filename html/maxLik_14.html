<div class="container">

<table style="width: 100%;"><tr>
<td>condiNumber</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Print matrix condition numbers column-by-column</h2>

<h3>Description</h3>

<p>This function prints the condition number of a matrix while adding
columns one-by-one.  This is useful for testing multicollinearity and
other numerical problems.  It is a generic function with a default
method, and a method for <code>maxLik</code> objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">condiNumber(x, ...)
## Default S3 method:
condiNumber(x, exact = FALSE, norm = FALSE,
   printLevel=print.level, print.level=1, digits = getOption( "digits" ), ... )
## S3 method for class 'maxLik'
condiNumber(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric matrix, condition numbers of which are to be printed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>logical, should condition numbers be exact or
approximations (see <code>kappa</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>logical, whether the columns should be normalised to have
unit norm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printLevel</code></td>
<td>
<p>numeric, positive value will output the numbers
during the calculations.  Useful for interactive work.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.level</code></td>
<td>
<p>same as ‘printLevel’, for backward
compatibility</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>minimal number of significant digits to print
(only relevant if argument <code>print.level</code> is larger than zero).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to <code>condiNumber.default</code>
are currently ignored;
further arguments to <code>condiNumber.maxLik</code>
are passed to <code>condiNumber.default</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Statistical model often fail because of a high correlation between
the explanatory variables in the linear index (multicollinearity)
or because the evaluated maximum of a non-linear model is
virtually flat.  In both cases, the (near) singularity of the related
matrices may help to understand the problem.
</p>
<p><code>condiNumber</code> inspects the matrices column-by-column and
indicates which variables lead to a jump in the condition
number (cause singularity).
If the matrix column name does not immediately indicate the
problem, one may run an OLS model by estimating this column
using all the previous columns as explanatory variables.  Those
columns that explain almost all the variation in the current one will
have very high
<code class="reqn">t</code>-values. 
</p>


<h3>Value</h3>

<p>Invisible vector of condition numbers by column.  If the start values
for <code>maxLik</code> are named, the condition numbers are named
accordingly. 
</p>


<h3>Author(s)</h3>

<p>Ott Toomet</p>


<h3>References</h3>

<p>Greene, W. (2012): <em>Econometrics Analysis</em>, 7th edition,
p. 130.
</p>


<h3>See Also</h3>

<p><code>kappa</code></p>


<h3>Examples</h3>

<pre><code class="language-R">   set.seed(0)
   ## generate a simple nearly multicollinear dataset
   x1 &lt;- runif(100)
   x2 &lt;- runif(100)
   x3 &lt;- x1 + x2 + 0.000001*runif(100) # this is virtually equal to x1 + x2
   x4 &lt;- runif(100)
   y &lt;- x1 + x2 + x3 + x4 + rnorm(100)
   m &lt;- lm(y ~ -1 + x1 + x2 + x3 + x4)
   print(summary(m)) # note the outlandish estimates and standard errors
                     # while R^2 is 0.88. This suggests multicollinearity
   condiNumber(model.matrix(m))   # note the value 'explodes' at x3
   ## we may test the results further:
   print(summary(lm(x3 ~ -1 + x1 + x2)))
   # Note the extremely high t-values and R^2: x3 is (almost) completely
   # explained by x1 and x2
</code></pre>


</div>