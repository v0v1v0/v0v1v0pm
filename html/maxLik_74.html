<div class="container">

<table style="width: 100%;"><tr>
<td>MaxControl-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class <code>"MaxControl"</code>
</h2>

<h3>Description</h3>

<p>This is the structure that holds the optimization control options.
The corresponding constructors take
the parameters, perform consistency checks, and return the
control structure.  Alternatively, it overwrites the supplied
parameters in an existing <code>MaxControl</code> structure.  There is also
a method to extract the control structure from the estimated
‘maxim’-objects.  
</p>


<h3>Slots</h3>

<p>The default values and definition of the slots:
</p>

<dl>
<dt>tol</dt>
<dd>
<p>1e-8, stopping condition 
for <code>maxNR</code> and related optimizers.
Stop if the absolute difference
between successive iterations is less than <code>tol</code>, returns
code 2.</p>
</dd>
<dt>reltol</dt>
<dd>
<p>sqrt(.Machine$double.eps), relative convergence
tolerance (used by <code>maxNR</code> related optimizers, and
<code>optim</code>-based optimizers.
The algorithm stops if
it iteration increases the value by less than a factor of
<code>reltol*(abs(val) + reltol)</code>.
Returns code 2.</p>
</dd>
<dt>gradtol</dt>
<dd>
<p>1e-6, stopping condition
for <code>maxNR</code> and related optimizers.
Stops if norm of the gradient is
less than <code>gradtol</code>, returns code 1.</p>
</dd>
<dt>steptol</dt>
<dd>
<p>1e-10, stopping/error condition
for <code>maxNR</code> and related optimizers.
If <code>qac == "stephalving"</code> and the quadratic
approximation leads to a worse, instead of a better value, or to
<code>NA</code>, the step length
is halved and a new attempt is made.  If necessary, this procedure is repeated
until <code>step &lt; steptol</code>, thereafter code 3 is returned.</p>
</dd>
</dl>
<dl>
<dt>lambdatol</dt>
<dd>
<p>1e-6, (for <code>maxNR</code> related
optimizers)
controls whether Hessian is treated as negative
definite.  If the
largest of the eigenvalues of the Hessian is larger than
<code>-lambdatol</code> (Hessian is not negative definite),
a suitable diagonal matrix is subtracted from the
Hessian (quadratic hill-climbing) in order to enforce negative
definiteness.</p>
</dd>
</dl>
<dl>
<dt>qac</dt>
<dd>
<p>"stephalving", character, Qadratic Approximation
Correction for <code>maxNR</code> related optimizers.  When the new
guess is worse than the initial one, program attempts to correct it:
<code>"stephalving"</code> decreases the
step but keeps the direction.
<code>"marquardt"</code> uses
<cite>Marquardt (1963)</cite> method by decreasing the step length while also
moving closer to the pure gradient direction.  It may be faster and
more robust choice in areas where quadratic approximation behaves poorly.</p>
</dd>
<dt>qrtol</dt>
<dd>
<p>1e-10, QR-decomposition tolerance
for Hessian inversion in <code>maxNR</code> related optimizers.
</p>
</dd>
<dt>marquardt_lambda0</dt>
<dd>
<p>0.01, a positive numeric, initial correction term
for <cite>Marquardt (1963)</cite> correction in
<code>maxNR</code>-related optimizers</p>
</dd>
<dt>marquardt_lambdaStep</dt>
<dd>
<p>2, how much the <cite>Marquardt (1963)</cite>
correction is decreased/increased at
successful/unsuccesful step
for <code>maxNR</code> related optimizers</p>
</dd>
<dt>marquardt_maxLambda</dt>
<dd>
<p>1e12, maximum allowed correction term
for <code>maxNR</code> related optimizers.
If exceeded, the
algorithm exits with return code 3.</p>
</dd>
</dl>
<dl>
<dt>nm_alpha</dt>
<dd>
<p>1, Nelder-Mead simplex method reflection
factor (see Nelder &amp; Mead, 1965)</p>
</dd>
<dt>nm_beta</dt>
<dd>
<p>0.5, Nelder-Mead contraction factor</p>
</dd>
<dt>nm_gamma</dt>
<dd>
<p>2, Nelder-Mead expansion factor</p>
</dd>
</dl>
<dl>
<dt>sann_cand</dt>
<dd>
<p><code>NULL</code> or a function for <code>"SANN"</code> algorithm
to generate a new candidate point;
if <code>NULL</code>, Gaussian Markov kernel is used
(see argument <code>gr</code> of <code>optim</code>).</p>
</dd>
<dt>sann_temp</dt>
<dd>
<p>10, starting temperature
for the “SANN” cooling schedule.  See <code>optim</code>.</p>
</dd>
<dt>sann_tmax</dt>
<dd>
<p>10, number of function evaluations at each temperature for
the “SANN” optimizer.  See <code>optim</code>.</p>
</dd>
<dt>sann_randomSeed</dt>
<dd>
<p>123, integer to seed random numbers to
ensure replicability of “SANN” optimization and preserve
<code>R</code> random numbers.  Use
options like <code>SANN_randomSeed=Sys.time()</code> or
<code>SANN_randomeSeed=sample(1000,1)</code> if you want stochastic results.
</p>
</dd>
</dl>
<p>General options for stochastic gradient methods:
</p>
<dl>
<dt>SG_learningRate</dt>
<dd>
<p>0.1, learning rate, numeric</p>
</dd>
<dt>SG_batchSize</dt>
<dd>
<p><code>NULL</code>, batch size for Stochastic Gradient Ascent.  A
positive integer, or <code>NULL</code> for full-batch gradent ascent.</p>
</dd>
<dt>SG_clip</dt>
<dd>
<p><code>NULL</code>, gradient clipping threshold.  This is
the max allowed squared Euclidean norm of the gradient.  If the
actual norm of the gradient exceeds (square root of) this
threshold, the gradient will be scaled back accordingly while
preserving its direction.  <code>NULL</code> means no clipping.
</p>
</dd>
<dt>SG_patience</dt>
<dd>
<p><code>NULL</code>, or integer.  Stopping condition: if
the objective function is worse than its largest value so far this
many times, the algorithm stops, and returns not the last
parameter value but the one that
gave the best results so far.  This is mostly useful if gradient
is computed on training data and the
objective function on validation data.
</p>
</dd>
<dt>SG_patienceStep</dt>
<dd>
<p>1L, integer.  After how many epochs to check
the patience value.  1 means to check (and hence to compute the
objective function) at each epoch.
</p>
</dd>
</dl>
<p>Options for SGA:
</p>
<dl>
<dt>SGA_momentum</dt>
<dd>
<p>0, numeric momentum parameter for SGA.  Must lie
in interval <code class="reqn">[0,1]</code>.
</p>
</dd>
</dl>
<p>Options for Adam:
</p>
<dl>
<dt>Adam_momentum1</dt>
<dd>
<p>0.9, numeric in <code class="reqn">[0,1]</code>, the first moment momentum</p>
</dd>
<dt>Adam_momentum2</dt>
<dd>
<p>0.999, numeric in <code class="reqn">[0,1]</code>, the second moment momentum</p>
</dd>
</dl>
<p>General options:
</p>
<dl>
<dt>iterlim</dt>
<dd>
<p>150, stopping condition (the default differs for
different methods).  Stop if more than <code>iterlim</code>
iterations performed.  Note that ‘iteration’ may mean
different things for different optimizers.</p>
</dd>
<dt>max.rows</dt>
<dd>
<p>20, maximum number of matrix rows to be printed when
requesting verbosity in the optimizers.
</p>
</dd>
<dt>max.cols</dt>
<dd>
<p>7, maximum number of columns to be printed.  This
also applies to vectors that are printed horizontally.
</p>
</dd>
<dt>printLevel</dt>
<dd>
<p>0, the level of verbosity.  Larger values print
more information.  Result depends on the optimizer.  Form
<code>print.level</code> is also accepted by the methods for
compatibility.</p>
</dd>
<dt>storeParameters</dt>
<dd>
<p><code>FALSE</code>, whether to store and return the
parameter
values at each epoch.  If <code>TRUE</code>, the stored values
can be retrieved with <code>storedParameters</code>-method.  The
parameters are stored as a matrix with rows corresponding to the
epochs and columns to the parameter components.
</p>
</dd>
<dt>storeValues</dt>
<dd>
<p><code>FALSE</code>, whether to store and return the objective
function values at each epoch.  If <code>TRUE</code>, the stored values
can be retrieved with <code>storedValues</code>-method.</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt>maxControl</dt>
<dd>
<p><code>(...)</code> creates a “MaxControl” object.  The
arguments must be in the form <code>option1 = value1, option2 =
	value2, ...</code>.  The options should be slot names, but the method
also supports selected other parameter forms for compatibility reasons
e.g. “print.level” instead of “printLevel”.
In case there are more than one option with
similar name, the last one overwrites the previous values.  This
allows the user to override default parameters in the control
list.  See example in maxLik-package.
</p>
</dd>
<dt>maxControl</dt>
<dd>
<p><code>(x = "MaxControl", ...)</code> overwrites parameters
of an existing “MaxControl” object.  The ‘...’
argument must be in the form <code>option1 = value1, option2 =
	value2, ...</code>.  In case there are more than one option with
similar name, only the last one is taken into account.  This
allows the user to override default parameters in the control
list. See example in maxLik-package.
</p>
</dd>
<dt>maxControl</dt>
<dd>
<p><code>(x = "maxim")</code> extracts “MaxControl”
structure from an estimated model</p>
</dd>
<dt>show</dt>
<dd>
<p>shows the parameter values</p>
</dd>
</dl>
<h3>Details</h3>

<p>Typically, the control options are supplied in the form of a list, in which
case the corresponding default values are overwritten by the
user-specified ones.  However, one may also create the control
structure by <code>maxControl(opt1=value1, opt2=value2, ...)</code> and
supply such value directly to the optimizer.  In this case the
optimization routine takes all the values from the control object.
</p>


<h3>Note</h3>

<p>Several control parameters can also be supplied directly to the
optimization routines.
</p>


<h3>Author(s)</h3>

<p>Ott Toomet
</p>


<h3>References</h3>


<ul>
<li>
<p> Nelder, J. A. &amp; Mead, R. A (1965) Simplex Method for Function
Minimization <em>The Computer Journal</em> <b>7</b>, 308–313
</p>
</li>
<li>
<p> Marquardt, D. W. (1963) An Algorithm for Least-Squares Estimation of
Nonlinear Parameters <em>Journal of the Society for Industrial and
Applied Mathematics</em> <b>11</b>, 431–441 
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">library(maxLik)
## Create a 'maxControl' object:
maxControl(tol=1e-4, sann_tmax=7, printLevel=2)

## Optimize quadratic form t(D) %*% W %*% D with p.d. weight matrix,
## s.t. constraints sum(D) = 1
quadForm &lt;- function(D) {
   return(-t(D) %*% W %*% D)
}
eps &lt;- 0.1
W &lt;- diag(3) + matrix(runif(9), 3, 3)*eps
D &lt;- rep(1/3, 3)
                        # initial values
## create control object and use it for optimization
co &lt;- maxControl(printLevel=2, qac="marquardt", marquardt_lambda0=1)
res &lt;- maxNR(quadForm, start=D, control=co)
print(summary(res))
## Now perform the same with no trace information
co &lt;- maxControl(co, printLevel=0)
res &lt;- maxNR(quadForm, start=D, control=co) # no tracing information
print(summary(res))  # should be the same as above
maxControl(res) # shows the control structure
</code></pre>


</div>