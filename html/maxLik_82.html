<div class="container">

<table style="width: 100%;"><tr>
<td>sumt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Equality-constrained optimization
</h2>

<h3>Description</h3>

<p>Sequentially Unconstrained Maximization Technique (SUMT) based
optimization for linear equality constraints.
</p>
<p>This implementation is primarily intended to be called from other
maximization routines, such as <code>maxNR</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sumt(fn, grad=NULL, hess=NULL,
start,
maxRoutine, constraints,
SUMTTol = sqrt(.Machine$double.eps),
SUMTPenaltyTol = sqrt(.Machine$double.eps),
SUMTQ = 10,
SUMTRho0 = NULL,
printLevel=print.level, print.level = 0, SUMTMaxIter = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>

<p>function of a (single) vector parameter.  The function may have more
arguments (passed by ...), but those are not treated as the
parameter. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grad</code></td>
<td>

<p>gradient function of <code>fn</code>.  NULL if missing
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hess</code></td>
<td>

<p>function, Hessian of the <code>fn</code>.  NULL if missing
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>

<p>numeric, initial value of the parameter
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxRoutine</code></td>
<td>

<p>maximization algorithm, such as <code>maxNR</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>list, information for constrained maximization.
Currently two components are supported: <code>eqA</code> and <code>eqB</code>
for linear equality constraints: <code class="reqn">A \beta + B = 0</code>.  The user must ensure that the matrices <code>A</code> and
<code>B</code> are conformable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SUMTTol</code></td>
<td>

<p>stopping condition.  If the estimates at successive outer
iterations are close enough, i.e. maximum of the absolute value over
the component difference is smaller than SUMTTol, the algorithm
stops.
</p>
<p>Note this does not necessarily mean that the constraints are
satisfied.
If the penalty function is too “weak”, SUMT may repeatedly find
the same optimum.  In that case a warning is issued.  The user may
set SUMTTol to a lower value, e.g. to zero.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SUMTPenaltyTol</code></td>
<td>

<p>stopping condition.  If the barrier value (also called penalty)
<code class="reqn">(A \beta + B)'(A \beta + B)</code> is less than
<code>SUMTTol</code>, the algorithm stops
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SUMTQ</code></td>
<td>

<p>a double greater than one, controlling the growth of the <code>rho</code>
as described in Details. Defaults to 10.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SUMTRho0</code></td>
<td>

<p>Initial value for <code>rho</code>.  If not specified, a (possibly)
suitable value is
selected.  See Details.
</p>
<p>One should consider supplying <code>SUMTRho0</code> in case where the
unconstrained problem does not have a maximum, or the maximum is too
far from the constrained value.  Otherwise the authomatically selected
value may not lead to convergence.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printLevel</code></td>
<td>

<p>Integer, debugging information.  Larger number prints more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.level</code></td>
<td>
<p>same as ‘printLevel’, for backward
compatibility</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SUMTMaxIter</code></td>
<td>

<p>Maximum SUMT iterations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Other arguments to <code>maxRoutine</code> and <code>fn</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Sequential Unconstrained Minimization Technique is a heuristic
for constrained optimization.  To minimize a function <code class="reqn">f</code>
subject to
constraints, it uses a non-negative penalty function <code class="reqn">P</code>,
such that <code class="reqn">P(x)</code> is zero
iff <code class="reqn">x</code>
satisfies the constraints.  One iteratively minimizes
<code class="reqn">f(x) + \varrho_k P(x)</code>, where the
<code class="reqn">\varrho</code>
values are increased according to the rule
<code class="reqn">\varrho_{k+1} = q \varrho_k</code> for some
constant <code class="reqn">q &gt; 1</code>, until convergence is
achieved in the sense that the barrier value
<code class="reqn">P(x)'P(x)</code> is close to zero.  Note that there is no
guarantee that the global constrained optimum is
found.  Standard practice recommends to use the best solution
found in “sufficiently many” replications.
</p>
<p>Any of
the maximization algorithms in the <span class="pkg">maxLik</span>, such as
<code>maxNR</code>, can be used for the unconstrained step.
</p>
<p>Analytic gradient and hessian
are used if provided.
</p>


<h3>Value</h3>

<p>Object of class 'maxim'.  In addition, a component
</p>
<table><tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>A list, describing the constrained optimization.
Includes the following components:
</p>

<dl>
<dt>type</dt>
<dd>
<p>type of constrained optimization</p>
</dd>
<dt>barrier.value</dt>
<dd>
<p>value of the penalty function at maximum</p>
</dd>
<dt>code</dt>
<dd>
<p>code for the stopping condition</p>
</dd>
<dt>message</dt>
<dd>
<p>a short message, describing the stopping condition</p>
</dd>
<dt>outer.iterations</dt>
<dd>
<p>number of iterations in the SUMT step</p>
</dd>
</dl>
</td>
</tr></table>
<h3>Note</h3>

<p>In case of equality constraints, it
may be more efficient to enclose the function
in a wrapper function.  The wrapper calculates full set of parameters
based on a smaller set of parameters, and the
constraints.
</p>


<h3>Author(s)</h3>

<p>Ott Toomet, Arne Henningsen
</p>


<h3>See Also</h3>

<p><code>sumt</code> in package <span class="pkg">clue</span>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## We maximize exp(-x^2 - y^2) where x+y = 1
hatf &lt;- function(theta) {
   x &lt;- theta[1]
   y &lt;- theta[2]
   exp(-(x^2 + y^2))
   ## Note: you may prefer exp(- theta %*% theta) instead
}
## use constraints: x + y = 1
A &lt;- matrix(c(1, 1), 1, 2)
B &lt;- -1
res &lt;- sumt(hatf, start=c(0,0), maxRoutine=maxNR,
            constraints=list(eqA=A, eqB=B))
print(summary(res))
</code></pre>


</div>