<div class="container">

<table style="width: 100%;"><tr>
<td>maximin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Space-filling design under the criterion of maximin distance
</h2>

<h3>Description</h3>

<p>Generates a space-filling design under the criterion of maximum-minimum distance;
both discrete and continuous searches are provided.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  maximin.cand(n, Xcand, Tmax, Xorig=NULL, init=NULL, verb=FALSE, tempfile=NULL) 
  maximin(n, p, T, Xorig=NULL, Xinit=NULL, verb=FALSE, plot=FALSE, boundary=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> the number of space-filling locations </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xcand</code></td>
<td>
<p> the candidate set, from which each space-filling location is selected </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tmax</code></td>
<td>
<p> the number of iterations; <code>Tmax &lt;= nrow(Xcand)</code>; to be safe, set <code>Tmax = nrow(Xcand)</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xorig</code></td>
<td>
<p> the existing design; <code>ncol(Xorig) = ncol(Xcand)</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p> the initial indices of <code>X</code>; it can be randomly selected from <code>Xcand</code> or introduced from a previous experiment. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p> progress indicator — every tenth iteration is printed out; by default <code>verb = FALSE</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tempfile</code></td>
<td>
<p> the name of a temporary file given the progress is saved with each iteration; by default <code>tempfile = NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p> the dimensionality of input space </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>
<p> the number of iterations; <code class="reqn">T &gt; n</code>; setting <code class="reqn">T = 10 * n</code> is a good starting point. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xinit</code></td>
<td>
<p> the (initial) design introduced from a previous experiment </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p> if <code>plot = TRUE</code>, then the search space and the "start location –&gt; new location" with each iteration is plotted; 
if <code class="reqn">p &gt; 2</code>, then TWO input coordinates are RANDOMLY chosen for plotting; it is worth noticing that the search space 
only VISUALLY makes sense when <code class="reqn">p = 2</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p> if <code>boundary = TRUE</code>, then for each iteration, the "to-be-swapped-in" location will be away from the 
boundary in addition to being away from other <code>X</code> locations and <code>Xorig</code>; how far is it? <code class="reqn">min(d, 4*d.bound)</code>, 
where <code>d</code> is the Euclidean distance between the "to-be-swapped-in" location and other <code>X</code> locations as well as <code>Xorig</code>, while 
<code>d.bound</code> is the minimum Euclidean distance between the "to-be-swapped-in" location and the boundaries.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Constructing a space-filling design under the criterion of maximum-minimum distance is quite 
useful in computer experiments and related fields. Previously, researchers would construct 
such a design in a random accept-reject way, i.e., randomly propose a location within the 
study region to replace a randomly selected row from the initial design. If such a proposal 
increases the minimum pairwise Euclidean distance, then accept the replacement; otherwise 
keep the original design location. By repeatedly proposing (and accept-rejecting) in this 
way one is able to construct an (approximately) space-filling design.  However the algorithm 
is inefficient computationally.  The reason is that the proposals are not optimized in any way.
</p>
<p>In this package, we provide an alternative to build up a well-defined space-filling design 
more efficiently. There are two versions, one is with discrete search, while the other is 
with continuous search. For the former, each iteration proposes to swap out a row from the 
initial design with the minimum distance, and swap in one location from a candidate set to 
increase the minimum distance. For the latter, the core idea is the same, but instead of working 
with a candidate set, <code>optim</code> is used to maximize the distance between the "to-be-swapped-in" 
location and other design locations as well as to any existing design, <code>Xorig</code>. Several 
heuristics are deployed for situations where the search becomes stuck in a local mode.  One 
involves moving to a location with non-minimum distance, and the other is to jump to a location 
which has the maximum minimum distance. 
</p>
<p>For a visualization of applying <code>maximin.cand</code> in a real-life problem on solar irradiance, see Sun et al. (2019).
</p>
<p><code>maximin.cand</code> returns the indices of <code>Xcand</code>, which makes the final space-filling design,
and the minimum pairwise Euclidean distance with each iteration
</p>
<p><code>maximin</code> returns the combined existing design and the space-filling design, 
together with the minimum pairwise Euclidean distance with each iteration
</p>


<h3>Value</h3>

<p><code>maximin.cand</code> returns
</p>
<table>
<tr style="vertical-align: top;">
<td><code>inds</code></td>
<td>
<p> the indices of <code>Xcand</code>, which makes the final space-filling design </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mis</code></td>
<td>
<p> the minimum distance with each iteration; <code>length(mis) = Tmax + 1</code> </p>
</td>
</tr>
</table>
<p><code>maximin</code> returns
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Xf</code></td>
<td>
 <p><code>dim(Xf) = (nrow(Xorig) + n) * p</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mi</code></td>
<td>
<p> the minimum distance with each iteration; <code>length(mi) = T + 1</code> </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Furong Sun <a href="mailto:furong.sun@gmail.com">furong.sun@gmail.com</a> and Robert B. Gramacy <a href="mailto:rbg@vt.edu">rbg@vt.edu</a> 
</p>


<h3>References</h3>

<p>F. Sun, R.B. Gramacy, B. Haaland, S.Y. Lu, and Y. Hwang (2019)
<em>Synthesizing Simulation and Field Data of Solar Irradiance</em>, Statistical Analysis and Data Mining, 12(4), 311-324;
preprint on arXiv:1806.05131.
</p>
<p>M.H.Y. Tan (2013)
<em>Minimax Designs for Finite Design Regions</em>, Technometrics, 55(3), 346-358. 
</p>
<p>M.E. Johnson, L.M. Moore, and D. Yivisaker (1990)
<em>Minimax and Maximin Distance Designs</em>, Journal of Statistical Planning and Inference, 26(2), 131-148. 
</p>


<h3>Examples</h3>

<pre><code class="language-R">   
 ## Not run: 
   ## maximin.cand
   # generate the design
   library("lhs")
   n &lt;- 100
   p &lt;- 2
   Xorig &lt;- randomLHS(10, p)
   x1 &lt;- seq(0, 1, length.out=n)
   Xcand &lt;- expand.grid(replicate(p, x1, simplify=FALSE))
   names(Xcand) &lt;- paste0("x", 1:2)
   T &lt;- nrow(Xcand)
   Xsparse &lt;- maximin.cand(n=n, Xcand=Xcand, Tmax=T, Xorig=Xorig, 
                           init=NULL, verb=FALSE, tempfile=NULL)
   
   maxmd &lt;- as.numeric(format(round(max(na.omit(Xsparse$mis)), 5), nsmall=5))
   
   # visualization
   par(mfrow=c(1, 2))
   X &lt;- Xcand[Xsparse$inds,]
   plot(X$x1, X$x2, xlab=expression(x[1]), ylab=expression(x[2]), 
        xlim=c(0, 1), ylim=c(0, 1), 
        main=paste0("n=", n, "_p=", p, "_maximin=", maxmd))
   points(Xorig, col=2, pch=20)
   abline(h=c(0, 1), v=c(0, 1), lty=2, col=2)
   if(!is.null(Xorig))
   {
     legend("topright", "Xorig", xpd=TRUE, horiz=TRUE, 
            inset=c(-0.03, -0.05), pch=20, col=2, bty="n")
   }
   plot(log(na.omit(Xsparse$mis)), type="b", 
        xlab="iteration", ylab="log(minimum distance)", 
        main="progress on minimum distance")
   abline(v=n, lty=2)
   mtext(paste0("design size=", n), at=n, cex=0.6)
   
  
## End(Not run)
  
  ## maximin
  # generate the design
  library("lhs")
  n &lt;- 10
  p &lt;- 2
  T &lt;- 10*n
  Xorig &lt;- randomLHS(10, p)
  Xsparse &lt;- maximin(n=n, p=p, T=T, Xorig=Xorig, Xinit=NULL, 
                     verb=FALSE, plot=FALSE, boundary=FALSE)
  maxmd &lt;- as.numeric(format(round(Xsparse$mi[T+1], 5), nsmall=5))
  
  # visualization
  par(mfrow=c(1,2))
  plot(Xsparse$Xf[,1], Xsparse$Xf[,2], xlab=expression(x[1]), ylab=expression(x[2]), 
       xlim=c(0, 1), ylim=c(0, 1), 
       main=paste0("n=", n, " p=", p, " T=", T, " maximin=", maxmd))
  points(Xorig, col=2, pch=20)
  abline(h=c(0,1), v=c(0,1), lty=2, col=2)
  if(!is.null(Xorig)) legend("topright", "Xorig", xpd=TRUE, horiz=TRUE, 
     inset=c(-0.03, -0.05), pch=20, col=2, bty="n")
  plot(log(Xsparse$mi), type="b", xlab="iteration", ylab="log(minimum distance)", 
       main="progress on minimum distance")
  abline(v=n, lty=2)
  mtext(paste0("design size=", n), at=n, cex=0.6)
  abline(v=T, lty=2)
  mtext(paste0("max.md=", maxmd), at=T, cex=0.6)
</code></pre>


</div>