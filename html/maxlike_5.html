<div class="container">

<table style="width: 100%;"><tr>
<td>maxlike</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Model occurrence probability using presence-only data
</h2>

<h3>Description</h3>

<p>This function estimates the probability of occurrence using
presence-only data and spatially-referenced covariates. Species
distribution maps can be created by plotting the
expected values of occurrence probability.  The model is described by
Royle et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class="language-R">  maxlike(formula, rasters, points, x=NULL, z=NULL,
          link=c("logit", "cloglog"),
          starts, hessian = TRUE, fixed, removeDuplicates=FALSE,
          savedata=FALSE, na.action = "na.omit", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>A right-hand side <code>formula</code> describing the model.
At least 1 continuous covariate must be present in the formula.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rasters</code></td>
<td>

<p>The spatially-referenced covariate data formatted as a 'raster
stack' created by the <code>stack</code> function
in the <code>raster-package</code>. It's a good idea to standardize
these by subtracting the mean and dividing by the standard
deviation. This will make it easier for <code>optim</code> to find
the maximum-likelihood estimates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>

<p>A <code>matrix</code> or <code>data.frame</code> with the X and Y
coordinates of the presence locations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>A <code>matrix</code> or <code>data.frame</code> with the explanatory
data for presence locations. In case data is provided for <code>x</code>
and <code>z</code>, arguments <code>rasters</code> and <code>points</code> will be ignored
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>

<p>A <code>matrix</code> or <code>data.frame</code> with the explanatory
data for background locations. In case data is provided for <code>x</code>
and <code>z</code>, arguments <code>rasters</code> and <code>points</code> will be ignored
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>

<p>The link function. Either "logit" (the default) or "cloglog".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starts</code></td>
<td>

<p>Starting values for the parameters. This should be a vector with as
many elements as there are parameters. By default, all starting
values are 0, which should be adequate if covariates are standardized.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>

<p>Logical. Should the hessian be computed and the variance-covariance
matrix returned?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>

<p>Optional vector for fixing parameters. It must be
of length equal to the number of parameters in the
model. If an element of <code>fixed</code> is NA, then the parameter is
estimated, otherwise if it is a real number, the parameter is fixed
at this value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeDuplicates</code></td>
<td>

<p>Logical. Should duplicate points be removed? Defaults to FALSE, but
note that the MAXENT default is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>savedata</code></td>
<td>

<p>Should the raster data be saved with the fitted model? Defaults to
FALSE in order to reduce the size of the returned object. If you
wish to make predictions, it is safer to set this to TRUE, otherwise
the raster data are searched for in the working directory, and thus
may not be the data used to fit the model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>See <code>options</code> for choices
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments passed to <code>optim</code>
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>points</code> and <code>rasters</code>
should the same coordinate system. The program does not check
this so it is up to the user.
</p>


<h3>Value</h3>

<p>A list with 8 components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Est</code></td>
<td>
<p>data.frame containing the parameter estimates (Ests) and
standard errors (SE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>variance-covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AIC</code></td>
<td>
<p>AIC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the original call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pts.removed</code></td>
<td>
<p>The points removed due to missing values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pix.removed</code></td>
<td>
<p>The pixels removed due to missing values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim</code></td>
<td>
<p>The object returned by <code>optim</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>not.fixed</code></td>
<td>
<p>A logical vector indicating if a parameter was
estimated or fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>The link function</p>
</td>
</tr>
</table>
<h3>Warnings</h3>

<p>Maximizing the log-likelihood function is achieved using the
<code>optim</code> function, which can fail to find the global optima
if sensible starting values are not
supplied. The default starting values are <code>rep(0, npars)</code>, which
will often be adequate if the covariates have been
standardized. Standardizing covariates is thus recommended.
Even when covariates are standardized, it is always a good idea to try
various starting values to see if the
log-likelihood can be increased. When fitting models with many
parameters, good starting values can be found by fitting simpler
models first.
</p>


<h3>Note</h3>

<p>In general it is very hard to obtain a random sample of presence
points, which is a requirement of both the Royle et al. (2012)
method and of MAXENT. This is one of many reasons why presence-absence
data are preferable to presence-only data. When presence-absence data
are available, they can be modeled using functions such as
<code>glm</code>. Creating species distribution maps
from <code>glm</code> is easily accomplished using the
<code>predict</code> method.
</p>
<p>The MAXENT software assumes that species prevalence is known a
priori. If the user does not specify a value for prevalence,
prevalence is set to 0.5. MAXENT predictions of occurrence probability
are highly sensitive to this setting. In contrast, <code>maxlike</code>
directly estimates prevalence.
</p>
<p>Another weakness of models for presence-only data is that they do not
allow one to model detection probability, which is typically less than
one in field conditions. If detection probability is affected by the same
covariates that affect occurrence probability, then bias
is inevitable. The R package <span class="pkg">unmarked</span>
(Fiske and Chandler 2011) offers numerous
methods for jointly modeling both occurrence and detection probability
when detection/non-detection data are available.
</p>


<h3>References</h3>

<p>Royle, J.A., R.B. Chandler, C. Yackulic and J.
D. Nichols. 2012. Likelihood analysis of species occurrence probability
from presence-only data for modelling species distributions. Methods
in Ecology and Evolution. doi: 10.1111/j.2041-210X.2011.00182.x
</p>
<p>Fiske, I. and R.B. Chandler. 2011. unmarked: An R Package for Fitting
Hierarchical Models of Wildlife Occurrence and Abundance. Journal of
Statistical Software 43(10).
</p>


<h3>See Also</h3>

 <p><code>maxlike-package</code>, <code>raster</code>,
<code>carw</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

# Carolina Wren data used in Royle et. al (2012)
data(carw)

# Covert data.frame to a list of rasters
rl &lt;- lapply(carw.data$raster.data, function(x) {
   m &lt;- matrix(x, nrow=carw.data$dim[1], ncol=carw.data$dim[2], byrow=TRUE)
   r &lt;- raster(m)
   extent(r) &lt;- carw.data$ext
   r
})

# Create a raster stack and add layer names
rs &lt;- stack(rl[[1]], rl[[2]], rl[[3]], rl[[4]], rl[[5]], rl[[6]])
names(rs) &lt;- names(carw.data$raster.data)

plot(rs)


# Fit a model
fm &lt;- maxlike(~pcMix + I(pcMix^2) + pcDec + I(pcDec^2)+ pcCon +
    I(pcCon^2) + pcGr + I(pcGr^2) +
    Lat + I(Lat^2) + Lon + I(Lon^2), rs, carw.data$xy1,
    method="BFGS", removeDuplicates=TRUE, savedata=TRUE)

summary(fm)
confint(fm)
AIC(fm)
logLik(fm)


# Produce species distribution map (ie, expected probability of occurrence)
psi.hat &lt;- predict(fm) # Will warn if savedata=FALSE
plot(psi.hat)
points(carw.data$xy1, pch=16, cex=0.1)



# MAXENT sets "default prevalence" to an arbitrary value, 0.5.
# We could do something similar by fixing the intercept at logit(0.5)=0.
# However, it seems more appropriate to estimate this parameter.

# fm.fix &lt;- update(fm, fixed=c(0, rep(NA,length(coef(fm))-1)))

# Predict data.frame
presenceData &lt;- as.data.frame(extract(rs, carw.data$xy1))
presenceData &lt;- presenceData[complete.cases(presenceData), ]
presence.predictions &lt;- predict(fm, newdata=presenceData)
summary(presence.predictions)

# Calibrate with data.frames
PresenceUniqueCells &lt;- unique(cellFromXY(rs, xy=carw.data$xy1))
PresenceUnique &lt;- xyFromCell(rs, PresenceUniqueCells)
presenceData &lt;- as.data.frame(extract(rs, PresenceUnique))
library(dismo)
background &lt;- randomPoints(rs, n=ncell(rs), extf=1.00)
backgroundData &lt;- as.data.frame(extract(rs, y=background))
backgroundData &lt;- backgroundData[complete.cases(backgroundData), ]
fm2 &lt;- maxlike(~pcMix + I(pcMix^2) + pcDec + I(pcDec^2)+ pcCon +
    I(pcCon^2) + pcGr + I(pcGr^2) +
    Lat + I(Lat^2) + Lon + I(Lon^2),
    rasters=NULL, points=NULL,
    x=presenceData, z=backgroundData,
    method="BFGS", removeDuplicates=TRUE, savedata=TRUE)

summary(fm2)

fm2$rasters &lt;- rs
psi.hat2 &lt;- predict(fm2)


# Simulation example

set.seed(131)
x1 &lt;- sort(rnorm(100))
x1 &lt;- raster(outer(x1, x1), xmn=0, xmx=100, ymn=0, ymx=100)

x2 &lt;- raster(matrix(runif(1e4), 100, 100), 0, 100, 0, 100)

# Code factors as dummy variables.
# Note, using asFactor(x3) will not help
x3 &lt;- raster(matrix(c(0,1), 100, 100), 0, 100, 0, 100)

logit.psi &lt;- -1 + 1*x1 + 0*x2
psi &lt;- exp(logit.psi)/(1+exp(logit.psi))
plot(psi)

r &lt;- stack(x1, x2, x3)
names(r) &lt;- c("x1", "x2", "x3")
plot(r)

pa &lt;- matrix(NA, 100, 100)
pa[] &lt;- rbinom(1e4, 1, as.matrix(psi))
str(pa)
table(pa)

pa &lt;- raster(pa, 0, 100, 0, 100)
plot(pa)

xy &lt;- xyFromCell(pa, sample(Which(pa==1, cells=TRUE), 1000))

plot(x1)
points(xy)

fm2 &lt;- maxlike(~x1 + x2 + x3, r, xy)

summary(fm2)
confint(fm2)
AIC(fm2)
logLik(fm2)


## End(Not run)

</code></pre>


</div>