<div class="container">

<table style="width: 100%;"><tr>
<td>maxnodf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate the maximum nestedness of a bipartite network</h2>

<h3>Description</h3>

<p>Calculates the maximum NODF that be achieved in a network with a given number of rows, columns and links.
</p>


<h3>Usage</h3>

<pre><code class="language-R">maxnodf(web, quality = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>web</code></td>
<td>
<p>Either a numeric matrix describing a bipartite network (a bipartite incidence matrix where elements are positive numbers if nodes interact, and 0 otherwise) 
or a numeric vector of length 3 of the form web = c(#Rows, #Columns, #Links).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quality</code></td>
<td>
<p>An optional quality parameter to control the tradeoff between computation time and result quality. Can be 0, 1 or 2.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a given network, <code>maxnodf</code> calculates the maximum nestedness that can be achieved in a network with a given number of rows, columns and links, subject to the constraint that all rows and columns must have at least one link (i.e. marginal totals must always be &gt;= 1). 
This allows nestedness values to be normalised as <code class="reqn">NODF/max(NODF)</code> following Song et al (2017). To control for connectance and network size, Song et al. (2017) suggest an additional normalisation that
can be used: <code class="reqn">(NODF/max(NODF))/(C * log(S))</code> where C is the network connectance and S is the geometric mean of the number of plants and pollinators in the network.
</p>
<p><code>maxnodf</code> has three algorithms for finding the maximum nestedness of a bipartite network. These can be set using the <code>quality</code> argument. Lower quality settings are faster, but find worse optima. Higher quality settings
are slower, but find better optima.
</p>

<ul>
<li>
<p><code>quality</code> = 0, uses a greedy algorithm.
</p>
</li>
<li>
<p><code>quality</code> = 1, uses a greedy algorithm plus hillclimbing.
</p>
</li>
<li>
<p><code>quality</code> = 2, uses a simulated annealing algorithm, with the greedy algorithm output as the start point. Best results, but requires the most computation time.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Returns a list of length 2, where the first element ('max_nodf') is the maximum nestedness of the network and the second element ('max_nodf_mtx') is the incidence matrix corresponding to this maximum nestedness.
</p>


<h3>References</h3>

<p>Song, C., Rohr, R.P. and Saavedra, S., 2017. Why are some plantâ€“pollinator networks more nested than others? Journal of Animal Ecology, 86(6), pp.1417-1424
</p>


<h3>Examples</h3>

<pre><code class="language-R">maxnodf(matrix(1.0, 12, 10))
maxnodf(c(14, 13, 52), 2)
</code></pre>


</div>