<div class="container">

<table style="width: 100%;"><tr>
<td>parallelogram_maze</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>parallelogram_maze .</h2>

<h3>Description</h3>

<p>Recursively draw a parallelogram maze, with the first side consisting of
<code>height</code> segments of length <code>unit_len</code>, and the second side 
<code>width</code> segments of length <code>unit_len</code>. The angle between
the first and second side may be set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">parallelogram_maze(unit_len, height, width = height, angle = 90,
  clockwise = TRUE, method = c("two_parallelograms", "four_parallelograms",
  "uniform", "random"), start_from = c("midpoint", "corner"), balance = 0,
  height_boustro = c(1, 1), width_boustro = c(1, 1),
  draw_boundary = FALSE, num_boundary_holes = 2, boundary_lines = TRUE,
  boundary_holes = NULL, boundary_hole_color = NULL,
  boundary_hole_locations = NULL, boundary_hole_arrows = FALSE,
  end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the ‘holes’ in the boundary lines and
generally controls the spacing of mazes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>height</code></td>
<td>
<p>the length of the first side in numbers of <code>unit_len</code>
segments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>the length of the second side in numbers of <code>unit_len</code>
segments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>angle</code></td>
<td>
<p>the angle (in degrees) between the first and second sides.
Note that this is the angle that the Turtle turns when rounding
the first corner, so it is the internal angle at the starting
point (if starting from a corner), and the external angle at
the second corner.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>there are many ways to recursive draw an isosceles
trapezoid.  The following values are acceptable:
</p>

<dl>
<dt>two_parallelograms</dt>
<dd>
<p>The parallelogram maze is built as two
parallelogram mazes with a holey line between them.</p>
</dd>
<dt>four_parallelograms</dt>
<dd>
<p>The parallelogram maze is built as four
parallelogram mazes with three holey lines and one solid line between them.</p>
</dd>
<dt>uniform</dt>
<dd>
<p>The parallelogram maze is built as four
parallelogram mazes with three holey lines and one solid line between them.
Sub-mazes are chosen to be nearly equal in size.</p>
</dd>
<dt>random</dt>
<dd>
<p>A method is chosen uniformly at random.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance</code></td>
<td>
<p>for the <code>two_parallelograms</code> method, we choose whether
to split on height or width based on a balance condition. The log odds
of choosing height over width is the factor <code>balance</code> times the 
sign of the difference <code>height - width</code>. When balance takes the default
value of 0, you have equal odds of selecting to split on height or width.
Note that balance is positive and large, you tend to generate nearly
uniform splits. When balance is negative and large, you tend to have
imbalanced mazes, and the imbalance propagates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>height_boustro</code></td>
<td>
<p>an array of two values, which help determine
the location of holes in internal lines of length
<code>height</code>. The default value, <code>c(1,1)</code> results in 
uniform selection. Otherwise the location of holes are chosen
with probability proportional to a beta density with 
<code>shape1</code> and <code>shape2</code> the two elements of <code>height_boustro</code>
in order. In sub mazes, this parameter is reversed, which
can lead to ‘boustrophedonic’ mazes. The sum of values
should probably not exceed 30, as otherwise the location of internal
holes is forced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width_boustro</code></td>
<td>
<p>an array of two values, which help determine
the location of any split along lines which are length <code>width</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code>holey_path</code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code>holey_path</code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary_hole_locations</code></td>
<td>
<p>the ‘locations’ of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Draws a maze in an parallelogram, starting from the midpoint
of the first side (or the corner before the first side via the
<code>start_from</code> option). Can recursively subdivide into two or
four parallelograms.  The first (and third) side shall consist of <code>height</code>
segments of length <code>unit_len</code>. The second and fourth side consist of
<code>width</code> segments of length <code>unit_len</code>. The angle between them is
<code>angle</code>. Here is an example maze:
</p>

<p><img src="../help/figures/para-maze-1.png" width="100%" alt="Figure: parallelogram maze"></p>
<p>This function admits a <code>balance</code> parameter which controls
how the maze should be recursively subdivided. A negative value creates
imbalanced mazes, while positive values create more uniform mazes. Here are
create seven mazes created side by side with an increasing balance
parameter:
</p>

<p><img src="../help/figures/para-imbalance-fade-1.png" width="100%" alt="Figure: parallelogram maze"></p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(TurtleGraphics)

turtle_init(500,300,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
 turtle_setpos(15,15)
 turtle_setangle(0)
 parallelogram_maze(angle=90,unit_len=10,width=45,height=25,method='uniform',
 	start_from='corner',draw_boundary=TRUE)
})

# testing imbalance condition
turtle_init(400,500,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
 turtle_setpos(15,250)
 turtle_setangle(0)
 parallelogram_maze(angle=90,unit_len=10,width=30,height=40,
   method='two_parallelograms',draw_boundary=TRUE,balance=-1.0)
})

# a bunch of imbalanced mazes, fading into each other
turtle_init(850,400,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
  turtle_setpos(15,200)
  turtle_setangle(0)
  valseq &lt;- seq(from=-1.5,to=1.5,length.out=4)
  blines &lt;- c(1,2,3,4)
  bholes &lt;- c(1,3)
  set.seed(12354)
  for (iii in seq_along(valseq)) {
     parallelogram_maze(angle=90,unit_len=10,width=20,height=25,
      method='two_parallelograms',draw_boundary=TRUE,balance=valseq[iii],
       end_side=3,boundary_lines=blines,boundary_holes=bholes)
     turtle_right(180)
     blines &lt;- c(2,3,4)
     bholes &lt;- c(3)
  }
})

# a somewhat 'boustrophedonic' maze
turtle_init(500,300,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
 turtle_setpos(15,15)
 turtle_setangle(0)
 parallelogram_maze(angle=90,unit_len=10,width=47,height=27,
    method='two_parallelograms', height_boustro=c(21,3),width_boustro=c(21,3),balance=-0.25,
		 start_from='corner',draw_boundary=TRUE)
})
</code></pre>


</div>