<div class="container">

<table style="width: 100%;"><tr>
<td>confint.mboost</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Pointwise Bootstrap Confidence Intervals
</h2>

<h3>Description</h3>

<p>Compute and display pointwise confidence intervals
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mboost'
confint(object, parm = NULL, level = 0.95, B = 1000,
        B.mstop = 25, newdata = NULL, which = parm,
        papply = ifelse(B.mstop == 0, mclapply, lapply),
        cvrisk_options = list(), ...)
## S3 method for class 'mboost.ci'
plot(x, which, level = x$level, ylim = NULL, type = "l", col = "black",
     ci.col = rgb(170, 170, 170, alpha = 85, maxColorValue = 255),
     raw = FALSE, print_levelplot = TRUE,...)
## S3 method for class 'mboost.ci'
lines(x, which, level = x$level,
     col = rgb(170, 170, 170, alpha = 85, maxColorValue = 255),
     raw = FALSE, ...)


## S3 method for class 'glmboost'
confint(object, parm = NULL, level = 0.95,
        B = 1000, B.mstop = 25, which = parm, ...)
## S3 method for class 'glmboost.ci'
print(x, which = NULL, level = x$level, pe = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>a fitted model object of class <code>glmboost</code>, <code>gamboost</code> or
<code>mboost</code> for which the confidence intervals should be computed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm, which</code></td>
<td>

<p>a subset of base-learners to take into account for computing
confidence intervals. See <code>mboost_methods</code> for details.
<code>parm</code> is just a synonyme for <code>which</code> to be in line with
the generic <code>confint</code> function. Preferably use <code>which</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>

<p>the confidence level required.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>

<p>number of outer bootstrap replicates used to compute the empirical
bootstrap confidence intervals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.mstop</code></td>
<td>

<p>number of inner bootstrap replicates used to determine the optimal
mstop on each of the <code>B</code> bootstrap samples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>optionally, a data frame on which to compute the predictions for the
confidence intervals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>papply</code></td>
<td>

<p>(parallel) apply function for the outer bootstrap, defaults to
<code>mclapply</code> if no inner bootstrap is used to
determine the optimal stopping iteration. For details see
argument <code>papply</code> in <code>cvrisk</code>. Be careful with your
computing resources if you use parallel computing for both, the
inner and the outer bootstrap.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvrisk_options</code></td>
<td>

<p>(optionally) specify a named list with arguments to the inner
bootstrap. For example use <code>cvrisk_options = list(mc.cores =
      2)</code> to specify that the <code>mclapply</code> function within
<code>cvrisk</code> uses 2 cores to compute the optimal
<code>mstop</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a confidence interval object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>

<p>limits of the y scale. Per default computed from the data to plot.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>type of graphic for the point estimate, i.e., for the predicted
function. Per default a line is plotted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>

<p>color of the point estimate, i.e., for the predicted function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.col</code></td>
<td>

<p>color of the confidence interval.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>

<p>logical, should the raw function estimates or the derived confidence
estimates be plotted?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_levelplot</code></td>
<td>

<p>logical, should the <span class="pkg">lattice</span> <code>levelplot</code> be printed
or simply returned for further modifications. This argument is only
considered if bivariate effect estimates are plotted. If
<code>print_levelplot</code> is set to <code>FALSE</code>, a list with objects
<code>mean</code>, <code>lowerPI</code> and <code>upperPI</code> is returned
containing the three <code>levelplot</code> objects.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pe</code></td>
<td>

<p>logical, should the point estimtate (PE) be also returned?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments to the outer bootstrap such as <code>mc.cores</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Use a nested boostrap approach to compute pointwise confidence
intervals for the predicted partial functions or regression
parameters. The approach is further described in Hofner et al. (2016).
</p>


<h3>Value</h3>

<p>An object of class <code>glmboost.ci</code> or <code>mboost.ci</code> with special
<code>print</code> and/or <code>plot</code> functions.
</p>


<h3>Author(s)</h3>

<p>Benjamin Hofner &lt;benjamin.hofner@pei.de&gt;
</p>


<h3>References</h3>

<p>Benjamin Hofner, Thomas Kneib and Torsten Hothorn (2016), 
A Unified Framework of Constrained Regression. 
<em>Statistics &amp; Computing</em>, <b>26</b>, 1â€“14.
</p>


<h3>See Also</h3>

<p><code>cvrisk</code> for crossvalidation approaches and
<code>mboost_methods</code> for other methods.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
############################################################
## Do not run these examples automatically as they take
## some time (~ 30 seconds depending on the system)

### a simple linear example
set.seed(1907)
data &lt;- data.frame(x1 = rnorm(100), x2 = rnorm(100),
                   z = factor(sample(1:3, 100, replace = TRUE)))
data$y &lt;- rnorm(100, mean = data$x1 - data$x2 - 1 * (data$z == 2) +
                            1 * (data$z == 3), sd = 0.1)
linmod &lt;- glmboost(y ~ x1 + x2 + z, data = data,
                   control = boost_control(mstop = 200))

## compute confidence interval from 10 samples. Usually one should use
## at least 1000 samples.
CI &lt;- confint(linmod, B = 10, level = 0.9)
CI

## to compute a confidence interval for another level simply change the
## level in the print function:
print(CI, level = 0.8)
## or print a subset (with point estimates):
print(CI, level = 0.8, pe = TRUE, which = "z")

### a simple smooth example
set.seed(1907)
data &lt;- data.frame(x1 = rnorm(100), x2 = rnorm(100))
data$y &lt;- rnorm(100, mean = data$x1^2 - sin(data$x2), sd = 0.1)
gam &lt;- gamboost(y ~ x1 + x2, data = data,
                control = boost_control(mstop = 200))

## compute confidence interval from 10 samples. Usually one should use
## at least 1000 samples.
CI_gam &lt;- confint(gam, B = 10, level = 0.9)

par(mfrow = c(1, 2))
plot(CI_gam, which = 1)
plot(CI_gam, which = 2)
## to compute a confidence interval for another level simply change the
## level in the plot or lines function:
lines(CI_gam, which = 2, level = 0.8)

## End(Not run)
</code></pre>


</div>