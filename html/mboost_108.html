<div class="container">

<table style="width: 100%;"><tr>
<td>methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Methods for Gradient Boosting Objects </h2>

<h3>Description</h3>

<p>Methods for models fitted by boosting algorithms.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'glmboost'
print(x, ...)
## S3 method for class 'mboost'
print(x, ...)

## S3 method for class 'mboost'
summary(object, ...)

## S3 method for class 'mboost'
coef(object, which = NULL,
    aggregate = c("sum", "cumsum", "none"), ...)
## S3 method for class 'glmboost'
coef(object, which = NULL,
     aggregate = c("sum", "cumsum", "none"), off2int = FALSE, ...)

## S3 method for class 'mboost'
x[i, return = TRUE, ...]
mstop(x) &lt;- value

## S3 method for class 'mboost'
AIC(object, method = c("corrected", "classical", "gMDL"),
    df = c("trace", "actset"), ..., k = 2)

## S3 method for class 'mboost'
mstop(object, ...)
## S3 method for class 'gbAIC'
mstop(object, ...)
## S3 method for class 'cvrisk'
mstop(object, ...)

## S3 method for class 'mboost'
predict(object, newdata = NULL,
        type = c("link", "response", "class"), which = NULL,
        aggregate = c("sum", "cumsum", "none"), ...)
## S3 method for class 'glmboost'
predict(object, newdata = NULL,
        type = c("link", "response", "class"), which = NULL,
        aggregate = c("sum", "cumsum", "none"), ...)

## S3 method for class 'mboost'
fitted(object, ...)

## S3 method for class 'mboost'
residuals(object, ...)
## S3 method for class 'mboost'
resid(object, ...)

## S3 method for class 'glmboost'
variable.names(object, which = NULL, usedonly = FALSE, ...)
## S3 method for class 'mboost'
variable.names(object, which = NULL, usedonly = FALSE, ...)

## S3 method for class 'mboost'
extract(object, what = c("design", "penalty", "lambda", "df",
                         "coefficients", "residuals",
                         "variable.names", "bnames", "offset",
                         "nuisance", "weights", "index", "control"),
        which = NULL, ...)
## S3 method for class 'glmboost'
extract(object, what = c("design", "coefficients", "residuals",
                         "variable.names", "offset",
                         "nuisance", "weights", "control"),
        which = NULL, asmatrix = FALSE, ...)
## S3 method for class 'blg'
extract(object, what = c("design", "penalty", "index"),
        asmatrix = FALSE, expand = FALSE, ...)

## S3 method for class 'mboost'
logLik(object, ...)
## S3 method for class 'gamboost'
hatvalues(model, ...)
## S3 method for class 'glmboost'
hatvalues(model, ...)

## S3 method for class 'mboost'
selected(object, ...)

## S3 method for class 'mboost'
risk(object, ...)

## S3 method for class 'mboost'
nuisance(object)

downstream.test(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> objects of class <code>glmboost</code>, <code>gamboost</code>,
<code>blackboost</code> or <code>gbAIC</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> objects of class <code>glmboost</code> or <code>gamboost</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>objects of class mboost</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p> optionally, a data frame in which to look for variables with
which to predict. In case the model was fitted using the <code>matrix</code>
interface to <code>glmboost</code>, <code>newdata</code> must be a <code>matrix</code>
as well (an error is given otherwise).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p> a subset of base-learners to take into account for computing
predictions or coefficients. If <code>which</code> is given
(as an integer vector or characters corresponding
to base-learners) a list or matrix is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usedonly</code></td>
<td>
<p> logical. Indicating whether all variable names should
be returned or only those selected in the boosting algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> the type of prediction required.  The default is on the scale
of the predictors; the alternative <code>"response"</code> is on
the scale of the response variable.  Thus for a
binomial model the default predictions are of log-odds
(probabilities on logit scale) and <code>type = "response"</code> gives
the predicted probabilities.  The <code>"class"</code> option returns
predicted classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate</code></td>
<td>
<p> a character specifying how to aggregate predictions
or coefficients of single base-learners. The default
returns the prediction or coefficient for the final number of
boosting iterations. <code>"cumsum"</code> returns a
list with matrices (one per base-learner) with the
cumulative coefficients for all iterations
simultaneously (in columns). <code>"none"</code> returns a
list of matrices where the <code class="reqn">j</code>th columns of the
respective matrix contains the predictions
of the base-learner of the <code class="reqn">j</code>th boosting
iteration (and zero if the base-learner is not
selected in this iteration).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>off2int</code></td>
<td>
<p> logical. Indicating whether the offset should be
added to the intercept (if there is any)
or if the offset is returned as attribute of
the coefficient (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p> integer. Index specifying the model to extract. If <code>i = 0</code>, 
the offset model is returned. If <code>i</code> is smaller than the initial 
<code>mstop</code>, a subset is used. If <code>i</code> is larger than the 
initial <code>mstop</code>, additional boosting steps are performed until 
step <code>i</code> is reached. See details for more information. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p> integer. See <code>i</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return</code></td>
<td>
<p> a logical indicating whether the changed object is
returned. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> a character specifying if the corrected AIC criterion or
a classical (-2 logLik + k * df) should be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p> a character specifying how degrees of freedom should be computed:
<code>trace</code> defines degrees of freedom by the trace of the
boosting hat matrix and <code>actset</code> uses the number of
non-zero coefficients for each boosting iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>  numeric, the <em>penalty</em> per parameter to be used; the default
<code>k = 2</code> is the classical AIC. Only used when
<code>method = "classical"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p> a character specifying the quantities to <code>extract</code>.
Depending on <code>object</code> this can be a subset of
<code>"design"</code> (default; design matrix),
<code>"penalty"</code> (penalty matrix),
<code>"lambda"</code> (smoothing parameter), <code>"df"</code>
(degrees of freedom), <code>"coefficients"</code>,
<code>"residuals"</code>, <code>"variable.names"</code>,
<code>"bnames"</code> (names of the base-learners),
<code>"offset"</code>, <code>"nuisance"</code>, <code>"weights"</code>,
<code>"index"</code> (index of ties used to expand the design
matrix) and <code>"control"</code>. In future versions additional
extractors might be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asmatrix</code></td>
<td>
<p> a logical indicating whether the the returned
matrix should be coerced to a matrix (default) or if the
returned object stays as it is (i.e., potentially a
<em>sparse</em> matrix). This option is only applicable if
<code>extract</code> returns matrices, i.e., <code>what = "design"</code> or
<code>what = "penalty"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand</code></td>
<td>
<p> a logical indicating whether the design matrix should
be expanded (default: <code>FALSE</code>). This is useful if  ties
where taken into account either manually (via argument
<code>index</code> in a base-learner) or automatically for data sets
with many observations. <code>expand = TRUE</code> is equivalent to
<code>extract(B)[extract(B, what = "index"),]</code> for a
base-learner <code>B</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments passed to callies. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions can be used to extract details from fitted models.
<code>print</code> shows a dense representation of the model fit and
<code>summary</code> gives a more detailed representation.
</p>
<p>The function <code>coef</code> extracts the regression coefficients of a
linear model fitted using the <code>glmboost</code> function or an
additive model fitted using the <code>gamboost</code>. Per default,
only coefficients of selected base-learners are returned. However, any
desired coefficient can be extracted using the <code>which</code> argument
(see examples for details). Per default, the coefficient of the final
iteration is returned (<code>aggregate = "sum"</code>) but it is also
possible to return the coefficients from all iterations simultaniously
(<code>aggregate = "cumsum"</code>). If <code>aggregate = "none"</code> is
specified, the coefficients of the <em>selected</em> base-learners are
returned (see examples below).
For models fitted via <code>glmboost</code> with option <code>center
  = TRUE</code> the intercept is rarely selected. However, it is implicitly
estimated through the centering of the design matrix. In this case the
intercept is always returned except <code>which</code> is specified such
that the intercept is not selected. See examples below.
</p>
<p>The <code>predict</code> function can be used to predict the status of the
response variable for new observations whereas <code>fitted</code> extracts
the regression fit for the observations in the learning sample. For
<code>predict</code> <code>newdata</code> can be specified, otherwise the fitted
values are returned. If <code>which</code> is specified, marginal effects of
the corresponding base-learner(s) are returned. The argument
<code>type</code> can be used to make predictions on the scale of the
<code>link</code> (i.e., the linear predictor <code class="reqn">X\beta</code>),
the <code>response</code> (i.e. <code class="reqn">h(X\beta)</code>, where h is the
response function) or the <code>class</code> (in case of
classification). Furthermore, the predictions can be aggregated
analogously to <code>coef</code> by setting <code>aggregate</code> to either
<code>sum</code> (default; predictions of the final iteration are given),
<code>cumsum</code> (predictions of all iterations are returned
simultaniously) or <code>none</code> (change of prediction in each
iteration). If applicable the <code>offset</code> is added to the predictions.
If marginal predictions are requested the <code>offset</code> is attached
to the object via <code>attr(..., "offset")</code> as adding the offset to
one of the marginal predictions doesn't make much sense.
</p>
<p>The <code>[.mboost</code> function can be used to enhance or restrict a given
boosting model to the specified boosting iteration <code>i</code>. Note that
in both cases the original <code>x</code> will be changed to reduce the
memory footprint. If the boosting model is enhanced by specifying an
index that is larger than the initial <code>mstop</code>, only the missing
<code>i - mstop</code> steps are fitted. If the model is restricted, the
spare steps are not dropped, i.e., if we increase <code>i</code> again,
these boosting steps are immediately available. Alternatively, the
same operation can be done by <code>mstop(x) &lt;- i</code>.
</p>
<p>The <code>residuals</code> function can be used to extract the residuals
(i.e., the negative gradient of the current iteration). <code>resid</code>
is is an alias for <code>residuals</code>.
</p>
<p>Variable names (including those of interaction effects specified via
<code>by</code> in a base-learner) can be extracted using the generic
function <code>variable.names</code>, which has special methods for boosting
objects.
</p>
<p>The generic <code>extract</code> function can be used to extract various
characteristics of a fitted model or a base-learner. Note that the
sometimes a penalty function is returned (e.g. by
<code>extract(bols(x), what = "penalty")</code>) even if the estimation is
unpenalized. However, in this case the penalty paramter <code>lambda</code>
is set to zero. If a matrix is returned by <code>extract</code> one can to
set <code>asmatrix = TRUE</code> if the returned matrix should be coerced to
class <code>matrix</code>. If <code>asmatrix = FALSE</code> one might get a sparse
matrix as implemented in package <code>Matrix</code>. If one requests the
design matrix (<code>what = "design"</code>) <code>expand = TRUE</code> expands
the resulting matrix by taking the duplicates handeled via
<code>index</code> into account.
</p>
<p>The ids of base-learners selected during the fitting process can be
extracted using <code>selected()</code>. The <code>nuisance()</code> method
extracts nuisance parameters from the fit that are handled internally
by the corresponding family object, see
<code>"boost_family"</code>. The <code>risk()</code> function can be
used to extract the computed risk (either the <code>"inbag"</code> risk or
the <code>"oobag"</code> risk, depending on the control argument; see
<code>boost_control</code>).
</p>
<p>For (generalized) linear and additive models, the <code>AIC</code> function
can be used to compute both the classical AIC (only available for
<code>familiy = Binomial()</code> and <code>familiy = Poisson()</code>) and
corrected AIC (Hurvich et al., 1998, only available when <code>family
  = Gaussian()</code> was used). Details on the used approximations for the
hat matrix can be found in Buehlmann and Hothorn (2007). The AIC is
useful for the determination of the optimal number of boosting
iterations to be applied (which can be extracted via <code>mstop</code>).
The degrees of freedom are either computed via the trace of the
boosting hat matrix (which is rather slow even for moderate sample
sizes) or the number of variables (non-zero coefficients) that entered
the model so far (faster but only meaningful for linear models fitted
via <code>gamboost</code> (see Hastie, 2007)). For a discussion of
the use of AIC based stopping see also Mayr, Hofner and Schmid (2012).
</p>
<p>In addition, the general Minimum Description Length criterion
(Buehlmann and Yu, 2006) can be computed using function <code>AIC</code>.
</p>
<p>Note that <code>logLik</code> and <code>AIC</code> only make sense when the
corresponding <code>Family</code> implements the appropriate loss
function.
</p>
<p><code>downstream.test</code> computes tests for linear models fitted via <code>glmboost</code>
with a likelihood based loss function and only suitable without early stopping, i.e., 
if likelihood based model converged. In order to work, the Fisher matrix must
be implemented in the <code>Family</code>; currently this is only the case for 
family <code>RCG</code>.
</p>


<h3>Warning</h3>

<p>The coefficients resulting from boosting with family
<code>Binomial(link = "logit")</code> are <code class="reqn">1/2</code> of the coefficients of a logit  model obtained via <code>glm</code> (see <code>Binomial</code>).
</p>


<h3>Note</h3>

<p>The <code>[.mboost</code> function changes the original object, i.e.
<code>gbmodel[10]</code> changes <code>gbmodel</code> directly!
</p>


<h3>References</h3>

<p>Benjamin Hofner, Andreas Mayr, Nikolay Robinzonov and Matthias Schmid
(2014). Model-based Boosting in R: A Hands-on Tutorial Using the R
Package mboost. <em>Computational Statistics</em>, <b>29</b>, 3–35.<br><a href="https://doi.org/10.1007/s00180-012-0382-5">doi:10.1007/s00180-012-0382-5</a>
</p>
<p>Clifford M. Hurvich, Jeffrey S. Simonoff and Chih-Ling Tsai (1998),
Smoothing parameter selection in nonparametric regression using
an improved Akaike information criterion.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>20</b>(2), 271–293.
</p>
<p>Peter Buehlmann and Torsten Hothorn (2007),
Boosting algorithms: regularization, prediction and model fitting.
<em>Statistical Science</em>, <b>22</b>(4), 477–505.
</p>
<p>Trevor Hastie (2007), Discussion of “Boosting algorithms:
Regularization, prediction and model fitting” by Peter Buehlmann and
Torsten Hothorn. <em>Statistical Science</em>, <b>22</b>(4), 505.
</p>
<p>Peter Buehlmann and Bin Yu (2006), Sparse boosting. <em>Journal of
Machine Learning Research</em>, <b>7</b>, 1001–1024.
</p>
<p>Andreas Mayr, Benjamin Hofner, and Matthias Schmid (2012). The
importance of knowing when to stop - a sequential stopping rule for
component-wise gradient boosting. <em>Methods of Information in
Medicine</em>, <b>51</b>, 178–186. <br>
DOI: <a href="https://doi.org/10.3414/ME11-02-0030">doi:10.3414/ME11-02-0030</a>
</p>


<h3>See Also</h3>

<p><code>gamboost</code>, <code>glmboost</code> and
<code>blackboost</code> for model fitting.
</p>
<p><code>plot.mboost</code> for plotting methods.
</p>
<p><code>cvrisk</code> for cross-validated stopping iteration.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  ### a simple two-dimensional example: cars data
  cars.gb &lt;- glmboost(dist ~ speed, data = cars,
                      control = boost_control(mstop = 2000),
                      center = FALSE)
  cars.gb

  ### initial number of boosting iterations
  mstop(cars.gb)

  ### AIC criterion
  aic &lt;- AIC(cars.gb, method = "corrected")
  aic

  ### extract coefficients for glmboost
  coef(cars.gb)
  coef(cars.gb, off2int = TRUE)        # offset added to intercept
  coef(lm(dist ~ speed, data = cars))  # directly comparable

  cars.gb_centered &lt;- glmboost(dist ~ speed, data = cars,
                               center = TRUE)
  selected(cars.gb_centered)           # intercept never selected
  coef(cars.gb_centered)               # intercept implicitly estimated
                                       # and thus returned
  ## intercept is internally corrected for mean-centering
  - mean(cars$speed) * coef(cars.gb_centered, which="speed") # = intercept
  # not asked for intercept thus not returned
  coef(cars.gb_centered, which="speed")
  # explicitly asked for intercept
  coef(cars.gb_centered, which=c("Intercept", "speed"))

  ### enhance or restrict model
  cars.gb &lt;- gamboost(dist ~ speed, data = cars,
                      control = boost_control(mstop = 100, trace = TRUE))
  cars.gb[10]
  cars.gb[100, return = FALSE] # no refitting required
  cars.gb[150, return = FALSE] # only iterations 101 to 150
                               # are newly fitted

  ### coefficients for optimal number of boosting iterations
  coef(cars.gb[mstop(aic)])
  plot(cars$dist, predict(cars.gb[mstop(aic)]),
       ylim = range(cars$dist))
  abline(a = 0, b = 1)

  ### example for extraction of coefficients
  set.seed(1907)
  n &lt;- 100
  x1 &lt;- rnorm(n)
  x2 &lt;- rnorm(n)
  x3 &lt;- rnorm(n)
  x4 &lt;- rnorm(n)
  int &lt;- rep(1, n)
  y &lt;- 3 * x1^2 - 0.5 * x2 + rnorm(n, sd = 0.1)
  data &lt;- data.frame(y = y, int = int, x1 = x1, x2 = x2, x3 = x3, x4 = x4)

  model &lt;- gamboost(y ~ bols(int, intercept = FALSE) +
                        bbs(x1, center = TRUE, df = 1) +
                        bols(x1, intercept = FALSE) +
                        bols(x2, intercept = FALSE) +
                        bols(x3, intercept = FALSE) +
                        bols(x4, intercept = FALSE),
                    data = data, control = boost_control(mstop = 500))

  coef(model) # standard output (only selected base-learners)
  coef(model,
       which = 1:length(variable.names(model))) # all base-learners
  coef(model, which = "x1") # shows all base-learners for x1

  cf1 &lt;- coef(model, which = c(1,3,4), aggregate = "cumsum")
  tmp &lt;- sapply(cf1, function(x) x)
  matplot(tmp, type = "l", main = "Coefficient Paths")

  cf1_all &lt;- coef(model, aggregate = "cumsum")
  cf1_all &lt;- lapply(cf1_all, function(x) x[, ncol(x)]) # last element
  ## same as coef(model)

  cf2 &lt;- coef(model, aggregate = "none")
  cf2 &lt;- lapply(cf2, rowSums) # same as coef(model)

  ### example continued for extraction of predictions

  yhat &lt;- predict(model) # standard prediction; here same as fitted(model)
  p1 &lt;- predict(model, which = "x1") # marginal effects of x1
  orderX &lt;- order(data$x1)
  ## rowSums needed as p1 is a matrix
  plot(data$x1[orderX], rowSums(p1)[orderX], type = "b")

  ## better: predictions on a equidistant grid
  new_data &lt;- data.frame(x1 = seq(min(data$x1), max(data$x1), length = 100))
  p2 &lt;- predict(model, newdata = new_data, which = "x1")
  lines(new_data$x1, rowSums(p2), col = "red")

  ### extraction of model characteristics
  extract(model, which = "x1")  # design matrices for x1
  extract(model, what = "penalty", which = "x1") # penalty matrices for x1
  extract(model, what = "lambda", which = "x1") # df and corresponding lambda for x1
       ## note that bols(x1, intercept = FALSE) is unpenalized

  extract(model, what = "bnames")  ## name of complete base-learner
  extract(model, what = "variable.names") ## only variable names
  variable.names(model)            ## the same

  ### extract from base-learners
  extract(bbs(x1), what = "design")
  extract(bbs(x1), what = "penalty")
  ## weights and lambda can only be extracted after using dpp
  weights &lt;- rep(1, length(x1))
  extract(bbs(x1)$dpp(weights), what = "lambda")
</code></pre>


</div>