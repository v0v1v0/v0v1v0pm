<div class="container">

<table style="width: 100%;"><tr>
<td>Family</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Gradient Boosting Families </h2>

<h3>Description</h3>

<p><code>boost_family</code> objects provide a convenient way to specify loss functions
and corresponding risk functions to be optimized by one of the boosting
algorithms implemented in this package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Family(ngradient, loss = NULL, risk = NULL,
       offset = function(y, w)
           optimize(risk, interval = range(y),
                    y = y, w = w)$minimum,
       check_y = function(y) y,
       weights = c("any", "none", "zeroone", "case"),
       nuisance = function() return(NA),
       name = "user-specified", fW = NULL,
       response = function(f) NA,
       rclass = function(f) NA)
AdaExp()
AUC()
Binomial(type = c("adaboost", "glm"),
         link = c("logit", "probit", "cloglog", "cauchit", "log"), ...)
GaussClass()
GaussReg()
Gaussian()
Huber(d = NULL)
Laplace()
Poisson()
GammaReg(nuirange = c(0, 100))
CoxPH()
QuantReg(tau = 0.5, qoffset = 0.5)
ExpectReg(tau = 0.5)
NBinomial(nuirange = c(0, 100))
PropOdds(nuirange = c(-0.5, -1), offrange = c(-5, 5))
Weibull(nuirange = c(0, 100))
Loglog(nuirange = c(0, 100))
Lognormal(nuirange = c(0, 100))
Gehan()
Hurdle(nuirange = c(0, 100))
Multinomial()
Cindex(sigma = 0.1, ipcw = 1)
RCG(nuirange = c(0, 1), offrange = c(-5, 5))

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ngradient</code></td>
<td>
<p> a function with arguments <code>y</code>, <code>f</code> and <code>w</code> implementing the
<em>negative</em> gradient of the <code>loss</code> function (which is to be minimized). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p> an optional loss function with arguments <code>y</code> and <code>f</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p> an optional risk function with arguments <code>y</code>, <code>f</code> and <code>w</code> to be minimized (!),
the weighted mean of the loss function by default. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p> a function with argument <code>y</code> and <code>w</code> (weights)
for computing a <em>scalar</em> offset. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fW</code></td>
<td>
<p> transformation of the fit for the diagonal weights matrix for an
approximation of the boosting hat matrix for loss functions other than
squared error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p> inverse link function of a GLM or any other transformation
on the scale of the response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rclass</code></td>
<td>
<p> function to derive class predictions from conditional class
probabilities (for models with factor response variable).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_y</code></td>
<td>
<p> a function for checking and transforming
the class / mode of a response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nuisance</code></td>
<td>
<p> a function for extracting nuisance parameters from the family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p> a character indicating what type of weights are
allowed. These can be either arbitrary (non-negative) weights
<code>"any"</code>, only zero and one weights <code>"zeroone"</code>,
(non-negative) interger weights <code>"case"</code>, or no weights are
allowed <code>"none"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p> a character giving the name of the loss function for pretty printing. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> which parameterization of <code>Binomial</code> shoule be used?</p>
</td>
</tr>
</table>
<p> b
</p>
<table>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p> link function. For possible values see Usage section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p> delta parameter for Huber loss function. If omitted, it is chosen adaptively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p> the quantile or expectile to be estimated, a number strictly between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qoffset</code></td>
<td>
<p> quantile of response distribution to be used as offset, i.e., 
starting values for the intercept. Per default the median of the response is used,
which is in general a good choice (see Fenske et al. 2011, for details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nuirange</code></td>
<td>
<p> a vector containing the end-points of the interval to be
searched for the minimum risk w.r.t. the nuisance parameter.
In case of <code>PropOdds</code>, the starting values for
the nuisance parameters. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offrange</code></td>
<td>
<p> interval to search in for offset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>smoothness parameter for sigmoid functions inside <code>Cindex</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ipcw</code></td>
<td>
<p>vector containing inverse probability of censoring weights for all observations. If omitted, it is estimated inside <code>Cindex</code> family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments to link functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The boosting algorithm implemented in <code>mboost</code> minimizes the
(weighted) empirical risk function <code>risk(y, f, w)</code> with respect to <code>f</code>.
By default, the risk function is the weighted sum of the loss function <code>loss(y, f)</code>
but can be chosen arbitrarily. The <code>ngradient(y, f)</code> function is the negative
gradient of <code>loss(y, f)</code> with respect to <code>f</code>.
</p>
<p>Pre-fabricated functions for the most commonly used loss functions are
available as well. Buehlmann and Hothorn (2007) give a detailed
overview of the available loss functions. An updated overview can 
be found in Hofner et al (2014). 
</p>
<p>The <code>offset</code> function returns the population minimizers evaluated at the 
response, i.e., <code class="reqn">1/2 \log(p / (1 - p))</code> for <code>Binomial()</code> or <code>AdaExp()</code>
and <code class="reqn">(\sum w_i)^{-1} \sum w_i y_i</code> for <code>Gaussian()</code> and the
median for <code>Huber()</code> and <code>Laplace()</code>. The offset is used as starting 
value for the boosting algorithm.
</p>
<p>Note that all families are functions and thus need to be specified either with
empty brackets (e.g., <code>family = Gaussian()</code> for Gaussian regression) or 
with additional arguments if these are supported by the respective family 
(e.g., <code>family = QuantReg(tau = 0.2)</code> for quantile regression for the 
20% quantile).
</p>
<p><strong>A short summary of the available families is given in the following paragraphs:</strong>
</p>
<p><code>AdaExp()</code>, <code>Binomial()</code> and <code>AUC()</code> implement
families for binary classification. <code>AdaExp()</code> uses the
exponential loss, which essentially leads to the AdaBoost algorithm
of Freund and Schapire (1996). <code>Binomial()</code> implements the
negative binomial log-likelihood of a logistic regression model
as loss function. Thus, using <code>Binomial</code> family closely corresponds
to fitting a logistic model. Alternative link functions
can be specified.
</p>
<p>However, the coefficients resulting from boosting with family
<code>Binomial(link = "logit")</code> are <code class="reqn">1/2</code> of the coefficients of a logit model
obtained via <code>glm</code>.  Buehlmann and Hothorn (2007) argue that the
family <code>Binomial</code> is the preferred choice for binary
classification. For binary classification problems the response
<code>y</code> has to be a <code>factor</code>. Internally <code>y</code> is re-coded
to <code class="reqn">-1</code> and <code class="reqn">+1</code> (Buehlmann and Hothorn 2007). 
</p>
<p><code>Binomial(type = "glm")</code> is an alternative to <code>Binomial()</code> leading to 
coefficients of the same size as coefficients from a classical logit 
model via <code>glm</code>. Additionally, it works not only with a 
two-level factor but also with a two-column matrix containing the number 
of successes and number of failures (again, similar to <code>glm</code>). 
</p>
<p><code>AUC()</code> uses <code class="reqn">1-AUC(y, f)</code> as the loss function.
The area under the ROC curve (AUC) is defined as
<code class="reqn">AUC = (n_{-1} n_1)^{-1} \sum_{i: y_i = 1} \sum_{j: y_j = -1} I(f_i &gt; f_j)</code>.
Since this is not differentiable in <code>f</code>, we approximate the jump function
<code class="reqn">I((f_i - f_j) &gt; 0)</code> by the distribution function of the triangular
distribution on <code class="reqn">[-1, 1]</code> with mean <code class="reqn">0</code>, similar to the logistic
distribution approximation used in Ma and Huang (2005).
</p>
<p><code>Gaussian()</code> is the default family in <code>mboost</code>. It
implements <code class="reqn">L_2</code>Boosting for continuous response. Note
that families <code>GaussReg()</code> and <code>GaussClass()</code> (for regression
and classification) are deprecated now.
<code>Huber()</code> implements a robust version for boosting with
continuous response, where the Huber-loss is used. <code>Laplace()</code>
implements another strategy for continuous outcomes and uses the
<code class="reqn">L_1</code>-loss instead of the <code class="reqn">L_2</code>-loss as used by
<code>Gaussian()</code>.
</p>
<p><code>Poisson()</code> implements a family for fitting count data with
boosting methods. The implemented loss function is the negative
Poisson log-likelihood. Note that the natural link function
<code class="reqn">\log(\mu) = \eta</code> is assumed. The default step-site <code>nu = 0.1</code>
is probably too large for this family (leading to
infinite residuals) and smaller values are more appropriate.
</p>
<p><code>GammaReg()</code> implements a family for fitting nonnegative response
variables. The implemented loss function is the negative Gamma
log-likelihood with logarithmic link function (instead of the natural
link).
</p>
<p><code>CoxPH()</code> implements the negative partial log-likelihood for Cox
models. Hence, survival models can be boosted using this family.
</p>
<p><code>QuantReg()</code> implements boosting for quantile regression, which is
introduced in Fenske et al. (2009). <code>ExpectReg</code> works in analogy,
only for expectiles, which were introduced to regression by Newey and Powell (1987).
</p>
<p>Families with an additional scale parameter can be used for fitting
models as well: <code>PropOdds()</code> leads to proportional odds models
for ordinal outcome variables (Schmid et al., 2011). When using this
family, an ordered set of threshold parameters is re-estimated in each
boosting iteration. An example is given below which also shows how to
obtain the thresholds. <code>NBinomial()</code> leads to regression models with
a negative binomial conditional distribution of the response.
<code>Weibull()</code>, <code>Loglog()</code>, and <code>Lognormal()</code> implement
the negative log-likelihood functions of accelerated failure time
models with Weibull, log-logistic, and lognormal distributed outcomes,
respectively. Hence, parametric survival models can be boosted using
these families. For details see Schmid and Hothorn (2008) and Schmid
et al. (2010).
</p>
<p><code>Gehan()</code> implements rank-based estimation of survival data in an
accelerated failure time model. The loss function is defined as the sum
of the pairwise absolute differences of residuals. The response needs to
be defined as <code>Surv(y, delta)</code>, where <code>y</code> is the observed survial
time (subject to censoring) and <code>delta</code> is the non-censoring indicator
(see <code>Surv</code> for details). For details on <code>Gehan()</code> see
Johnson and Long (2011).
</p>
<p><code>Cindex()</code> optimizes the concordance-index for survival data (often denoted
as Harrell's C or C-index). The concordance index evaluates the rank-based
concordance probability between the model and the outcome. The C-index measures
whether large values of the model are associated with short survival times  and
vice versa. The interpretation is similar to the AUC: A C-index of 1 represents a
perfect discrimination while a C-index of 0.5 will be achieved by a completely
non-informative marker. The <code>Cindex()</code> family is based on an estimator by
Uno et al. (2011), which incorporates inverse probability of censoring weighting
<code>ipcw</code>. To make the estimator differentiable, sigmoid functions are applied;
the corresponding smoothness can be controlled via <code>sigma</code>. For details on
<code>Cindex()</code> see Mayr and Schmid (2014).
</p>
<p>Hurdle models for zero-inflated count data can be fitted by using a combination
of the <code>Binomial()</code> and <code>Hurdle()</code> families. While the <code>Binomial()</code>
family allows for fitting the zero-generating process of the Hurdle model,
<code>Hurdle()</code> fits a negative binomial regression model to the non-zero
counts. Note that the specification of the Hurdle model allows for using
<code>Binomial()</code> and <code>Hurdle()</code> independently of each other.
</p>
<p>Linear or additive multinomial logit models can be fitted using
<code>Multinomial()</code>; although is family requires some extra effort for
model specification (see example).  More specifically, the predictor must
be in the form of a linear array model (see <code>%O%</code>).  Note
that this family does not work with tree-based base-learners at the
moment. The class corresponding to the last level of the factor coding
of the response is used as reference class.
</p>
<p><code>RCG()</code> implements the ratio of correlated gammas (RCG) model proposed
by Weinhold et al. (2016).
</p>


<h3>Value</h3>

<p>An object of class <code>boost_family</code>.
</p>


<h3>Warning</h3>

<p>The coefficients resulting from boosting with family
<code>Binomial(link = "logit")</code> are <code class="reqn">1/2</code> of the coefficients of a logit model
obtained via <code>glm</code> (see above). 
</p>
<p>For <code>AUC()</code>, variables should be centered and scaled and observations with weight &gt; 0 must not contain missing values.
The estimated coefficients for <code>AUC()</code> have no probabilistic interpretation.
</p>


<h3>Author(s)</h3>

<p><code>ExpectReg()</code> was donated by Fabian Sobotka.
<code>AUC()</code> was donated by Fabian Scheipl.
</p>


<h3>References</h3>

<p>Peter Buehlmann and Torsten Hothorn (2007),
Boosting algorithms: regularization, prediction and model fitting.
<em>Statistical Science</em>, <b>22</b>(4), 477–505.
</p>
<p>Nora Fenske, Thomas Kneib, and Torsten Hothorn (2011),
Identifying risk factors for severe childhood malnutrition by
boosting additive quantile regression.
<em>Journal of the American Statistical Association</em>, <b>106</b>:494-510.
</p>
<p>Yoav Freund and Robert E. Schapire (1996),
Experiments with a new boosting algorithm.
In <em>Machine Learning: Proc. Thirteenth International Conference</em>,
148–156.
</p>
<p>Shuangge Ma and Jian Huang (2005), Regularized ROC method for
disease classification and biomarker selection with microarray
data. <em>Bioinformatics</em>, <b>21</b>(24), 4356–4362.
</p>
<p>Andreas Mayr and Matthias Schmid (2014). 
Boosting the concordance index for survival data – a unified 
framework to derive and evaluate biomarker combination.     
<em>PloS ONE</em>, <b>9</b>(1):84483.
</p>
<p>Whitney K. Newey and James L. Powell (1987),
Asymmetric least squares estimation and testing.
<em>Econometrika</em>, <b>55</b>, 819–847.
</p>
<p>Matthias Schmid and Torsten Hothorn (2008),
Flexible boosting of accelerated failure time models.
<em>BMC Bioinformatics</em>, <b>9</b>(269).
</p>
<p>Matthias Schmid, Sergej Potapov, Annette Pfahlberg,
and Torsten Hothorn (2010). Estimation and regularization techniques for
regression models with multidimensional prediction functions.
<em>Statistics and Computing</em>, <b>20</b>, 139–150.
</p>
<p>Schmid, M., T. Hothorn, K. O. Maloney, D. E. Weller and S. Potapov
(2011): Geoadditive regression modeling of stream biological
condition. <em>Environmental and Ecological Statistics</em>,
<b>18</b>(4), 709–733.
</p>
<p>Uno H, Cai T, Pencina MJ, D Agostino RB and Wei LJ (2011). 
On the C-statistics for evaluating overall adequacy of risk prediction 
procedures with censored survival data. 
<em>Statistics in Medicine</em>, <b>30</b>(10), 1105–17.
</p>
<p>Benjamin Hofner, Andreas Mayr, Nikolay Robinzonov and Matthias Schmid
(2014). Model-based Boosting in R: A Hands-on Tutorial Using the R
Package mboost. <em>Computational Statistics</em>, <b>29</b>, 3–35.<br><a href="https://doi.org/10.1007/s00180-012-0382-5">doi:10.1007/s00180-012-0382-5</a>
</p>
<p>Available as vignette via: <code>vignette(package = "mboost", "mboost_tutorial")</code>
</p>
<p>Brent A. Johnson and Qi Long (2011) Survival ensembles by the sum of pairwise
differences with application to lung cancer microarray studies.
<em>Annals of Applied Statistics</em>, <b>5</b>, 1081–1101.
</p>
<p>Weinhold, L., S. Pechlivanis, S. Wahl, P. Hoffmann and M. Schmid (2016) A Statistical Model for the
Analysis of Bounded Response Variables in DNA Methylation Studies.
<em>BMC Bioinformatics</em>. 2016; 17: 480. <a href="https://doi.org/10.1186/s12859-016-1347-4">doi:10.1186/s12859-016-1347-4</a>
</p>


<h3>See Also</h3>

<p><code>mboost</code> for the usage of <code>Family</code>s. See
<code>boost_family-class</code> for objects resulting from a call to <code>Family</code>. </p>


<h3>Examples</h3>

<pre><code class="language-R">### Define a new family
MyGaussian &lt;- function(){
       Family(ngradient = function(y, f, w = 1) y - f,
       loss = function(y, f) (y - f)^2,
       name = "My Gauss Variant")
}
# Now use the new family
data(bodyfat, package = "TH.data")
mod &lt;- mboost(DEXfat ~ ., data = bodyfat, family = MyGaussian())
# N.B. that the family needs to be called with empty brackets


### Proportional odds model
data(iris)
iris$Species &lt;- factor(iris$Species, ordered = TRUE)
if (require("MASS")) {
    (mod.polr &lt;- polr(Species  ~ Sepal.Length, data = iris))
}
mod.PropOdds &lt;- glmboost(Species  ~ Sepal.Length, data = iris,
                         family = PropOdds(nuirange = c(-0.5, 3)))
mstop(mod.PropOdds) &lt;- 1000
## thresholds are treated as nuisance parameters, to extract these use
nuisance(mod.PropOdds)
## effect estimate
coef(mod.PropOdds)["Sepal.Length"]
## make thresholds comparable to a model without intercept
nuisance(mod.PropOdds) - coef(mod.PropOdds)["(Intercept)"] -
    attr(coef(mod.PropOdds), "offset")

### Multinomial logit model via a linear array model
## One needs to convert the data to a list
myiris &lt;- as.list(iris)
## ... and define a dummy vector with one factor level less
## than the outcome, which is used as reference category.
myiris$class &lt;- factor(levels(iris$Species)[-nlevels(iris$Species)])
## Now fit the linear array model
mlm &lt;- mboost(Species ~ bols(Sepal.Length, df = 2) %O%
                        bols(class, df = 2, contrasts.arg = "contr.dummy"),
              data = myiris,
              family = Multinomial())
coef(mlm) ## one should use more boosting iterations.
head(round(pred &lt;- predict(mlm, type = "response"), 2))

## Prediction with new data:
newdata &lt;- as.list(iris[1,])
## One always needs to keep the dummy vector class as above!
newdata$class &lt;- factor(levels(iris$Species)[-nlevels(iris$Species)])
pred2 &lt;- predict(mlm, type = "response", newdata = newdata)
## check results
pred[1, ]
pred2

## Not run: ############################################################
## Do not run and check these examples automatically as
## they take some time

## Compare results with nnet::multinom
if (require("nnet")) {
    mlmn &lt;- multinom(Species ~ Sepal.Length, data = iris)
    max(abs(fitted(mlm[1000], type = "response") -
            fitted(mlmn, type = "prob")))
}

## End(Not run and test)

## End(Not run)


### Example for RCG model
## generate covariate values
set.seed(12345)
x1 &lt;- rnorm(500)
x2 &lt;- rnorm(500)
## generate linear predictors
zetaM &lt;- 0.1 + 0.3 * x1 - 0.5 * x2 
zetaU &lt;- 0.1 - 0.1 * x1 + 0.2 * x2
## generate beta values
M &lt;- rgamma(500, shape = 2, rate = exp(zetaM))
U &lt;- rgamma(500, shape = 2, rate = exp(zetaU))
y &lt;- M / (M + U)

## fit RCG model
data &lt;- data.frame(y, x1, x2)
RCGmodel &lt;- glmboost(y ~ x1 + x2, data = data, family = RCG(),
                     control = boost_control(mstop = 1000,
                     trace = TRUE, nu = 0.01))
## true coefficients: gamma = (0.0, 0.4, -0.7),
##                    alpha (= shape) = 2,
##                    rho = 0
## compare to coefficient estimates
coef(RCGmodel)
nuisance(RCGmodel)

## compute downstream tests 
## (only suitable without early stopping, i.e., if likelihood based model converged)
downstream.test(RCGmodel)

## compute conditional expectations
predictions &lt;- predict(RCGmodel, type = "response")
plot(predictions, y)
abline(0,1)

</code></pre>


</div>