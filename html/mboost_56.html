<div class="container">

<table style="width: 100%;"><tr>
<td>glmboost</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Gradient Boosting with Component-wise Linear Models </h2>

<h3>Description</h3>

<p>Gradient boosting for optimizing arbitrary loss functions where component-wise
linear models are utilized as base-learners.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'formula'
glmboost(formula, data = list(), weights = NULL,
          offset = NULL, family = Gaussian(),
          na.action = na.pass, contrasts.arg = NULL,
          center = TRUE, control = boost_control(), oobweights = NULL, ...)
## S3 method for class 'matrix'
glmboost(x, y, center = TRUE, weights = NULL,
          offset = NULL, family = Gaussian(),
          na.action = na.pass, control = boost_control(), oobweights = NULL, ...)
## Default S3 method:
glmboost(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p> a symbolic description of the model to be fit. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> a data frame containing the variables in the model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting
process. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p> a numeric vector to be used as offset (optional).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a <code>Family</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts.arg</code></td>
<td>
<p>a list, whose entries are contrasts suitable for input
to the <code>contrasts</code> replacement function and whose names are
the names of columns of <code>data</code> containing factors.
See <code>model.matrix.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>logical indicating of the predictor variables are centered before fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p> a list of parameters controlling the algorithm. For
more details see <code>boost_control</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oobweights</code></td>
<td>
<p> an additional vector of out-of-bag weights, which is
used for the out-of-bag risk (i.e., if <code>boost_control(risk =
      "oobag")</code>). This argument is also used internally by
<code>cvrisk</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> design matrix. Sparse matrices of class <code>Matrix</code> can be used as well.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p> vector of responses. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments passed to <code>mboost_fit</code>; currently none.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A (generalized) linear model is fitted using a boosting algorithm based on component-wise
univariate linear models. The fit, i.e., the regression coefficients, can be
interpreted in the usual way. The methodology is described in
Buehlmann and Yu (2003), Buehlmann (2006), and Buehlmann and Hothorn (2007).
Examples and further details are given in Hofner et al (2014).
</p>


<h3>Value</h3>

<p>An object of class <code>glmboost</code> with <code>print</code>, <code>coef</code>,
<code>AIC</code> and <code>predict</code> methods being available.
For inputs with longer variable names, you might want to change
<code>par("mai")</code> before calling the <code>plot</code> method of <code>glmboost</code>
objects visualizing the coefficients path.
</p>


<h3>References</h3>

<p>Peter Buehlmann and Bin Yu (2003),
Boosting with the L2 loss: regression and classification.
<em>Journal of the American Statistical Association</em>, <b>98</b>,
324–339.
</p>
<p>Peter Buehlmann (2006), Boosting for high-dimensional linear models.
<em>The Annals of Statistics</em>, <b>34</b>(2), 559–583.
</p>
<p>Peter Buehlmann and Torsten Hothorn (2007),
Boosting algorithms: regularization, prediction and model fitting.
<em>Statistical Science</em>, <b>22</b>(4), 477–505.
</p>
<p>Torsten Hothorn, Peter Buehlmann, Thomas Kneib, Mattthias Schmid and
Benjamin Hofner (2010), Model-based Boosting 2.0. <em>Journal of
Machine Learning Research</em>, <b>11</b>, 2109–2113.
</p>
<p>Benjamin Hofner, Andreas Mayr, Nikolay Robinzonov and Matthias Schmid
(2014). Model-based Boosting in R: A Hands-on Tutorial Using the R
Package mboost. <em>Computational Statistics</em>, <b>29</b>, 3–35.<br><a href="https://doi.org/10.1007/s00180-012-0382-5">doi:10.1007/s00180-012-0382-5</a>
</p>
<p>Available as vignette via: <code>vignette(package = "mboost", "mboost_tutorial")</code>
</p>


<h3>See Also</h3>

<p>See <code>mboost_fit</code> for the generic boosting function, 
<code>gamboost</code> for boosted additive models, and
<code>blackboost</code> for boosted trees. 
</p>
<p>See <code>baselearners</code> for possible base-learners. 
</p>
<p>See <code>cvrisk</code> for cross-validated stopping iteration. 
</p>
<p>Furthermore see <code>boost_control</code>, <code>Family</code> and
<code>methods</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
    ### a simple two-dimensional example: cars data
    cars.gb &lt;- glmboost(dist ~ speed, data = cars,
                        control = boost_control(mstop = 2000),
                        center = FALSE)
    cars.gb

    ### coefficients should coincide
    cf &lt;- coef(cars.gb, off2int = TRUE)     ## add offset to intercept
    coef(cars.gb) + c(cars.gb$offset, 0)    ## add offset to intercept (by hand)
    signif(cf, 3)
    signif(coef(lm(dist ~ speed, data = cars)), 3)
    ## almost converged. With higher mstop the results get even better

    ### now we center the design matrix for
    ### much quicker "convergence"
    cars.gb_centered &lt;- glmboost(dist ~ speed, data = cars,
                                 control = boost_control(mstop = 2000),
                                 center = TRUE)

    ## plot coefficient paths of glmboost
    par(mfrow=c(1,2), mai = par("mai") * c(1, 1, 1, 2.5))
    plot(cars.gb, main = "without centering")
    plot(cars.gb_centered, main = "with centering")

    ### alternative loss function: absolute loss
    cars.gbl &lt;- glmboost(dist ~ speed, data = cars,
                         control = boost_control(mstop = 1000),
                         family = Laplace())
    cars.gbl
    coef(cars.gbl, off2int = TRUE)

    ### plot fit
    par(mfrow = c(1,1))
    plot(dist ~ speed, data = cars)
    lines(cars$speed, predict(cars.gb), col = "red")     ## quadratic loss
    lines(cars$speed, predict(cars.gbl), col = "green")  ## absolute loss

    ### Huber loss with adaptive choice of delta
    cars.gbh &lt;- glmboost(dist ~ speed, data = cars,
                         control = boost_control(mstop = 1000),
                         family = Huber())

    lines(cars$speed, predict(cars.gbh), col = "blue")   ## Huber loss
    legend("topleft", col = c("red", "green", "blue"), lty = 1,
           legend = c("Gaussian", "Laplace", "Huber"), bty = "n")

    ### sparse high-dimensional example that makes use of the matrix
    ### interface of glmboost and uses the matrix representation from
    ### package Matrix
    library("Matrix")
    n &lt;- 100
    p &lt;- 10000
    ptrue &lt;- 10
    X &lt;- Matrix(0, nrow = n, ncol = p)
    X[sample(1:(n * p), floor(n * p / 20))] &lt;- runif(floor(n * p / 20))
    beta &lt;- numeric(p)
    beta[sample(1:p, ptrue)] &lt;- 10
    y &lt;- drop(X %*% beta + rnorm(n, sd = 0.1))
    mod &lt;- glmboost(y = y, x = X, center = TRUE) ### mstop needs tuning
    coef(mod, which = which(beta &gt; 0))

</code></pre>


</div>