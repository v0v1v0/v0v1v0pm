<div class="container">

<table style="width: 100%;"><tr>
<td>plot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plot effect estimates of boosting models
</h2>

<h3>Description</h3>

<p>Plot coefficient plots for <code>glmboost</code> models and partial effect
plots for all other <code>mboost</code> models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
## S3 method for class 'glmboost'
plot(x, main = deparse(x$call), col = NULL,
     off2int = FALSE, ...)

## S3 method for class 'mboost'
plot(x, which = NULL, newdata = NULL,
     type = "b", rug = TRUE, rugcol = "black",
     ylim = NULL, xlab = NULL, ylab = expression(f[partial]),
     add = FALSE, ...)

## S3 method for class 'mboost'
lines(x, which = NULL, type = "l", rug = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>object of class <code>glmboost</code> or an object inheriting from
<code>mboost</code> for plotting.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>

<p>a title for the plot.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>

<p>(a vector of) colors for plotting the lines representing the
coefficient paths.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>off2int</code></td>
<td>

<p>logical indicating whether the offset should be added to the
intercept (if there is any) or if the offset is neglected for
plotting (default).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>

<p>a subset of base-learners used for plotting. If <code>which</code> is
given (as an integer vector or characters corresponding
to base-learners) only the corresponding partial effect plots are
depicted. Per default all selected base-learners are plotted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>optionally, a data frame in which to look for variables with
which to make predictions that are then plotted. This is especially
useful if the data that was used to fit the model shows some larger
gaps as effect plots are linearly interpolated between observations.
For an example using <code>newdata</code> see below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>character string giving the type of plot desired. Per default,
points and lines are plotted (<code>"b"</code>). Other useful options are
points (<code>"p"</code>) or lines (<code>"l"</code>). See
<code>plot.default</code> for details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug</code></td>
<td>

<p>logical. Should a rug be added to the x-axis?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rugcol</code></td>
<td>

<p>color for the rug.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>

<p>the y limits of the plot.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>

<p>a label for the x axis.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>

<p>a label for the y axis.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>

<p>logical. Should the plot be added to the previous plot?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments to the <code>plot</code> functions. E.g. one can
specify the x limits <code>xlim</code> or the color of the plot using
<code>col</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The coefficient paths for <code>glmboost</code> models show how the
coefficient estimates evolve with increasing <code>mstop</code>. Each line
represents one parameter estimate. Parameter estimates are only
depicted when they they are selected at any time in the boosting
model. Parameters that are not selected are droped from the figure
(see example).
</p>
<p>Models specified with <code>gamboost</code> or <code>mboost</code> are plotted as
partial effects. Only the effect of the current bossting iteration is
depicted instead of the coefficient paths as for linear models. The
function <code>lines</code> is just a wrapper to <code>plot(... , add =
    TRUE)</code> where per default the effect is plotted as line and the
<code>rug</code> is set to <code>FALSE</code>.
</p>
<p>Spatial effects can be also plotted using the function <code>plot</code>
for mboost models (using <code>lattice</code> graphics). More complex
effects reuquire manual plotting: One needs to predict the effects on
a disired grid and plot the effect estimates.
</p>


<h3>Value</h3>

<p>A plot of the fitted model.
</p>


<h3>References</h3>

<p>Benjamin Hofner, Andreas Mayr, Nikolay Robinzonov and Matthias Schmid
(2014). Model-based Boosting in R: A Hands-on Tutorial Using the R
Package mboost. <em>Computational Statistics</em>, <b>29</b>, 3â€“35.<br><a href="https://doi.org/10.1007/s00180-012-0382-5">doi:10.1007/s00180-012-0382-5</a>
</p>


<h3>See Also</h3>

<p><code>mboost_methods</code> for further methods.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### a simple example: cars data with one random variable
set.seed(1234)
cars$z &lt;- rnorm(50)

########################################
## Plot linear models
########################################

## fit a linear model
cars.lm &lt;- glmboost(dist ~ speed + z, data = cars)

## plot coefficient paths of glmboost
par(mfrow = c(3, 1), mar = c(4, 4, 4, 8))
plot(cars.lm,
     main = "Coefficient paths (offset not included)")
plot(cars.lm, off2int = TRUE,
     main = "Coefficient paths (offset included in intercept)")

## plot coefficient paths only for the first 15 steps,
## i.e., bevore z is selected
mstop(cars.lm) &lt;- 15
plot(cars.lm, off2int = TRUE, main = "z is not yet selected")


########################################
## Plot additive models; basics
########################################

## fit an additive model
cars.gam &lt;- gamboost(dist ~ speed + z, data = cars)

## plot effects
par(mfrow = c(1, 2), mar = c(4, 4, 0.1, 0.1))
plot(cars.gam)

## use same y-lims
plot(cars.gam, ylim = c(-50, 50))

## plot only the effect of speed
plot(cars.gam, which = "speed")
## as partial matching is used we could also use
plot(cars.gam, which = "sp")


########################################
## More complex plots
########################################

## Let us use more boosting iterations and compare the effects.

## We change the plot type and plot both effects in one figure:
par(mfrow = c(1, 1), mar = c(4, 4, 4, 0.1))
mstop(cars.gam) &lt;- 100
plot(cars.gam, which = 1, col = "red", type = "l", rug = FALSE,
     main = "Compare effect for various models")

## Now the same model with 1000 iterations
mstop(cars.gam) &lt;- 1000
lines(cars.gam, which = 1, col = "grey", lty = "dotted")

## There are some gaps in the data. Use newdata to get a smoother curve:
newdata &lt;- data.frame(speed = seq(min(cars$speed), max(cars$speed),
                                  length = 200))
lines(cars.gam, which = 1, col = "grey", lty = "dashed",
      newdata = newdata)

## The model with 1000 steps seems to overfit the data.
## Usually one should use e.g. cross-validation to tune the model.

## Finally we refit the model using linear effects as comparison
cars.glm &lt;- gamboost(dist ~ speed + z, baselearner = bols, data = cars)
lines(cars.glm, which = 1, col = "black")
## We see that all effects are more or less linear.

## Add a legend
legend("topleft", title = "Model",
       legend = c("... with mstop = 100", "... with mstop = 1000",
         "... with linear effects"),
       lty = c("solid", "dashed", "solid"),
       col = c("red", "grey", "black"))

</code></pre>


</div>