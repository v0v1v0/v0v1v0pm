<div class="container">

<table style="width: 100%;"><tr>
<td>mbrglm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Median Bias Reduction in Binomial-Response GLMs
</h2>

<h3>Description</h3>

<p>Fits binomial-response GLMs using the median bias-reduction method proposed in Kenne Pagui et al. (2016, Section 3). 
The proposed method is obtained by modifying the score equation in such a way that the solution is an approximately median 
unbiased estimator for each parameter component. The median bias-reduction method enjoys several good properties with respect to the maximum likelihood.
In particular,  the resulting estimator is component-wise median unbiased with and error of order (<code class="reqn">\mathop{\rm
O}(n^{-1})</code>) and is equivariant under joint reparameterizations that transform each parameter component separately. 
It has the same asymptotic distribution as the maximum likelihood estimator. Moreover, the resulting estimates and their corresponding 
standard errors are always finite while the maximum likelihood estimates can be infinite in situations where complete or quasi separation occurs.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mbrglm(formula, family = binomial, data, weights, subset, na.action, start = NULL, 
 etastart, mustart, offset, model = TRUE, method = "mbrglm.fit", x = FALSE, 
  y = TRUE, contrasts = NULL, control.glm = glm.control(), 
  control.mbrglm = mbrglm.control(), ...)

mbrglm.fit(x, y, weights = rep(1, nobs), start = NULL,  etastart = NULL, mustart = NULL,
 offset = rep(0, nobs), family = binomial(), control = glm.control(), 
 control.mbrglm = mbrglm.control(),  intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class <code>formula</code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. For glm this can be a character string naming a family function, a family function or the result of a call to a family function. For mbrglm.fit only the third option is supported. (See <code>family</code> for details of family functions.) mbrglm currently supports only the "binomial" family with links "logit", "probit", "cloglog".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which glm is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should be NULL or a numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain NAs. The default is set by the na.action setting of <code>options</code>, and is <code>na.fail</code> if that is unset. The 'factory-fresh' default is <code>na.omit</code>. Another possible value is NULL, no action. Value <code>na.exclude</code>can be useful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. One or more <code>offset</code> terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See <code>model.offset</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For glm.fit this is passed to <code>glm.control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>logical. Should an intercept be included in the null model?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a logical value indicating whether model frame should be included as a component of the returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method to be used for fitting the model. The unique method is "mbrglm.fit", which uses the median modified score function to estimate the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>For mbrglm: logical values indicating whether the model matrix used in the fitting process should be returned as components of the returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>For mbrglm: logical values indicating whether the response vector  used in the fitting process should be returned as components of the returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>an optional list. See the contrasts.arg of model.matrix.default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.glm</code></td>
<td>
<p><code>control.glm</code> replaces the <code>control</code>
argument in <code>glm</code> but essentially does the same job. It
is a list  of parameters to control <code>glm.fit</code>. See the
documentation of  <code>glm.control1</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.mbrglm</code></td>
<td>
<p>a list of parameters for controlling the fitting process when method="mbrglm.fit". See documentation <code>mbrglm.control</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>mbrglm.fit</code> is the workhorse function for fitting the model using
the median bias-reduction method.
</p>
<p>The main iteration of <code>mbrglm.fit</code> consists to calculate the required quantities for the construction
of the modified iterative re-weighted least square which involves the modification term of the score function in the
adjusted dependent variable.
</p>
<p>Iteration is repeated until either the iteration limit has been reached or the Euclidean distance  of the median modified scores is less than some specified positive constant (see the <code>mbr.maxit</code> and
<code>mbr.epsilon</code> arguments in <code>mbrglm.control</code>).
</p>


<h3>Value</h3>

<p><code>mbrglm</code> returns an object of class <code>"mbrglm"</code>. A
<code>"mbrglm"</code> object inherits first from <code>"glm"</code> and then from
<code>"lm"</code> and is a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p> Pearson's residual in the final iteration of the IWLS fit. Since cases with zero weights are omitted, their working residuals are NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>the numeric rank of the fitted linear model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>the <code>family</code> object used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.predictors</code></td>
<td>
<p>the linear fit on link scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>up to a constant, minus twice the maximized log-likelihood. Where sensible, the constant is chosen so that a saturated model has deviance zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null.deviance</code></td>
<td>
<p>The deviance for the null model, comparable with deviance. The null model will include the offset, and an intercept if there is one in the model. Note that this will be incorrect if the link function depends on the data other than through the fitted mean: specify a zero offset to force a correct calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>the working weights, that is the weights in the final iteration of the IWLS fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.weights</code></td>
<td>
<p>the weights initially supplied, a vector of 1s if none were.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.null</code></td>
<td>
<p>the residual degrees of freedom for the null model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>if requested (the default) the y vector used. (It is a vector even for a binomial model.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>if requested, the model matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>logical. Was the modified IWLS algorithm judged to have converged?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>logical. Is the fitted value on the boundary of the attainable values?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ModifiedScores</code></td>
<td>
<p>the vector of the median modified scores for the
parameters at the final iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FisherInfo</code></td>
<td>
<p>the Fisher information matrix evaluated at the
resulting estimates. Only available when <code>method = "mbrglm.fit"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FisherInfoInvs</code></td>
<td>
<p>the inverse of Fisher information matrix evaluated at the
resulting estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIter</code></td>
<td>
<p>the number of iterations that were required until
convergence. Only available when <code>method = "mbrglm.fit"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>if requested (the default), the model frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>the terms object used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the data argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>the offset vector used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.mbrglm</code></td>
<td>
<p>the <code>control.mbrglm</code> argument that was passed to
<code>mbrglm</code>. Only available when <code>method = "mbrglm.fit"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>(where relevant) the contrasts used.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>1.  'mbrglm' and 'mbrglm.fit' were written using as basis structure
the code of  'brglm' and 'brglm.fit', respectively. The functions 'brglm' and 'brglm.fit' are implemented in the R package brglm version 0.5-9 by Ioannis Kosmidis. While,  'print.mbrglm', 'summary.mbrglm' and  'print.summary.mbrglm' are  modifications of  'print.glm', 'summary.glm' and  'print.summary.glm', respectively.
</p>


<h3>Author(s)</h3>

<p>Euloge Clovis Kenne Pagui, <a href="mailto:kenne@stat.unipd.it">kenne@stat.unipd.it</a>, Alessandra Salvan, <a href="mailto:salvan@stat.unipd.it">salvan@stat.unipd.it</a> and  Nicola Sartori, <a href="mailto:sartori@stat.unipd.it">sartori@stat.unipd.it</a></p>


<h3>References</h3>

<p>Kenne Pagui, E. C., Salvan, A. and Sartori, N. (2016). Median bias
reduction of maximum likelihood estimates. <em>http://arxiv.org/abs/1604.04768</em>.
</p>


<h3>See Also</h3>

<p>brglm, brglm.fit, <code>glm</code>, <code>glm.fit</code></p>


<h3>Examples</h3>

<pre><code class="language-R"> ## First example
library(brglm)     
data(endo)
# Fit the GLM using maximum likelihood
endo.glm &lt;- glm(HG~NV+PI+EH,family=binomial,data=endo)
## Mean bias-reduced fit
endo.brglm&lt;-brglm(HG~NV+PI+EH,family=binomial,data=endo)
## Median bias-reduced fit
endo.mbrglm&lt;-mbrglm(HG~NV+PI+EH,family=binomial,data=endo)
endo.glm
endo.brglm
endo.mbrglm

# Now other links
update(endo.mbrglm, family = binomial(probit))
update(endo.mbrglm, family = binomial(cloglog))

##------------------------
## paper by Andrey Gelman et al. 2008. Annals of applied Statistics.
## application to binomial
## example 4.2
##----------------------

# first way

x&lt;-c(-0.86,-0.30,-0.05,0.73)
z.x&lt;- (1/sqrt(4))*(x-mean(x))/sqrt(var(x))
weights&lt;-rep(5,4)
z&lt;-c(0,1,3,5)
y=z/weights
fit.glm&lt;-glm(y~z.x,family=binomial,weights=weights)
fit.brglm&lt;-brglm(y~z.x,family=binomial,weights=weights)
fit.mbrglm&lt;-mbrglm(y~z.x,family=binomial,weights=weights)
fit.glm
fit.brglm
fit.mbrglm

# in alternative
fit.glm&lt;-glm(cbind(z,weights-z)~z.x,family=binomial)
fit.brglm&lt;-brglm(cbind(z,weights-z)~z.x,family=binomial)
fit.mbrglm&lt;-mbrglm(cbind(z,weights-z)~z.x,family=binomial)
fit.glm
fit.brglm
fit.mbrglm

##----------------------------------------
# Rasch model: 100 subjects and 5 items
##----------------------------------------

I &lt;- 5
S &lt;-  100

## function to generate data
gendata.M &lt;- function(gamma, alpha, beta)
{
  I &lt;- length(alpha) 
  S &lt;- length(gamma) 
  data.y &lt;- matrix(0, nrow=S, ncol=I)
  for(i in 1:I)
  {
    mui &lt;- plogis(alpha[i] + gamma * beta[i])
    data.y[,i] &lt;- rbinom(S, size=1, prob=mui)
  }
  return(data.y)      
}

alphas &lt;- c(0.0,  0.7,  1.6,  0.6, -0.5)
betas &lt;- rep(1,I)
gammas &lt;- rnorm(S)

y &lt;- gendata.M(gammas,alphas,betas)

y.dat &lt;- data.frame(y=y[1:(S*I)],subject=factor(rep(1:S,I)),item=factor(rep(1:I,each=S)))

## Not run: 
fit.glm &lt;- glm(y~subject-1+item,family=binomial,data=y.dat)
fit.brglm &lt;- brglm(y~subject-1+item,family=binomial,data=y.dat)
fit.mbrglm &lt;- mbrglm(y~subject-1+item,family=binomial,data=y.dat)

## End(Not run)
summary(fit.glm)
summary(fit.brglm)
summary(fit.mbrglm)

</code></pre>


</div>