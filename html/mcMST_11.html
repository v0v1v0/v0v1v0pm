<div class="container">

<table style="width: 100%;"><tr>
<td>getExactFront</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Enumerate all Pareto-optimal solutions.</h2>

<h3>Description</h3>

<p>Function which expects a problem instance of a combinatorial optimization
problem (e.g., MST), a multi-objective function and a solution enumerator, i.e., a function
which enumerates all possible solutions (e.g., all Pruefer codes in case of a
MST problem) and  determines both the Pareto front and Pareto set by
exhaustive enumeration.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getExactFront(instance, obj.fun, enumerator.fun, n.objectives, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>instance</code></td>
<td>
<p>[any]<br>
Problem instance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj.fun</code></td>
<td>
<p>[<code>function(solution, instance)</code>]<br>
Objective function which expects a numeric vector <code>solution</code> encoding a
solution candidate and a problem instance <code>instance</code>. The function should
return a numeric vector of length <code>n.objectives</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>enumerator.fun</code></td>
<td>
<p>[<code>function(n)</code>]<br>
Function to exhaustively generate all possible candidate solutions.
Expects a single integer value n, i.e., the instance size, e.g., the
number of nodes for a graph problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Number of objectives of problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>[<code>logical(1)</code>]<br>
Should pareto set be simplified to matrix?
This will only be done if all elements are of the same length. Otherwise
the parameter will be ignored.
Default is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>[<code>list</code>] List with elements <code>pareto.set</code> (matrix of Pareto-optimal solutions)
and <code>pareto.front</code> (matrix of corresponding weight vectors).
</p>


<h3>Note</h3>

<p>This method exhaustively enumerates all possible solutions
of a given multi-objective combinatorial optimization problem. Thus,
it is limited to small input size due to combinatorial explosion.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># here we enumerate all Pareto-optimal solutions of a bi-objective mcMST problem
# we use the Pruefer-code enumerator. Thus, we need to define an objective
# function, which is able to handle this type of endcoding
objfunMCMST = function(pcode, instance) {
  getWeight(instance, prueferToEdgeList(pcode))
}

# next we generate a random bi-objective graph
g = genRandomMCGP(5L)

# ... and finally compute the exact front of g
res = getExactFront(g, obj.fun = objfunMCMST, enumerator.fun = enumerateMST, n.objectives = 2L)
## Not run: 
plot(res$pareto.front)

## End(Not run)
</code></pre>


</div>