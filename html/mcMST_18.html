<div class="container">

<table style="width: 100%;"><tr>
<td>mcMSTEmoaBG</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Subgraph EMOA for the multi-criteria MST problem.</h2>

<h3>Description</h3>

<p>Evolutionary multi-objective algorithm to solve the
multi-objective minimum spanning tree problem. The algorithm relies
to mutation only to generate offspring. The package contains the subgraph mutator
(see <code>mutSubgraphMST</code>) or a simple one-edge exchange mutator
(see <code>mutEdgeExchange</code>). Of course, the user may use any
custom mutator which operators on edge lists as well
(see <code>makeMutator</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcMSTEmoaBG(
  instance,
  mu,
  lambda = mu,
  mut = NULL,
  selMating = NULL,
  selSurvival = ecr::selNondom,
  ref.point = NULL,
  max.iter = 100L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>instance</code></td>
<td>
<p>[<code>grapherator</code>]<br>
Multi-objective graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Population size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Number of offspring generated in each generation.
Default is <code>mu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mut</code></td>
<td>
<p>[<code>ecr_mutator</code>]<br>
Mutation operator.
Default is <code>mutSubgraphMST</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selMating</code></td>
<td>
<p>[<code>ecr_selector</code>]<br>
Mating selector.
Default is <code>selSimple</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selSurvival</code></td>
<td>
<p>[<code>ecr_selector</code>]<br>
Survival selector.
Default is <code>link[ecr]{selNondom}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref.point</code></td>
<td>
<p>[<code>numeric(n.objectives) | NULL</code>]<br>
Reference point for hypervolume computation used for logging.
If <code>NULL</code> the sum of the <code class="reqn">n</code> largest edges in each objective
is used where <code class="reqn">n</code> is the number of nodes of <code>instance</code>.
This is an upper bound for the size of each spanning tree
with <code class="reqn">(n-1)</code> edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
Maximal number of iterations.
Default is <code>100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>[<code>any</code>]<br>
Further parameters passed to mutator.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>[<code>ecr_result</code>] List of type <code>ecr_result</code>
with the following components:
</p>

<dl>
<dt>task</dt>
<dd>
<p>The <code>ecr_optimization_task</code>.</p>
</dd>
<dt>log</dt>
<dd>
<p>Logger object.</p>
</dd>
<dt>pareto.idx</dt>
<dd>
<p>Indizes of the non-dominated solutions in the last population.</p>
</dd>
<dt>pareto.front</dt>
<dd>
<p>(n x d) matrix of the approximated non-dominated front where n
is the number of non-dominated points and d is the number of objectives.</p>
</dd>
<dt>pareto.set</dt>
<dd>
<p>Matrix of decision space values resulting with objective values
given in pareto.front.</p>
</dd>
<dt>last.population</dt>
<dd>
<p>Last population.</p>
</dd>
<dt>message</dt>
<dd>
<p>Character string describing the reason of termination.</p>
</dd>
</dl>
<h3>References</h3>

<p>Bossek, J., and Grimme, C. A Pareto-Beneficial Sub-Tree Mutation
for the Multi-Criteria Minimum Spanning Tree Problem. In Proceedings of the
2017 IEEE Symposium Series on Computational Intelligence (2017). (accepted)
</p>


<h3>See Also</h3>

<p>Mutators <code>mutSubgraphMST</code> and <code>mutEdgeExchange</code>
</p>
<p>Other mcMST EMOAs: 
<code>mcMSTEmoaZhou()</code>
</p>
<p>Other mcMST algorithms: 
<code>mcMSTEmoaZhou()</code>,
<code>mcMSTPrim()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">inst = genRandomMCGP(10)
res = mcMSTEmoaBG(inst, mu = 20L, max.iter = 100L)
print(res$pareto.front)
print(tail(getStatistics(res$log)))
</code></pre>


</div>