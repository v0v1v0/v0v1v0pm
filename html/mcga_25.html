<div class="container">

<table style="width: 100%;"><tr>
<td>multi_mcga</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Performs multi objective machine coded genetic algorithms.
</h2>

<h3>Description</h3>

<p>Machine coded genetic algorithm (MCGA) is a fast tool for real-valued optimization problems. It uses the byte representation of variables rather than real-values. It performs the classical crossover operations (uniform) on these byte representations. Mutation operator is also similar to classical mutation operator, which is to say, it changes a randomly selected byte value of a chromosome by +1 or -1 with probability 1/2. In MCGAs there is no need for encoding-decoding process and the classical operators are directly applicable on real-values. It is fast and can handle a wide range of a search space with high precision. Using a 256-unary alphabet is the main disadvantage of this algorithm but a moderate size population is convenient for many problems.
</p>
<p>This function performs multi objective optimization using the same logic underlying the mcga. Chromosomes are sorted by their 
objective values using a non-dominated sorting algorithm. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">multi_mcga(popsize, chsize, crossprob = 1.0, mutateprob = 0.01, 
		   elitism = 1, minval, maxval, maxiter = 10, numfunc, evalFunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>popsize</code></td>
<td>

<p>Number of chromosomes. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chsize</code></td>
<td>

<p>Number of parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crossprob</code></td>
<td>

<p>Crossover probability. By default it is 1.0
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutateprob</code></td>
<td>

<p>Mutation probability. By default it is 0.01
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elitism</code></td>
<td>

<p>Number of best chromosomes to be copied directly into next generation. By default it is 1
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minval</code></td>
<td>

<p>The lower bound of the randomized initial population. This is not a constraint for parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxval</code></td>
<td>

<p>The upper bound of the randomized initial population. This is not a constraint for parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>

<p>The maximum number of generations. By default it is 10.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numfunc</code></td>
<td>

<p>Number of objective functions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evalFunc</code></td>
<td>

<p>An R function. By default, each problem is a minimization. This function must return a cost vector
with dimension of numfunc. Each element of this vector points to the corresponding function to optimize. 
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>population</code></td>
<td>
<p>Sorted population resulted after generations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>costs</code></td>
<td>
<p>Cost values for each chromosomes in the resulted population</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranks</code></td>
<td>
<p>Calculated ranks using a non-dominated sorting for each chromosome</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>Deb, K. (2000). An efficient constraint handling method for
genetic algorithms. Computer methods in applied mechanics and
engineering, 186(2), 311-338.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
 # We have two objective functions.
 f1&lt;-function(x){
   return(sin(x))
 }

 f2&lt;-function(x){
   return(sin(2*x))
 }

 # This function returns a vector of cost functions for a given x sent from mcga
 f&lt;-function(x){
   return ( c( f1(x), f2(x)) )
 }

 # main loop
 m&lt;-multi_mcga(popsize=200, chsize=1, minval= 0, elitism=2, 
 	      maxval= 2.0 * pi, maxiter=1000, crossprob=1.0, 
	      mutateprob=0.01, evalFunc=f, numfunc=2)

 # Points show best five solutions. 
 curve(f1, 0, 2*pi)
 curve(f2, 0, 2*pi, add=TRUE)

 p &lt;- m$population[1:5,]
 points(p, f1(p))
 points(p, f2(p))

## End(Not run)
</code></pre>


</div>