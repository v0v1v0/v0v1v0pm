<div class="container">

<table style="width: 100%;"><tr>
<td>re</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build a regular expression</h2>

<h3>Description</h3>

<p>Create an object of class <code>re</code> or coerce a character vector to an object of
class <code>re</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">re(x, perl = TRUE, ...)

as_re(x, perl = TRUE, ...)

as.re(x, perl = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Character vector of length one. The value of this character vector
is assumed to be a well-formed regular expression. In the current implementation
this is assumed, not checked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perl</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>x</code> is assumed to use PCRE (i.e. Perl
Compatible Regular Expressions) notation. If <code>FALSE</code>, <code>x</code> is assumed to use
base R's default regular expression notation.
Contrary to base R's regular expression functions, <code>re()</code> assumes that the
PCRE regular expression flavor is used by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This class exists because some functions in the mclm package
require their arguments to be marked as being regular expressions.
For example, <code>keep_re()</code> does not need its <code>pattern</code> argument to be a <code>re</code>
object, but if the user wants to subset items with brackets using
a regular expression, they must use a <code>re</code> object.
</p>


<h3>Value</h3>

<p>An object of class <code>re</code>, which is a wrapper around a character vector
flagging it as containing a regular expression. In essence it is a named
list: the <code>x</code> item contains the <code>x</code> input and the <code>perl</code> item contains
the value of the <code>perl</code> argument (<code>TRUE</code> by default).
</p>
<p>It has basic methods such as <code>print()</code>, <code>summary()</code> and <code>as.character()</code>.
</p>


<h3>See Also</h3>

<p><code>perl_flavor()</code>, <code>scan_re()</code>, <code>cat_re()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">toy_corpus &lt;- "Once upon a time there was a tiny toy corpus.
  It consisted of three sentences. And it lived happily ever after."

(tks &lt;- tokenize(toy_corpus))

# In `keep_re()`, the use of `re()` is optional
keep_re(tks, re("^.{3,}"))
keep_re(tks, "^.{3,}")

# When using brackets notation, `re()` is necessary
tks[re("^.{3,}")]
tks["^.{3,}"]

# build and print a `re` object
re("^.{3,}")
as_re("^.{3,}")
as.re("^.{3,}")
print(re("^.{3,}"))
</code></pre>


</div>