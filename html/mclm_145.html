<div class="container">

<table style="width: 100%;"><tr>
<td>re_convenience</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convenience functions in support of regular expressions</h2>

<h3>Description</h3>

<p>These functions are essentially simple wrappers around base R functions such as
<code>regexpr()</code>, <code>gregexpr()</code>, <code>grepl()</code>, <code>grep()</code>, <code>sub()</code> and <code>gsub()</code>.
The most important differences between the functions documented here and the
R base functions is the order of the arguments (<code>x</code> before <code>pattern</code>) and the
fact that the argument <code>perl</code> is set to <code>TRUE</code> by default.
</p>


<h3>Usage</h3>

<pre><code class="language-R">re_retrieve_first(
  x,
  pattern,
  ignore.case = FALSE,
  perl = TRUE,
  fixed = FALSE,
  useBytes = FALSE,
  requested_group = NULL,
  drop_NA = FALSE,
  ...
)

re_retrieve_last(
  x,
  pattern,
  ignore.case = FALSE,
  perl = TRUE,
  fixed = FALSE,
  useBytes = FALSE,
  requested_group = NULL,
  drop_NA = FALSE,
  ...
)

re_retrieve_all(
  x,
  pattern,
  ignore.case = FALSE,
  perl = TRUE,
  fixed = FALSE,
  useBytes = FALSE,
  requested_group = NULL,
  unlist = TRUE,
  ...
)

re_has_matches(
  x,
  pattern,
  ignore.case = FALSE,
  perl = TRUE,
  fixed = FALSE,
  useBytes = FALSE,
  ...
)

re_which(
  x,
  pattern,
  ignore.case = FALSE,
  perl = TRUE,
  fixed = FALSE,
  useBytes = FALSE,
  ...
)

re_replace_first(
  x,
  pattern,
  replacement,
  ignore.case = FALSE,
  perl = TRUE,
  fixed = FALSE,
  useBytes = FALSE,
  ...
)

re_replace_all(
  x,
  pattern,
  replacement,
  ignore.case = FALSE,
  perl = TRUE,
  fixed = FALSE,
  useBytes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Character vector to be searched or modified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>Regular expression specifying what is to be searched.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>
<p>Logical. Should the search be case insensitive?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perl</code></td>
<td>
<p>Logical. Whether the regular expressions use the PCRE flavor
of regular expression. Unlike in base R functions, the default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>pattern</code> is a string to be matched as is,
i.e. wildcards and special characters are not interpreted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useBytes</code></td>
<td>
<p>Logical. If <code>TRUE</code> the matching is done byte-by-byte rather than
character-by-character. See 'Details' in <code>grep()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>requested_group</code></td>
<td>
<p>Numeric.
If <code>NULL</code> or <code>0</code>, the output will contain matches for <code>pattern</code> as a whole.
If another number <code>n</code> is provided, then the output will not contain matches
for <code>pattern</code> but instead will only contain the matches for the <code>n</code>th capturing
group in <code>pattern</code> (the first if <code>requested_group = 1</code>, the second if
<code>requested_group = 2</code>...).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop_NA</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the output always has the same length as
the input <code>x</code> and items that do not contain a match for <code>pattern</code> yield <code>NA</code>.
If <code>TRUE</code>, such <code>NA</code> values are removed and therefore the result might contain
fewer items than <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unlist</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the output always has the same length as
the input <code>x</code>. More specifically, the result will be a list in which input
items that do not contain a match for <code>pattern</code> yield an empty vector, whereas
input items that do match will yield a vector of at least length one (depending
on the number of matches). If <code>TRUE</code>, the output is a single vector the length
of which may be shorter or longer than <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replacement</code></td>
<td>
<p>Character vector of length one specifying the replacement
string. It is to be taken literally, except that the notation <code style="white-space: pre;">⁠\\1⁠</code>, <code style="white-space: pre;">⁠\\2⁠</code>, etc.
can be used to refer to groups in <code>pattern</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For some of the arguments (e.g. <code>perl</code>, <code>fixed</code>) the reader is directed to
base R's regex documentation.
</p>


<h3>Value</h3>

<p><code>re_retrieve_first()</code>, <code>re_retrieve_last()</code> and <code>re_retrieve_all()</code> return
either a single vector of character data or a list containing such vectors.
<code>re_replace_first()</code> and <code>re_replace_all()</code> return the same type of character
vector as <code>x</code>.
</p>
<p><code>re_has_matches()</code> returns a logical vector indicating whether a match was
found in each of the elements in <code>x</code>; <code>re_which()</code> returns a numeric
vector indicating the indices of the elements of <code>x</code> for which a match was
found.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>re_retrieve_first()</code>: Retrieve from each item in <code>x</code> the first match
of <code>pattern</code>.
</p>
</li>
<li> <p><code>re_retrieve_last()</code>: Retrieve from each item in <code>x</code>
the last match of <code>pattern</code>.
</p>
</li>
<li> <p><code>re_retrieve_all()</code>: Retrieve from each item in <code>x</code>
all matches of <code>pattern</code>.
</p>
</li>
<li> <p><code>re_has_matches()</code>: Simple wrapper around <code>grepl()</code>.
</p>
</li>
<li> <p><code>re_which()</code>: Simple wrapper around <code>grep()</code>.
</p>
</li>
<li> <p><code>re_replace_first()</code>: Simple wrapper around <code>sub()</code>.
</p>
</li>
<li> <p><code>re_replace_all()</code>: Simple wrapper around <code>gsub()</code>.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">x &lt;- tokenize("This is a sentence with a couple of words in it.")
pattern &lt;- "[oe](.)(.)"

re_retrieve_first(x, pattern)
re_retrieve_first(x, pattern, drop_NA = TRUE)
re_retrieve_first(x, pattern, requested_group = 1)
re_retrieve_first(x, pattern, drop_NA = TRUE, requested_group = 1)
re_retrieve_first(x, pattern, requested_group = 2)

re_retrieve_last(x, pattern)
re_retrieve_last(x, pattern, drop_NA = TRUE)
re_retrieve_last(x, pattern, requested_group = 1)
re_retrieve_last(x, pattern, drop_NA = TRUE, requested_group = 1)
re_retrieve_last(x, pattern, requested_group = 2)

re_retrieve_all(x, pattern)
re_retrieve_all(x, pattern, unlist = FALSE)
re_retrieve_all(x, pattern, requested_group = 1)
re_retrieve_all(x, pattern, unlist = FALSE, requested_group = 1)
re_retrieve_all(x, pattern, requested_group = 2)

re_replace_first(x, "([oe].)", "{\\1}")
re_replace_all(x, "([oe].)", "{\\1}")
</code></pre>


</div>