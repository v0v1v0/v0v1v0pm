<div class="container">

<table style="width: 100%;"><tr>
<td>create_cooc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build collocation frequencies.</h2>

<h3>Description</h3>

<p>These functions builds a surface or textual collocation frequency for a specific node.
</p>


<h3>Usage</h3>

<pre><code class="language-R">surf_cooc(
  x,
  re_node,
  w_left = 3,
  w_right = 3,
  re_boundary = NULL,
  re_drop_line = NULL,
  line_glue = NULL,
  re_cut_area = NULL,
  re_token_splitter = re("[^_\\p{L}\\p{N}\\p{M}'-]+"),
  re_token_extractor = re("[_\\p{L}\\p{N}\\p{M}'-]+"),
  re_drop_token = NULL,
  re_token_transf_in = NULL,
  token_transf_out = NULL,
  token_to_lower = TRUE,
  perl = TRUE,
  blocksize = 300,
  verbose = FALSE,
  dot_blocksize = 10,
  file_encoding = "UTF-8"
)

text_cooc(
  x,
  re_node,
  re_boundary = NULL,
  re_drop_line = NULL,
  line_glue = NULL,
  re_cut_area = NULL,
  re_token_splitter = re("[^_\\p{L}\\p{N}\\p{M}'-]+"),
  re_token_extractor = re("[_\\p{L}\\p{N}\\p{M}'-]+"),
  re_drop_token = NULL,
  re_token_transf_in = NULL,
  token_transf_out = NULL,
  token_to_lower = TRUE,
  perl = TRUE,
  blocksize = 300,
  verbose = FALSE,
  dot_blocksize = 10,
  file_encoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>List of filenames of the corpus files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_node</code></td>
<td>
<p>Regular expression used for identifying instances of the 'node',
i.e. the target item for which collocation information is collected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_left</code></td>
<td>
<p>Number of tokens to the left of the 'node' that are treated as
belonging to the co-text of the 'node'. (But also see <code>re_boundary</code>.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_right</code></td>
<td>
<p>Number of tokens to the right of the 'node' that are treated as
belonging to the co-text of the 'node'. (But also see <code>re_boundary</code>.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_boundary</code></td>
<td>
<p>Regular expression.
</p>
<p>For <code>text_cooc()</code>, it identifies boundaries between 'textual units'.
</p>
<p>For <code>surf_cooc()</code>, it identifies 'cut-off' points for the co-text of
the 'node'. If it is not <code>NULL</code>, the maximum length of the left and right
co-texts are still given by <code>w_left</code> and <code>w_right</code>, but if a match
for <code>re_boundary</code> is found within the co-text, both the 'boundary token'
and all tokens beyond it are excluded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_drop_line</code></td>
<td>
<p>Regular expression or <code>NULL</code>. if <code>NULL</code>, the
argument  is ignored. Otherwise, lines in the corpus that match it are
treated as not belonging to the corpus and excluded from the results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line_glue</code></td>
<td>
<p>Character vector or <code>NULL</code>. if <code>NULL</code>, the argument
is ignored.
Otherwise, all the lines in the corpus are glued together in one character
vector of length 1, with the string <code>line_glue</code> pasted in between
consecutive lines.
</p>
<p>This value can also be equal to an empty string <code>""</code>.
</p>
<p>The 'line glue' operation is conducted immediately after the 'drop line' operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_cut_area</code></td>
<td>
<p>Regular expression or <code>NULL</code>. if <code>NULL</code>, the
argument  is ignored.
Otherwise, all matches in the corpus are 'cut out' from the text
prior to the identification of the tokens and are therefore not taken into
account when identifying the tokens.
</p>
<p>The 'cut area' operation is conducted immediately after the 'line glue' operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_token_splitter</code></td>
<td>
<p>Regular expression or <code>NULL</code>. if <code>NULL</code>,
the argument is ignored and <code>re_token_extractor</code> is used instead.
Otherwise, it identifies the areas between the tokens within a line of the corpus.
</p>
<p>The 'token identification' operation is conducted immediately after the
'cut area' operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_token_extractor</code></td>
<td>
<p>Regular expression that identifies the locations of
the actual tokens. It is only used if <code>re_token_splitter</code> is <code>NULL</code>.
Currently the implementation of this argument is a lot less time-efficient
than that of <code>re_token_splitter</code>.
</p>
<p>The 'token identification' operation is conducted immediately after the
'cut area' operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_drop_token</code></td>
<td>
<p>Regular expression or <code>NULL</code>. if <code>NULL</code>, the
argument is ignored. Otherwise, it identifies tokens to be excluded from the results.
</p>
<p>The 'drop token' operation is conducted immediately after the 'token
identification' operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_token_transf_in</code></td>
<td>
<p>A regular expression that identifies areas in the
tokens that are to be transformed. This argument works together with
<code>token_transf_out</code>. If either of them is <code>NULL</code>, they are both ignored.
</p>
<p>Otherwise, all matches in the tokens for <code>re_token_transf_in</code> are
replaced with the replacement string <code>token_transf_out</code>.
</p>
<p>The 'token transformation' operation is conducted immediately after the
'drop token' transformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>token_transf_out</code></td>
<td>
<p>A 'replacement string'. This argument works together
with <code>re_token_transf_in</code> and is ignored if either argument is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>token_to_lower</code></td>
<td>
<p>Logical. Whether tokens should be converted to
lowercase before returning the results.
</p>
<p>The 'token to lower' operation is conducted immediately after the 'token
transformation' operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perl</code></td>
<td>
<p>Logical. Whether the PCRE flavor of regular expressions
should be used in the arguments that contain regular expressions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blocksize</code></td>
<td>
<p>Number indicating how many corpus files are read to memory
'at each individual step' during the steps in the procedure. Normally the
default value of <code>300</code> should not be changed, but when one works with
exceptionally small corpus files, it may be worthwhile to use a higher
number, and when one works with exceptionally large corpus files, it may be
worthwhile to use a lower number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, messages are printed to the
console to indicate progress.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dot_blocksize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, dots are printed to the
console to indicate progress.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file_encoding</code></td>
<td>
<p>Encoding of the input files.
</p>
<p>Either a character vector of length 1, in which case all files are assumed
to be in the same encoding, or a character vector with the same length as
<code>x</code>, which allows for different encodings for different files.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Two major steps can be distinguished in the procedure conducted by these functions.
The first major step is the <em>identification of the (sequence of) tokens</em> that,
for the purpose of this analysis, will be considered to be the content of the corpus.
</p>
<p>The function arguments that jointly determine the details of this step are
<code>re_drop_line</code>, <code>line_glue</code>, <code>re_cut_area</code>, <code>re_token_splitter</code>,
<code>re_token_extractor</code>, <code>re_drop_token</code>, <code>re_token_transf_in</code>,
<code>token_transf_out</code>, and <code>token_to_lower</code>.
The sequence of tokens that is the ultimate outcome of this step is then
handed over to the second major step of the procedure.
</p>
<p>The second major step is the <em>establishment of the co-occurrence frequencies</em>.
The function arguments that jointly determine the details of this step are
<code>re_node</code> and <code>re_boundary</code> for both functions,
and <code>w_left</code> and <code>w_right</code> for <code>surf_cooc()</code> only.
It is important to know that this second step is conducted after the tokens
of the corpus have been identified, and that it is applied to a sequence of
tokens, not to the original text. More specifically the regular expressions
<code>re_node</code> and <code>re_boundary</code> are tested against individual tokens,
as they are identified by the token identification procedure.
Moreover, in <code>surf_cooc()</code>, the numbers <code>w_left</code> and <code>w_right</code>
also apply to tokens a they are identified by the token identification procedure.
</p>


<h3>Value</h3>

<p>An object of class <code>cooc_info</code>, containing information on
co-occurrence frequencies.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>surf_cooc()</code>: Build surface collocation frequencies
</p>
</li>
<li> <p><code>text_cooc()</code>: Build textual collocation frequencies
</p>
</li>
</ul>
</div>