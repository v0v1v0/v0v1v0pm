<div class="container">

<table style="width: 100%;"><tr>
<td>conc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build a concordance for the matches of a regex</h2>

<h3>Description</h3>

<p>This function builds a concordance for the matches of a regular expression. The result is a
dataset that can be written to a file with the function <code>write_conc()</code>.
It mimics the behavior of the concordance tool in the program AntConc.
</p>


<h3>Usage</h3>

<pre><code class="language-R">conc(
  x,
  pattern,
  c_left = 200,
  c_right = 200,
  perl = TRUE,
  re_drop_line = NULL,
  line_glue = "\n",
  re_cut_area = NULL,
  file_encoding = "UTF-8",
  as_text = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A character vector determining which text is to be used as corpus.
</p>
<p>If <code>as_text = TRUE</code>, <code>x</code> is treated as the actual text to be used
as corpus.
</p>
<p>If <code>as_text = FALSE</code> (the default), <code>x</code> is treated as a vector of
filenames, interpreted as the names of the corpus files that contain the
actual corpus data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>Character string containing the regular expression that serves
as search term for the concordancer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c_left</code></td>
<td>
<p>Number. How many characters to the left of each match must be
included in the result as left co-text of the match.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c_right</code></td>
<td>
<p>Number. How many characters to the right of each match must be
included in the result as right co-text of the match.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perl</code></td>
<td>
<p>If <code>TRUE</code>, <code>pattern</code> is treated as a PCRE flavor regular
expression. Otherwise, <code>pattern</code> is treated as a regular expression in R's
default flavor of regular expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_drop_line</code></td>
<td>
<p>Character vector or <code>NULL</code>. If <code>NULL</code>, the argument
is ignored.
Otherwise, lines in <code>x</code> containing a match for <code>re_drop_line</code> are
treated as not belonging to the corpus and are excluded from the results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line_glue</code></td>
<td>
<p>Character vector or <code>NULL</code>. If <code>NULL</code>, the argument
is ignored.
Otherwise, all lines in the corpus are glued together in one character
vector of length 1, with the string <code>line_glue</code> pasted in between
consecutive lines.
The value of <code>line_glue</code> can also be equal to the empty string (<code>""</code>).
The 'line_glue' operation is conducted immediately after the 'drop line' operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_cut_area</code></td>
<td>
<p>Character vector or <code>NULL</code>. If <code>NULL</code>, the argument
is ignored.
Otherwise, all matches in the corpus are 'cut out' of the text prior to the
identification of the tokens in the text (and are therefore not taken into
account when identifying tokens).
The 'cut area' operation is conducted immediately after the 'line glue' operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file_encoding</code></td>
<td>
<p>File encoding for reading each corpus file. Ignored if
<code>as_text = TRUE</code>. Otherwise, it must be a character vector of length one
(in which case the same encoding is used for all files) or with the same
length as <code>x</code> (in which case each file can have a different encoding).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_text</code></td>
<td>
<p>Logical.
If <code>TRUE</code>, the content of <code>x</code> is treated
as the actual text of the corpus (with each item within <code>x</code> treated as
a separate 'document in RAM').
</p>
<p>If <code>FALSE</code>, <code>x</code> is treated as a vector of filenames, interpreted
as the names of the corpus files with the actual corpus data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In order to make sure that the columns <code>left</code>, <code>match</code>,
and <code>right</code> in the output of <code>conc</code> do not contain any TAB or NEWLINE
characters, whitespace in these items is being 'normalized'.
More particularly, each stretch of whitespace, i.e. each  uninterrupted
sequences of whitespace characters, is replaced by  a single SPACE character.
</p>
<p>The values in the items the <code>glob_id</code> and <code>id</code> in the output
of <code>conc</code> are always identical in a dataset that is the output of the
function <code>conc</code>. The item <code>glob_id</code> only becomes useful when later,
for instance, one wants to merge two datasets.#'
</p>


<h3>Value</h3>

<p>Object of class <code>conc</code>, a kind of data frame with as its rows
the matches and with the following columns:
</p>

<ul>
<li> <p><code>glob_id</code>: Number indicating the position of the match in the
overall list of matches.
</p>
</li>
<li> <p><code>id</code>: Number indicating the position of the match in the list of matches
for one specific query.
</p>
</li>
<li> <p><code>source</code>: Either the filename of the file in which the match was found
(in case of the setting <code>as_text = FALSE</code>), or the string '-'
(in case of the setting <code>as_text = TRUE</code>).
</p>
</li>
<li> <p><code>left</code>: The left-hand side co-text of each match.
</p>
</li>
<li> <p><code>match</code>: The actual match.
</p>
</li>
<li> <p><code>right</code>: The right-hand side co-text of each match.
</p>
</li>
</ul>
<p>It also has additional attributes and methods such as:
</p>

<ul>
<li>
<p> base <code>as_data_frame()</code> and <code>print()</code> methods, as well as
a <code>print_kwic()</code> function,
</p>
</li>
<li>
<p> an <code>explore()</code> method.
</p>
</li>
</ul>
<p>An object of class <code>conc</code> can be merged with another by means of <code>merge_conc()</code>.
It can be written to file with <code>write_conc()</code> and then
read with <code>read_conc()</code>. It is also possible to import concordances created
by means other than <code>write_conc()</code> with <code>import_conc()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">(conc_data &lt;- conc('A very small corpus.', '\\w+', as_text = TRUE))
print(conc_data)
print_kwic(conc_data)
</code></pre>


</div>