<div class="container">

<table style="width: 100%;"><tr>
<td>densityMclustBounded</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model-based mixture density estimation for bounded data</h2>

<h3>Description</h3>

<p>Density estimation for bounded data via transformation-based approach for
Gaussian mixtures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">densityMclustBounded(
  data,
  G = NULL,
  modelNames = NULL,
  lbound = NULL,
  ubound = NULL,
  lambda = c(-3, 3),
  prior = NULL,
  initialization = NULL,
  nstart = 25,
  parallel = FALSE,
  seed = NULL,
  ...
)

## S3 method for class 'densityMclustBounded'
summary(object, parameters = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. If a
matrix or data frame, rows correspond to observations and columns correspond
to variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>An integer vector specifying the numbers of mixture components. By
default <code>G=1:3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelNames</code></td>
<td>
<p>A vector of character strings indicating the Gaussian
mixture models to be fitted on the transformed-data space.  See
<code>mclust::mclustModelNames()</code> for a descripton of available models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbound</code></td>
<td>
<p>Numeric vector proving lower bounds for variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ubound</code></td>
<td>
<p>Numeric vector proving upper bounds for variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A numeric vector providing the range (min and max) of searched
values for the transformation parameter(s). If a matrix is provided, then
for each variable a row should be provided containing the range of lambda
values for the transformation parameter. If a variable must have a fixed
lambda value, the provided min and max values should be equal. See examples
below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>A function specifying a prior for Bayesian regularization of
Gaussian mixtures. See <code>mclust::priorControl()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initialization</code></td>
<td>
<p>A list containing one or more of the following
components:
</p>

<ul>
<li> <p><code>noise</code> A logical or numeric vector indicating an initial guess as to
which observations are noise in the data. If numeric the entries should
correspond to row indexes of the data. If logical an automatic
entropy-based guess of noisy observations is made. When supplied, a noise
term will be added to the model in the estimation.
</p>
</li>
<li> <p><code>Vinv</code> When a noise component is included in the model, this is a
numerical optional argument providing the reciprocal of the volume of the
data.  By default, the <code>mclust::hypvol()</code> is used on the transformed data
from a preliminary model.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>
<p>An integer value specifying the number of replications of
k-means clustering to be used for initializing the EM algorithm. See
<code>kmeans()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>An optional argument which allows to specify if the search
over all possible models should be run sequentially (default) or in
parallel.
</p>
<p>For a single machine with multiple cores, possible values are:
</p>

<ul>
<li>
<p> a logical value specifying if parallel computing should be used (<code>TRUE</code>)
or not (<code>FALSE</code>, default) for evaluating the fitness function;
</p>
</li>
<li>
<p> a numerical value which gives the number of cores to employ. By default,
this is obtained from the function <code>parallel::detectCores()</code>;
</p>
</li>
<li>
<p> a character string specifying the type of parallelisation to use. This
depends on system OS: on Windows OS only <code>"snow"</code> type functionality is
available, while on Unix/Linux/Mac OSX both <code>"snow"</code> and <code>"multicore"</code>
(default) functionalities are available.
</p>
</li>
</ul>
<p>In all the cases described above, at the end of the search the cluster is
automatically stopped by shutting down the workers.
</p>
<p>If a cluster of multiple machines is available, evaluation of the fitness
function can be executed in parallel using all, or a subset of, the cores
available to the machines belonging to the cluster. However, this option
requires more work from the user, who needs to set up and register a
parallel back end.  In this case the cluster must be explicitely stopped
with <code>parallel::stopCluster()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>An integer value containing the random number generator state.
This argument can be used to replicate the result of k-means initialisation
strategy. Note that if parallel computing is required, the <span class="pkg">doRNG</span>
package must be installed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>'densityMclustBounded'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>A logical, if <code>TRUE</code> the estimated parameters of mixture
components are printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For more details see
<code>vignette("mclustAddons")</code>
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'densityMclustBounded'</code>.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian
mixture density estimation for bounded data. <em>Biometrical Journal</em>,
61:4, 873â€“888. <a href="https://doi.org/10.1002/bimj.201800174">doi:10.1002/bimj.201800174</a>
</p>


<h3>See Also</h3>

<p><code>predict.densityMclustBounded()</code>, <code>plot.densityMclustBounded()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# univariate case with lower bound
x &lt;- rchisq(200, 3)
xgrid &lt;- seq(-2, max(x), length=1000)
f &lt;- dchisq(xgrid, 3)  # true density
dens &lt;- densityMclustBounded(x, lbound = 0)
summary(dens)
summary(dens, parameters = TRUE)
plot(dens, what = "BIC")
plot(dens, what = "density")
lines(xgrid, f, lty = 2)
plot(dens, what = "density", data = x, breaks = 15)

# univariate case with lower &amp; upper bounds
x &lt;- rbeta(200, 5, 1.5)
xgrid &lt;- seq(-0.1, 1.1, length=1000)
f &lt;- dbeta(xgrid, 5, 1.5)  # true density
dens &lt;- densityMclustBounded(x, lbound = 0, ubound = 1)
summary(dens)
plot(dens, what = "BIC")
plot(dens, what = "density")
plot(dens, what = "density", data = x, breaks = 9)

# bivariate case with lower bounds
x1 &lt;- rchisq(200, 3)
x2 &lt;- 0.5*x1 + sqrt(1-0.5^2)*rchisq(200, 5)
x &lt;- cbind(x1, x2)
plot(x)
dens &lt;- densityMclustBounded(x, lbound = c(0,0))
summary(dens, parameters = TRUE)
plot(dens, what = "BIC")
plot(dens, what = "density")
plot(dens, what = "density", type = "hdr")
plot(dens, what = "density", type = "persp")
# specify different ranges for the lambda values of each variable
dens1 &lt;- densityMclustBounded(x, lbound = c(0,0), 
                              lambda = matrix(c(-2,2,0,1), 2, 2, byrow=TRUE))
# set lambda = 0 fixed for the second variable
dens2 &lt;- densityMclustBounded(x, lbound = c(0,0), 
                              lambda = matrix(c(0,1,0,0), 2, 2, byrow=TRUE))

dens[c("lambdaRange", "lambda", "loglik", "df")]
dens1[c("lambdaRange", "lambda", "loglik", "df")]
dens2[c("lambdaRange", "lambda", "loglik", "df")]


</code></pre>


</div>