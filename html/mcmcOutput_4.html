<div class="container">

<table style="width: 100%;"><tr>
<td>densityFolded</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Folded kernel density estimation
</h2>

<h3>Description</h3>

<p>Parameters are often constrained to be greater than zero (eg, standard deviation) or within the range (0, 1) (eg, probabilities), but the function <code>density</code> often returns non-zero densities outside these ranges. Simple truncation does not work, as the area under the curve is &lt; 1. The function <code>densityFolded</code> attempts to identify these constraints and gives an appropriate density.
</p>
<p>If <code>x</code> is a matrix, detection of constraints and selection of bandwidth is applied to the pooled values, but a separate density curve is fitted to each column of the matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">densityFolded(x, bw = "nrd0", adjust = 1, from=NA, to=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a numeric vector or matrix from which the estimate is to be computed; missing values not allowed. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>

<p>the smoothing bandwidth to be used; see <code>density</code> for details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>

<p>the bandwidth used is actually <code>adjust*bw</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from, to</code></td>
<td>

<p>the lower and upper ends of the grid at which the density is to be estimated; if NA, range will cover the values in x; ignored and replaced with 0 or 1 if a constraint is detected.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>other arguments passed to <code>density</code>.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list containing the following components:
</p>

<dl>
<dt>x </dt>
<dd>
<p>the n coordinates of the points where the density is estimated.</p>
</dd>
<dt>y	</dt>
<dd>
<p>a vector or matrix with the estimated density values.</p>
</dd>
<dt>bw </dt>
<dd>
<p>the bandwidth used.</p>
</dd>
<dt>n	</dt>
<dd>
<p>the sample size after elimination of missing values.</p>
</dd>
<dt>call </dt>
<dd>
<p>the call which produced the result.</p>
</dd>
<dt>data.name	</dt>
<dd>
<p>the deparsed name of the x argument.</p>
</dd>
</dl>
<p>If <code>y</code> is a vector, the output will have class <code>density</code>.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(graphics)
oldpar &lt;- par(mfrow=2:1)

x1 &lt;- rnorm(1e4)            # no constraint on x1
plot(density(x1))
plot(densityFolded(x1))     # no difference

x2 &lt;- abs(rnorm(1e4))       # x2 &gt;= 0, with mode at 0
plot(density(x2))           # density &gt; 0 when x2 &lt; 0, mode around 0.2
abline(v=0, col='grey')
plot(densityFolded(x2))     # mode plotted correctly
abline(v=0, col='grey')

x3 &lt;- rbeta(1e4, 1.5, 1.5)  # 0 &lt;= x3 &lt;= 1
plot(density(x3))           # density &gt; 0 when x2 &lt; 0 and x2 &gt; 1
abline(v=0:1, col='grey')
plot(densityFolded(x3))
abline(v=0:1, col='grey')

x4 &lt;- rbeta(1e4, 1.5, 0.9)  # 0 &lt;= x4 &lt;= 1, with mode at 1
plot(density(x4))           # mode appears to be around 0.95
abline(v=0:1, col='grey')
plot(densityFolded(x4))     # mode plotted correctly
abline(v=0:1, col='grey')

# Try with a matrix
x5 &lt;- cbind(rbeta(1e4, 2,2), rbeta(1e4, 2,3), rbeta(1e4, 3,2))
plot(density(x5))
tmp &lt;- densityFolded(x5)
with(tmp, matplot(x, y, type='l'))

par(oldpar)
</code></pre>


</div>