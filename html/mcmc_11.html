<div class="container">

<table style="width: 100%;"><tr>
<td>morph.metrop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Morphometric Metropolis Algorithm</h2>

<h3>Description</h3>

<p>Markov chain Monte Carlo for continuous random vector using a
Metropolis algorithm for an induced density.
</p>


<h3>Usage</h3>

<pre><code class="language-R">morph.metrop(obj, initial, nbatch, blen = 1, nspac = 1, scale = 1,
  outfun, debug = FALSE, morph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>see <code>metrop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>see <code>metrop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbatch</code></td>
<td>
<p>see <code>metrop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blen</code></td>
<td>
<p>see <code>metrop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nspac</code></td>
<td>
<p>see <code>metrop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>see <code>metrop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outfun</code></td>
<td>
<p>unlike for <code>metrop</code> must be a function or missing;
if missing the identity function, <code>function(x) x</code>, is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>see <code>metrop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>morph</code></td>
<td>
<p>morph object used for transformations.  See <code>morph</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>see <code>metrop</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>morph.metrop</code> implements morphometric methods for Markov
chains.  The caller specifies a log unnormalized probability density
and a transformation.  The transformation specified by the
<code>morph</code> parameter is used to induce a new log unnormalized
probability   density, a Metropolis algorithm is
run for the induced density.  The Markov chain is transformed back to
the original scale.  Running the Metropolis algorithm for the induced
density, instead of the original density, can result in a Markov chain
with better convergence properties.  For more details see Johnson and Geyer
(submitted).  Except for <code>morph</code>, all parameters are
passed to <code>metrop</code>, transformed when necessary.  The
<code>scale</code> parameter is <em>not</em> transformed.
</p>
<p>If <code class="reqn">X</code> is a real vector valued continuous random variable, and
<code class="reqn">Y = f(X)</code> where <code class="reqn">f</code> is a diffeomorphism, then the pdf of
<code class="reqn">Y</code> is given by </p>
<p style="text-align: center;"><code class="reqn">f_Y(y) = f_X(f^{-1}(y)) | \nabla f^{-1}(y)
  |</code>
</p>
<p> where <code class="reqn">f_X</code> is
the pdf of <code class="reqn">X</code> and <code class="reqn">\nabla f^{-1}</code> is the Jacobian
of <code class="reqn">f^{-1}</code>.  Because <code class="reqn">f</code> is a diffeomorphism, a Markov chain
for <code class="reqn">f_Y</code> may be transformed into a Markov chain for
<code class="reqn">f_X</code>.  Furthermore, these Markov chains are isomorphic
(Johnson and Geyer, submitted) and have the same convergence rate.
The <code>morph</code> variable provides a diffeomorphism,
<code>morph.metrop</code> uses this diffeomorphism to induce the log
unnormalized density, <code class="reqn">\log f_Y</code> based on the user
supplied log unnormalized density, <code class="reqn">\log f_X</code>.
<code>morph.metrop</code> runs a Metropolis algorithm for <code class="reqn">\log f_Y</code> and transforms the resulting Markov chain into a Markov chain for
<code class="reqn">f_X</code>.  The user accessible output components are the same as
those that come from <code>metrop</code>, see the documentation for
<code>metrop</code> for details.
</p>
<p>Subsequent calls of <code>morph.metrop</code> may change to the
transformation by specifying a new value for <code>morph</code>.
</p>
<p>Any of the other parameters to <code>morph.metrop</code> may also be
modified in subsequent calls.  See <code>metrop</code> for more details.
</p>
<p>The general idea is that a random-walk Metropolis sampler
(what <code>metrop</code> does) will not be geometrically
ergodic unless the tails of the unnormalized density decrease
superexponentially fast (so the tails of the log unnormalized density
decrease faster than linearly).  It may not be geometrically ergodic
even then (see Johnson and Geyer, submitted, for the complete theory).
The transformations used by this function (provided by <code>morph</code>)
can produce geometrically ergodic chains when the tails of the log
unnormalized density are too light for <code>metrop</code> to do so.
</p>
<p>When the tails of the unnormalized density are exponentially light but
not superexponentially light (so the tails of the log unnormalized density
are asymptotically linear, as in the case of exponential family models
when conjugate priors are used, for example logistic regression, Poisson
regression with log link, or log-linear models for categorical data), one
should use <code>morph</code> with <code>b = 0</code> (the default), which
produces a transformation of the form <code class="reqn">g_1</code> in the notation
used in the details section of the help for <code>morph</code>.
This will produce a geometrically ergodic sampler if other features of the
log unnormalized density are well behaved.  For example it will do so
for the exponential family examples mentioned above.
(See Johnson and Geyer, submitted, for the complete theory.)
</p>
<p>The transformation <code class="reqn">g_1</code> behaves like a shift transformation
on a ball of radius <code>r</code> centered at <code>center</code>, so these arguments
to <code>morph</code> should be chosen so that a sizable proportion of
the probability under the original (untransformed) unnormalized density
is contained in this ball.  This function will work when <code>r = 0</code> and
<code>center = 0</code> (the defaults) are used, but may not work as well as when
<code>r</code> and <code>center</code> are well chosen.
</p>
<p>When the tails of the unnormalized density are not exponentially light
(so the tails of the log unnormalized density decrease sublinearly, as
in the case of univariate and multivariate <code class="reqn">t</code> distributions), one
should use <code>morph</code> with <code>r &gt; 0</code> and <code>p = 3</code>, which
produces a transformation of the form <code class="reqn">g_2</code> composed
with <code class="reqn">g_1</code> in the notation
used in the details section of the help for <code>morph</code>.
This will produce a geometrically ergodic sampler if other features of the
log unnormalized density are well behaved.  For example it will do so
for the <code class="reqn">t</code> examples mentioned above.
(See Johnson and Geyer, submitted, for the complete theory.)
</p>


<h3>Value</h3>

<p>an object of class <code>mcmc</code>, subclass <code>morph.metropolis</code>.
This object is a list containing all of the elements from an object
returned by <code>metrop</code>, plus at least the following
components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>morph</code></td>
<td>
<p>the morph object used for the transformations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>morph.final</code></td>
<td>
<p>the final state of the Markov chain on the
transformed scale.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Johnson, L. T. and Geyer, C. J. (submitted)
Variable Transformation to Obtain Geometric Ergodicity
in the Random-walk Metropolis Algorithm.
</p>


<h3>See Also</h3>

<p><code>metrop</code>, <code>morph</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">out &lt;- morph.metrop(function(x) dt(x, df=3, log=TRUE), 0, blen=100,
  nbatch=100, morph=morph(b=1))
# change the transformation.
out &lt;- morph.metrop(out, morph=morph(b=2))
out$accept
# accept rate is high, increase the scale.
out &lt;- morph.metrop(out, scale=4)
# close to 0.20 is about right.
out$accept
</code></pre>


</div>