<div class="container">

<table style="width: 100%;"><tr>
<td>morph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Variable Transformation</h2>

<h3>Description</h3>

<p>Utility functions for variable transformation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">morph(b, r, p, center)
morph.identity()
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Positive real number.  May be missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Non-negative real number.  May be missing.  If <code>p</code> is
specified, <code>r</code> defaults to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Real number strictly greater than 2.  May be missing.  If
<code>r</code> is specified, <code>p</code> defaults to 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>Real scalar or vector.  May be missing.  If
<code>center</code> is a vector it should be the same length of the state
of the Markov chain, <code>center</code> defaults to 0</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>morph</code> function facilitates using variable transformations
by providing functions to (using <code class="reqn">X</code> for the original random
variable with the pdf <code class="reqn">f_X</code>, and <code class="reqn">Y</code> for the transformed
random variable with the pdf <code class="reqn">f_Y</code>):
</p>

<ul>
<li>
<p> Calculate the log unnormalized probability density for <code class="reqn">Y</code>
induced by the transformation.
</p>
</li>
<li>
<p> Transform an arbitrary function of <code class="reqn">X</code> to a function of
<code class="reqn">Y</code>.
</p>
</li>
<li>
<p> Transform values of <code class="reqn">X</code> to values of <code class="reqn">Y</code>.
</p>
</li>
<li>
<p> Transform values of <code class="reqn">Y</code> to values of <code class="reqn">X</code>
(the inverse transformation).
</p>
</li>
</ul>
<p>for a select few transformations.
</p>
<p><code>morph.identity</code> implements the identity transformation,
<code class="reqn">Y=X</code>.
</p>
<p>The parameters <code>r</code>, <code>p</code>, <code>b</code> and <code>center</code> specify the
transformation function.  In all cases, <code>center</code> gives the center
of the transformation, which is the value <code class="reqn">c</code> in the equation
</p>
<p style="text-align: center;"><code class="reqn">Y = f(X - c).</code>
</p>
<p>  If no parameters are specified, the identity
transformation, <code class="reqn">Y=X</code>, is used.
</p>
<p>The parameters <code>r</code>, <code>p</code> and <code>b</code> specify a function
<code class="reqn">g</code>, which is a monotonically increasing bijection from the
non-negative reals to the non-negative reals.  Then
</p>
<p style="text-align: center;"><code class="reqn">f(X) = g\bigl(|X|\bigr) \frac{X}{|X|}</code>
</p>

<p>where <code class="reqn">|X|</code> represents the Euclidean norm of the vector <code class="reqn">X</code>.
The inverse function is given by
</p>
<p style="text-align: center;"><code class="reqn">f^{-1}(Y) = g^{-1}\bigl(|Y|\bigr) \frac{Y}{|Y|}.</code>
</p>

<p>The parameters <code>r</code> and <code>p</code> are used to define the function
</p>
<p style="text-align: center;"><code class="reqn">g_1(x) = x + (x-r)^p I(x &gt; r)</code>
</p>

<p>where <code class="reqn">I( \cdot )</code>  is the indicator
function.  We require that <code>r</code> is non-negative and <code>p</code> is
strictly greater than 2.  The parameter <code>b</code> is used to define the
function
</p>
<p style="text-align: center;"><code class="reqn">g_2(x) = \bigl(e^{bx} - e / 3\bigr) I(x &gt; \frac{1}{b}) + 
    \bigl(x^3 b^3 e / 6 + x b e / 2\bigr) I(x \leq
    \frac{1}{b})</code>
</p>

<p>We require that <code class="reqn">b</code> is positive.
</p>
<p>The parameters <code>r</code>, <code>p</code> and <code>b</code> specify <code class="reqn">f^{-1}</code> in
the following manner:
</p>

<ul>
<li>
<p>  If one or both of <code>r</code> and <code>p</code> is specified, and <code>b</code>
is not specified, then </p>
<p style="text-align: center;"><code class="reqn">f^{-1}(X) = g_1(|X|)
      \frac{X}{|X|}.</code>
</p>
<p>  If only
<code>r</code> is specified, <code>p = 3</code> is used.  If only <code>p</code> is specified,
<code>r = 0</code> is used.
</p>
</li>
<li>
<p> If only <code>b</code> is specified, then </p>
<p style="text-align: center;"><code class="reqn">f^{-1}(X) = g_2(|X|)
      \frac{X}{|X|}.</code>
</p>

</li>
<li>
<p> If one or both of <code>r</code> and <code>p</code> is specified, and <code>b</code> is
also specified, then </p>
<p style="text-align: center;"><code class="reqn">f^{-1}(X) = g_2(g_1(|X|))
      \frac{X}{|X|}.</code>
</p>

</li>
</ul>
<h3>Value</h3>

<p>a list containing the functions
</p>

<ul>
<li> <p><code>outfun(f)</code>, a function that operates on functions.
<code>outfun(f)</code> returns the function <code>function(state, ...)
    f(inverse(state), ...)</code>.
</p>
</li>
<li> <p><code>inverse</code>, the inverse transformation function.
</p>
</li>
<li> <p><code>transform</code>, the transformation function.
</p>
</li>
<li> <p><code>lud</code>, a function that operates on functions.  As input,
<code>lud</code> takes a function that calculates a log unnormalized
probability density, and returns a function that calculates the
log unnormalized density by transforming a random variable using the
<code>transform</code> function.  <code>lud(f) = function(state, ...)
  f(inverse(state), ...) + log.jacobian(state)</code>, where
<code>log.jacobian</code> represents the function that calculate the log
Jacobian of the transformation.  <code>log.jacobian</code> is not returned.
</p>
</li>
</ul>
<h3>Warning</h3>

<p>The equations for the returned <code>transform</code> function (see below)
do not have a general analytical solution when <code>p</code> is not equal
to 3.  This implementation uses numerical approximation to calculate
<code>transform</code> when <code>p</code> is not equal to 3.  If computation
speed is a factor, it is advisable to use <code>p=3</code>.  This is not a
factor when using <code>morph.metrop</code>, as <code>transform</code> is
only called once during setup, and not at all while running the Markov chain.
</p>


<h3>See Also</h3>

<p><code>morph.metrop</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# use an exponential transformation, centered at 100.
b1 &lt;- morph(b=1, center=100)
# original log unnormalized density is from a t distribution with 3
# degrees of freedom, centered at 100.
lud.transformed &lt;- b1$lud(function(x) dt(x - 100, df=3, log=TRUE))
d.transformed &lt;- Vectorize(function(x) exp(lud.transformed(x)))
## Not run: 
curve(d.transformed, from=-3, to=3, ylab="Induced Density")

## End(Not run)
</code></pre>


</div>