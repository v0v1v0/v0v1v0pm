<div class="container">

<table style="width: 100%;"><tr>
<td>MCMCEnsemble</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MCMC ensemble sampler</h2>

<h3>Description</h3>

<p>Ensemble Markov Chain Monte Carlo sampler with different strategies to
generate proposals. Either the <em>stretch move</em> as proposed by Goodman and
Weare (2010), or a <em>differential evolution jump move</em> similar to Braak and
Vrugt (2008).
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMCEnsemble(
  f,
  inits,
  max.iter,
  n.walkers = 10 * ncol(inits),
  method = c("stretch", "differential.evolution"),
  coda = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>function that returns a single scalar value proportional to the log
probability density to sample from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inits</code></td>
<td>
<p>A matrix (or data.frame) containing the starting values for the
walkers. Each column is a variable to estimate and each row is a walker</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>maximum number of function evaluations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.walkers</code></td>
<td>
<p>number of walkers (ensemble size). An integer greater or
equal than 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method for proposal generation, either <code>"stretch"</code>, or
<code>"differential.evolution"</code>. This argument will be saved as an attribute
in the output (see examples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coda</code></td>
<td>
<p>logical. Should the samples be returned as coda::mcmc.list
object? (defaults to <code>FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to <code>f</code></p>
</td>
</tr>
</table>
<h3>Value</h3>


<ul>
<li>
<p> if <code>coda = FALSE</code> a list with:
</p>

<ul>
<li> <p><em>samples</em>: A three dimensional array of samples with dimensions <code>walker</code>
x <code>generation</code> x <code>parameter</code>
</p>
</li>
<li> <p><em>log.p</em>: A matrix with the log density evaluate for each walker at each
generation.
</p>
</li>
</ul>
</li>
<li>
<p> if <code>coda = TRUE</code> a list with:
</p>

<ul>
<li> <p><em>samples</em>: A object of class coda::mcmc.list containing all samples.
</p>
</li>
<li> <p><em>log.p</em>: A matrix with the log density evaluate for each walker at each
generation.
</p>
</li>
</ul>
</li>
</ul>
<p>In both cases, there is an additional attribute (accessible via
<code>attr(res, "ensemble.sampler")</code>) recording which ensemble sampling algorithm
was used.
</p>


<h3>References</h3>


<ul>
<li>
<p> ter Braak, C. J. F. and Vrugt, J. A. (2008) Differential Evolution Markov
Chain with snooker updater and fewer chains. Statistics and Computing, 18(4),
435–446, <a href="https://doi.org/10.1007/s11222-008-9104-9">doi:10.1007/s11222-008-9104-9</a>
</p>
</li>
<li>
<p> Goodman, J. and Weare, J. (2010) Ensemble samplers with affine invariance.
Communications in Applied Mathematics and Computational Science, 5(1), 65–80,
<a href="https://doi.org/10.2140/camcos.2010.5.65">doi:10.2140/camcos.2010.5.65</a>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## a log-pdf to sample from
p.log &lt;- function(x) {
    B &lt;- 0.03                              # controls 'bananacity'
    -x[1]^2/200 - 1/2*(x[2]+B*x[1]^2-100*B)^2
}

## set options and starting point
n_walkers &lt;- 10
unif_inits &lt;- data.frame(
  "a" = runif(n_walkers, 0, 1),
  "b" = runif(n_walkers, 0, 1)
)


## use stretch move
res1 &lt;- MCMCEnsemble(p.log, inits = unif_inits,
                     max.iter = 300, n.walkers = n_walkers,
                     method = "stretch")

attr(res1, "ensemble.sampler")

str(res1)


## use stretch move, return samples as 'coda' object
res2 &lt;- MCMCEnsemble(p.log, inits = unif_inits,
                     max.iter = 300, n.walkers = n_walkers,
                     method = "stretch", coda = TRUE)

attr(res2, "ensemble.sampler")

summary(res2$samples)
plot(res2$samples)


## use different evolution move, return samples as 'coda' object
res3 &lt;- MCMCEnsemble(p.log, inits = unif_inits,
                     max.iter = 300, n.walkers = n_walkers,
                     method = "differential.evolution", coda = TRUE)

attr(res3, "ensemble.sampler")

summary(res3$samples)
plot(res3$samples)

</code></pre>


</div>