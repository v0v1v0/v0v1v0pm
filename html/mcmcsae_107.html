<div class="container">

<table style="width: 100%;"><tr>
<td>SBC_test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation based calibration</h2>

<h3>Description</h3>

<p>Simulation based calibration
</p>


<h3>Usage</h3>

<pre><code class="language-R">SBC_test(
  ...,
  pars,
  n.draws = 25L,
  n.sim = 20L * n.draws,
  burnin = 25L,
  thin = 2L,
  show.progress = TRUE,
  verbose = TRUE,
  n.cores = 1L,
  cl = NULL,
  seed = NULL,
  export = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>passed to <code>create_sampler</code> (can be all parameters except <code>prior.only</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>named list with univariate functions of the parameters to use in test. This list
is passed to argument <code>pred</code> of <code>MCMCsim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.draws</code></td>
<td>
<p>number of posterior draws to retain in posterior simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.sim</code></td>
<td>
<p>number of simulation iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>burnin to use in posterior simulations, passed to <code>MCMCsim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>thinning to use in posterior simulations, passed to <code>MCMCsim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.progress</code></td>
<td>
<p>whether a progress bar should be shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>set to <code>FALSE</code> to suppress messages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>the number of cpu cores to use. Default is one, i.e. no parallel computation.
If an existing cluster <code>cl</code> is provided, <code>n.cores</code> will be set to the number
of workers in that cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>an existing cluster can be passed for parallel computation. If <code>NULL</code> and
<code>n.cores &gt; 1</code>, a new cluster is created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>a random seed (integer). For parallel computation it is used to independently
seed RNG streams for all workers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>export</code></td>
<td>
<p>a character vector with names of objects to export to the workers. This may
be needed for parallel execution if expressions in the model formulae depend on global variables.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A matrix with ranks.
</p>


<h3>References</h3>

<p>M. Modrak, A.H. Moon, S. Kim, P. Buerkner, N. Huurre, K. Faltejskova,
A. Gelman and A. Vehtari (2023).
Simulation-based calibration checking for Bayesian computation:
The choice of test quantities shapes sensitivity.
Bayesian Analysis, 1(1), 1-28.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# this example may take a long time
n &lt;- 10L
dat &lt;- data.frame(x=runif(n))
ranks &lt;- SBC_test(~ reg(~ 1 + x, prior=pr_normal(mean=c(0.25, 1), precision=1), name="beta"),
  sigma.mod=pr_invchisq(df=1, scale=list(df=1, scale=1)), data=dat,
  pars=list(mu="beta[1]", beta_x="beta[2]", sigma="sigma_"),
  n.draws=9L, n.sim=10L*20L, thin=2L, burnin=20L
)
ranks

## End(Not run)

</code></pre>


</div>