<div class="container">

<table style="width: 100%;"><tr>
<td>create_TMVN_sampler</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set up a sampler object for sampling from a possibly truncated and degenerate multivariate normal distribution</h2>

<h3>Description</h3>

<p>This function sets up an object for multivariate normal sampling based on a specified precision matrix.
Linear equality and inequality restrictions are supported.
For sampling under inequality restrictions four algorithms are available. The default in that case is
an exact Hamiltonian Monte Carlo algorithm (Pakman and Paninski, 2014). A related algorithm is the zig-zag
Hamiltonian Monte Carlo method (Nishimura et al., 2021) in which momentum is sampled from a Laplace instead
of normal distribution. Alternatively, a Gibbs sampling algorithm can be used (Rodriguez-Yam et al., 2004).
The fourth option is a data augmentation method that samples from a smooth approximation to the truncated
multivariate normal distribution (Souris et al., 2018).
</p>


<h3>Usage</h3>

<pre><code class="language-R">create_TMVN_sampler(
  Q,
  mu = NULL,
  Xy = NULL,
  update.Q = FALSE,
  update.mu = update.Q,
  name = "x",
  coef.names = NULL,
  R = NULL,
  r = NULL,
  S = NULL,
  s = NULL,
  lower = NULL,
  upper = NULL,
  check.constraints = FALSE,
  method = NULL,
  reduce = NULL,
  chol.control = chol_control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>precision matrix of the (unconstrained) multivariate normal distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>mean of the (unconstrained) multivariate normal distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xy</code></td>
<td>
<p>alternative to specifying mu; in this case <code>mu</code> is computed as <code class="reqn">Q^{-1}\code{Xy}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update.Q</code></td>
<td>
<p>whether <code>Q</code> is updated for each draw.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update.mu</code></td>
<td>
<p>whether <code>mu</code> is updated for each draw. By default equal to <code>update.Q</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>name of the TMVN vector parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.names</code></td>
<td>
<p>optional labels for the components of the vector parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>equality restriction matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>rhs vector for equality constraints <code class="reqn">R'x = r</code>, where <code class="reqn">R'</code> denotes the transpose of R.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>inequality restriction matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>rhs vector for inequality constraints <code class="reqn">S'x &gt;= s</code>, where <code class="reqn">S'</code> denotes the transpose of S.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>alternative to <code>s</code> for two-sided inequality restrictions <code class="reqn">\code{lower} &lt;= S'x &lt;= \code{upper}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>alternative to <code>s</code> for two-sided inequality restrictions <code class="reqn">\code{lower} &lt;= S'x &lt;= \code{upper}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.constraints</code></td>
<td>
<p>if <code>TRUE</code> check whether the starting values satisfy all constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>sampling method. The options are "direct" for direct sampling from the
unconstrained or equality constrained multivariate normal (MVN). For inequality constrained
MVN sampling three methods are supported: "HMC" for (exact) Hamiltonian Monte Carlo,
"HMCZigZag" for (exact) Hamiltonian Monte Carlo with Laplace momentum, "Gibbs" for a
component-wise Gibbs sampling approach, and "softTMVN" for a data augmentation method that samples
from a smooth approximation to the truncated MVN. Alternatively, the method setting
functions <code>m_direct</code>, <code>m_HMC</code>, <code>m_HMC_ZigZag</code>, <code>m_Gibbs</code> or
<code>m_softTMVN</code> can be used to select the method and possibly set some of its
options to non-default values, see <code>TMVN-methods</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduce</code></td>
<td>
<p>whether to a priori restrict the simulation to the subspace defined by the
equality constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chol.control</code></td>
<td>
<p>options for Cholesky decomposition, see <code>chol_control</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The componentwise Gibbs sampler uses univariate truncated normal samplers as described
in Botev and L'Ecuyer (2016). These samplers are implemented in R package <span class="pkg">TruncatedNormal</span>,
but here translated to C++ for an additional speed-up.
</p>


<h3>Value</h3>

<p>An environment for sampling from a possibly degenerate and truncated multivariate normal
distribution.
</p>


<h3>Author(s)</h3>

<p>Harm Jan Boonstra, with help from Grzegorz Baltissen
</p>


<h3>References</h3>

<p>Z.I. Botev and P. L'Ecuyer (2016).
Simulation from the Normal Distribution Truncated to an Interval in the Tail.
in VALUETOOLS.
</p>
<p>Y. Cong, B. Chen and M. Zhou (2017).
Fast simulation of hyperplane-truncated multivariate normal distributions.
Bayesian Analysis 12(4), 1017-1037.
</p>
<p>Y. Li and S.K. Ghosh (2015). Efficient sampling methods for truncated multivariate normal
and student-t distributions subject to linear inequality constraints.
Journal of Statistical Theory and Practice 9(4), 712-732.
</p>
<p>A. Nishimura, Z. Zhang and M.A. Suchard (2021). Hamiltonian zigzag sampler got more momentum
than its Markovian counterpart: Equivalence of two zigzags under a momentum refreshment limit.
arXiv:2104.07694.
</p>
<p>A. Pakman and L. Paninski (2014).
Exact Hamiltonian Monte Carlo for truncated multivariate gaussians.
Journal of Computational and Graphical Statistics 23(2), 518-542.
</p>
<p>G. Rodriguez-Yam, R.A. Davis and L.L. Scharf (2004).
Efficient Gibbs sampling of truncated multivariate normal with application to constrained linear regression.
Unpublished manuscript.
</p>
<p>H. Rue and L. Held (2005).
Gaussian Markov Random Fields.
Chapman &amp; Hall/CRC.
</p>
<p>A. Souris, A. Bhattacharya and P. Debdeep (2018).
The Soft Multivariate Truncated Normal Distribution.
arXiv:1807.09155.
</p>
<p>K.A. Valeriano, C.E. Galarza and L.A. Matos (2023).
Moments and random number generation for the truncated elliptical family of distributions.
Statistics and Computing 33(1), 1-20.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
S &lt;- cbind(diag(2), c(-1, 1), c(1.1, -1))  # inequality matrix
# S'x &gt;= 0 represents the wedge x1 &lt;= x2 &lt;= 1.1 x1
# example taken from Pakman and Paninski (2014)
# 1. exact Hamiltonian Monte Carlo (Pakman and Paninski, 2014)
sampler &lt;- create_TMVN_sampler(Q=diag(2), mu=c(4, 4), S=S, method="HMC")
sim &lt;- MCMCsim(sampler, n.iter=600, verbose=FALSE)
summary(sim)
plot(as.matrix(sim$x), pch=".")
# 2. exact Hamiltonian Monte Carlo with Laplace momentum (Nishimura et al., 2021)
sampler &lt;- create_TMVN_sampler(Q=diag(2), mu=c(4, 4), S=S, method="HMCZigZag")
sim &lt;- MCMCsim(sampler, n.iter=600, verbose=FALSE)
summary(sim)
plot(as.matrix(sim$x), pch=".")
# 3. Gibbs sampling approach (Rodriguez-Yam et al., 2004)
sampler &lt;- create_TMVN_sampler(Q=diag(2), mu=c(4, 4), S=S, method="Gibbs")
sim &lt;- MCMCsim(sampler, burnin=500, n.iter=2000, verbose=FALSE)
summary(sim)
plot(as.matrix(sim$x), pch=".")
# 4. soft TMVN approximation (Souris et al., 2018)
sampler &lt;- create_TMVN_sampler(Q=diag(2), mu=c(4, 4), S=S, method="softTMVN")
sim &lt;- MCMCsim(sampler, n.iter=600, verbose=FALSE)
summary(sim)
plot(as.matrix(sim$x), pch=".")


</code></pre>


</div>