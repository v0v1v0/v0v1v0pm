<div class="container">

<table style="width: 100%;"><tr>
<td>correlation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Correlation factor structures in generic model components</h2>

<h3>Description</h3>

<p>Element 'factor' of a model component created using function
<code>gen</code> is a formula composed of several possible terms described
below. It is used to derive a (typically sparse) precision matrix for a set of
coefficients, and possibly a matrix representing a set of linear constraints
to be imposed on the coefficient vector.
</p>

<dl>
<dt>iid(f)</dt>
<dd>
<p>Independent effects corresponding to the levels of factor <code>f</code>.</p>
</dd>
<dt>RW1(f, circular=FALSE, w=NULL)</dt>
<dd>
<p>First-order random walk over the levels of factor <code>f</code>.
The random walk can be made circular and different (fixed) weights can be attached to the innovations.
If specified, <code>w</code> must be a positive numeric vector of length one less than the number of
factor levels. For example, if the levels correspond to different times, it would often be
reasonable to choose <code>w</code> proportional to the reciprocal time differences. For equidistant
times there is generally no need to specify <code>w</code>.</p>
</dd>
<dt>RW2(f)</dt>
<dd>
<p>Second-order random walk.</p>
</dd>
<dt>AR1(f, phi, w=NULL)</dt>
<dd>
<p>First-order autoregressive correlation structure among
the levels of <code>f</code>. Required argument is the (fixed) autoregressive parameter <code>phi</code>.
For irregularly spaced AR(1) processes weights can be specified, in the same way as for
<code>RW1</code>.</p>
</dd>
<dt>season(f, period)</dt>
<dd>
<p>Dummy seasonal with period <code>period</code>.</p>
</dd>
<dt>spatial(f, poly.df, snap, queen, derive.constraints=FALSE)</dt>
<dd>
<p>CAR spatial correlation.
Argument <code>poly.df</code> can either be an object of (S4) class <code>SpatialPolygonsDataFrame</code>
or an object of (S3) class <code>sf</code>. The latter can be obtained, e.g., from reading in a
shape file using function <code>st_read</code>. Arguments <code>snap</code> and <code>queen</code>
are passed to <code>poly2nb</code>.
If <code>derive.constraints=TRUE</code> the constraint matrix for an IGMRF model component
is formed by computing the singular vectors of the precision matrix.</p>
</dd>
<dt>spline(f, knots, degree)</dt>
<dd>
<p>P-splines, i.e. penalized B-splines structure over
the domain of a quantitative variable f. Arguments knots and degree are passed to
<code>splineDesign</code>. If <code>knots</code> is a single value it is interpreted as
the number of knots, otherwise as a vector of knot positions. By default 40 equally spaced
knots are used, and a degree of 3.</p>
</dd>
<dt>custom(f, D=NULL, Q=NULL, R=NULL, derive.constraints=NULL)</dt>
<dd>
<p>Either a custom precision or incidence
matrix associated with factor f can be passed to argument <code>Q</code> or <code>D</code>. Optionally a
constraint matrix can be supplied as <code>R</code>, or constraints can be derived from the null space
of the precision matrix by setting <code>derive.constraints=TRUE</code>.</p>
</dd>
</dl>
<h3>Usage</h3>

<pre><code class="language-R">iid(name)

RW1(name, circular = FALSE, w = NULL)

RW2(name)

AR1(name, phi, w = NULL)

season(name, period)

spatial(name, poly.df, snap = sqrt(.Machine$double.eps), queen = TRUE)

spline(name, knots, degree)

custom(name, D = NULL, Q = NULL, R = NULL, derive.constraints = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>name of a variable, unquoted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>circular</code></td>
<td>
<p>whether the random walk is circular.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>a vector of weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>value of an autoregressive parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p>a positive integer specifying the seasonal period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poly.df</code></td>
<td>
<p>a spatial data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snap</code></td>
<td>
<p>passed to <code>poly2nb</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>queen</code></td>
<td>
<p>passed to <code>poly2nb</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>passed to <code>splineDesign</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>passed to <code>splineDesign</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>custom incidence matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>custom precision matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>custom restriction matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>derive.constraints</code></td>
<td>
<p>whether to derive the constraint matrix for an
IGMRF model component numerically from the precision matrix.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>B. Allevius (2018).
On the precision matrix of an irregularly sampled AR(1) process.
arXiv:1801.03791.
</p>
<p>H. Rue and L. Held (2005).
Gaussian Markov Random Fields.
Chapman &amp; Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# example of CAR spatial random effects
if (requireNamespace("sf")) {
  # 1. load a shape file of counties in North Carolina
  nc &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"))
  # 2. generate some data according to a model with a few regression
  # effects, as well as spatial random effects
  gd &lt;- generate_data(
    ~ reg(~ AREA + BIR74, prior=pr_normal(precision=1), name="beta") +
      gen(factor = ~ spatial(NAME, poly.df=nc), name="vs"),
    sigma.mod = pr_invchisq(df=10, scale=1),
    data = nc
  )
  # add the generated target variable and the spatial random effects to the
  # spatial dataframe object
  nc$y &lt;- gd$y
  nc$vs_true &lt;- gd$pars$vs
  # 3. fit a model to the generated data, and see to what extent the
  #    parameters used to generate the data, gd$pars, are reproduced
  sampler &lt;- create_sampler(
    y ~ reg(~ AREA + BIR74, prior=pr_normal(precision=1), name="beta") +
    gen(factor = ~ spatial(NAME, poly.df=nc), name="vs"),
    block=TRUE, data=nc
  )
  sim &lt;- MCMCsim(sampler, store.all=TRUE, n.iter=600, n.chain=2, verbose=FALSE)
  (summ &lt;- summary(sim))
  nc$vs &lt;- summ$vs[, "Mean"]
  plot(nc[c("vs_true", "vs")])
  plot(gd$pars$vs, summ$vs[, "Mean"]); abline(0, 1, col="red")
}


</code></pre>


</div>