<div class="container">

<table style="width: 100%;"><tr>
<td>MCMCsim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run a Markov Chain Monte Carlo simulation</h2>

<h3>Description</h3>

<p>Given a sampler object this function runs a MCMC simulation and stores the
posterior draws. A sampler object for a wide class of multilevel models
can be created using <code>create_sampler</code>, but users can also define
their own sampler functions, see below.
<code>MCMCsim</code> allows to choose the parameters for which simulation results
must be stored. It is possible to define derived quantities that will also
be stored. To save memory, it is also possible to only store Monte Carlo
means/standard errors for some large vector parameters, say. Another
way to use less memory is to save the simulation results of large vector
parameters to file.
For parameters specified in <code>plot.trace</code> trace plots or pair plots of
multiple parameters are displayed during the simulation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMCsim(
  sampler,
  from.prior = FALSE,
  n.iter = 1000L,
  n.chain = 3L,
  thin = 1L,
  burnin = if (from.prior) 0L else 250L,
  start = NULL,
  store,
  store.all = FALSE,
  pred = NULL,
  store.mean,
  store.sds = FALSE,
  to.file = NULL,
  filename = "MCdraws_",
  write.single.prec = FALSE,
  verbose = TRUE,
  n.progress = n.iter%/%10L,
  trace.convergence = NULL,
  stop.on.convergence = FALSE,
  convergence.bound = 1.05,
  plot.trace = NULL,
  add.to.plot = TRUE,
  plot.type = "l",
  n.cores = 1L,
  cl = NULL,
  seed = NULL,
  export = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sampler</code></td>
<td>
<p>sampler object created by <code>create_sampler</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from.prior</code></td>
<td>
<p>whether to sample from the prior. By default <code>from.prior=FALSE</code>
and samples are taken from the posterior.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>number of draws after burnin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.chain</code></td>
<td>
<p>number of independent chains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>only every <code>thin</code>'th draw is kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>number of draws to discard at the beginning of each chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>an optional function to generate starting values or a list containing for each chain
a named list of starting values. It may be used to provide starting values for some or all parameters.
The sampler object's own start function, if it exists, is called to generate any starting values not
provided by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store</code></td>
<td>
<p>vector of names of parameters to store MCMC draws for. By default, simulations are
stored for all parameters returned by <code>sampler$store_default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.all</code></td>
<td>
<p>if <code>TRUE</code> simulation vectors of all parameters returned by the sampling
function of <code>sampler</code> will be stored. The default is <code>FALSE</code>, and in that case
only simulations for the parameters named in <code>store</code> are stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>list of character strings defining derived quantities to be computed (and stored) for each draw.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.mean</code></td>
<td>
<p>vector of names of parameters for which only the mean (per chain) is to be stored.
This may be useful for large vector parameters (e.g. regression residuals) for which storing complete
MCMC output would use too much memory. The function <code>sampler$store_mean_default</code>
exists it provides the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.sds</code></td>
<td>
<p>if <code>TRUE</code> store for all parameters in <code>store.mean</code>, besides the mean, also
the standard deviation. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to.file</code></td>
<td>
<p>vector of names of parameters to write to file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>name of file to write parameter draws to.
Each named parameter is written to a separate file, named <code>filename_parametername</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write.single.prec</code></td>
<td>
<p>Whether to write to file in single precision. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>FALSE</code> no output is sent to the screen during the simulation. <code>TRUE</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.progress</code></td>
<td>
<p>update diagnostics and plots after so many iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.convergence</code></td>
<td>
<p>vector of names of parameters for which Gelman-Rubin R-hat diagnostics are printed to the screen every <code>n.progress</code> iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop.on.convergence</code></td>
<td>
<p>if <code>TRUE</code> stop the simulation if the R-hat diagnostics for all parameters in <code>trace.convergence</code> are less than <code>convergence.bound</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence.bound</code></td>
<td>
<p>threshold used with <code>stop.on.convergence</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.trace</code></td>
<td>
<p>character vector of parameter names for which to plot draws
during the simulation. For one or two parameters trace plots will be shown,
and if more parameters are specified the results will be displayed in a pairs
plot. For vector parameters a specific component can be selected using brackets,
e.g. <code>"beta[2]"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.to.plot</code></td>
<td>
<p>if <code>TRUE</code> the plot is updated every <code>n.progress</code> iterations,
otherwise a new plot (with new scales) is created after every <code>n.progress</code> iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.type</code></td>
<td>
<p>default is "l" (lines).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>the number of cpu cores to use. Default is 1, i.e. no parallel computation.
If an existing cluster <code>cl</code> is provided, <code>n.cores</code> will be set to the number
of workers in that cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>an existing cluster can be passed for parallel computation. If <code>NULL</code> and
<code>n.cores &gt; 1</code>, a new cluster is created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>a random seed (integer). For parallel computation it is used to independently
seed RNG streams for all workers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>export</code></td>
<td>
<p>a character vector with names of objects to export to the workers. This may
be needed for parallel execution if expressions in <code>pred</code> depend on global variables.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A sampler object is an environment containing data and functions to use
for sampling. The following elements of the sampler object are used by
<code>MCMCsim</code>:
</p>

<dl>
<dt>start</dt>
<dd>
<p>function to generate starting values.</p>
</dd>
<dt>draw</dt>
<dd>
<p>function to draw samples, typically from a full conditional
posterior distribution.</p>
</dd>
<dt>rprior</dt>
<dd>
<p>function to draw from a prior distribution.</p>
</dd>
<dt>coef.names</dt>
<dd>
<p>list of vectors of parameter coefficient names, for
vector parameters.</p>
</dd>
<dt>MHpars</dt>
<dd>
<p>vector of names of parameters that are sampled using a
Metropolis-Hastings (MH) sampler; acceptance rates are kept for these
parameters.</p>
</dd>
<dt>adapt</dt>
<dd>
<p>function of acceptance rates of <code>MHpars</code> to adapt
MH-kernel, called every 100 iterations during the burn-in period.</p>
</dd>
</dl>
<h3>Value</h3>

<p>An object of class <code>mcdraws</code> containing posterior draws as well as some meta information.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># 1. create a sampler function
sampler &lt;- new.env()
sampler$draw &lt;- function(p) list(x=rnorm(1L), y=runif(1L))
# 2. do the simulation
sim &lt;- MCMCsim(sampler, store=c("x", "y"))
str(sim)
summary(sim)

# example that requires start values or a start function
sampler$draw &lt;- function(p) list(x=rnorm(1L), y=p$x * runif(1L))
sampler$start &lt;- function(p) list(x=rnorm(1L), y=runif(1L))
sim &lt;- MCMCsim(sampler, store=c("x", "y"))
summary(sim)
plot(sim, c("x", "y"))

# example using create_sampler; first generate some data
n &lt;- 100
dat &lt;- data.frame(x=runif(n), f=as.factor(sample(1:4, n, replace=TRUE)))
gd &lt;- generate_data(~ reg(~ x + f, prior=pr_normal(precision=1), name="beta"), data=dat)
dat$y &lt;- gd$y
sampler &lt;- create_sampler(y ~ x + f, data=dat)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=400, n.chain=2)
(summary(sim))
gd$pars

</code></pre>


</div>