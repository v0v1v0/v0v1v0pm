<div class="container">

<table style="width: 100%;"><tr>
<td>mec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a model component object for a regression (fixed effects) component
in the linear predictor with measurement errors in quantitative covariates</h2>

<h3>Description</h3>

<p>This function is intended to be used on the right hand side of the
<code>formula</code> argument to <code>create_sampler</code> or
<code>generate_data</code>. It creates an additive regression term in the
model's linear predictor. Covariates are assumed to be measured subject
to normally distributed errors with zero mean and variance specified using
the <code>formula</code> or <code>V</code> arguments. Note that this means that <code>formula</code>
should only contain quantitative variables, and no intercept.
By default, the prior for the regression
coefficients is improper uniform. A proper normal prior can be set up
using function <code>pr_normal</code>, and passed to argument <code>prior</code>.
It should be noted that <code>pr_normal</code> expects a precision matrix
as input for its second argument, and that the prior variance (matrix) is
taken to be the inverse of this precision matrix, where in case the
model's family is <code>"gaussian"</code> this matrix is additionally
multiplied by the residual scalar variance parameter <code>sigma_^2</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mec(
  formula = ~1,
  sparse = NULL,
  X = NULL,
  V = NULL,
  prior = NULL,
  Q0 = NULL,
  b0 = NULL,
  R = NULL,
  r = NULL,
  S = NULL,
  s = NULL,
  lower = NULL,
  upper = NULL,
  name = "",
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula specifying the predictors subject to measurement error
and possibly their variances as well. In the latter case the formula syntax
<code>~ (x1 | V.x1) + (x2 | V.x2) + ...</code> should be used where <code>x1, x2, ...</code>
are the names of (quantitative) predictors and <code>V.x1, V.x2, ...</code> are the names
of the variables holding the corresponding measurement error variances.
If only the predictors are specified
the formula has the usual form <code>~ x1 + x2 + ...</code>. In that case variances
should be specified using argument <code>V</code>.
All variable names are looked up in the data frame
passed as <code>data</code> argument to <code>create_sampler</code> or
<code>generate_data</code>, or in <code>environment(formula)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>whether the model matrix associated with <code>formula</code> should
be sparse. The default is to base this on a simple heuristic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a (possibly sparse) design matrix can be specified directly, as an
alternative to the creation of one based on <code>formula</code>. If <code>X</code> is
specified <code>formula</code> is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>measurement error variance; can contain zeros</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>prior specification for the regression coefficients. Currently only
normal priors are supported, specified using function <code>pr_normal</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q0</code></td>
<td>
<p>prior precision matrix for the regression effects. The default is a
zero matrix corresponding to a noninformative improper prior.
It can be specified as a scalar value, as a numeric vector of appropriate
length, or as a matrix object. DEPRECATED, please use argument <code>prior</code>
instead, i.e. <code>prior = pr_normal(mean = b0.value, precision = Q0.value)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>prior mean for the regression effect. Defaults to a zero vector.
It can be specified as a scalar value or as a numeric vector of
appropriate length. DEPRECATED, please use argument <code>prior</code>
instead, i.e. <code>prior = pr_normal(mean = b0.value, precision = Q0.value)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>optional constraint matrix for equality restrictions R'x = r where
<code>x</code> is the vector of regression effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>right hand side for the equality constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>optional constraint matrix for inequality constraints S'x &gt;= s where
x is the vector of regression effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>right hand side for the inequality constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>as an alternative to <code>s</code>, <code>lower</code> and <code>upper</code> may be specified
for two-sided constraints lower &lt;= S'x &lt;= upper.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>as an alternative to <code>s</code>, <code>lower</code> and <code>upper</code> may be specified
for two-sided constraints lower &lt;= S'x &lt;= upper.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>the name of the model component. This name is used in the output of the
MCMC simulation function <code>MCMCsim</code>. By default the name will be 'reg'
with the number of the model term attached.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>if <code>TRUE</code> a breakpoint is set at the beginning of the posterior
draw function associated with this model component. Mainly intended for developers.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object with precomputed quantities and functions for sampling from
prior or conditional posterior distributions for this model component. Intended
for internal use by other package functions.
</p>


<h3>References</h3>

<p>L.M. Ybarra and S.L. Lohr (2008).
Small area estimation when auxiliary information is measured with error.
Biometrika 95(4), 919-931.
</p>
<p>S. Arima, G.S. Datta and B. Liseo (2015).
Bayesian estimators for small area models when auxiliary information is measured with error.
Scandinavian Journal of Statistics 42(2), 518-529.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# example of Ybarra and Lohr (2008)
m &lt;- 50
X &lt;- rnorm(m, mean=5, sd=3)  # true covariate values
v &lt;- rnorm(m, sd=2)
theta &lt;- 1 + 3*X + v  # true values
psi &lt;- rgamma(m, shape=4.5, scale=2)
e &lt;- rnorm(m, sd=sqrt(psi))  # sampling error
y &lt;- theta + e  # direct estimates
C &lt;- c(rep(3, 10), rep(0, 40))  # measurement error for first 10 values
W &lt;- X + rnorm(m, sd=sqrt(C))  # covariate subject to measurement error

# fit Ybarra-Lohr model
sampler &lt;- create_sampler(
  y ~ 1 + mec(~ 0 + W, V=C) + gen(factor=~local_),
  Q0=1/psi, sigma.fixed=TRUE, linpred="fitted"
)
sim &lt;- MCMCsim(sampler, n.iter=800, n.chain=2, store.all=TRUE, verbose=FALSE)
(summ &lt;- summary(sim))
plot(X, W, xlab="true X", ylab="inferred X")
points(X, summ$mec2_X[, "Mean"], col="green")
abline(0, 1, col="red")
legend("topleft", legend=c("prior mean", "posterior mean"), col=c("black", "green"), pch=c(1,1))


</code></pre>


</div>