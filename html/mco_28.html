<div class="container">

<table style="width: 100%;"><tr>
<td>nsga2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>NSGA II MOEA</h2>

<h3>Description</h3>

<p>The NSGA-II algorithm minimizes a multidimensional function to approximate its Pareto front and Pareto set.
It does this by successive sampling of the search space, each such sample is called a <em>population</em>. 
The number of samples taken is governed by the <code>generations</code> parameter, the size of the sample by the <code>popsize</code> parameter.
Each population is obtained by creating so called offspring search points from the best individuals in the previous population. 
The best individuals are calculated by non-dominated sorting breaking ties using the crowding distance.
The total number of function evaluations used is 
</p>
<p style="text-align: center;"><code class="reqn">n_eval = popsize * (generations + 1)</code>
</p>

<p>when <code>generations</code> is a single number and
</p>
<p style="text-align: center;"><code class="reqn">n_eval = popsize * (max(generations) + 1)</code>
</p>

<p>when <code>generations</code> is a vector of numbers. 
Note the additional generation of evaluations in the above equation. 
These stem from the initial population which must be evaluated before the algorithm can start evolving new individuals.
</p>
<p>While the algorithm supports unbounded minimization, it will throw a warning and best results are obtained when a sensible upper and lower bound are given. 
No attempt is made to find such a sensible region of interest, instead if any element of the upper or lower bound is infinite, it is replace with a very large number (currently +/-4.49423283715579e+307).
</p>


<h3>Usage</h3>

<pre><code class="language-R">  nsga2(fn, idim, odim, ...,
        constraints = NULL, cdim = 0,
        lower.bounds = rep(-Inf, idim), upper.bounds = rep(Inf, idim),
        popsize = 100, generations = 100,
        cprob = 0.7, cdist = 5,
        mprob = 0.2, mdist = 10,
        vectorized=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>Function to be minimized</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idim</code></td>
<td>
<p>Input dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>odim</code></td>
<td>
<p>Output dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed through to 'fn'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>Constraint function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cdim</code></td>
<td>
<p>Constraint dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.bounds</code></td>
<td>
<p>Lower bound of parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.bounds</code></td>
<td>
<p>Upper bound of parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>popsize</code></td>
<td>
<p>Size of population</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>generations</code></td>
<td>
<p>Number of generations to breed. If a vector, then
the result will contain the population at each given generation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cprob</code></td>
<td>
<p>Crossover probability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cdist</code></td>
<td>
<p>Crossover distribution index</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mprob</code></td>
<td>
<p>Mutation probability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mdist</code></td>
<td>
<p>Mutation distribution index</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vectorized</code></td>
<td>
<p>If <code>TRUE</code>, the objective and constraint
functions must be vectorized, i.e. accept a matrix instead of a
vector and return a matrix instead of a vector. The matrix is
structured such that one individual parameter combination is
contained in each row (the matrix has shape <code>popsize * idim</code>)
and each objective is stored in a row of the returned matrix (the
returned matrix must have shape <code>odim * popsize</code>).
</p>
<p>A vectorized of a function <code>fn</code> should behave like
<code>apply(x, 1, f</code> for a population stored in the matrix <code>x</code>. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If generation is an integer, a list describing the final population
with components <code>par</code>, <code>value</code> and <code>pareto.optimal</code>. If
generations is a vector, a list is returned. The i-th element of the
list contains the population after generations[i] generations, this is
not necessarily the set of new individuals that were evaluated in this 
generation. Some of the new individuals might have been eliminated in
the selection phase.  
</p>


<h3>Author(s)</h3>

<p>Heike Trautmann <a href="mailto:trautmann@statistik.uni-dortmund.de">trautmann@statistik.uni-dortmund.de</a>,
Detlef Steuer <a href="mailto:steuer@hsu-hamburg.de">steuer@hsu-hamburg.de</a> and
Olaf Mersmann <a href="mailto:olafm@statistik.uni-dortmund.de">olafm@statistik.uni-dortmund.de</a>
</p>


<h3>References</h3>

<p>Deb, K., Pratap, A., and Agarwal, S..
A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II.
<em>IEEE Transactions on Evolutionary Computation</em>, <b>6 (8)</b>
(2002), 182-197.
</p>


<h3>See Also</h3>

<p><code>zdt1</code> for more examples and a list of
multiobjective test functions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Binh 1 problem:
binh1 &lt;- function(x) {
  y &lt;- numeric(2)
  y[1] &lt;- crossprod(x, x)
  y[2] &lt;- crossprod(x - 5, x - 5)
  return (y)
}
r1 &lt;- nsga2(binh1, 2, 2,
           generations=150, popsize=100,
           cprob=0.7, cdist=20,
           mprob=0.2, mdist=20,
           lower.bounds=rep(-5, 2),
           upper.bounds=rep(10, 2))
plot(r1)

## VNT problem:
vnt &lt;- function(x) {  
  y &lt;- numeric(3)
  xn &lt;- crossprod(x, x)
  y[1] &lt;- xn/2 + sin(xn);
  y[2] &lt;- (crossprod(c(3, -2), x) + 4)^2/8 + (crossprod(c(1, -1), x) + 1)^2/27 + 15
  y[3] &lt;- 1/(xn + 1) - 1.1*exp(-xn)
  return (y)
}

r2 &lt;- nsga2(vnt, 2, 3,
           generations=150, popsize=100,
           lower.bounds=rep(-3, 2),
           upper.bounds=rep(3, 2))
plot(r2)

## Example using constraints:
## minimize     f(x) = (x[1]^2, x[2]^2)
## subject to   g(x) = (sum(x) - 5) &gt;= 0
f &lt;- function(x) { x^2 }
g &lt;- function(x) { sum(x) - 5 }
res &lt;- nsga2(f, 2, 2, generations=500,
             lower.bounds=c(0, 0), upper.bounds=c(10, 10),
             constraints=g, cdim=1)
opar &lt;-par(mfrow=c(1,2))
plot(res, xlab="y1", ylab="y2", main="Objective space")
plot(res$par, xlab="x1", ylab="x2", main="Parameter space")
par(opar)
</code></pre>


</div>