<div class="container">

<table style="width: 100%;"><tr>
<td>mCompanion</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Create objects from class MultiCompanion </h2>

<h3>Description</h3>

<p>Create, generate, or simulate objects from class <code>"MultiCompanion"</code> by
specifying the matrix in several ways.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mCompanion(x, detect = "nothing", misc = list(), ...)

## S4 method for signature 'MultiCompanion'
initialize(.Object, xtop, mo, n, mo.col, ido, x, dimnames,
           detect = "nothing", misc = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>the matrix or, for <code>mCompanion</code> only, the top of the
matrix or a character string, see section ‘Details’.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>misc</code></td>
<td>

<p>information to be stored in the object's pad.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>other arguments to be passed down to generator functions, see
section ‘Details’.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xtop</code></td>
<td>
<p> the top of the matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mo</code></td>
<td>
<p> the multi-companion order of the matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> the dimension. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mo.col</code></td>
<td>

<p>the top order, meaniing that columns mo.col+1,...,n of the top of
the matrix are zeros. <code>mo.col</code> may also be set to "detect", in
which case it is determined by scanning <code>xtop</code> or <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ido</code></td>
<td>
<p> the dimension of the identity sub-matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimnames</code></td>
<td>
<p> is not used currently. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detect</code></td>
<td>

<p>controls whether automatic detection of <code>mo</code> and <code>mo.col</code>
should be attempted. The values tested are "mo", "mo.col", "all",
and "nothing" with obvious meanings.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.Object</code></td>
<td>
<p>this is set implicitly by package "methods". </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Objects from class <code>"MultiCompanion"</code> can be created by calling
<code>mCompanion()</code> or <code>new("MultiCompanion", ...)</code>. In the
latter case the “...” arguments are as for the
<code>initialize</code> method, except <code>.Object</code>. Do not call
<code>initialize</code> directly.
</p>
<p><code>mCompanion</code> can generate multi-companion matrices from spectral
information, full or partial, using the methodology developed by
Boshnakov and Iqelan (2009). If the
specification is not given in full, the missing information is filled
with suitably simulated values. For example, unspecifies eigenvalues
are generated inside the unit circle, <code>sim_mc</code>.
</p>
<p>If argument <code>x</code> is the string "sim" or "gen", then
<code>mCompanion</code> calls <code>sim_mc</code> or
<code>make_mcmatrix</code>, respectively, with the arguments
<code>...</code> and converts the result to class MultiCompanion.  See the
documentation of those functions for further details and examples.
The conversion may be the main reason to use <code>mCompanion</code> in this
way rather than call <code>sim_mc</code> and <code>make_mcmatrix</code> directly.
</p>
<p>Otherwise, if <code>x</code> is numeric it is taken to specify the top of
the matrix unless <code>detect="mo"</code> in which case it is the whole
matrix.  In both cases all arguments are passed down to <code>new</code>, the
only (more or less) change being that <code>x</code> is passed down as
<code>xtop=x</code> and <code>x=x</code>, respectively, see
<code>MultiCompanion</code>.

</p>
<p><code>detect=="gen"</code> signifies that <code>x</code> has the format of the
output from <code>sim_mc</code> or <code>make_mcmatrix</code>, so that <code>mCompanion</code>
may use the additional information in such objects.
</p>
<p>The multi-companion order is determined automatically from the content
of the matrix if <code>detect=="mo"</code>.
</p>


<h3>Value</h3>

<p>a multi-companion matrix, an object of class <code>"MultiCompanion"</code>
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
“Multi-companion matrices.”
<em>Linear Algebra Appl.</em>, <b>354</b>, 53–83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN (2007).
“Singular value decomposition of multi-companion matrices.”
<em>Linear Algebra Appl.</em>, <b>424</b>(2-3), 393–404.
ISSN 0024-3795, <a href="https://doi.org/10.1016/j.laa.2007.02.010">doi:10.1016/j.laa.2007.02.010</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
“Generation of time series models with given spectral properties.”
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349–368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code>sim_mc</code>,
<code>make_mcmatrix</code>,
<code>MultiCompanion</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate a 6x6 mc matrix with 2 non-trivial rows
mCompanion("sim", dim = 4, mo = 2)
# simulate a 6x6 mc matrix with 4 non-trivial rows
mCompanion("sim", dim = 6, mo = 4)
# similar to above but top rows with 2 non-zero columns
mCompanion("sim", dim = 6, mo = 4, mo.col = 2)

## specify the non-trivial top rows (as a matrix):
m1 &lt;- matrix(1:24, nrow = 4)
mCompanion(m1)            # mc matrix with m1 on top

m2 &lt;- rbind(c(1, 2, 0, 0), c(3, 4, 0, 0))
x2a &lt;- mCompanion(m2)     # mc matrix with m2 on top
x2a@mo.col                #  = 4

x2 &lt;- mCompanion(m2, mo.col = "detect")
x2@mo.col                #  = 2,  detects the 0 columns in m2
mCompanion(m2, mo.col = 2)  # same

# create manually an mc matrix
(m3 &lt;- rbind(m1, c(1, rep(0, 5)), c(0, 1, rep(0, 4))))
# turn it into a MultiCompanion object
x3 &lt;- mCompanion(x = m3, detect = "mo")
x3@mo
x3 &lt;- mCompanion(m3)
x3@mo

m4 &lt;- rbind(c(1, 2, rep(0, 4)), c(3, 4, rep(0, 4)))

x4 &lt;- mCompanion(m4, mo = 2)
x4@mo.col    #  = 6,
## special structure not incorporated in x4,
##   eigen and mc_eigen are equiv. in this case
eigen(x4)
mc_eigen(x4)

x4a &lt;- mCompanion(m4, mo = 2, mo.col = 2)
x4a@mo.col    #  = 2,  has Jordan blocks of size &gt; 1
## the eigenvectors do not span the space:
eigen(x4a)
## mc_eigen exploits the Jordan structure, e.g.2x2 Jordan blocks,
## and gives the generalised eigenvectors:
(ev &lt;- mc_eigen(x4a))

x4a %*% ev$vectors

## construct the Jordan matrix of x4a from eigenvalues and eigenvectors
(x4a.j &lt;- Jordan_matrix(ev$values,  ev$len.block))

## check that AX = XJ and A = XJX^-1, up to numerical precision:
x4a %*% ev$vectors  -  ev$vectors %*% x4a.j
x4a  -  ev$vectors %*% x4a.j %*% solve(ev$vectors)
</code></pre>


</div>