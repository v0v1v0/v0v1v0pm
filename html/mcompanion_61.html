<div class="container">

<table style="width: 100%;"><tr>
<td>mc_eigen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The eigen decomposition of a multi-companion matrix</h2>

<h3>Description</h3>

<p>Give the eigenvalues or the entire eigen decomposition of a
multi-companion matrix
</p>


<h3>Usage</h3>

<pre><code class="language-R">mc_eigen(x, ...)
mc_eigenvalues(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a multi-companion matrix, an object of class MultiCompanion.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments, currently not used. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Both functions first check if the decomposition is stored in
<code>x</code> and, if that is the case, return the result without
computations. This is particularly useful when the matrix is created
from its spectral decomposition in the first place. The only
restrictions on the result in this case come from the structure of
multi-companion matrices.
</p>
<p>Otherwise they use <code>eigen</code> to do the main computation. In
addition, if the top of the matrix has structural columns of zeroes,
<code>mc_eigen</code> takes care to call <code>eigen</code> with a sub-matrix
whose last column is not zero, and handles the zero eigenvalues
separately.
</p>
<p>Note that <code>x@mo.col</code> is the last column containing nonzero
elements in the top of the matrix. By calling <code>eigen</code> on the top
left <code>x@mo.col</code> square block, rather than on the entire matrix,
we achieve several things. Firstly, this block may turn out to be
non-singular. In that case, the chains corresponding to zero
eigenvalues, if any, are structural and straightforward. Secondly, if
this block turns out to be singular, we know that by reducing the
dimension we have left out only elements corresponding to zero
eigenvalues. The vectors associated with zero eigenvalues are somewhat
tricky in this case, but manageable.
</p>
<p>The net effect is that the only restriction comes from the use of
<code>eigen</code>, which does not handle Jordan chains of length larger
than one.  In general, this is not a problem, since chains with more
than one vector are not likely to occur numerically. In particular, it
is relatively safe to assume that the space spanned by the non-zero
eigenvalues of the multicompanion matrix has a basis of
eigenvectors. However, when <code>x@mo.col</code> is smaller than the
dimension of the matrix, eigenchains associated with the zero value
can easily occur, due to the structure of the matrix.  That is why we
pay special attention to them.
</p>
<p>In <code>mc_eigen</code> the handling of the zero eigenvalues is based on
<code>mc_chain_extend</code>.  The latter takes care also of zero
eigenvalues whose Jordan blocks are of size larger than one.
</p>


<h3>Value</h3>

<p>For <code>mc_eigenvalues</code>, the eigenvalues as a vector.
</p>
<p>For <code>mc_eigen</code>, the eigenvalues and eigenvectors as a list with
components <code>values</code> and <code>vectors</code>. In addition the list
contains a component <code>len.block</code> with the lengths of the Jordan
chains.
</p>


<h3>Note</h3>

<p><code>mc_eigenvalues</code> currently simply calls <code>eigen</code> if the
eigenvalues are not stored in the object. It is probably mostly useful
when the interest is in the nonzero eigenvalues.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
“Multi-companion matrices.”
<em>Linear Algebra Appl.</em>, <b>354</b>, 53–83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- sim_mc(6,4,mo.col=2)
x
y &lt;- mCompanion(x,detect="gen")
y
z &lt;- as.matrix(y)
xx &lt;- mCompanion(x=z,mo.col=2)
mc_eigen(xx)
</code></pre>


</div>