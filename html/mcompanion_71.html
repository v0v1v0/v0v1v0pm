<div class="container">

<table style="width: 100%;"><tr>
<td>mf_VSform</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Extract properties of multi-filters </h2>

<h3>Description</h3>

<p>Extract properties for scalar and vector of seasons forms of multi-filters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mf_order(x, i = "max", form = "pc", perm)
mf_period(x)
mf_poles(x, blocks = FALSE)
mf_VSform(x, first = 1, form = "U", perm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code> x </code></td>
<td>
<p> the filter, an object of class  <code>"MultiFilter"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> i </code></td>
<td>
<p> index, integer vector or a string. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> first </code></td>
<td>
<p>the first season of the year.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> form </code></td>
<td>

<p>the form of the filter to which the result refers,
one of "pc", "I", "U", or "L", see Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> perm </code></td>
<td>
<p>permutation of the seasons within the year.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> blocks </code></td>
<td>
<p> request lengths of Jordan chains.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>With the default <code>i=="max"</code> the function <code>mf_order</code> returns
a single number, the order of the filter in the representation
requested by <code>form</code>.
The orders of the components may be obtained with the setting
<code>i=="all"</code> which gives a vector whose j-th element is the order
of the j-th component of the filter. A subset of these may be obtained
with numeric <code>i</code> which is treated as standard index vector.
Values for <code>i</code> other than the default are meaningful mainly for
<code>form="pc"</code>.
</p>
<p><code>mf_VSform</code> arranges the filter coefficients in one of the vector
of seasons forms (todo: cite me). The component <code>Phi</code> of the
result is a matrix obtained by putting the coefficient matrices next
to each other, [A1 ... Ad].  If <code>perm</code> is provided, then the
result is the same for "U" and "L".
</p>
<p><code>mf_VSform</code> is called implicitly by the subscripting operation
("[") when needed, it is more flexible and is recommended for general
use.
</p>
<p>For the vector forms ("I", "U", and "L") the argument <code>perm</code>
specifies the arrangement of the components of the filter in that
form. For the I- and U-forms the default is <code>mf_period(x):1</code>, for
the L-form it is <code>1:mf_period(x)</code>.
</p>
<p>Currently <code>perm</code> may take on
values that can  be obtained from the default by rotation, e.g. if the
period is 4,  <code>perm</code> may be one of
(4,3,2,1), (1,4,3,2), (2,1,4,3), (3,2,1,4) for the U-form,
and
(1,2,3,4), (4,1,2,3), (3,4,1,2), (2,3,4,1) for the L-form.
Other permutations may be usefull in some situations but may not
result in U- or L- forms (without further transformations).
For I-form any permutation should be permissible when implemented
(todo:).
</p>
<p>For <code>mf_order</code> the argument <code>perm</code> affects the computation
only, not the ordering in the result.  The result (if vector) is not
permuted unless the argument <code>i</code> asks for this.
For <code>mf_VSform</code> however such a behaviour would be very peculiar
and the rows of the result are for the permuted seasons.
In short, the i-th element of the result of <code>mf_order</code> (if
vector) gives the order (in the requested form) of the i-th season
but the i-th row of any of the matrices returned by  <code>mf_VSform</code>
depends on <code>perm</code> and <code>form</code>.
</p>
<p>Note: the terminology here reflects application to pc processes,
probably should be made more neutral in this respect.
</p>
<p>todo: (2013-03-26) <code>mf_order</code> seems unfinished.
</p>


<h3>Value</h3>

<p>For <code>mf_order</code>,
if <code>i = "max"</code> a positive integer,
otherwise a vector  of positive integers.
</p>
<p>For <code>mf_period</code> the period of the filter, a positive integer.
</p>
<p>For <code>mf_poles</code>,
if <code>blocks = FALSE</code>, a vector of the eigenvalues of the associated
multi-companion matrix, each eigenvalue repeated according to its
algebraic multiplicity.
If <code>blocks = TRUE</code>, a 2-column matrix with the eigenvalues in the
first column and the lengths of the  Jordan chains in the second.
There is one row  for each  chain (i.e. multiple eigenvalues are
repeated according to their geometric multiplicity).
</p>
<p>For <code>mf_VSform</code> a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Phi0</code></td>
<td>
<p>the zero lag coefficient, a matrix,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>the remaining coefficients, a matrix,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi0inv</code></td>
<td>

<p>(<code>form=="I"</code> only) the inverse of the zero lag coefficient
matrix of the vs-form, a matrix. (<strong>TODO:</strong> the name of this
component is misleading since in the case <code>form = "I"</code> Phi0 is
the identity matrix and <code>Phi0inv</code> is not equal to the inverse
of Phi0.)
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
“Multi-companion matrices.”
<em>Linear Algebra Appl.</em>, <b>354</b>, 53–83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
“Generation of time series models with given spectral properties.”
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349–368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code>MultiFilter</code> and the examples there,
<code>mcStable</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## simulate a 3x3 2-companion matrix
##  and turn it into a multi-filter
(m &lt;- mCompanion("sim", dim=3, mo=2))
(flt &lt;- new("MultiFilter", mc = m ))
mf_period(flt)
mf_poles(flt)
abs(mf_poles(flt))
mf_VSform(flt,form="U")
mf_VSform(flt,form="L")
mf_VSform(flt,form="I")

## simulate a pc filter (2 seasons)
## and turn it into a multi-filter object
(rfi &lt;- sim_pcfilter(2, 3))
(flt &lt;- new("MultiFilter", coef = rfi$pcfilter))
mf_period(flt)
mf_poles(flt)
abs(mf_poles(flt))
mf_VSform(flt, form="U")
mf_VSform(flt, form="I")
mf_VSform(flt, form="L")

## indexing can be used  to extract filter coefficients
flt[]
flt[1,]
## the rest are some checks of numerical performance.
rfi
rfi$mat==0

zapsmall(rfi$mat)
mCompanion(zapsmall(rfi$mat))
unclass(mCompanion(zapsmall(rfi$mat)))
unclass(mCompanion(rfi$mat))

flt1 &lt;- new("MultiFilter", mc = mCompanion(zapsmall(rfi$mat)))
flt2 &lt;- flt

flt1[]
flt2[]
flt1[] - flt2[]
rfi$pcfilter - rfi$mat[1:2,]

mf_poles(flt1)
abs(mf_poles(flt1))

svd(rfi$mat)
rcond(rfi$mat)
Matrix::rcond(Matrix::Matrix(rfi$mat),"O")
1/Matrix::rcond(Matrix::Matrix(rfi$mat),"O")
</code></pre>


</div>