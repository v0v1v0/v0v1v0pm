<div class="container">

<table style="width: 100%;"><tr>
<td>MultiCompanion-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "MultiCompanion"</h2>

<h3>Description</h3>

<p>Objects and methods for multi-companion matrices</p>


<h3>Objects from the Class</h3>

<p>For ordinary usage objects from this class should behave as matrices
and there should be no need to access the slots directly.
</p>
<p>Objects can be created with the function <code>mCompanion</code>.
Other functions in the mcompanion package also produce
<code>MultiCompanion</code> objects.
</p>
<p>It is possible also to call <code>new()</code> directly:
</p>
<pre>
    new("MultiCompanion", xtop, mo, n, mo.col, ido, x, dimnames,
        detect, misc)
  </pre>
<p>Arguments:
</p>

<dl>
<dt><code>xtop</code></dt>
<dd>
<p> is the top of the matrix. </p>
</dd>
<dt><code>mo</code></dt>
<dd>
<p> is the multi-companion order of the matrix. </p>
</dd>
<dt><code>n</code></dt>
<dd>
<p> is the dimension. </p>
</dd>
<dt><code>mo.col</code></dt>
<dd>
<p> is the top order, meaniing that columns
mo.col+1,...,n of the top of the matrix are zeros. <code>mo.col</code>
may also be set to "detect", in which case it is determined by
scanning <code>xtop</code> or <code>x</code>. </p>
</dd>
<dt><code>ido</code></dt>
<dd>
<p> the dimension of the identity sub-matrix. </p>
</dd>
<dt><code>x</code></dt>
<dd>
<p> the whole matrix. </p>
</dd>
<dt><code>dimnames</code></dt>
<dd>
<p> is not used currently. </p>
</dd>
<dt><code>detect</code></dt>
<dd>
<p> controls whether automatic detection of
<code>mo</code> and <code>mo.col</code> should be attempted. The values tested
are "mo", "mo.col", "all", and "nothing" with obvious meanings. </p>
</dd>
<dt><code>misc</code></dt>
<dd>
<p> todo: describe this argument! </p>
</dd>
</dl>
<p>Normally one of <code>xtop</code> and <code>x</code> is supplied but if both are,
they are checked for consistency, including the elements of the matrix
(equality is tested with <code>==</code>).  To facilitate calls with one
unnamed argument, when <code>xtop</code> is a square matrix it is taken
to be the entire matrix (provided that <code>x</code> is missing).
</p>
<p>Aside from <code>xtop</code> (or <code>x</code>), most of the remaining arguments
can be deduced automatically.  The number of rows and columns of
<code>xtop</code> give the multi-companion order and the dimension of the
matrix, respectively. A vector <code>xtop</code> is taken to stand for a
matrix with one row. <code>x</code> needs to be square or a vector of length
equal to exact square. <code>mo</code> and <code>mo.col</code> may be determined
from the contents of <code>x</code> and <code>xtop</code>. There is no harm in
ignoring <code>mo.col</code> but it is useful for our applications. Note
that by default it is to set to the number of columns and not
determined by scanning the matrix.
</p>
<p>The contents of the  <code>misc</code> argument are  stored in the pad of
the new object.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>xtop</code>:</dt>
<dd>
<p>The top of the matrix, an object of class <code>"matrix"</code> </p>
</dd>
<dt>
<code>mo</code>:</dt>
<dd>
<p>Multi-companion order, an object of class <code>"numeric"</code> </p>
</dd>
<dt>
<code>ido</code>:</dt>
<dd>
<p>dimension of the identity submatrix, object of class <code>"numeric"</code></p>
</dd>
<dt>
<code>mo.col</code>:</dt>
<dd>
<p>number of non-zero columns in top rows, object of class <code>"numeric"</code></p>
</dd>
<dt>
<code>pad</code>:</dt>
<dd>
<p>storage for additional info, object of class <code>"objectPad"</code> </p>
</dd>
<dt>
<code>x</code>:</dt>
<dd>
<p>inherited, object of class <code>"numeric"</code> </p>
</dd>
<dt>
<code>Dim</code>:</dt>
<dd>
<p>inherited, object of class <code>"integer"</code> </p>
</dd>
<dt>
<code>Dimnames</code>:</dt>
<dd>
<p>inherited, object of class <code>"list"</code> </p>
</dd>
<dt>
<code>factors</code>:</dt>
<dd>
<p>inherited, object of class <code>"list"</code> </p>
</dd>
</dl>
<h3>Extends</h3>

<p>Class <code>"ddenseMatrix"</code>, directly.
Class <code>"generalMatrix"</code>, directly.
Class <code>"dMatrix"</code>, by class <code>"ddenseMatrix"</code>.
Class <code>"denseMatrix"</code>, by class <code>"ddenseMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"ddenseMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"ddenseMatrix"</code>.
Class <code>"compMatrix"</code>, by class <code>"generalMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"generalMatrix"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>%*%</dt>
<dd>
<p><code>signature(x = "ANY", y = "MultiCompanion")</code>: ... </p>
</dd>
<dt>%*%</dt>
<dd>
<p><code>signature(x = "MultiCompanion", y = "MultiCompanion")</code>: ... </p>
</dd>
<dt>%*%</dt>
<dd>
<p><code>signature(x = "MultiCompanion", y = "ANY")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "MultiCompanion", i = "index", j = "index",
        drop = "logical")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "MultiCompanion", i = "index", j = "missing", drop = "logical")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "MultiCompanion", i = "missing", j =
        "index", drop = "logical")</code>: ... </p>
</dd>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "dgeMatrix", to = "MultiCompanion")</code>: ... </p>
</dd>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "matrix", to = "MultiCompanion")</code>: ... </p>
</dd>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "MultiCompanion", to = "matrix")</code>: ... </p>
</dd>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "MultiCompanion", to = "dgeMatrix")</code>: ... </p>
</dd>
<dt>initialize</dt>
<dd>
<p><code>signature(.Object = "MultiCompanion")</code>:
This method is called implicitly when the user calls
<code>new("MultiCompanion",...)</code>.
</p>
</dd>
<dt>mcStable</dt>
<dd>
<p><code>signature(x = "MultiCompanion")</code>: ... </p>
</dd>
<dt>t</dt>
<dd>
<p><code>signature(x = "MultiCompanion")</code>: ... </p>
</dd>
<dt>%*%</dt>
<dd>
<p><code>signature(x = "matrix", y = "MultiCompanion")</code>: ... </p>
</dd>
<dt>%*%</dt>
<dd>
<p><code>signature(x = "MultiCompanion", y = "matrix")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "MultiCompanion", i = "index", j = "index", drop = "missing")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "MultiCompanion", i = "index", j = "missing", drop = "missing")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "MultiCompanion", i = "missing", j = "index", drop = "missing")</code>: ... </p>
</dd>
<dt>%*%</dt>
<dd>
<p><code>signature(x = "MultiCompanion", y = "vector")</code>: ... </p>
</dd>
<dt>%*%</dt>
<dd>
<p><code>signature(x = "vector", y = "MultiCompanion")</code>: ... </p>
</dd>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "MultiCompanion", to = "Matrix")</code>: ... </p>
</dd>
<dt>coerce&lt;-</dt>
<dd>
<p><code>signature(from = "MultiCompanion", to = "Matrix")</code>: ... </p>
</dd>
<dt>Math</dt>
<dd>
<p><code>signature(x = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Math2</dt>
<dd>
<p><code>signature(x = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "ANY", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "complex", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "logical", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "matrix", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "MultiCompanion", e2 = "ANY")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "MultiCompanion", e2 = "complex")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "MultiCompanion", e2 = "logical")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "MultiCompanion", e2 = "matrix")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "MultiCompanion", e2 = "Matrix")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "MultiCompanion", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "MultiCompanion", e2 = "numeric")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "MultiCompanion", e2 = "vector")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "vector", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Summary</dt>
<dd>
<p><code>signature(x = "MultiCompanion")</code>: ... </p>
</dd>
</dl>
<h3>Note</h3>

<p>The implementation is rather redundant, this class probably should
inherit in a different way from classes in Matrix package or may be
not inherit at all.
</p>
<p>Methods to get the multi-order, mo.col, and others, would be useful
but first the terminology needs to be made consistent.
</p>
<p>Other matrix arithmetic operations?
</p>
<p>Argument <code>n</code> is called <code>dim</code> in other functions.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
“Multi-companion matrices.”
<em>Linear Algebra Appl.</em>, <b>354</b>, 53–83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
“Generation of time series models with given spectral properties.”
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349–368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code>mCompanion</code> and  the examples there;
the following functions produce multi-companion matrices but do not
return <code>MultiCompanion</code> objects:
</p>
<p><code>sim_mc</code>, <code>make_mcmatrix</code>
</p>



<h3>Examples</h3>

<pre><code class="language-R">a1 &lt;- matrix(1:12, nrow = 2)
mc1 &lt;- new("MultiCompanion", xtop = a1)
new("MultiCompanion", a1)   # same

a2 &lt;- matrix(c(1:6, rep(0, 4)), nrow = 2)   # 1st 3 columns of a2 are non-zero
mc2 &lt;- new("MultiCompanion", a2)
mc2
mc2@mo.col     # =5, because the default is to set mo.col to ncol

mc2a &lt;- new("MultiCompanion", a2, detect = "mo.col")
mc2a@mo.col   # =3, compare with above

b &lt;- as(mc2, "matrix")  # b is ordinary R matrix
mcb &lt;- new("MultiCompanion", x = b)
       new("MultiCompanion", b)   # same as mcb

mcb@mo        # 2 (mo detected)
mcb@mo.col    # 5 (no attempt to detect mo.col)

mcba &lt;- new("MultiCompanion", b, detect = "all")
mcba@mo        # 2 (mo detected)
mcba@mo.col    # 3 (mo.col detected)
</code></pre>


</div>