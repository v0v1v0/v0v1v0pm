<div class="container">

<table style="width: 100%;"><tr>
<td>MultiFilter-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "MultiFilter" </h2>

<h3>Description</h3>

<p>Objects and methods  for filters with more than one set of
coefficients.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("MultiFilter", coef, mc, order, sign)</code>.
</p>
<p>Objects from this class represent periodic filters. A
<code class="reqn">d</code>-periodic filter relates an input series
<code class="reqn">\varepsilon_{t}</code> to an output series
<code class="reqn">y_t</code> by the following formula:
</p>
<p style="text-align: center;"><code class="reqn"> y_t
    =   \sum_{i=1}^{p_t} \phi  _t(i)y          _{t-i}
      % + \sum_{i=1}^{q_t} \theta_t(i)\varepsilon_{t-i}
      + \varepsilon_t
      ,
    </code>
</p>

<p>where the coefficients <code class="reqn">\phi_t(i)</code> are <code class="reqn">d</code>-periodic in
<code class="reqn">t</code>, i.e. <code class="reqn">\phi_{t+d}(i)=\phi_t(i)</code> and
<code class="reqn">p_{t+d} = p_{t}</code>.
</p>
<p>The periodicity means that it is sufficient to store the coefficients
in a <code class="reqn">d \times p</code> matrix, where
<code class="reqn">p=\max(p_1,\dots,p_t)</code>.
Slot <code>coef</code> contains such a matrix.
</p>
<p>The filter may be specified either by its coefficients or by its
multi-companion form.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>mc</code>:</dt>
<dd>
<p>the multi-companion form of the filter, an object
of class <code>"MultiCompanion"</code>
</p>
</dd>
<dt>
<code>coef</code>:</dt>
<dd>
<p>the coefficients of the filter, an object of
class <code>"matrix"</code>, whose <code class="reqn">s</code>th row contains the
coefficients for <code class="reqn">t=k \times d +s</code>.
</p>
</dd>
<dt>
<code>order</code>:</dt>
<dd>
<p>the periodic order of the filter,
a numeric vector giving the orders of the individual seasons.
</p>
</dd>
<dt>
<code>sign</code>:</dt>
<dd>
<p>1 or -1. The default value, 1, corresponds to
the formula given in section "Objects from the Class". It can also
be -1, if the sum on the right-hand side of that formula is
preceded by a minus (usual convention in signal processing).
</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt>[</dt>
<dd>
<p><code>signature(x = "MultiFilter", i = "ANY", j = "ANY",
	drop = "ANY")</code>:
take subset of the coefficients of the filter in various forms.
</p>
<p>To do: the function needs more work! Document the function and the
additional arguments!
</p>
</dd>
<dt>initialize</dt>
<dd>
<p><code>signature(.Object = "MultiFilter")</code>:
This function is called implicitly by <code>new</code>, see the
signature for <code>new</code> above.
One of <code>mc</code> and  <code>coef</code> must be supplied, the other
arguments are optional.
</p>
<p>If <code>mc</code> is missing it is computed from <code>coef</code>.
In this case, component <code>mC.factorsmat</code> of slot <code>misc</code>
of <code>mc</code> is set to the companion factorisation of <code>mc</code>
(essentially the reversed rows of <code>coef</code>).
</p>
<p>If <code>coef</code> is missing it is computed from <code>mc</code>, see
<code>mc_factors</code>.
</p>
</dd>
<dt>mcStable</dt>
<dd>
<p><code>signature(x = "MultiFilter")</code>:
Check if the filter is stable.
</p>
</dd>
</dl>
<p>See also the documentation for the following functions which are
effectively methods for class "MuliFilter" but are not defined as
formal methods:
</p>
<p><code>mf_period</code>, <code>mf_order</code>, <code>mf_poles</code>,
<code>mf_VSform</code>.

</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
“Multi-companion matrices.”
<em>Linear Algebra Appl.</em>, <b>354</b>, 53–83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
“Generation of time series models with given spectral properties.”
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349–368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>


<p><code>MultiCompanion</code>,
<code>mf_period</code>, <code>mf_order</code>,
<code>mf_poles</code>,
<code>mf_VSform</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">showClass("MultiFilter")

m &lt;- mCompanion("sim",dim=3,mo=2)   # simulate a 3x3 2-comp. matrix
flt &lt;- new("MultiFilter", mc = m )
flt[]
mf_period(flt)
mf_poles(flt)
abs(mf_poles(flt))

mf_VSform(flt,form="U")
mf_VSform(flt,form="L")
mf_VSform(flt,form="I")


# try arguments "coef" and "mc", for comparison
rfi &lt;- sim_pcfilter(2,3) # period=2, order=c(3,3)
# per. filter from a multi-companion matrix
flt1 &lt;- new("MultiFilter",mc=  mCompanion(zapsmall(rfi$mat)) )
flt1[]
mf_period(flt1)
mf_poles(flt1)
abs(mf_poles(flt1))

mf_VSform(flt1,form="U")
mf_VSform(flt1,form="L")
mf_VSform(flt1,form="I")

# per. filter from coefficients, should be the same (numerically)
flt2 &lt;- new("MultiFilter",coef=rfi$pcfilter)
flt2[]
mf_period(flt2)
mf_poles(flt2)
abs(mf_poles(flt2))

mf_VSform(flt2,form="U")
mf_VSform(flt2,form="L")
mf_VSform(flt2,form="I")

</code></pre>


</div>