<div class="container">

<table style="width: 100%;"><tr>
<td>plot.mcpfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot full fits</h2>

<h3>Description</h3>

<p>Plot prior or posterior model draws on top of data. Use <code>plot_pars</code> to
plot individual parameter estimates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mcpfit'
plot(
  x,
  facet_by = NULL,
  lines = 25,
  geom_data = "point",
  cp_dens = TRUE,
  q_fit = FALSE,
  q_predict = FALSE,
  rate = TRUE,
  prior = FALSE,
  which_y = "ct",
  arma = TRUE,
  nsamples = 2000,
  scale = "response",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An <code>mcpfit</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>facet_by</code></td>
<td>
<p>String. Name of a varying group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lines</code></td>
<td>
<p>Positive integer or <code>FALSE</code>. Number of lines (posterior
draws). FALSE or <code>lines = 0</code> plots no lines. Note that lines always plot
fitted values - not predicted. For prediction intervals, see the <code>q_predict</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom_data</code></td>
<td>
<p>String. One of "point", "line" (good for time-series),
or FALSE (don not plot).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cp_dens</code></td>
<td>
<p>TRUE/FALSE. Plot posterior densities of the change point(s)?
Currently does not respect <code>facet_by</code>. This will be added in the future.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q_fit</code></td>
<td>
<p>Whether to plot quantiles of the posterior (fitted value).
</p>

<ul>
<li> <p><code>TRUE</code> Add 2.5% and 97.5% quantiles. Corresponds to
<code>q_fit = c(0.025, 0.975)</code>.
</p>
</li>
<li> <p><code>FALSE</code> No quantiles
</p>
</li>
<li>
<p> A vector of quantiles. For example, <code>quantiles = 0.5</code>
plots the median and <code>quantiles = c(0.2, 0.8)</code> plots the 20% and 80%
quantiles.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q_predict</code></td>
<td>
<p>Same as <code>q_fit</code>, but for the prediction interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rate</code></td>
<td>
<p>Boolean. For binomial models, plot on raw data (<code>rate = FALSE</code>) or
response divided by number of trials (<code>rate = TRUE</code>). If FALSE, linear
interpolation on trial number is used to infer trials at a particular x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>TRUE/FALSE. Plot using prior samples? Useful for <code>mcp(..., sample = "both")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_y</code></td>
<td>
<p>What to plot on the y-axis. One of
</p>

<ul>
<li> <p><code>"ct"</code>: The central tendency which is often the mean after applying the
link function.
</p>
</li>
<li> <p><code>"sigma"</code>: The variance
</p>
</li>
<li> <p><code>"ar1"</code>, <code>"ar2"</code>, etc. depending on which order of the autoregressive
effects you want to plot.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arma</code></td>
<td>
<p>Whether to include autoregressive effects.
</p>

<ul>
<li> <p><code>TRUE</code> Compute autoregressive residuals. Requires the response variable in <code>newdata</code>.
</p>
</li>
<li> <p><code>FALSE</code> Disregard the autoregressive effects. For <code>family = gaussian()</code>, <code>predict()</code> just use <code>sigma</code> for residuals.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsamples</code></td>
<td>
<p>Integer or <code>NULL</code>. Number of samples to return/summarise.
If there are varying effects, this is the number of samples from each varying group.
<code>NULL</code> means "all". Ignored if both are <code>FALSE</code>. More samples trade speed for accuracy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>One of
</p>

<ul>
<li>
<p> "response": return on the observed scale, i.e., after applying the inverse link function.
</p>
</li>
<li>
<p> "linear": return on the parameter scale (where the linear trends are modelled).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>plot()</code> uses <code>fit$simulate()</code> on posterior samples. These represent the
(joint) posterior distribution.
</p>


<h3>Value</h3>

<p>A <span class="pkg">ggplot2</span> object.
</p>


<h3>Author(s)</h3>

<p>Jonas Kristoffer Lindel√∏v <a href="mailto:jonas@lindeloev.dk">jonas@lindeloev.dk</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Typical usage. demo_fit is an mcpfit object.
plot(demo_fit)

plot(demo_fit, prior = TRUE)  # The prior

plot(demo_fit, lines = 0, q_fit = TRUE)  # 95% HDI without lines
plot(demo_fit, q_predict = c(0.1, 0.9))  # 80% prediction interval
plot(demo_fit, which_y = "sigma", lines = 100)  # The variance parameter on y

# Show a panel for each varying effect
# plot(fit, facet_by = "my_column")

# Customize plots using regular ggplot2
library(ggplot2)
plot(demo_fit) + theme_bw(15) + ggtitle("Great plot!")


</code></pre>


</div>