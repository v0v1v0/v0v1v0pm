<div class="container">

<table style="width: 100%;"><tr>
<td>assign_date</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Assign dates to two sequential hours</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a>
</p>
<p>This function will be removed on the next <code>mctq</code> version. You can still find
it in the <a href="https://github.com/giperbio/lubritime"><code>lubritime</code></a> package.
</p>
<p><code>assign_date()</code> assign dates to two sequential hours. It can facilitate
time arithmetic by locating time values without a date reference on a
timeline.
</p>


<h3>Usage</h3>

<pre><code class="language-R">assign_date(start, end, ambiguity = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>start, end</code></td>
<td>
<p>An <code>hms</code> or <code>POSIXt</code>
object indicating the start or end hour.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ambiguity</code></td>
<td>
<p>(optional) a <code>numeric</code> or <code>NA</code> value to
instruct <code>assign_date()</code> on how to deal with ambiguities. See the Details
section to learn more (default: <code>0</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Class requirements</h4>

<p>The <code>mctq</code> package works with a set of object classes specially created to
hold time values. These classes can be found in the
lubridate and hms
packages. Please refer to those package documentations to learn more about
them.
</p>



<h4>
<code>ambiguity</code> argument</h4>

<p>In cases when <code>start</code> is equal to <code>end</code>, there are two possibilities of
intervals between the two hours (ambiguity). That's because <code>start</code> and <code>end</code>
can be at the same point in time or they can distance themselves by one day,
considering a two-day timeline.
</p>
<div class="sourceCode"><pre> start,end       start,end       start,end       start,end
   start            end            start            end
   10:00           10:00           10:00           10:00
-----|---------------|---------------|---------------|-----&gt;
    0h              0h              0h              0h
            24h             24h             24h
</pre></div>
<p>You must instruct <code>assign_date()</code> on how to deal with this problem if it
occurs. There are three options to choose.
</p>

<ul>
<li> <p><code>ambiguity = 0</code>: to consider the interval between <code>start</code> and <code>end</code> as 0
hours, i.e., <code>start</code> and <code>end</code> are located at the same point in time
(default).
</p>
</li>
<li> <p><code>ambiguity = 24</code>: to consider the interval between <code>start</code> and <code>end</code> as 24
hours, i.e., <code>start</code> and <code>end</code> distance themselves by one day.
</p>
</li>
<li> <p><code>ambiguity = NA</code>: to disregard these cases, assigning <code>NA</code> as value.
</p>
</li>
</ul>
<h4>Base date and timezone</h4>

<p><code>assign_date()</code> uses the
<a href="https://en.wikipedia.org/wiki/Unix_time">Unix epoch</a> (1970-01-01) date as
the start date for creating intervals.
</p>
<p>The output will always have <code>"UTC"</code> set as timezone. Learn more about
time zones in <code>?timezone</code>.
</p>



<h4>
<code>POSIXt</code> objects</h4>

<p><code>POSIXt</code> objects passed as argument to <code>start</code> or <code>end</code>
will be stripped of their dates. Only the time will be considered.
</p>
<p>Both <code>POSIXct</code> and <code>POSIXlt</code> are
objects that inherits the class <code>POSIXt</code>. Learn more about it in
<code>?DateTimeClasses</code>.
</p>



<h4>
<code>NA</code> values</h4>

<p><code>assign_date()</code> will return an <code>Interval</code> <code>NA</code>-<code>NA</code>
if <code>start</code> or <code>end</code> are <code>NA</code>.
</p>



<h3>Value</h3>

<p>A <code>start</code>â€“<code>end</code> <code>Interval</code> object.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Scalar example

start &lt;- hms::parse_hms("23:11:00")
end &lt;- hms::parse_hms("05:30:00")
assign_date(start, end)
#&gt; [1] 1970-01-01 23:11:00 UTC--1970-01-02 05:30:00 UTC # Expected

start &lt;- hms::parse_hms("10:15:00")
end &lt;- hms::parse_hms("13:25:00")
assign_date(start, end)
#&gt; [1] 1970-01-01 10:15:00 UTC--1970-01-01 13:25:00 UTC # Expected

start &lt;- hms::parse_hms("05:42:00")
end &lt;- hms::as_hms(NA)
assign_date(start, end)
#&gt; [1] NA--NA # Expected

## Vector example

start &lt;- c(hms::parse_hm("09:45"), hms::parse_hm("20:30"))
end &lt;- c(hms::parse_hm("21:15"), hms::parse_hm("04:30"))
assign_date(start, end)
#&gt; [1] 1970-01-01 09:45:00 UTC--1970-01-01 21:15:00 UTC # Expected
#&gt; [2] 1970-01-01 20:30:00 UTC--1970-01-02 04:30:00 UTC # Expected

## To assign a 24 hours interval to ambiguities

start &lt;- lubridate::as_datetime("1985-01-15 12:00:00")
end &lt;- lubridate::as_datetime("2020-09-10 12:00:00")
assign_date(start, end, ambiguity = 24)
#&gt; [1] 1970-01-01 12:00:00 UTC--1970-01-02 12:00:00 UTC # Expected
</code></pre>


</div>