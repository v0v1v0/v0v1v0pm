<div class="container">

<table style="width: 100%;"><tr>
<td>sjl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute MCTQ social jetlag</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt="[Maturing]"></a>
</p>
<p><code>sjl()</code> computes the <strong>relative or absolute social jetlag</strong> for standard,
micro, and shift versions of the Munich ChronoType Questionnaire (MCTQ).
</p>
<p><code>sjl_rel()</code> is just a wrapper for <code>sjl()</code> with <code>abs = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sjl(msw, msf, abs = TRUE, method = "shorter")

sjl_rel(msw, msf, method = "shorter")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>msw</code></td>
<td>
<p>An <code>hms</code> object corresponding to the <strong>local time of
mid-sleep on workdays</strong> from a standard, micro, or shift version of the
MCTQ questionnaire. You can use <code>msl()</code> to compute it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msf</code></td>
<td>
<p>An <code>hms</code> object corresponding to the <strong>local time of
mid-sleep on work-free days</strong> from a standard, micro, or shift version of
the MCTQ questionnaire. You can use <code>msl()</code> to compute it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abs</code></td>
<td>
<p>(optional) a <code>logical</code> object indicating if the
function must return an absolute value (default: <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>(optional) a string indicating which method the function must
use to compute the social jetlag. See the Methods section to learn
more (default: <code>"shorter"</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Standard MCTQ</strong> functions were created following the guidelines in
Roenneberg, Wirz-Justice, &amp; Merrow (2003), Roenneberg, Allebrandt, Merrow, &amp;
Vetter (2012), and from The Worldwide Experimental Platform (theWeP, n.d.).
</p>
<p><strong><code class="reqn">\mu</code>MCTQ</strong> functions were created following the guidelines in Ghotbi
et al. (2020), in addition to the guidelines used for the standard MCTQ.
</p>
<p><strong>MCTQ<code class="reqn">^{Shift}</code></strong> functions were created following the
guidelines in Juda, Vetter, &amp; Roenneberg (2013), in addition to the
guidelines used for the standard MCTQ.
</p>
<p>See the References section to learn more.
</p>


<h4>Class requirements</h4>

<p>The <code>mctq</code> package works with a set of object classes specially created to
hold time values. These classes can be found in the
lubridate and hms
packages. Please refer to those package documentations to learn more about
them.
</p>



<h4>Rounding and fractional time</h4>

<p>Some operations may produce an output with fractional time (e.g.,
<code>"19538.3828571429s (~5.43 hours)"</code>, <code>01:15:44.505</code>). If you want, you
can round it with <code>round_time()</code>.
</p>
<p>Our recommendation is to avoid rounding, but, if you do, make sure that you
only round your values after all computations are done. That way you avoid
<a href="https://en.wikipedia.org/wiki/Round-off_error">round-off errors</a>.
</p>



<h3>Value</h3>


<ul>
<li>
<p> If <code>abs = TRUE</code>, a <code>Duration</code> object corresponding
to the absolute social jetlag.
</p>
</li>
<li>
<p> If <code>abs = FALSE</code>, a <code>Duration</code> object
corresponding to the relative social jetlag.
</p>
</li>
</ul>
<p>The output may also vary depending on the <code>method</code> used.
</p>


<h3>Guidelines</h3>

<p>Roenneberg, Allebrandt, Merrow, &amp; Vetter (2012), Juda, Vetter, &amp; Roenneberg
(2013), and The Worldwide Experimental Platform (n.d.) guidelines for <code>sjl()</code>
(<code class="reqn">SJL_{rel}</code> and <code class="reqn">SJL</code>) computation are as follows.
</p>


<h4>Notes</h4>


<ul>
<li>
<p> For MCTQ<code class="reqn">^{Shift}</code>, the computation below must be applied to
each shift section of the questionnaire.
</p>
</li>
<li>
<p> Due to time arithmetic issues, <code>sjl()</code> does a slightly different
computation by default than those proposed by the authors mentioned above.
See <code>vignette("sjl-computation", package = "mctq")</code> for more details.
</p>
</li>
<li>
<p> If you are visualizing this documentation in plain text, you may have some
trouble understanding the equations. You can see this documentation on the
package <a href="https://docs.ropensci.org/mctq/reference/">website</a>.
</p>
</li>
</ul>
<h4>For standard and micro versions of the MCTQ</h4>

<p style="text-align: center;"><code class="reqn">SJL_{rel} = MSF - MSW</code>
</p>

<p style="text-align: center;"><code class="reqn">SJL = | MSF - MSW |</code>
</p>

<p>Where:
</p>

<ul>
<li> <p><code class="reqn">SJL_{rel}</code> = Relative social jetlag.
</p>
</li>
<li> <p><code class="reqn">SJL</code> = Absolute social jetlag.
</p>
</li>
<li> <p><code class="reqn">MSW</code> = Local time of mid-sleep on workdays.
</p>
</li>
<li> <p><code class="reqn">MSF</code> = Local time of mid-sleep on work-free days.
</p>
</li>
</ul>
<p><strong>*</strong> <code class="reqn">W</code> = Workdays; <code class="reqn">F</code> = Work-free days.
</p>



<h4>For the shift version of the MCTQ</h4>

<p style="text-align: center;"><code class="reqn">SJL_{rel}^{M/E/N} = MSF^{M/E/N} - MSW^{M/E/N}</code>
</p>

<p style="text-align: center;"><code class="reqn">SJL^{M/E/N} = | MSF^{M/E/N} - MSW^{M/E/N} |</code>
</p>

<p>Where:
</p>

<ul>
<li> <p><code class="reqn">SJL_{rel}^{M/E/N}</code> = Relative social jetlag in a particular shift.
</p>
</li>
<li> <p><code class="reqn">SJL^{M/E/N}</code> = Absolute social jetlag in a particular shift.
</p>
</li>
<li> <p><code class="reqn">MSW^{M/E/N}</code> = Local time of mid-sleep between two days in a
particular shift.
</p>
</li>
<li> <p><code class="reqn">MSF^{M/E/N}</code> = Local time of mid-sleep between two free days after a
particular shift.
</p>
</li>
</ul>
<p><strong>*</strong> <code class="reqn">W</code> = Workdays; <code class="reqn">F</code> = Work-free days, <code class="reqn">M</code> =
Morning shift; <code class="reqn">E</code> = Evening shift; <code class="reqn">N</code> = Night shift.
</p>



<h3>Methods for computing the social jetlag</h3>

<p>There are different approaches to compute the social jetlag (<code class="reqn">SJL</code>). By
default, <code>sjl()</code> uses an approach that we call "the shorter interval
approach" (<code>"shorter"</code>).
</p>
<p>The topics below provide a simple explanation of each method supported by
<code>sjl()</code>. To get a detail understating of this methods, see
<code>vignette("sjl-computation", package = "mctq")</code>.
</p>

<ul><li> <p><code>"difference"</code>
</p>
</li></ul>
<p>By using <code>method = "difference"</code>, <code>sjl()</code> will do the exact computation
proposed by the MCTQ authors, i.e., <code class="reqn">SJL</code> will be computed as the linear
difference between <code class="reqn">MSF</code> and <code class="reqn">MSW</code> (see the Guidelines section).
</p>
<p><strong>We do not recommend using this method</strong>, as it has many limitations.
</p>

<ul><li> <p><code>"shorter"</code>
</p>
</li></ul>
<p>This is the default method for <code>sjl()</code>. It's based on the shorter
interval between <code class="reqn">MSW</code> and <code class="reqn">MSF</code>, solving most of the issues
relating to <code class="reqn">SJL</code> computation.
</p>

<ul><li> <p><code>"longer"</code>
</p>
</li></ul>
<p>The <code>"longer"</code> method uses the same logic of the <code>"shorter"</code> method, but,
instead of using the shorter interval between <code class="reqn">MSW</code> and <code class="reqn">MSF</code>, it
uses the longer interval between the two, considering a two-day window.
</p>
<p>This method may help in special contexts, like when dealing with
shift-workers that have a greater than 12 hours distance between their
mid-sleep hours.
</p>


<h3>References</h3>

<p>Ghotbi, N., Pilz, L. K., Winnebeck, E. C., Vetter, C., Zerbini, G., Lenssen,
D., Frighetto, G., Salamanca, M., Costa, R., Montagnese, S., &amp; Roenneberg, T.
(2020). The <code class="reqn">\mu</code>MCTQ: an ultra-short version of the Munich ChronoType
Questionnaire. <em>Journal of Biological Rhythms</em>, <em>35</em>(1), 98-110.
<a href="https://doi.org/10.1177/0748730419886986">doi:10.1177/0748730419886986</a>
</p>
<p>Jankowski K. S. (2017). Social jet lag: sleep-corrected formula.
<em>Chronobiology International</em>, <em>34</em>(4), 531-535.
<a href="https://doi.org/10.1080/07420528.2017.1299162">doi:10.1080/07420528.2017.1299162</a>
</p>
<p>Juda, M., Vetter, C., &amp; Roenneberg, T. (2013). The Munich ChronoType
Questionnaire for shift-workers (MCTQ<code class="reqn">^{Shift}</code>). <em>Journal of
Biological Rhythms</em>, <em>28</em>(2), 130-140. <a href="https://doi.org/10.1177/0748730412475041">doi:10.1177/0748730412475041</a>
</p>
<p>Roenneberg T., Allebrandt K. V., Merrow M., &amp; Vetter C. (2012). Social jetlag
and obesity. <em>Current Biology</em>, <em>22</em>(10), 939-43.
<a href="https://doi.org/10.1016/j.cub.2012.03.038">doi:10.1016/j.cub.2012.03.038</a>
</p>
<p>Roenneberg, T., Pilz, L. K., Zerbini, G., &amp; Winnebeck, E. C. (2019).
Chronotype and social jetlag: a (self-) critical review. <em>Biology</em>, <em>8</em>(3),
54. <a href="https://doi.org/10.3390/biology8030054">doi:10.3390/biology8030054</a>
</p>
<p>Roenneberg, T., Wirz-Justice, A., &amp; Merrow, M. (2003). Life between clocks:
daily temporal patterns of human chronotypes. <em>Journal of Biological
Rhythms</em>, <em>18</em>(1), 80-90. <a href="https://doi.org/10.1177/0748730402239679">doi:10.1177/0748730402239679</a>
</p>
<p>The Worldwide Experimental Platform (n.d.). MCTQ.
<a href="https://www.thewep.org/documentations/mctq/">https://www.thewep.org/documentations/mctq/</a>
</p>


<h3>See Also</h3>

<p>Other MCTQ functions: 
<code>fd()</code>,
<code>gu()</code>,
<code>le_week()</code>,
<code>msf_sc()</code>,
<code>msl()</code>,
<code>napd()</code>,
<code>sd24()</code>,
<code>sd_overall()</code>,
<code>sd_week()</code>,
<code>sdu()</code>,
<code>sjl_sc()</code>,
<code>sjl_weighted()</code>,
<code>so()</code>,
<code>tbt()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Scalar example

msw &lt;- hms::parse_hm("03:30")
msf &lt;- hms::parse_hm("05:00")

sjl(msw, msf)
#&gt; [1] "5400s (~1.5 hours)" # Expected
sjl(msw, msf, abs = FALSE)
#&gt; [1] "5400s (~1.5 hours)" # Expected
sjl_rel(msw, msf) # Wrapper function
#&gt; [1] "5400s (~1.5 hours)" # Expected

msw &lt;- hms::parse_hm("04:30")
msf &lt;- hms::parse_hm("23:30")

sjl(msw, msf)
#&gt; [1] "18000s (~5 hours)" # Expected
sjl(msw, msf, abs = FALSE)
#&gt; [1] "18000s (~-5 hours)" # Expected
sjl_rel(msw, msf) # Wrapper function
#&gt; [1] "18000s (~-5 hours)" # Expected

msw &lt;- hms::as_hms(NA)
msf &lt;- hms::parse_hm("05:15")

sjl(msw, msf)
#&gt; [1] NA # Expected

## Vector example

msw &lt;- c(hms::parse_hm("02:05"), hms::parse_hm("04:05"))
msf &lt;- c(hms::parse_hm("23:05"), hms::parse_hm("04:05"))

sjl(msw, msf)
#&gt; [1] "10800s (~3 hours)" "0s" # Expected
sjl(msw, msf, abs = FALSE)
#&gt; [1] "-10800s (~-3 hours)" "0s" # Expected
sjl_rel(msw, msf) # Wrapper function
#&gt; [1] "-10800s (~-3 hours)" "0s" # Expected

## Using different methods

msw &lt;- hms::parse_hm("19:15")
msf &lt;- hms::parse_hm("02:30")

sjl(msw, msf, abs = FALSE, method = "difference")
#&gt; [1] "-60300s (~-16.75 hours)" # Expected
sjl(msw, msf, abs = FALSE, method = "shorter") # Default method
#&gt; [1] "26100s (~7.25 hours)" # Expected
sjl(msw, msf, abs = FALSE, method = "longer")
#&gt; [1] "-60300s (~-16.75 hours)" # Expected

msw &lt;- hms::parse_hm("02:45")
msf &lt;- hms::parse_hm("04:15")

sjl(msw, msf, abs = FALSE, method = "difference")
#&gt; [1] "5400s (~1.5 hours)" # Expected
sjl(msw, msf, abs = FALSE, method = "shorter") # Default method
#&gt; [1] "5400s (~1.5 hours)" # Expected
sjl(msw, msf, abs = FALSE, method = "longer")
#&gt; [1] "-81000s (~-22.5 hours)" # Expected

## Converting the output to 'hms'

msw &lt;- hms::parse_hm("01:15")
msf &lt;- hms::parse_hm("03:25")
sjl(msw, msf)
#&gt; [1] "7800s (~2.17 hours)" # Expected

hms::as_hms(as.numeric(sjl(msw, msf)))
#&gt; 02:10:00 # Expected

## Rounding the output at the seconds level

msw &lt;- hms::parse_hms("04:19:33.1234")
msf &lt;- hms::parse_hms("02:55:05")
sjl(msw, msf)
#&gt; [1] "5068.12339997292s (~1.41 hours)" # Expected

round_time(sjl(msw, msf))
#&gt; [1] "5068s (~1.41 hours)" # Expected
</code></pre>


</div>