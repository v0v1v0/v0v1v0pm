<div class="container">

<table style="width: 100%;"><tr>
<td>sjl_sc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Jankowski's MCTQ sleep-corrected social jetlag</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt="[Maturing]"></a>
</p>
<p><code>sjl_sc()</code> computes the <strong>Jankowski's (2017) sleep-corrected social jetlag</strong>
for standard, micro, and shift versions of the Munich ChronoType
Questionnaire (MCTQ).
</p>
<p><code>sjl_sc_rel()</code> is just a wrapper for <code>sjl_sc()</code> with <code>abs = FALSE</code>.
</p>
<p>Please note that the Jankowski (2017) did not proposed a "relative"
sleep-corrected social jetlag, but the user may consider using it.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sjl_sc(so_w, se_w, so_f, se_f, abs = TRUE, method = "shorter")

sjl_sc_rel(so_w, se_w, so_f, se_f, method = "shorter")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>so_w</code></td>
<td>
<p>An <code>hms</code> object corresponding to the <strong>local time
of sleep onset on workdays</strong> from a standard, micro, or shift version of
the MCTQ questionnaire. You can use <code>so()</code> to compute it for
the standard or shift version.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se_w</code></td>
<td>
<p>An <code>hms</code> object corresponding to the <strong>local time
of sleep end on workdays</strong> from a standard, micro, or shift version of the
MCTQ questionnaire.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>so_f</code></td>
<td>
<p>An <code>hms</code> object corresponding to the <strong>local time
of sleep onset on work-free days</strong> from a standard, micro, or shift version
of the MCTQ questionnaire. You can use <code>so()</code> to compute it
for the standard or shift version.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se_f</code></td>
<td>
<p>An <code>hms</code> object corresponding to the <strong>local time
of sleep end on work-free days</strong> from a standard, micro, or shift version
of the MCTQ questionnaire.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abs</code></td>
<td>
<p>(optional) a <code>logical</code> object indicating if the
function must return an absolute value (default: <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>(optional) a string indicating which method the function must
use to compute the social jetlag. See the Methods section to learn
more (default: <code>"shorter"</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Standard MCTQ</strong> functions were created following the guidelines in
Roenneberg, Wirz-Justice, &amp; Merrow (2003), Roenneberg, Allebrandt, Merrow, &amp;
Vetter (2012), and from The Worldwide Experimental Platform (theWeP, n.d.).
</p>
<p><strong><code class="reqn">\mu</code>MCTQ</strong> functions were created following the guidelines in Ghotbi
et al. (2020), in addition to the guidelines used for the standard MCTQ.
</p>
<p><strong>MCTQ<code class="reqn">^{Shift}</code></strong> functions were created following the
guidelines in Juda, Vetter, &amp; Roenneberg (2013), in addition to the
guidelines used for the standard MCTQ.
</p>
<p>See the References section to learn more.
</p>


<h4>Class requirements</h4>

<p>The <code>mctq</code> package works with a set of object classes specially created to
hold time values. These classes can be found in the
lubridate and hms
packages. Please refer to those package documentations to learn more about
them.
</p>



<h4>Rounding and fractional time</h4>

<p>Some operations may produce an output with fractional time (e.g.,
<code>"19538.3828571429s (~5.43 hours)"</code>, <code>01:15:44.505</code>). If you want, you
can round it with <code>round_time()</code>.
</p>
<p>Our recommendation is to avoid rounding, but, if you do, make sure that you
only round your values after all computations are done. That way you avoid
<a href="https://en.wikipedia.org/wiki/Round-off_error">round-off errors</a>.
</p>



<h3>Value</h3>


<ul>
<li>
<p> If <code>abs = TRUE</code>, a <code>Duration</code> object corresponding
to the absolute sleep-corrected social jetlag.
</p>
</li>
<li>
<p> If <code>abs = FALSE</code>, a <code>Duration</code> object
corresponding to the relative sleep-corrected social jetlag.
</p>
</li>
</ul>
<p>The output may also vary depending on the <code>method</code> used.
</p>


<h3>Guidelines</h3>

<p>In an article published in 2017, Konrad S. Jankowski argued that the original
formula for computing the social jetlag (<code class="reqn">SJL</code>) captures not only the
misalignment between social and biological time, but also the sleep debt
resulting from sleep deprivation during workdays. Jankowski then proposed the
following guideline for a sleep-corrected social jetlag
(<code class="reqn">SJL_{sc}</code>) computation.
</p>


<h4>Notes</h4>


<ul>
<li>
<p> The Jankowski's alternative is disputed. We recommend seeing
Roenneberg, Pilz, Zerbini, &amp; Winnebeck (2019) discussion about it
(see item 3.4.2).
</p>
</li>
<li>
<p> For MCTQ<code class="reqn">^{Shift}</code>, the computation below must be applied to
each shift section of the questionnaire.
</p>
</li>
<li>
<p> Due to time arithmetic issues, <code>sjl_sc()</code> does a slightly different
computation by default than those proposed by the author mentioned above.
See <code>vignette("sjl-computation", package = "mctq")</code> for more details.
</p>
</li>
<li>
<p> If you are visualizing this documentation in plain text, you may have some
trouble understanding the equations. You can see this documentation on the
package <a href="https://docs.ropensci.org/mctq/reference/">website</a>.
</p>
</li>
</ul>
<h4>For standard and micro versions of the MCTQ</h4>

<p style="text-align: center;"><code class="reqn">\textrm{If } SD_{W} &gt; SD_{F} \; \&amp; \; SE_{W} \leq SE_{F} \; , \;
SJL_{sc} = | SE_{F} - SE_{W} |</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Else } \; , \; SJL_{sc} = | SO_{F} - SO_{W} |</code>
</p>

<p>Where:
</p>

<ul>
<li> <p><code class="reqn">SJL_{sc}</code> = Jankowski's sleep-corrected social jetlag.
</p>
</li>
<li> <p><code class="reqn">SO_{W}</code> = Local time of sleep onset on workdays.
</p>
</li>
<li> <p><code class="reqn">SE_{W}</code> = Local time of sleep end on workdays.
</p>
</li>
<li> <p><code class="reqn">SO_{F}</code> = Local time of sleep onset on work-free days.
</p>
</li>
<li> <p><code class="reqn">SE_{F}</code> = Local time of sleep end on work-free days.
</p>
</li>
</ul>
<p><strong>*</strong> <code class="reqn">W</code> = Workdays; <code class="reqn">F</code> = Work-free days.
</p>



<h4>For the shift version of the MCTQ</h4>

<p style="text-align: center;"><code class="reqn">\textrm{If } SD_W^{M/E/N} &gt; SD_F^{M/E/N} \; \&amp; \; SE_W^{M/E/N}
\leq SE_F^{M/E/N} \; , \; SJL_{sc}^{M/E/N} = | SE_F^{M/E/N} -
SE_W^{M/E/N} |</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Else } \; , \; | SJL_{sc}^{M/E/N} = SO_F^{M/E/N} -
SO_W^{M/E/N} |</code>
</p>

<p>Where:
</p>

<ul>
<li> <p><code class="reqn">SJL_{sc}^{M/E/N}</code> = Jankowski's sleep-corrected social jetlag in a
particular shift.
</p>
</li>
<li> <p><code class="reqn">SO_W^{M/E/N}</code> = Local time of sleep onset between two days in a
particular shift.
</p>
</li>
<li> <p><code class="reqn">SE_W^{M/E/N}</code> = Local time of sleep end between two days in a
particular shift.
</p>
</li>
<li> <p><code class="reqn">SO_F^{M/E/N}</code> = Local time of sleep onset between two free days after
a particular shift.
</p>
</li>
<li> <p><code class="reqn">SE_F^{M/E/N}</code> = Local time of sleep end between two free days after a
particular shift.
</p>
</li>
</ul>
<p><strong>*</strong> <code class="reqn">W</code> = Workdays; <code class="reqn">F</code> = Work-free days, <code class="reqn">M</code> =
Morning shift; <code class="reqn">E</code> = Evening shift; <code class="reqn">N</code> = Night shift.
</p>



<h3>Methods for computing the sleep-corrected social jetlag</h3>

<p>There are different approaches to compute the sleep-corrected social jetlag
(<code class="reqn">SJL_{sc}</code>). By default, <code>sjl_sc()</code> uses an approach that we
call "the shorter interval approach" (<code>"shorter"</code>).
</p>
<p>The topics below provide a simple explanation of each method supported by
<code>sjl_sc()</code>. To get a detail understating of this methods, see
<code>vignette("sjl-computation", package = "mctq")</code>.
</p>

<ul><li> <p><code>"difference"</code>
</p>
</li></ul>
<p>By using <code>method = "difference"</code>, <code>sjl_sc()</code> will do the exact computation
proposed by Jankowski, i.e., <code class="reqn">SJL_{sc}</code> will be computed as the
linear difference between <code class="reqn">SO_f</code>/<code class="reqn">SE_f</code> and <code class="reqn">SO_W</code>/<code class="reqn">SE_W</code>
(see the
Guidelines section).
</p>
<p><strong>We do not recommend using this method</strong>, as it has many limitations.
</p>

<ul><li> <p><code>"shorter"</code>
</p>
</li></ul>
<p>This is the default method for <code>sjl_sc()</code>. It's based on the shorter interval
between <code class="reqn">SO_f</code>/<code class="reqn">SE_f</code> and <code class="reqn">SO_W</code>/<code class="reqn">SE_W</code>, solving most of the
issues relating to <code class="reqn">SJL_{sc}</code> computation.
</p>

<ul><li> <p><code>"longer"</code>
</p>
</li></ul>
<p>The <code>"longer"</code> method uses the same logic of the <code>"shorter"</code> method, but,
instead of using the shorter interval between <code class="reqn">SO_f</code>/<code class="reqn">SE_f</code> and
<code class="reqn">SO_W</code>/<code class="reqn">SE_W</code>, it uses the longer interval between the two,
considering a two-day window.
</p>
<p>This method may help in special contexts, like when dealing with
shift-workers that have a greater than 12 hours distance between their
sleep hours.
</p>


<h3>References</h3>

<p>Ghotbi, N., Pilz, L. K., Winnebeck, E. C., Vetter, C., Zerbini, G., Lenssen,
D., Frighetto, G., Salamanca, M., Costa, R., Montagnese, S., &amp; Roenneberg, T.
(2020). The <code class="reqn">\mu</code>MCTQ: an ultra-short version of the Munich ChronoType
Questionnaire. <em>Journal of Biological Rhythms</em>, <em>35</em>(1), 98-110.
<a href="https://doi.org/10.1177/0748730419886986">doi:10.1177/0748730419886986</a>
</p>
<p>Jankowski K. S. (2017). Social jet lag: sleep-corrected formula.
<em>Chronobiology International</em>, <em>34</em>(4), 531-535.
<a href="https://doi.org/10.1080/07420528.2017.1299162">doi:10.1080/07420528.2017.1299162</a>
</p>
<p>Juda, M., Vetter, C., &amp; Roenneberg, T. (2013). The Munich ChronoType
Questionnaire for shift-workers (MCTQ<code class="reqn">^{Shift}</code>). <em>Journal of
Biological Rhythms</em>, <em>28</em>(2), 130-140. <a href="https://doi.org/10.1177/0748730412475041">doi:10.1177/0748730412475041</a>
</p>
<p>Roenneberg T., Allebrandt K. V., Merrow M., &amp; Vetter C. (2012). Social jetlag
and obesity. <em>Current Biology</em>, <em>22</em>(10), 939-43.
<a href="https://doi.org/10.1016/j.cub.2012.03.038">doi:10.1016/j.cub.2012.03.038</a>
</p>
<p>Roenneberg, T., Pilz, L. K., Zerbini, G., &amp; Winnebeck, E. C. (2019).
Chronotype and social jetlag: a (self-) critical review. <em>Biology</em>, <em>8</em>(3),
54. <a href="https://doi.org/10.3390/biology8030054">doi:10.3390/biology8030054</a>
</p>
<p>Roenneberg, T., Wirz-Justice, A., &amp; Merrow, M. (2003). Life between clocks:
daily temporal patterns of human chronotypes. <em>Journal of Biological
Rhythms</em>, <em>18</em>(1), 80-90. <a href="https://doi.org/10.1177/0748730402239679">doi:10.1177/0748730402239679</a>
</p>
<p>The Worldwide Experimental Platform (n.d.). MCTQ.
<a href="https://www.thewep.org/documentations/mctq/">https://www.thewep.org/documentations/mctq/</a>
</p>


<h3>See Also</h3>

<p>Other MCTQ functions: 
<code>fd()</code>,
<code>gu()</code>,
<code>le_week()</code>,
<code>msf_sc()</code>,
<code>msl()</code>,
<code>napd()</code>,
<code>sd24()</code>,
<code>sd_overall()</code>,
<code>sd_week()</code>,
<code>sdu()</code>,
<code>sjl_weighted()</code>,
<code>sjl()</code>,
<code>so()</code>,
<code>tbt()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Scalar example

so_w &lt;- hms::parse_hm("02:00")
se_w &lt;- hms::parse_hm("10:00")
so_f &lt;- hms::parse_hm("01:00")
se_f &lt;- hms::parse_hm("08:00")

sjl_sc(so_w, se_w, so_f, se_f)
#&gt; [1] "3600s (~1 hours)" # Expected
sjl_sc(so_w, se_w, so_f, se_f, abs = FALSE)
#&gt; [1] "-3600s (~-1 hours)" # Expected (negative sjl_sc)
sjl_sc_rel(so_w, se_w, so_f, se_f) # Wrapper function
#&gt; [1] "-3600s (~-1 hours)" # Expected (negative sjl_sc)
sjl(msl(so_w, sdu(so_w, se_w)), msl(so_f, sdu(so_f, se_f)))
#&gt; [1] "5400s (~1.5 hours)" # Expected

so_w &lt;- hms::parse_hm("22:00")
se_w &lt;- hms::parse_hm("06:00")
so_f &lt;- hms::parse_hm("01:00")
se_f &lt;- hms::parse_hm("06:00") # sd_w &gt; sd_f &amp; se_w &lt;= se_f

sjl_sc(so_w, se_w, so_f, se_f) # sjl_sc = | se_f - se_w |
#&gt; [1] "0s" # Expected
sjl_sc(so_w, se_w, so_f, se_f, abs = FALSE)
#&gt; [1] "0s" # Expected
sjl_sc_rel(so_w, se_w, so_f, se_f) # Wrapper function
#&gt; [1] "0s" # Expected
sjl(msl(so_w, sdu(so_w, se_w)), msl(so_f, sdu(so_f, se_f)))
#&gt; [1] "5400s (~1.5 hours)" # Expected

so_f &lt;- hms::as_hms(NA)

sjl_sc(so_w, se_w, so_f, se_f)
#&gt; [1] NA # Expected

## Vector example

so_w &lt;- c(hms::parse_hm("00:00"), hms::parse_hm("01:00"))
se_w &lt;- c(hms::parse_hm("08:00"), hms::parse_hm("07:00"))
so_f &lt;- c(hms::parse_hm("01:00"), hms::parse_hm("01:00"))
se_f &lt;- c(hms::parse_hm("09:00"), hms::parse_hm("09:00"))

sjl_sc(so_w, se_w, so_f, se_f)
#&gt; [1] "3600s (~1 hours)" "0s" # Expected
sjl_sc(so_w, se_w, so_f, se_f, abs = FALSE)
#&gt; [1] "3600s (~1 hours)" "0s" # Expected
sjl_sc_rel(so_w, se_w, so_f, se_f) # Wrapper function
#&gt; [1] "3600s (~1 hours)" "0s" # Expected
sjl(msl(so_w, sdu(so_w, se_w)), msl(so_f, sdu(so_f, se_f)))
#&gt; [1] "3600s (~1 hours)" "3600s (~1 hours)" # Expected

## See other examples in '?sjl()'
</code></pre>


</div>