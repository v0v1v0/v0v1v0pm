<div class="container">

<table style="width: 100%;"><tr>
<td>sjl_weighted</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute MCTQ absolute social jetlag across all shifts</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt="[Maturing]"></a>
</p>
<p><code>sjl_weighted()</code> computes the <strong>absolute social jetlag across all shifts</strong>
for the shift version of the Munich ChronoType Questionnaire (MCTQ).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sjl_weighted(sjl, n_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sjl</code></td>
<td>
<p>A <code>list</code> object with
<code>Duration</code> elements corresponding to the <strong>social
jetlag in each shift</strong> from a shift version of the MCTQ questionnaire (you
can use <code>sjl()</code> to compute it). <code>sjl</code> elements and values must be
paired with <code>n</code> elements and values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_w</code></td>
<td>
<p>A <code>list</code> object with
integerish <code>integer</code> or
<code>double</code> elements corresponding to the <strong>number of days
worked in each shift within a shift cycle</strong> from a shift version of the
MCTQ questionnaire. <code>n</code> elements and values must be paired with <code>sjl</code>
elements and values.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Standard MCTQ</strong> functions were created following the guidelines in
Roenneberg, Wirz-Justice, &amp; Merrow (2003), Roenneberg, Allebrandt, Merrow, &amp;
Vetter (2012), and from The Worldwide Experimental Platform (theWeP, n.d.).
</p>
<p><strong><code class="reqn">\mu</code>MCTQ</strong> functions were created following the guidelines in Ghotbi
et al. (2020), in addition to the guidelines used for the standard MCTQ.
</p>
<p><strong>MCTQ<code class="reqn">^{Shift}</code></strong> functions were created following the
guidelines in Juda, Vetter, &amp; Roenneberg (2013), in addition to the
guidelines used for the standard MCTQ.
</p>
<p>See the References section to learn more.
</p>


<h4>Class requirements</h4>

<p>The <code>mctq</code> package works with a set of object classes specially created to
hold time values. These classes can be found in the
lubridate and hms
packages. Please refer to those package documentations to learn more about
them.
</p>



<h4>Rounding and fractional time</h4>

<p>Some operations may produce an output with fractional time (e.g.,
<code>"19538.3828571429s (~5.43 hours)"</code>, <code>01:15:44.505</code>). If you want, you
can round it with <code>round_time()</code>.
</p>
<p>Our recommendation is to avoid rounding, but, if you do, make sure that you
only round your values after all computations are done. That way you avoid
<a href="https://en.wikipedia.org/wiki/Round-off_error">round-off errors</a>.
</p>



<h3>Value</h3>

<p>A <code>Duration</code> object corresponding to the
vectorized weighted mean of <code>sjl</code> with <code>n_w</code> as weights.
</p>


<h3>Operation</h3>

<p>The shift version of the MCTQ was developed for shift-workers rotating
through morning-, evening-, and night-shifts, but it also allows adaptations
to other shift schedules (Juda, Vetter, &amp; Roenneberg, 2013). For this reason,
<code>sjl_weighted()</code> must operate with any shift combination.
</p>
<p>Considering the requirement above, <code>sjl_weighted()</code> was developed to only
accept <code>list</code> objects as arguments. For this approach to
work, both <code>sjl</code> and <code>n_w</code> arguments must be lists with paired elements and
values, i.e., the first element of <code>sjl</code> (e.g., <code>sjl_m</code>) must be paired with
the first element of <code>n_w</code> (e.g., <code>n_w_m</code>). The function will do the work of
combining them and output a weighted mean.
</p>


<h3>Guidelines</h3>

<p>Juda, Vetter, &amp; Roenneberg (2013) and The Worldwide Experimental Platform
(n.d.) guidelines for <code>sjl_weighted()</code> (<code class="reqn">\emptyset
SJL_{weighted}</code>) computation are as follows.
</p>


<h4>Notes</h4>


<ul>
<li>
<p> The absolute social jetlag across all shifts (<code class="reqn">\emptyset
SJL_{weighted}</code>) is the weighted average of all absolute
social jetlags.
</p>
</li>
<li>
<p> The authors describe an equation for a three-shift schedule, but this may
not be your case. That's why this function works a little bit differently
(see the Operation section), allowing you to compute a weighted average with
any shift combination.
</p>
</li>
<li>
<p> If you are visualizing this documentation in plain text, you may have some
trouble understanding the equations. You can see this documentation on the
package <a href="https://docs.ropensci.org/mctq/reference/">website</a>.
</p>
</li>
</ul>
<h4>Computation</h4>

<p style="text-align: center;"><code class="reqn">\emptyset SJL_{weighted} = \frac{(| SJL^{M} | \times n_{W}^{M}) +
(| SJL^{E} | \times n_{W}^{E}) + (| SJL^{N} | \times n_{W}^{N})}{n_{W}^{M} +
n_{W}^{E} + n_{W}^{N}}</code>
</p>

<p>Where:
</p>

<ul>
<li> <p><code class="reqn">\emptyset SJL_{weighted}</code> = Absolute social jetlag across all shifts.
</p>
</li>
<li> <p><code class="reqn">SJL^{M/E/N}</code> = Absolute social jetlag in each shift.
</p>
</li>
<li> <p><code class="reqn">n_{W}^{M/E/N}</code> = Number of days worked in each shift within a shift
cycle.
</p>
</li>
</ul>
<p><strong>*</strong> <code class="reqn">W</code> = Workdays; <code class="reqn">F</code> = Work-free days, <code class="reqn">M</code> =
Morning shift; <code class="reqn">E</code> = Evening shift; <code class="reqn">N</code> = Night shift.
</p>



<h3>References</h3>

<p>Ghotbi, N., Pilz, L. K., Winnebeck, E. C., Vetter, C., Zerbini, G., Lenssen,
D., Frighetto, G., Salamanca, M., Costa, R., Montagnese, S., &amp; Roenneberg, T.
(2020). The <code class="reqn">\mu</code>MCTQ: an ultra-short version of the Munich ChronoType
Questionnaire. <em>Journal of Biological Rhythms</em>, <em>35</em>(1), 98-110.
<a href="https://doi.org/10.1177/0748730419886986">doi:10.1177/0748730419886986</a>
</p>
<p>Juda, M., Vetter, C., &amp; Roenneberg, T. (2013). The Munich ChronoType
Questionnaire for shift-workers (MCTQ<code class="reqn">^{Shift}</code>). <em>Journal of
Biological Rhythms</em>, <em>28</em>(2), 130-140. <a href="https://doi.org/10.1177/0748730412475041">doi:10.1177/0748730412475041</a>
</p>
<p>Roenneberg T., Allebrandt K. V., Merrow M., &amp; Vetter C. (2012). Social jetlag
and obesity. <em>Current Biology</em>, <em>22</em>(10), 939-43.
<a href="https://doi.org/10.1016/j.cub.2012.03.038">doi:10.1016/j.cub.2012.03.038</a>
</p>
<p>Roenneberg, T., Wirz-Justice, A., &amp; Merrow, M. (2003). Life between clocks:
daily temporal patterns of human chronotypes. <em>Journal of Biological
Rhythms</em>, <em>18</em>(1), 80-90. <a href="https://doi.org/10.1177/0748730402239679">doi:10.1177/0748730402239679</a>
</p>
<p>The Worldwide Experimental Platform (n.d.). MCTQ.
<a href="https://www.thewep.org/documentations/mctq/">https://www.thewep.org/documentations/mctq/</a>
</p>


<h3>See Also</h3>

<p>Other MCTQ functions: 
<code>fd()</code>,
<code>gu()</code>,
<code>le_week()</code>,
<code>msf_sc()</code>,
<code>msl()</code>,
<code>napd()</code>,
<code>sd24()</code>,
<code>sd_overall()</code>,
<code>sd_week()</code>,
<code>sdu()</code>,
<code>sjl_sc()</code>,
<code>sjl()</code>,
<code>so()</code>,
<code>tbt()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Scalar example

sjl &lt;- list(sjl_m = lubridate::dhours(1.25),
            sjl_e = lubridate::dhours(0.5),
            sjl_n = lubridate::dhours(3))
n_w &lt;- list(n_w_m = 3, n_w_e = 1, n_w_n = 4)
sjl_weighted(sjl, n_w)
#&gt; [1] "7312.5s (~2.03 hours)" # Expected

sjl &lt;- list(sjl_m = lubridate::dhours(1.25),
            sjl_e = lubridate::as.duration(NA),
            sjl_n = lubridate::dhours(3))
n_w &lt;- list(n_w_m = 3, n_w_e = 1, n_w_n = 4)
sjl_weighted(sjl, n_w)
#&gt; [1] NA # Expected

## Vector example

sjl &lt;- list(sjl_m = c(lubridate::dhours(2), lubridate::dhours(2.45)),
            sjl_e = c(lubridate::dhours(3.21), lubridate::as.duration(NA)),
            sjl_n = c(lubridate::dhours(1.2), lubridate::dhours(5.32)))
n_w &lt;- list(n_w_m = c(1, 3), n_w_e = c(4, 1), n_w_n = c(3, 3))
sjl_weighted(sjl, n_w)
#&gt; [1] "8298s (~2.31 hours)" NA # Expected

## Checking the first output from vector example

if (requireNamespace("stats", quietly = TRUE)) {
    i &lt;- 1
    x &lt;- c(sjl[["sjl_m"]][i], sjl[["sjl_e"]][i], sjl[["sjl_n"]][i])
    w &lt;- c(n_w[["n_w_m"]][i], n_w[["n_w_e"]][i], n_w[["n_w_n"]][i])
    lubridate::as.duration(stats::weighted.mean(x, w))
}
#&gt; [1] "8298s (~2.31 hours)" # Expected

## Converting the output to hms

sjl &lt;- list(sjl_m = lubridate::dhours(0.25),
            sjl_e = lubridate::dhours(1.2),
            sjl_n = lubridate::dhours(4.32))
n_w &lt;- list(n_w_m = 4, n_w_e = 2, n_w_n = 1)

sjl_weighted(sjl, n_w)
#&gt; [1] "3970.28571428571s (~1.1 hours)" # Expected

hms::as_hms(as.numeric(sjl_weighted(sjl, n_w)))
#&gt; 01:06:10.285714 # Expected

## Rounding the output at the seconds level

round_time(sjl_weighted(sjl, n_w))
#&gt; [1] "3970s (~1.1 hours)" # Expected

round_time(hms::as_hms(as.numeric(sjl_weighted(sjl, n_w))))
#&gt; 01:06:10 # Expected
</code></pre>


</div>