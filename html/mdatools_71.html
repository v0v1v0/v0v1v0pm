<div class="container">

<table style="width: 100%;"><tr>
<td>ipls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Variable selection with interval PLS</h2>

<h3>Description</h3>

<p>Applies iPLS algorithm to find variable intervals most important for
prediction.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ipls(
  x,
  y,
  glob.ncomp = 10,
  center = TRUE,
  scale = FALSE,
  cv = list("ven", 10),
  exclcols = NULL,
  exclrows = NULL,
  int.ncomp = glob.ncomp,
  int.num = NULL,
  int.width = NULL,
  int.limits = NULL,
  int.niter = NULL,
  ncomp.selcrit = "min",
  method = "forward",
  x.test = NULL,
  y.test = NULL,
  silent = FALSE,
  full = FALSE,
  cv.scope = "local"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix with predictor values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a vector with response values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glob.ncomp</code></td>
<td>
<p>maximum number of components for a global PLS model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>logical, center or not the data values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>logical, standardize or not the data values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv</code></td>
<td>
<p>cross-validation settings (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclcols</code></td>
<td>
<p>columns of x to be excluded from calculations (numbers, names or vector with logical values).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclrows</code></td>
<td>
<p>rows to be excluded from calculations (numbers, names or vector with logical values).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.ncomp</code></td>
<td>
<p>maximum number of components for interval PLS models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.num</code></td>
<td>
<p>number of intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.width</code></td>
<td>
<p>width of intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.limits</code></td>
<td>
<p>a two column matrix with manual intervals specification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.niter</code></td>
<td>
<p>maximum number of iterations (if NULL it will be the smallest of two values: number of intervals and 30).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp.selcrit</code></td>
<td>
<p>criterion for selecting optimal number of components ('min' for minimum of RMSECV).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>iPLS method (<code>'forward'</code> or <code>'backward'</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.test</code></td>
<td>
<p>matrix with predictors for test set (by default is NULL, if specified, is used instead of cv).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.test</code></td>
<td>
<p>matrix with responses for test set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>logical, show or not information about selection process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>logical, if TRUE the procedure will continue even if no improvements is observed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.scope</code></td>
<td>
<p>scope for center/scale operations inside CV loop: 'global' — using globally computed mean and std
or 'local' — recompute new for each local calibration set.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm splits the predictors into several intervals and tries to find a combination
of the intervals, which gives best prediction performance. There are two selection methods:
"forward" when the intervals are successively included, and "backward" when the intervals
are successively excluded from a model. On the first step the algorithm finds the best
(forward) or the worst (backward) individual interval. Then it tests the others to find the
one which gives the best model in a combination with the already selected/excluded one. The
procedure continues until no improvements is observed or the maximum number of iteration
is reached.
</p>
<p>There are several ways to specify the intervals. First of all either number of intervals
(<code>int.num</code>) or width of the intervals (<code>int.width</code>) can be provided. Alternatively
one can specify the limits (first and last variable number) of the intervals manually
with <code>int.limits</code>.
</p>
<p>Cross-validation settings, <code>cv</code>, can be a number or a list. If <code>cv</code> is a number, it
will be used as a number of segments for random cross-validation (if <code>cv = 1</code>, full
cross-validation will be preformed). If it is a list, the following syntax can be used:
<code>cv = list('rand', nseg, nrep)</code> for random repeated cross-validation with <code>nseg</code>
segments and <code>nrep</code> repetitions or <code>cv = list('ven', nseg)</code> for systematic splits
to <code>nseg</code> segments ('venetian blinds').
</p>


<h3>Value</h3>

<p>object of 'ipls' class with several fields, including:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>var.selected</code></td>
<td>
<p>a vector with indices of selected variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.selected</code></td>
<td>
<p>a vector with indices of selected intervals </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.num</code></td>
<td>
<p>total number of intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.width</code></td>
<td>
<p>width of the intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.limits</code></td>
<td>
<p>a matrix with limits for each interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.stat</code></td>
<td>
<p>a data frame with statistics for the selection algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glob.stat</code></td>
<td>
<p>a data frame with statistics for the first step (individual intervals)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gm</code></td>
<td>
<p>global PLS model with all variables included</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>om</code></td>
<td>
<p>optimized PLS model with selected variables</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>[1] Lars Noergaard at al.  Interval partial least-squares regression (iPLS): a
comparative chemometric study with an example from near-infrared spectroscopy.
Appl.Spec. 2000; 54: 413-419
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(mdatools)

## forward selection for simdata

data(simdata)
Xc = simdata$spectra.c
yc = simdata$conc.c[, 3, drop = FALSE]

# run iPLS and show results
im = ipls(Xc, yc, int.ncomp = 5, int.num = 10, cv = 4, method = "forward")
summary(im)
plot(im)

# show "developing" of RMSECV during the algorithm execution
plotRMSE(im)

# plot predictions before and after selection
par(mfrow = c(1, 2))
plotPredictions(im$gm)
plotPredictions(im$om)

# show selected intervals on spectral plot
ind = im$var.selected
mspectrum = apply(Xc, 2, mean)
plot(simdata$wavelength, mspectrum, type = 'l', col = 'lightblue')
points(simdata$wavelength[ind], mspectrum[ind], pch = 16, col = 'blue')

</code></pre>


</div>