<div class="container">

<table style="width: 100%;"><tr>
<td>mdmb_regression</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Several Regression Models with Prior Distributions and Sampling Weights
</h2>

<h3>Description</h3>

<p>Several regression functions which allow for sampling weights and
prior distributions.
</p>
<p>The function <code>yjt_regression</code> performs a linear regression in which the
response variable is transformed according to the Yeo-Johnson transformation
(Yeo &amp; Johnson, 2000; see <code>yjt_dist</code>) and the residuals are
distributed following the scaled <code class="reqn">t</code> distribution. The degrees of freedom
of the <code class="reqn">t</code> distribution can be fixed or estimated (<code>est_df=TRUE</code>).
The function <code>bct_regression</code> has same functionality like the
Yeo-Johnson transformation but employs a Box-Cox transformation
of the outcome variable.
</p>
<p>The Yeo-Johnson transformation can be extended by a probit transformation
(<code>probit=TRUE</code>) to cover the case of bounded variables on <code class="reqn">[0,1]</code>.
</p>
<p>The function <code>logistic_regression</code> performs logistic regression
for dichotomous data.
</p>
<p>The function <code>oprobit_regression</code> performs ordinal probit regression
for ordinal polytomous data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">#---- linear regression with Yeo-Johnson transformed scaled t distribution
yjt_regression(formula, data, weights=NULL, beta_init=NULL, beta_prior=NULL,
        df=Inf, lambda_fixed=NULL, probit=FALSE, est_df=FALSE, df_min=0.5, df_max=100,
        use_grad=2, h=1e-5, optimizer="optim", maxiter=300, control=NULL)

## S3 method for class 'yjt_regression'
coef(object, ...)
## S3 method for class 'yjt_regression'
logLik(object, ...)
## S3 method for class 'yjt_regression'
predict(object, newdata=NULL, trafo=TRUE,  ...)
## S3 method for class 'yjt_regression'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'yjt_regression'
vcov(object, ...)

#---- linear regression with Box-Cox transformed scaled t distribution
bct_regression(formula, data, weights=NULL, beta_init=NULL, beta_prior=NULL,
        df=Inf, lambda_fixed=NULL, est_df=FALSE, use_grad=2, h=1e-5,
        optimizer="optim", maxiter=300, control=NULL)

## S3 method for class 'bct_regression'
coef(object, ...)
## S3 method for class 'bct_regression'
logLik(object, ...)
## S3 method for class 'bct_regression'
predict(object, newdata=NULL, trafo=TRUE, ...)
## S3 method for class 'bct_regression'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'bct_regression'
vcov(object, ...)

#---- logistic regression
logistic_regression(formula, data, weights=NULL, beta_init=NULL,
         beta_prior=NULL, use_grad=2, h=1e-5, optimizer="optim", maxiter=300,
         control=NULL)

## S3 method for class 'logistic_regression'
coef(object, ...)
## S3 method for class 'logistic_regression'
logLik(object, ...)
## S3 method for class 'logistic_regression'
predict(object, newdata=NULL, ...)
## S3 method for class 'logistic_regression'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'logistic_regression'
vcov(object, ...)

#---- ordinal probit regression
oprobit_regression(formula, data, weights=NULL, beta_init=NULL,
        use_grad=2, h=1e-5, optimizer="optim", maxiter=300,
        control=NULL, control_optim_fct=NULL)

## S3 method for class 'oprobit_regression'
coef(object, ...)
## S3 method for class 'oprobit_regression'
logLik(object, ...)
## S3 method for class 'oprobit_regression'
predict(object, newdata=NULL, ...)
## S3 method for class 'oprobit_regression'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'oprobit_regression'
vcov(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>Formula
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Data frame. The dependent variable must be coded as 0 and 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional vector of sampling weights
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_init</code></td>
<td>

<p>Optional vector of initial regression coefficients
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_prior</code></td>
<td>
<p>Optional list containing priors of all parameters
(see Examples for definition of this list).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Fixed degrees of freedom for scaled <code class="reqn">t</code> distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_fixed</code></td>
<td>
<p>Optional fixed value for <code class="reqn">\lambda</code> for scaled
<code class="reqn">t</code> distribution with Yeo-Johnson transformation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probit</code></td>
<td>
<p>Logical whether probit transformation should be employed for
bounded outcome in <code>yjt_regression</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est_df</code></td>
<td>
<p>Logical indicating whether degrees of freedom in
<code class="reqn">t</code> distribution should be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df_min</code></td>
<td>
<p>Minimum value for estimated degrees of freedom</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df_max</code></td>
<td>
<p>Maximum value for estimated degrees of freedom</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_grad</code></td>
<td>
<p>Computation method for gradients in <code>stats::optim</code>.
The value <code>0</code> is the internal approximation of
<code>stats::optim</code> and applies the settings in <span class="pkg">mdmb</span> (<code class="reqn">\le</code>0.3).
The specification <code>use_grad=1</code> uses the calculation of
the gradient in <code>CDM::numerical_Hessian</code>. The value <code>2</code> is
usually the most efficient calculation of the gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Numerical differentiation parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>Type of optimizer to be chosen. Options are
<code>"nlminb"</code> (<code>stats::nlminb</code>) and
the default <code>"optim"</code> (<code>stats::optim</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>Maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>Optional arguments to be passed to optimization function
(<code>stats::nlminb</code>) or
<code>stats::optim</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control_optim_fct</code></td>
<td>
<p>Optional control argument for gradient in
optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object of class <code>logistic_regression</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Design matrix for <code>predict</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trafo</code></td>
<td>
<p>Logical indicating whether fitted values should be on the
transformed metric (<code>trafo=TRUE</code>) or the original metric
(<code>trafo=FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits for rounding</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>File name if the <code>summary</code> output should be sunk into a file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List containing values
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>Estimated regression coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>Estimated covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partable</code></td>
<td>
<p>Parameter table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector of values of dependent variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xdes</code></td>
<td>
<p>Design matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Sampling weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>Fitted values in metric of probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.predictor</code></td>
<td>
<p>Fitted values in metric of logits</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike</code></td>
<td>
<p>Log likelihood value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logprior</code></td>
<td>
<p>Log prior value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logpost</code></td>
<td>
<p>Log posterior value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike_case</code></td>
<td>
<p>Case-wise likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>Information criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R2</code></td>
<td>
<p>Pseudo R-square value according to McKelvey and Zavoina</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Alexander Robitzsch
</p>


<h3>References</h3>

<p>McKelvey, R., &amp; Zavoina, W. (1975). A statistical model for the analysis of
ordinal level dependent variables.
<em>Journal of Mathematical Sociology, 4</em>(1), 103-120.
<a href="https://doi.org/10.1080/0022250X.1975.9989847">doi:10.1080/0022250X.1975.9989847</a>
</p>
<p>Yeo, I.-K., &amp; Johnson, R. (2000). A new family of power transformations to
improve normality or symmetry. <em>Biometrika, 87</em>(4), 954-959.
<a href="https://doi.org/10.1093/biomet/87.4.954">doi:10.1093/biomet/87.4.954</a>
</p>


<h3>See Also</h3>

<p>See <code>yjt_dist</code> or <code>car::yjPower</code>
for functions for the Yeo-Johnson transformation.
</p>
<p>See <code>stats::lm</code> and
<code>stats::glm</code> for linear and logistic
regression models.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
# EXAMPLE 1: Simulated example logistic regression
#############################################################################

#--- simulate dataset
set.seed(986)
N &lt;- 500
x &lt;- stats::rnorm(N)
y &lt;- 1*( stats::runif(N) &lt; stats::plogis( -0.8 + 1.2 * x ) )
data &lt;- data.frame( x=x, y=y )

#--- estimate logistic regression with mdmb::logistic_regression
mod1 &lt;- mdmb::logistic_regression( y ~ x, data=data )
summary(mod1)

## Not run: 
#--- estimate logistic regression with stats::glm
mod1b &lt;- stats::glm( y ~ x, data=data, family="binomial")
summary(mod1b)

#--- estimate logistic regression with prior distributions
b0 &lt;- list( "dnorm", list(mean=0, sd=100) )  # first parameter
b1 &lt;- list( "dcauchy", list(location=0, scale=2.5) )   # second parameter
beta_priors &lt;- list( b0, b1 )  # order in list defines priors for parameters
#* estimation
mod2 &lt;- mdmb::logistic_regression( y ~ x, data=data, beta_prior=beta_priors )
summary(mod2)

#############################################################################
# EXAMPLE 2: Yeo-Johnson transformed scaled t regression
#############################################################################

#*** create simulated data
set.seed(9865)
n &lt;- 1000
x &lt;- stats::rnorm(n)
y &lt;- .5 + 1*x + .7*stats::rt(n, df=8 )
y &lt;- mdmb::yj_antitrafo( y, lambda=.5 )
dat &lt;- data.frame( y=y, x=x )
# display data
graphics::hist(y)

#--- Model 1: fit regression model with transformed normal distribution (df=Inf)
mod1 &lt;- mdmb::yjt_regression( y ~ x, data=dat )
summary(mod1)

#--- Model 2: fit regression model with transformed scaled t distribution (df=10)
mod2 &lt;- mdmb::yjt_regression( y ~ x, data=dat, df=10)
summary(mod2)

#--- Model 3: fit regression model with transformed normal distribution (df=Inf)
#             and fixed transformation parameter lambda of .5
mod3 &lt;- mdmb::yjt_regression( y ~ x, data=dat, lambda_fixed=.5)
summary(mod3)

#--- Model 4: fit regression model with transformed normal distribution (df=Inf)
#             and fixed transformation parameter lambda of 1
#             -&gt; This model corresponds to least squares regression
mod4 &lt;- mdmb::yjt_regression( y ~ x, data=dat, lambda_fixed=1)
summary(mod4)

# fit with lm function
mod4b &lt;- stats::lm( y ~ x, data=dat )
summary(mod4b)

#--- Model 5: fit regression model with estimated degrees of freedom
mod5 &lt;- mdmb::yjt_regression( y ~ x, data=dat, est_df=TRUE)
summary(mod5)

#** compare log-likelihood values
logLik(mod1)
logLik(mod2)
logLik(mod3)
logLik(mod4)
logLik(mod4b)
logLik(mod5)

#############################################################################
# EXAMPLE 3: Regression with Box-Cox and Yeo-Johnson transformations
#############################################################################

#*** simulate data
set.seed(985)
n &lt;- 1000
x &lt;- stats::rnorm(n)
y &lt;- .5 + 1*x + stats::rnorm(n, sd=.7 )
y &lt;- mdmb::bc_antitrafo( y, lambda=.5 )
dat &lt;- data.frame( y=y, x=x )

#--- Model 1: fit regression model with Box-Cox transformation
mod1 &lt;- mdmb::bct_regression( y ~ x, data=dat )
summary(mod1)
#--- Model 2: fit regression model with Yeo-Johnson transformation
mod2 &lt;- mdmb::yjt_regression( y ~ x, data=dat )
summary(mod2)
#--- compare fit
logLik(mod1)
logLik(mod2)

#############################################################################
# EXAMPLE 4: Ordinal probit regression
#############################################################################

#--- simulate data
set.seed(987)
N &lt;- 1500
x &lt;- stats::rnorm(N)
z &lt;- stats::rnorm(N)
# regression coefficients
b0 &lt;- -.5 ; b1 &lt;- .6 ; b2 &lt;- .1
# vector of thresholds
thresh &lt;- c(-1, -.3, 1)
yast &lt;- b0 + b1 * x + b2*z + stats::rnorm(N)
y &lt;- as.numeric( cut( yast, c(-Inf,thresh,Inf) ) ) - 1
dat &lt;- data.frame( x=x, y=y, z=z )

#--- probit regression
mod &lt;- mdmb::oprobit_regression( formula=y ~ x + z + I(x*z), data=dat)
summary(mod)

## End(Not run)
</code></pre>


</div>