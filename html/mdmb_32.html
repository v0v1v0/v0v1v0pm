<div class="container">

<table style="width: 100%;"><tr>
<td>frm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Factored Regression Model: Generalized Linear Regression Model with Missing Covariates
</h2>

<h3>Description</h3>

<p>The factored regression model (FRM) allows the estimation of the linear regression model
(with normally distributed residuals) and the generalized logistic regression model
(logistic regression for dichotomous outcomes). Missing values in covariates are
handled by posing a conditional univariate distribution for each covariate. The
approach follows Ibrahim (1990), Ibrahim, Chen, Lipsitz and Herring (2005),
Lee and Mitra (2016), and Zhang and Wang (2017) and is applied in
Luedtke, Robitzsch, and West (2020a, 2020b). Latent variables
and covariates with measurement error or multiple indicators can also be handled
within this framework (see Examples 3, 4 and 5).
</p>
<p>Missing values are handled by numerical integration in <code>frm_em</code>
(see also Allison, 2012). The user has to specify an integration grid for each
variable (defined in argument <code>nodes</code> for each model).
</p>
<p>Standard error estimates in <code>frm_em</code> are obtained by a numerical differentiation of
the Fisher score function (see Jamshidian &amp; Jennrich, 2000).
</p>
<p>The function <code>frm_fb</code> employs a fully Bayesian approach with noninformative
prior distribution. This function imputes missing values in the models from
the posterior distributions. Imputed datasets can be extracted by the
function <code>frm2datlist</code>.
</p>
<p>The current functionality only support missing values on continuous covariates
(accommodating skewness and only positive values), dichotomous covariates and
ordinal covariates.
</p>
<p>Multilevel models (using <code>model="mlreg"</code>) for normally distributed
(<code>outcome="normal"</code>) and ordinal variables (<code>outcome="probit"</code>)
as well as variables at higher levels (using argument <code>variable_level</code>)
are accommodated. Note that multilevel models can only be fit with <code>frm_fb</code>
and not with <code>frm_em</code>.
</p>
<p>The handling of nominal covariates will be included in future
<span class="pkg">mdmb</span> package versions.
</p>


<h3>Usage</h3>

<pre><code class="language-R"># Factored regression model: Numerical integration with EM algorithm
frm_em(dat, dep, ind, weights=NULL, verbose=TRUE, maxiter=500, conv_dev=1e-08,
         conv_parm=1e-05, nodes_control=c(11,5), h=1e-04, use_grad=2,
        update_model=NULL)

## S3 method for class 'frm_em'
coef(object, ...)
## S3 method for class 'frm_em'
logLik(object, ...)
## S3 method for class 'frm_em'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'frm_em'
vcov(object, ...)

# Factored regression model: Fully Bayesian estimation
frm_fb(dat, dep, ind, weights=NULL, verbose=TRUE, data_init=NULL, iter=500,
        burnin=100, Nimp=10, Nsave=3000, refresh=25, acc_bounds=c(.45,.50),
        print_iter=10, use_gibbs=TRUE, aggregation=TRUE)

## S3 method for class 'frm_fb'
coef(object, ...)
## S3 method for class 'frm_fb'
plot(x, idparm=NULL, ask=TRUE, ... )
## S3 method for class 'frm_fb'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'frm_fb'
vcov(object, ...)

frm2datlist(object, as_mids=FALSE)  # create list of imputed datasets
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>Data frame
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dep</code></td>
<td>

<p>List containing model specification for dependent variable. The list
has arguments (see Examples)
</p>
<p><code>model</code>: String indicating the model type. Options are
<code>"linreg"</code> (wrapper to <code>stats::lm</code>
or <code>stats::lm.wfit</code>),
<code>"logistic"</code> for dichotomous variables (wrapper to
<code>logistic_regression</code>), <code>"oprobit"</code> for ordinal variables
(wrapper to <code>oprobit_regression</code>),
<code>"yjtreg"</code> for continuous variables and bounded variables on <code class="reqn">(0,1)</code>
(wrapper to <code>yjt_regression</code>),
<code>"bctreg"</code> for positive continuous variables
(wrapper to <code>bct_regression</code>),
<code>"mlreg"</code> for multilevel models with normally distributed and ordinal
data (wrapper to <code>miceadds::ml_mcmc</code>)
<br><code>formula</code>: An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> formula object. <br><code>nodes</code> (for <code>frm_em</code>): Vector containing the integration nodes <br><code>nodes_weights</code> (for <code>frm_em</code>):
Optional vector containing initial probabilities for each node <br><code>coef_inits</code>: Optional vector containing initial coefficient for the model <br><code>sigma_fixed</code>: Fixed standard deviations in case of <code>model="linreg"</code>.
Heterogeneous standard deviations are allowed. <br><code>R_args</code>: Arguments for estimation functions. <br><code>sampling_level</code>: Variable name for cluster identifiers for level for sampling values
for multilevel data. Sampling at level of clusters can be beneficials
if derived variables from cluster members (e.g., group means) occur
in multilevel models. The option is only applicable for <code>frm_fb</code>. <br><code>variable_level</code>: Cluster identifier indicating level of variable for imputations
of higher-level variables
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind</code></td>
<td>

<p>List containing a list of univariate conditional models for covariates.
See <code>dep</code> for more details on specification.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Optional vector of sampling weights
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical indicating whether convergence progress should be displayed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>

<p>Maximum number of iterations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv_dev</code></td>
<td>

<p>Convergence criterion for deviance
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv_parm</code></td>
<td>

<p>Convergence criterion for regression coefficients
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodes_control</code></td>
<td>
<p>Control arguments if nodes are not provided
by the user. The first value denote the number of nodes, while
the second value denotes the spread of the node distribution defined
as the factor of the standard deviation of the observed data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Step width for numerical differentiation for calculating the
covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_grad</code></td>
<td>
<p>Computation method for gradient in <code>yjt_regression</code>,
<code>bct_regression</code> or <code>logistic_regression</code>.
It can be <code>0</code> (compatible with <span class="pkg">mdmb</span> <code class="reqn">\le</code>0.3),
<code>1</code> or <code>2</code> (most efficient one).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update_model</code></td>
<td>
<p>Optional proviously fitted model can be used as an input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_init</code></td>
<td>
<p>Initial values for dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Number of burnin iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nimp</code></td>
<td>
<p>Number of imputed datasets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nsave</code></td>
<td>
<p>(Maximum) Number of values to be saved for MCMC chain</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refresh</code></td>
<td>
<p>Number of imputations after which proposal distribution
should be updated in Metropolis-Hastings step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acc_bounds</code></td>
<td>
<p>Bounds for acceptance rates for parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_iter</code></td>
<td>
<p>Number of imputation after which iteration progress
should be displayed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_gibbs</code></td>
<td>
<p>Logical indicating whether Gibbs sampling instead of
Metropolis-Hastings sampling should be used. Can be only
applied for <code>linreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregation</code></td>
<td>
<p>Logical indicating whether complete dataset should be
used for computing the predictive distribution of missing values.
<code>argument=TRUE</code> is often needed for multilevel data in which cluster
means are included in regression models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object of corresponding class</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of corresponding class</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits in <code>summary</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>File to which the <code>summary</code> should be linked</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idparm</code></td>
<td>
<p>Indices for parameters to be plotted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ask</code></td>
<td>
<p>Logical indicating whether the user is asked before new plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_mids</code></td>
<td>
<p>Logical indicating whether multiply imputed datasets
should be converted into objects of class <code>mids</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function allows for fitting a factored regression model. Consider the case
of three variables <code class="reqn">Y</code>, <code class="reqn">X</code> and <code class="reqn">Z</code>. A factored regression model
consists of a sequence of univariate conditional models <code class="reqn">P(Y|X,Z)</code>,
<code class="reqn">P(X|Z)</code> and <code class="reqn">P(Z)</code> such that the joint distribution can be factorized as
</p>
<p style="text-align: center;"><code class="reqn"> P(Y,X,Z)=P( Y|X,Z) P(X|Z) P(Z) </code>
</p>

<p>Each of the three variables can contain missing values. Missing values are
integrated out by posing a distributional assumption for each variable with
missing values.
</p>


<h3>Value</h3>

<p>For <code>frm_em</code> it is a list containing the following values
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>
<p>Estimated coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>Covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partable</code></td>
<td>
<p>Summary parameter table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_coefs</code></td>
<td>
<p>List with all estimated coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ll</code></td>
<td>
<p>Log likelihood value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>like</code></td>
<td>
<p>Individual likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>Data frame with included latent values for each variable with missing
values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>Standard errors for coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>Information matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>Convergence indicator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>Information criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind0</code></td>
<td>
<p>List with model specifications including <code>dep</code> and <code>ind</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictorMatrix</code></td>
<td>
<p>Predictor matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variablesMatrix</code></td>
<td>
<p>Matrix containing all variables appearing in statistical
models</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>desc_vars</code></td>
<td>
<p>Descriptive statistics of variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_results</code></td>
<td>
<p>Results from fitted models</p>
</td>
</tr>
</table>
<p>The output for <code>frm_fb</code> contains particular additional values
</p>
<table>
<tr style="vertical-align: top;">
<td><code>tech_summary</code></td>
<td>
<p>Summary table with informations about MCMC algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values_coda</code></td>
<td>
<p>Sampled parameter values saved as class <code>mcmc</code> for
analysis in <span class="pkg">coda</span> package</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parms_mcmc</code></td>
<td>
<p>Object containing informations of sampled parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>imputations_mcmc</code></td>
<td>
<p>Object containing informations of imputed datasets</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The <code>coef</code> and <code>vcov</code> methods can be used to extract coefficients and
the corresponding covariance matrix, respectively. Standard errors for a fitted
object <code>mod</code> can be extracted by making use of the <span class="pkg">survey</span>
package and the statement <code>survey::SE(mod)</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Robitzsch
</p>


<h3>References</h3>

<p>Allison, P. D. (2012). <em>Handling missing data by maximum likelihood</em>.
SAS Global Forum 2012.
</p>
<p>Bartlett, J. W., &amp; Morris, T. P. (2015) Multiple imputation of covariates by
substantive-model compatible fully conditional specification.
<em>Stata Journal, 15</em>(2), 437-456.
</p>
<p>Bartlett, J. W., Seaman, S. R., White, I. R., Carpenter, J. R., &amp; Alzheimer's Disease
Neuroimaging Initiative (2015). Multiple imputation of covariates by fully conditional
specification: Accommodating the substantive model.
<em>Statistical Methods in Medical Research, 24</em>(4), 462-487.
<a href="https://doi.org/10.1177/0962280214521348">doi:10.1177/0962280214521348</a>
</p>
<p>Erler, N. S., Rizopoulos, D., Rosmalen, J. V., Jaddoe, V. W., Franco, O. H., &amp;
Lesaffre, E. M. (2016). Dealing with missing covariates in epidemiologic studies:
A comparison between multiple
imputation and a full Bayesian approach. <em>Statistics in Medicine, 35</em>(17),
2955-2974. <a href="https://doi.org/10.1002/sim.6944">doi:10.1002/sim.6944</a>
</p>
<p>Ibrahim, J. G. (1990). Incomplete data in generalized linear models.
<em>Journal of the American Statistical Association, 85</em>(411), 765-769.
<a href="https://doi.org/10.1080/01621459.1990.10474938">doi:10.1080/01621459.1990.10474938</a>
</p>
<p>Ibrahim, J. G., Chen, M. H., Lipsitz, S. R., &amp; Herring, A. H. (2005).
Missing-data methods for generalized linear models: A comparative review.
<em>Journal of the American Statistical Association, 100</em>(469), 332-346.
<a href="https://doi.org/10.1198/016214504000001844">doi:10.1198/016214504000001844</a>
</p>
<p>Jamshidian, M., &amp; Jennrich, R. I. (2000). Standard errors for EM estimation.
<em>Journal of the Royal Statistical Society (Series B), 62</em>(2), 257-270.
<a href="https://doi.org/10.1111/1467-9868.00230">doi:10.1111/1467-9868.00230</a>
</p>
<p>Keller, B. T., &amp; Enders, C. K. (2018). <em>Blimp user's manual</em>. Los Angeles, CA. <br><em>http://www.appliedmissingdata.com/multilevel-imputation.html</em>
</p>
<p>Lee, M. C., &amp; Mitra, R. (2016). Multiply imputing missing values in data sets
with mixed measurement scales using a sequence of generalised linear models.
<em>Computational Statistics &amp; Data Analysis, 95</em>(24), 24-38.
<a href="https://doi.org/10.1016/j.csda.2015.08.004">doi:10.1016/j.csda.2015.08.004</a>
</p>
<p>Luedtke, O., Robitzsch, A., &amp; West, S. (2020a). Analysis of interactions and nonlinear
effects with missing data: A factored regression modeling approach using maximum
likelihood estimation. <em>Multivariate Behavioral Research, 55</em>(3), 361-381.
<a href="https://doi.org/10.1080/00273171.2019.1640104">doi:10.1080/00273171.2019.1640104</a>
</p>
<p>Luedtke, O., Robitzsch, A., &amp; West, S. (2020b). Regression models involving nonlinear
effects with missing data: A sequential modeling approach using Bayesian estimation.
<em>Psychological Methods, 25</em>(2), 157-181.
<a href="https://doi.org/10.1037/met0000233">doi:10.1037/met0000233</a>
</p>
<p>Zhang, Q., &amp; Wang, L. (2017). Moderation analysis with missing data in the predictors.
<em>Psychological Methods, 22</em>(4), 649-666.
<a href="https://doi.org/10.1037/met0000104">doi:10.1037/met0000104</a>
</p>


<h3>See Also</h3>

<p>See also the <span class="pkg">icdGLM</span> package for estimation of generalized
linear models with incomplete discrete covariates.
</p>
<p>The imputation of covariates in substantive models with interactions or nonlinear
terms can be also conducted with the <span class="pkg">JointAI</span> package which is a wrapper
to the JAGS software (see Erler et al., 2016). This package is also based on a sequential
modelling approach.
</p>
<p>The <span class="pkg">jomo</span> package also accommodates substantive models (<code>jomo::jomo.lm</code>)
based on a joint modeling framework.
</p>
<p>Substantive model compatible imputation based
on fully conditional specification can be found in the <span class="pkg">smcfcs</span> package
(see Bartlett et al., 2015; Bartlett &amp; Morris, 2015)
or the Blimp stand-alone software (Keller &amp; Enders, 2018).
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#############################################################################
# EXAMPLE 1: Simulated example linear regression with interaction effects
#############################################################################

# The interaction model stats::lm( Y ~ X + Z + X:Z) is of substantive interest.
# There can be missing values in all variables.

data(data.mb01)
dat &lt;- data.mb01$missing

#******************************************
# Model 1: ML approach

#--- specify models

# define integration nodes
xnodes &lt;- seq(-4,4,len=11)        # nodes for X
ynodes &lt;- seq(-10,10,len=13)
  # nodes for Y. These ynodes are not really necessary for this dataset because
  # Y has no missing values.

# define model for dependent variable Y
dep &lt;- list("model"="linreg", "formula"=Y ~  X*Z, "nodes"=ynodes )

# model P(X|Z)
ind_X &lt;- list( "model"="linreg", "formula"=X ~ Z, "nodes"=xnodes )
# all models for covariates
ind &lt;- list( "X"=ind_X )

#--- estimate model with numerical integration
mod1 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind )
summary(mod1)

# extract some informations
coef(mod1)
vcov(mod1)
logLik(mod1)

#******************************************
# Model 2: Fully Bayesian approach / Multiple Imputation

#--- define models
dep &lt;- list("model"="linreg", "formula"=Y ~  X*Z )
ind_X &lt;- list( "model"="linreg", "formula"=X ~ Z  )
ind_Z &lt;- list( "model"="linreg", "formula"=Z ~ 1  )
ind &lt;- list( "X"=ind_X, Z=ind_Z)

#--- estimate model
mod2 &lt;- mdmb::frm_fb(dat, dep, ind, burnin=200, iter=1000)
summary(mod2)
#* plot parameters
plot(mod2)

#--- create list of multiply imputed datasets
datlist &lt;- mdmb::frm2datlist(mod2)
# convert into object of class mids
imp2 &lt;- miceadds::datlist2mids(datlist)
# estimate linear model on multiply imputed datasets
mod2c &lt;- with(imp2, stats::lm( Y ~ X*Z ) )
summary( mice::pool(mod2c) )

#******************************************
# Model 3: Multiple imputation in jomo package

library(jomo)

# impute with substantive model containing interaction effects
formula &lt;- Y ~ X*Z
imp &lt;- jomo::jomo.lm( formula=formula, data=dat, nburn=100, nbetween=100)

# convert to object of class mids
datlist &lt;- miceadds::jomo2mids( imp )
# estimate linear model
mod3 &lt;- with(datlist, lm( Y ~ X*Z ) )
summary( mice::pool(mod3) )

#############################################################################
# EXAMPLE 2: Simulated example logistic regression with interaction effects
#############################################################################

# Interaction model within a logistic regression Y ~ X + Z + X:Z
# Y and Z are dichotomous variables.

# attach data
data(data.mb02)
dat &lt;- data.mb02$missing

#******************************************
# Model 1: ML approach

#--- specify model

# define nodes
xnodes &lt;- seq(-5,5,len=15)  # X - normally distributed variable
ynodes &lt;- c(0,1)                # Y and Z dichotomous variable

# model P(Y|X,Z) for dependent variable
dep &lt;- list("model"="logistic", "formula"=Y ~  X*Z, "nodes"=ynodes )
# model P(X|Z)
ind_X &lt;- list( "model"="linreg", "formula"=X ~ Z, "nodes"=xnodes )
# model P(Z)
ind_Z &lt;- list( "model"="logistic", "formula"=Z ~ 1, "nodes"=ynodes )
ind &lt;- list(  "Z"=ind_Z, "X"=ind_X )

#--- estimate model with numerical integration
mod1 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind )
summary(mod1)

#******************************************
# Model 2: Fully Bayesian approach

#--- specify model
dep &lt;- list("model"="logistic", "formula"=Y ~  X*Z  )
ind_X &lt;- list( "model"="linreg", "formula"=X ~ Z )
ind_Z &lt;- list( "model"="logistic", "formula"=Z ~ 1 )
ind &lt;- list(  "Z"=ind_Z, "X"=ind_X )

#--- Bayesian estimation
mod2 &lt;- mdmb::frm_fb(dat=dat, dep=dep, ind=ind, burnin=500, iter=1000 )
summary(mod2)

#############################################################################
# EXAMPLE 3: Confirmatory factor analysis
#############################################################################

# A latent variable can be considered as missing data and the 'frm_em' function
# is used to estimate the latent variable model.

#--- simulate data
N &lt;- 1000
set.seed(91834)
# latent variable
theta &lt;- stats::rnorm(N)
# simulate items
y1 &lt;- 1.5 + 1*theta + stats::rnorm(N, sd=.7 )
y2 &lt;- 1.9 + .7*theta + stats::rnorm(N, sd=1 )
y3 &lt;- .9 + .7*theta + stats::rnorm(N, sd=.2 )
dat &lt;- data.frame(y1,y2,y3)
dat$theta &lt;- NA

#******************************************
# Model 1: ML approach

#--- define model
nodes &lt;- seq(-4,4,len=21)
ind_y1 &lt;- list("model"="linreg", "formula"=y1 ~  offset(1*theta),
                "nodes"=nodes )
ind_y2 &lt;- list( "model"="linreg", "formula"=y2 ~ theta, "nodes"=nodes,
                "coef_inits"=c(NA,1) )
ind_y3 &lt;- list( "model"="linreg", "formula"=y3 ~ theta, "nodes"=nodes,
                 "coef_inits"=c(1,1) )
dep &lt;- list( "model"="linreg", "formula"=theta ~ 0, "nodes"=nodes )
ind &lt;- list( "y1"=ind_y1,  "y2"=ind_y2, "y3"=ind_y3)

#*** estimate model with mdmb::frm_em
mod1 &lt;- mdmb::frm_em(dat, dep, ind)
summary(mod1)

#*** estimate model in lavaan
library(lavaan)
lavmodel &lt;- "
     theta=~ 1*y1 + y2 + y3
     theta ~~ theta
     "
mod1b &lt;- lavaan::cfa( model=lavmodel, data=dat )
summary(mod1b)

# compare likelihood
logLik(mod1)
logLik(mod1b)

#############################################################################
# EXAMPLE 4: Rasch model
#############################################################################

#--- simulate data
set.seed(91834)
N &lt;- 500
# latent variable
theta0 &lt;- theta &lt;- stats::rnorm(N)
# number of items
I &lt;- 7
dat &lt;- sirt::sim.raschtype( theta, b=seq(-1.5,1.5,len=I) )
colnames(dat) &lt;- paste0("I",1:I)
dat$theta &lt;- NA

#******************************************
# Model 1: ML approach

#--- define model
nodes &lt;- seq(-4,4,len=13)
dep &lt;- list("model"="linreg", "formula"=theta ~  0, "nodes"=nodes )
ind &lt;- list()
for (ii in 1:I){
    ind_ii &lt;- list( "model"="logistic", formula=
                 stats::as.formula( paste0("I",ii, " ~ offset(1*theta)") ) )
    ind[[ii]] &lt;- ind_ii
}
names(ind) &lt;- colnames(dat)[-(I+1)]

#--- estimate Rasch model with mdmb::frm_em
mod1 &lt;- mdmb::frm_em(dat, dep, ind )
summary(mod1)

#--- estmate Rasch model with sirt package
library(sirt)
mod2 &lt;- sirt::rasch.mml2( dat[,-(I+1)], theta.k=nodes, use.freqpatt=FALSE)
summary(mod2)

#** compare estimated parameters
round(cbind(coef(mod1), c( mod2$sd.trait, -mod2$item$thresh[ seq(I,1)] ) ), 3)

#############################################################################
# EXAMPLE 5: Regression model with measurement error in covariates
#############################################################################

#--- simulate data
set.seed(768)
N &lt;- 1000
# true score
theta &lt;- stats::rnorm(N)
# heterogeneous error variance
var_err &lt;- stats::runif(N, .5, 1)
# simulate observed score
x &lt;- theta + stats::rnorm(N, sd=sqrt(var_err) )
# simulate outcome
y &lt;- .3 + .7 * theta + stats::rnorm( N, sd=.8 )
dat0 &lt;- dat &lt;- data.frame( y=y, x=x, theta=theta )

#*** estimate model with true scores (which are unobserved in real datasets)
mod0 &lt;- stats::lm( y ~ theta, data=dat0 )
summary(mod0)

#******************************************
# Model 1: Model-based approach

#--- specify model
dat$theta &lt;- NA
nodes &lt;- seq(-4,4,len=15)
dep &lt;- list( "model"="linreg", "formula"=y ~ theta, "nodes"=nodes,
                "coef_inits"=c(NA, .4 ) )
ind &lt;- list()
ind[["theta"]] &lt;- list( "model"="linreg", "formula"=theta ~ 1,
                         "nodes"=nodes  )
ind[["x"]] &lt;- list( "model"="linreg", "formula"=x ~ 0 + offset(theta),
                        "nodes"=nodes )
# assumption of heterogeneous known error variance
ind[["x"]]$sigma_fixed &lt;- sqrt( var_err )

#--- estimate regression model
mod1 &lt;- mdmb::frm_em(dat, dep, ind )
summary(mod1)

#******************************************
# Model 2: Fully Bayesian estimation

#--- specify model
dep &lt;- list( "model"="linreg", "formula"=y ~ theta )
ind &lt;- list()
ind[["theta"]] &lt;- list( "model"="linreg", "formula"=theta ~ 1  )
ind[["x"]] &lt;- list( "model"="linreg", "formula"=x ~ 0 + offset(theta) )
# assumption of heterogeneous known error variance
ind[["x"]]$sigma_fixed &lt;- sqrt( var_err )
data_init &lt;- dat
data_init$theta &lt;- dat$x

# estimate model
mod2 &lt;- mdmb::frm_fb(dat, dep, ind, burnin=200, iter=1000, data_init=data_init)
summary(mod2)
plot(mod2)

#############################################################################
# EXAMPLE 6: Non-normally distributed covariates:
#            Positive values with Box-Cox transformation
#############################################################################

# simulate data with chi-squared distributed covariate from
# regression model Y ~ X
set.seed(876)
n &lt;- 1500
df &lt;- 2
x &lt;- stats::rchisq( n, df=df )
x &lt;- x / sqrt( 2*df)
y &lt;- 0 + 1*x
R2 &lt;- .25    # explained variance
y &lt;- y + stats::rnorm(n, sd=sqrt( (1-R2)/R2 * 1) )
dat0 &lt;- dat &lt;- data.frame( y=y, x=x )

# simulate missing responses
prop_miss &lt;- .5
cor_miss &lt;- .7
resp_tend &lt;- cor_miss*(dat$y-mean(y) )/ stats::sd(y) +
                 stats::rnorm(n, sd=sqrt( 1 - cor_miss^2) )
dat[ resp_tend &lt; stats::qnorm( prop_miss ), "x" ] &lt;- NA
summary(dat)

#-- complete data
mod0 &lt;- stats::lm( y ~ x, data=dat0 )
summary(mod0)
#-- listwise deletion
mod1 &lt;- stats::lm( y ~ x, data=dat )
summary(mod1)

# normal distribution assumption for frm

# define models
dep &lt;- list("model"="linreg", "formula"=y ~  x )
# normally distributed data
ind_x1 &lt;- list( "model"="linreg", "formula"=x ~ 1 )
# Box-Cox normal distribution
ind_x2 &lt;- list( "model"="bctreg", "formula"=x ~ 1,
              nodes=c( seq(0.05, 3, len=31), seq( 3.5, 9, by=.5 ) ) )
ind1 &lt;- list( "x"=ind_x1 )
ind2 &lt;- list( "x"=ind_x2 )

#--- incorrect normal distribution assumption
mod1 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind1 )
summary(mod1)

#--- model chi-square distribution of predictor with Box-Cox transformation
mod2 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind2 )
summary(mod2)

#############################################################################
# EXAMPLE 7: Latent interaction model
#############################################################################

# A latent interaction model Y ~ FX + FZ is of interest. Y is directly observed,
# FX and FZ are both indirectly observed by three items

#--- simulate data
N &lt;- 1000
set.seed(987)
# latent variable
FX &lt;- stats::rnorm(N)
FZ &lt;- stats::rnorm(N)
# simulate items
x1 &lt;- 1.5 + 1*FX + stats::rnorm(N, sd=.7 )
x2 &lt;- 1.9 + .7*FX + stats::rnorm(N, sd=1 )
x3 &lt;- .9 + .7*FX + stats::rnorm(N, sd=.2 )
z1 &lt;- 1.5 + 1*FZ + stats::rnorm(N, sd=.7 )
z2 &lt;- 1.9 + .7*FZ + stats::rnorm(N, sd=1 )
z3 &lt;- .9 + .7*FZ + stats::rnorm(N, sd=.2 )
dat &lt;- data.frame(x1,x2,x3,z1,z2,z3)
dat$FX &lt;- NA
dat$FZ &lt;- NA
dat$y &lt;- 2 + .5*FX + .3*FZ + .4*FX*FZ + rnorm( N, sd=1 )

# estimate interaction model with ML

#--- define model
nodes &lt;- seq(-4,4,len=11)
ind_x1 &lt;- list("model"="linreg", "formula"=x1 ~  offset(1*FX),
                "nodes"=nodes )
ind_x2 &lt;- list( "model"="linreg", "formula"=x2 ~ FX, "nodes"=nodes,
                "coef_inits"=c(NA,1) )
ind_x3 &lt;- list( "model"="linreg", "formula"=x3 ~ FX, "nodes"=nodes,
                 "coef_inits"=c(1,1) )
ind_FX &lt;- list( "model"="linreg", "formula"=FX ~ 0, "nodes"=nodes )
ind_z1 &lt;- list("model"="linreg", "formula"=z1 ~  offset(1*FZ),
                "nodes"=nodes )
ind_z2 &lt;- list( "model"="linreg", "formula"=z2 ~ FZ, "nodes"=nodes,
                "coef_inits"=c(NA,1) )
ind_z3 &lt;- list( "model"="linreg", "formula"=z3 ~ FZ, "nodes"=nodes,
                 "coef_inits"=c(1,1) )
ind_FZ &lt;- list( "model"="linreg", "formula"=FZ ~ 0 + FX, "nodes"=nodes )
ind &lt;- list( "x1"=ind_x1,  "x2"=ind_x2, "x3"=ind_x3, "FX"=ind_FX,
            "z1"=ind_z1,  "z2"=ind_z2, "z3"=ind_z3, "FX"=ind_FZ )
dep &lt;- list( "model"="linreg", formula=y ~ FX+FZ+FX*FZ, "coef_inits"=c(1,.2,.2,0) )

#*** estimate model with mdmb::frm_em
mod1 &lt;- mdmb::frm_em(dat, dep, ind)
summary(mod1)

#############################################################################
# EXAMPLE 8: Non-ignorable data in Y
#############################################################################

# regression Y ~ X in which Y is missing depending Y itself

library(mvtnorm)
cor_XY &lt;- .4        # correlation between X and Y
prop_miss &lt;- .5     # missing proportion
cor_missY &lt;- .7     # correlation with missing propensity
N &lt;- 3000           # sample size

#----- simulate data
set.seed(790)
Sigma &lt;- matrix( c(1, cor_XY, cor_XY, 1), 2, 2 )
mu &lt;- c(0,0)
dat &lt;- mvtnorm::rmvnorm( N, mean=mu, sigma=Sigma )
colnames(dat) &lt;- c("X","Y")
dat &lt;- as.data.frame(dat)

#-- generate missing responses on Y depending on Y itself
y1 &lt;- dat$Y
miss_tend &lt;- cor_missY * y1  + rnorm(N, sd=sqrt( 1 - cor_missY^2) )
dat$Y[ miss_tend &lt; quantile( miss_tend, prop_miss ) ] &lt;- NA

#--- ML estimation under assumption of ignorability
nodes &lt;- seq(-5,5,len=15)
dep &lt;- list("model"="linreg", "formula"=Y ~  X, "nodes"=nodes )
ind_X &lt;- list( "model"="linreg", "formula"=X ~ 1, "nodes"=nodes )
ind &lt;- list( "X"=ind_X )
mod1 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind)
summary(mod1)

#--- ML estimation under assumption with specifying a model for non-ignorability
#    for response indicator resp_Y
dat$resp_Y &lt;- 1* ( 1 - is.na(dat$Y) )
dep &lt;- list("model"="linreg", "formula"=Y ~  X, "nodes"=nodes )
ind_X &lt;- list( "model"="linreg", "formula"=X ~ 1, "nodes"=nodes )
ind_respY &lt;- list( "model"="logistic", "formula"=resp_Y ~ Y, "nodes"=nodes )
ind &lt;- list( "X"=ind_X, "resp_Y"=ind_respY )
mod2 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind)
summary(mod2)

#############################################################################
# EXAMPLE 9: Ordinal variables: Graded response model
#############################################################################

#--- simulate data
N &lt;- 2000
set.seed(91834)
# latent variable
theta &lt;- stats::rnorm(N)
# simulate items
y1 &lt;- 1*theta + stats::rnorm(N)
y2 &lt;- .7*theta + stats::rnorm(N)
y3 &lt;- .7*theta + stats::rnorm(N)
# discretize variables
y1 &lt;- as.numeric( cut( y1, breaks=c(-Inf, -.5, 0.4, 1, Inf ) ) ) - 1
y2 &lt;- as.numeric( cut( y2, breaks=c(-Inf, 0.3, 1, Inf ) ) ) - 1
y3 &lt;- as.numeric( cut( y3, breaks=c(-Inf, .2, Inf ) ) ) - 1
# define dataset
dat &lt;- data.frame(y1,y2,y3)
dat$theta &lt;- NA

#******************************************
# Model 1: Fully Bayesian estimation

#--- define model
ind_y1 &lt;- list( "model"="oprobit", "formula"=y1 ~  offset(1*theta) )
ind_y2 &lt;- list( "model"="oprobit", "formula"=y2 ~ theta )
ind_y3 &lt;- list( "model"="oprobit", "formula"=y3 ~ theta )
dep &lt;- list( "model"="linreg", "formula"=theta ~ 0  )
ind &lt;- list( "y1"=ind_y1,  "y2"=ind_y2, "y3"=ind_y3)
# initial data
data_init &lt;- dat
data_init$theta &lt;- as.numeric( scale(dat$y1) ) + stats::rnorm(N, sd=.4 )

#-- estimate model
iter &lt;- 3000; burnin &lt;- 1000
mod1 &lt;- mdmb::frm_fb(dat=dat, dep=dep, ind=ind, data_init=data_init,
                   iter=iter, burnin=burnin)
summary(mod1)
plot(mod1)

#############################################################################
# EXAMPLE 10: Imputation for missig predictors in models with interaction
#             effects in multilevel regression models
#############################################################################

library(miceadds)
data(data.mb04, package="mdmb")
dat &lt;- data.mb04

#*** model specification
mcmc_iter &lt;- 4   # number of MCMC iterations for model parameter sampling
model_formula &lt;- y ~ cwc(x, idcluster) + gm(x, idcluster) + w + w*cwc(x, idcluster) +
                   w*gm(x, idcluster) + ( 1 + cwc(x, idcluster) | idcluster)
dep &lt;- list("model"="mlreg", "formula"=model_formula,
               R_args=list(iter=mcmc_iter, outcome="normal") )
ind_x &lt;- list( "model"="mlreg", "formula"=x ~ w + (1|idcluster), R_args=list(iter=mcmc_iter),
                  sampling_level="idcluster" )
# group means of x are involved in the outcome model. Therefore, Metropolis-Hastings
# sampling of missing values in x should be conducted at the level of clusters,
# i.e. specifying sampling_level
ind &lt;- list("x"=ind_x)

# --- estimate model
mod1 &lt;- mdmb::frm_fb(dat, dep, ind, aggregation=TRUE)
# argument aggregation is necessary because group means are involved in regression formulas

#-------------
#*** imputation of a continuous level-2 variable w

#  create artificially some missings on w
dat[ dat$idcluster %%3==0, "w" ] &lt;- NA

# define level-2 model with argument variable_level
ind_w &lt;- list( "model"="linreg", "formula"=w ~ 1, "variable_level"="idcluster" )
ind &lt;- list( x=ind_x, w=ind_w)

#* conduct imputations
mod2 &lt;- mdmb::frm_fb(dat, dep, ind, aggregation=TRUE)
summary(mod2)

#--- Model 1 with user-defined prior distributions for covariance matrices
model_formula &lt;- y ~ cwc(x, idcluster) + gm(x, idcluster) + w + w*cwc(x, idcluster) +
                   w*gm(x, idcluster) + ( 1 + cwc(x, idcluster) | idcluster)

# define scale degrees of freedom (nu) and scale matrix (S) for inverse Wishart distribution
psi_nu0_list &lt;- list( -3 )
psi_S0_list &lt;- list( diag(0,2) )
dep &lt;- list("model"="mlreg", "formula"=model_formula,
               R_args=list(iter=mcmc_iter, outcome="normal",
               psi_nu0_list=psi_nu0_list, psi_S0_list=psi_S0_list ) )

# define nu and S parameters for covariate model
psi_nu0_list &lt;- list( .4 )
psi_S0_list &lt;- list( matrix(.2, nrow=1, ncol=1) )
ind_x &lt;- list( "model"="mlreg", "formula"=x ~ w + (1|idcluster),
                   R_args=list(iter=mcmc_iter, psi_nu0_list=psi_nu0_list,
                            psi_S0_list=psi_S0_list),
                  sampling_level="idcluster" )
ind &lt;- list("x"=ind_x)

# --- estimate model
mod3 &lt;- mdmb::frm_fb(dat, dep, ind, aggregation=TRUE)

#############################################################################
# EXAMPLE 11: Bounded variable combined with Yeo-Johnson transformation
#############################################################################

#*** simulate data
set.seed(876)
n &lt;- 1500
x &lt;- mdmb::ryjt_scaled( n, location=-.2, shape=.8, lambda=.9, probit=TRUE)
R2 &lt;- .25    # explained variance
y &lt;- 1*x + stats::rnorm(n, sd=sqrt( (1-R2)/R2 * stats::var(x)) )
dat0 &lt;- dat &lt;- data.frame( y=y, x=x )

# simulate missing responses
prop_miss &lt;- .5
cor_miss &lt;- .7
resp_tend &lt;- cor_miss*(dat$y-mean(y) )/ stats::sd(y) +
                 stats::rnorm(n, sd=sqrt( 1 - cor_miss^2) )
dat[ resp_tend &lt; stats::qnorm(prop_miss), "x" ] &lt;- NA
summary(dat)

#*** define models
dep &lt;- list("model"="linreg", "formula"=y ~  x )
# distribution according to Yeo-Johnson transformation
ind_x1 &lt;- list( "model"="yjtreg", "formula"=x ~ 1 )
# distribution according to Probit Yeo-Johnson transformation
ind_x2 &lt;- list( "model"="yjtreg", "formula"=x ~ 1, R_args=list("probit"=TRUE ) )
ind1 &lt;- list( "x"=ind_x1 )
ind2 &lt;- list( "x"=ind_x2 )

#--- complete data
mod0 &lt;- stats::lm( y~x, data=dat0)
summary(mod0)

#--- Yeo-Johnson normal distribution (for unbounded variables)
mod1 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind1 )
summary(mod1)

#--- Probit Yeo-Johnson normal distribution (for bounded variable on (0,1))
mod2 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind2)
summary(mod2)

#--- same model, but MCMC estimation
mod3 &lt;- mdmb::frm_fb(dat, dep, ind=ind2, burnin=2000, iter=5000)
summary(mod3)
plot(mod3)

#############################################################################
# EXAMPLE 12: Yeo-Johnson transformation with estimated degrees of freedom
#############################################################################

#*** simulate data
set.seed(876)
n &lt;- 1500
x &lt;- mdmb::ryjt_scaled( n, location=-.2, shape=.8, lambda=.9, df=10 )
R2 &lt;- .25    # explained variance
y &lt;- 1*x + stats::rnorm(n, sd=sqrt( (1-R2)/R2 * stats::var(x)) )
dat0 &lt;- dat &lt;- data.frame( y=y, x=x )

# simulate missing responses
prop_miss &lt;- .5
cor_miss &lt;- .7
resp_tend &lt;- cor_miss*(dat$y-mean(y) )/ stats::sd(y) +
                 stats::rnorm(n, sd=sqrt( 1-cor_miss^2) )
dat[ resp_tend &lt; stats::qnorm(prop_miss), "x" ] &lt;- NA
summary(dat)

#*** define models
dep &lt;- list("model"="linreg", "formula"=y ~  x )
# specify distribution with estimated degrees of freedom
ind_x &lt;- list( "model"="yjtreg", "formula"=x ~ 1, R_args=list(est_df=TRUE ) )
ind &lt;- list( "x"=ind_x )

#--- Yeo-Johnson t distribution
mod1 &lt;- mdmb::frm_fb(dat=dat, dep=dep, ind=ind, iter=3000, burnin=1000 )
summary(mod1)

## End(Not run)
</code></pre>


</div>