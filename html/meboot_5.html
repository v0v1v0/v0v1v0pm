<div class="container">

<table style="width: 100%;"><tr>
<td>flexMeboot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Flexible Extension of the Maximum Entropy Bootstrap Procedure</h2>

<h3>Description</h3>

<p>This function extends the maximum entropy bootstrap procedure
implemented in <code>meboot</code>
to allow for for a flexible trend up, flat or down.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  flexMeboot (x, reps = 9, segment = 5, forc = FALSE, myseq = seq(-1, 1, by = 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of data, <code>ts</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reps</code></td>
<td>
<p>number of replicates to generate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segment</code></td>
<td>
<p>block size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forc</code></td>
<td>
<p>logical. If TRUE the ensemble is forced to satisfy the central limit theorem.
See <code>force.clt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>myseq</code></td>
<td>
<p>directions for trend within a block of data is chosen randomly with the user's choice
limited by the range of values given by myseq. For example, <code>myseq=seq(-1,1,by=0.5)</code>
provides five options for direction changes. If the user specifies any single number
instead of a sequence, (e.g., <code>myseq=1</code>) then <code>flexMeboot</code> will not change the directions
of trends at all, but will modify the original <code>meboot</code> function to resample separately
within several non-overlapping blocks, before joining them into resampled time series.
This may be desirable for long series and for some applications.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>flexMeboot</code> uses non-overlapping blocks having only m observations.
A trend <code class="reqn">a + bt</code> is replaced by <code class="reqn">a + Bt</code>,
where <code>B = sample(myseq) * b</code>.
</p>
<p>Its steps are as follows:
</p>

<ol>
<li>
<p> Choose block size <code>segment</code> denoted here as <code class="reqn">m</code>
(default equal to <code class="reqn">m=5</code>)
and divide the original time series <code>x</code> of length <code class="reqn">T</code>
into <code class="reqn">k = floor(T/m)</code> blocks or subsets. Note that when
<code class="reqn">T/m</code> is not an integer the <code class="reqn">k</code>-th block will have a few more than
<code class="reqn">m</code> items. Hence let us denote the number of observations in each block as
<code class="reqn">m</code> which equals <code class="reqn">m</code> for most blocks, except the <code class="reqn">k</code>-th.
</p>
</li>
<li>
<p> Regress each block having m observations as subsets of <code>x</code> on the set
<code class="reqn">\tau = 1, 2,..., m</code>, and store the intercept <code class="reqn">b0</code>,
the slope <code class="reqn">b1</code> of <code class="reqn">\tau</code> and the residuals <code class="reqn">r</code>.
</p>
</li>
<li>
<p> Note that the positive (negative) sign of the slope <code class="reqn">b1</code> in this regression
determines the up (down) direction of the time series in that block.
Hence the next step of the algorithm replaces <code class="reqn">b1</code> by <code class="reqn">B1 = b1 * w</code>, defined
by a randomly chosen weight <code class="reqn">w in (-1, 0, 1)</code>.
For example, when the random choice yields <code class="reqn">w = -1</code>, the sign of <code class="reqn">b1</code> is
reversed. Our weighting independently injects some limited flexibility
to the directions of values block segments of the original time series.
</p>
</li>
<li>
<p> Reconstruct all time series blocks as: <code class="reqn">b0 + b1 * w * \tau + r</code>,
by adding back the residual <code class="reqn">r</code> of the regression on <code class="reqn">\tau</code>.
</p>
</li>
<li>
<p> The next step applies the function <code>meboot</code> to each
block of time serie-now having a modified trend-and create a large
number, <code class="reqn">J</code>, of resampled time series for each of the <code class="reqn">k</code> blocks.
</p>
</li>
<li>
<p> Sequentially join the <code class="reqn">J</code> replicates of all <code class="reqn">k</code> blocks or subsets together.
</p>
</li>
</ol>
<h3>Value</h3>

<p>A matrix containing by columns
the bootstrapped replicated of the original data <code>x</code>.
</p>


<h3>References</h3>

<p>Vinod, H.D. (2012), Constructing Scenarios of Time Heterogeneous Series for Stress Testing,
Available at SSRN: <a href="https://www.ssrn.com/abstract=1987879">https://www.ssrn.com/abstract=1987879</a>.
</p>


<h3>See Also</h3>

<p><code>meboot</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(235)
myseq &lt;- seq(-1, 1, by = 0.5)
xx &lt;- flexMeboot(x = AirPassengers, myseq = myseq, reps = 3)
matplot(cbind(AirPassengers, xx), type = "l")
</code></pre>


</div>