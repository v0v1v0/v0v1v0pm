<div class="container">

<table style="width: 100%;"><tr>
<td>robustness</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate robustness across networks.</h2>

<h3>Description</h3>

<p>This class is a wrapper for robustness calculation and visualization.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-robustness-new"><code>robustness$new()</code></a>
</p>
</li>
<li> <p><a href="#method-robustness-plot"><code>robustness$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-robustness-clone"><code>robustness$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-robustness-new"></a>



<h4>Method <code>new()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>robustness$new(
  network_list,
  remove_strategy = c("edge_rand", "edge_strong", "edge_weak", "node_rand", "node_hub",
    "node_degree_high", "node_degree_low")[1],
  remove_ratio = seq(0, 1, 0.1),
  measure = c("Eff", "Eigen", "Pcr")[1],
  run = 10
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>network_list</code></dt>
<dd>
<p>a list with multiple networks; all the networks should be <code>trans_network</code> object 
created from <code>trans_network</code> class of <code>microeco</code> package.</p>
</dd>
<dt><code>remove_strategy</code></dt>
<dd>
<p>default "edge_rand"; 
</p>

<dl>
<dt><strong>"edge_rand"</strong></dt>
<dd>
<p>edges are randomly removed.</p>
</dd>
<dt><strong>"edge_strong"</strong></dt>
<dd>
<p>edges are removed in decreasing order of weight.</p>
</dd>
<dt><strong>"edge_weak"</strong></dt>
<dd>
<p>edges are removed in increasing order of weight.</p>
</dd>
<dt><strong>"node_rand"</strong></dt>
<dd>
<p>nodes are removed randomly.</p>
</dd>
<dt><strong>"node_hub"</strong></dt>
<dd>
<p>node hubs are randomly removed. The hubs include network hubs and module hubs.</p>
</dd>
<dt><strong>"node_degree_high"</strong></dt>
<dd>
<p>nodes are removed in decreasing order of degree.</p>
</dd>
<dt><strong>"node_degree_low"</strong></dt>
<dd>
<p>nodes are removed in increasing order of degree.</p>
</dd>
</dl>
</dd>
<dt><code>remove_ratio</code></dt>
<dd>
<p>default seq(0, 1, 0.1).</p>
</dd>
<dt><code>measure</code></dt>
<dd>
<p>default "Eff"; network robustness measures. 
</p>

<dl>
<dt><strong>"Eff"</strong></dt>
<dd>
<p>network efficiency. The average efficiency of the network is defined:
</p>
<p style="text-align: center;"><code class="reqn">Eff = \frac{1}{N(N - 1)} \sum_{i \neq j \in G}\frac{1}{d(i, j)}</code>
</p>

<p>where N is the total number of nodes and <em>d(i,j)</em> is the shortest path between node i and node j. 
When the weight is found in the edge attributes, <code class="reqn">d(i,j)</code> denotes the weighted shortest path between node i and node j.
For more details, please read the references &lt;doi: 10.1007/s11704-016-6108-z&gt; and &lt;doi: 10.1038/s41598-020-60298-7&gt;.
</p>
</dd>
<dt><strong>"Eigen"</strong></dt>
<dd>
<p>natural connectivity &lt;doi: 10.1007/s11704-016-6108-z&gt;.
The natural connectivity can be regarded as an average eigenvalue that changes strictly monotonically with the addition or deletion of edges. It is defined:
</p>
<p style="text-align: center;"><code class="reqn">\bar{\lambda} = \ln(\frac{1}{N} \sum_{i=1}^{N} e^{\lambda~i~})</code>
</p>

<p>where <code class="reqn">\lambda~i~</code> is the <code class="reqn">i</code>th eigenvalue of the graph adjacency matrix. The larger the value of <code class="reqn">\bar{\lambda}</code> is, the more robust the network is.
</p>
</dd>
<dt><strong>"Pcr"</strong></dt>
<dd>
<p>critical removal fraction of vertices (edges) for the disintegration of networks 
&lt;doi: 10.1007/s11704-016-6108-z&gt; &lt;doi: 10.1103/PhysRevE.72.056130&gt;.
This is a robustness measure based on random graph theory.
The critical fraction against random attacks is labeled as <code class="reqn">P_{c}^r</code>. It is defined:
</p>
<p style="text-align: center;"><code class="reqn">P_{c}^r = 1 - \frac{1}{\frac{\langle k^2 \rangle}{\langle k \rangle} - 1}</code>
</p>

<p>where <code class="reqn">\langle k \rangle</code> is the average nodal degree of the original network, and <code class="reqn">\langle k^2 \rangle</code> is the average of square of nodal degree. 
</p>
</dd>
</dl>
</dd>
<dt><code>run</code></dt>
<dd>
<p>default 10. Replication number of simulation for the sampling method; Only available when <code>remove_strategy</code> = "edge_rand", "node_rand" or "node_hub".</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_table</code> and <code>res_summary</code>, stored in the object. The <code>res_table</code> is the original simulation result.
The Mean and SD in <code>res_summary</code> come from the <code>res_table</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>tmp &lt;- robustness$new(soil_amp_network, remove_strategy = c("edge_rand"), 
  measure = c("Eff"), run = 3, remove_ratio = c(0.1, 0.5, 0.9))

</pre>
</div>


<hr>
<a id="method-robustness-plot"></a>



<h4>Method <code>plot()</code>
</h4>

<p>Plot the simulation results.
</p>


<h5>Usage</h5>

<div class="r"><pre>robustness$plot(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  show_point = TRUE,
  point_size = 1,
  point_alpha = 0.6,
  show_errorbar = TRUE,
  errorbar_position = position_dodge(0),
  errorbar_size = 1,
  errorbar_width = 0.1,
  add_fitting = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt>
<dd>
<p>colors used for presentation.</p>
</dd>
<dt><code>show_point</code></dt>
<dd>
<p>default TRUE; whether show the point.</p>
</dd>
<dt><code>point_size</code></dt>
<dd>
<p>default .3; point size value.</p>
</dd>
<dt><code>point_alpha</code></dt>
<dd>
<p>default .6; point alpha value.</p>
</dd>
<dt><code>show_errorbar</code></dt>
<dd>
<p>default TRUE; whether show the errorbar by using the SD result.</p>
</dd>
<dt><code>errorbar_position</code></dt>
<dd>
<p>default position_dodge(0); Position adjustment, either as a string (such as "identity"), 
or the result of a call to a position adjustment function.</p>
</dd>
<dt><code>errorbar_size</code></dt>
<dd>
<p>default 1; errorbar size.</p>
</dd>
<dt><code>errorbar_width</code></dt>
<dd>
<p>default 0.1; errorbar width.</p>
</dd>
<dt><code>add_fitting</code></dt>
<dd>
<p>default FALSE; whether add fitted smooth line. FALSE denotes add line segment among points.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to ggplot2::geom_line (when add_fitting = FALSE) or ggplot2::geom_smooth (when add_fitting = TRUE).</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>ggplot</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
tmp$plot(linewidth = 1)
}
</pre>
</div>


<hr>
<a id="method-robustness-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>robustness$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">
## ------------------------------------------------
## Method `robustness$new`
## ------------------------------------------------

tmp &lt;- robustness$new(soil_amp_network, remove_strategy = c("edge_rand"), 
  measure = c("Eff"), run = 3, remove_ratio = c(0.1, 0.5, 0.9))


## ------------------------------------------------
## Method `robustness$plot`
## ------------------------------------------------


tmp$plot(linewidth = 1)

</code></pre>


</div>