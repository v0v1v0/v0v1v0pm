<div class="container">

<table style="width: 100%;"><tr>
<td>melt_fwf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Return melted data for each token in a fixed width file</h2>

<h3>Description</h3>

<p>For certain non-rectangular data formats, it can be useful to parse the data
into a melted format where each row represents a single token.
</p>


<h3>Usage</h3>

<pre><code class="language-R">melt_fwf(
  file,
  col_positions,
  locale = default_locale(),
  na = c("", "NA"),
  comment = "",
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  progress = show_progress(),
  skip_empty_rows = FALSE
)

fwf_empty(
  file,
  skip = 0,
  skip_empty_rows = FALSE,
  col_names = NULL,
  comment = "",
  n = 100L
)

fwf_widths(widths, col_names = NULL)

fwf_positions(start, end = NULL, col_names = NULL)

fwf_cols(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">⁠http://⁠</code>,
<code style="white-space: pre;">⁠https://⁠</code>, <code style="white-space: pre;">⁠ftp://⁠</code>, or <code style="white-space: pre;">⁠ftps://⁠</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code>clipboard()</code> will read from the system clipboard.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_positions</code></td>
<td>
<p>Column positions, as created by <code>fwf_empty()</code>,
<code>fwf_widths()</code> or <code>fwf_positions()</code>. To read in only selected fields,
use <code>fwf_positions()</code>. If the width of the last column is variable (a
ragged fwf file), supply the last end position as NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code>locale()</code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comment</code></td>
<td>
<p>A string used to identify comments. Any text after the
comment characters will be silently ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip</code></td>
<td>
<p>Number of lines to skip before reading data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>Display a progress bar? By default it will only display
in an interactive session and not while knitting a document. The automatic
progress bar can be disabled by setting option <code>readr.show_progress</code> to
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip_empty_rows</code></td>
<td>
<p>Should blank rows be ignored altogether? i.e. If this
option is <code>TRUE</code> then blank rows will not be represented at all.  If it is
<code>FALSE</code> then they will be represented by <code>NA</code> values in all the columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_names</code></td>
<td>
<p>Either NULL, or a character vector column names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of lines the tokenizer will read to determine file structure. By default
it is set to 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>widths</code></td>
<td>
<p>Width of each field. Use NA as width of last field when
reading a ragged fwf file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start, end</code></td>
<td>
<p>Starting and ending (inclusive) positions of each field.
Use NA as last end field when reading a ragged fwf file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>If the first element is a data frame,
then it must have all numeric columns and either one or two rows.
The column names are the variable names. The column values are the
variable widths if a length one vector, and if length two, variable start and end
positions. The elements of <code>...</code> are used to construct a data frame
with or or two rows as above.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>melt_fwf()</code> parses each token of a fixed width file into a single row, but
it still requires that each field is in the same in every row of the
source file.
</p>


<h3>Value</h3>

<p>A <code>tibble()</code> of four columns:
</p>

<ul>
<li> <p><code>row</code>, the row that the token comes from in the original file
</p>
</li>
<li> <p><code>col</code>, the column that the token comes from in the original file
</p>
</li>
<li> <p><code>data_type</code>, the data type of the token, e.g. <code>"integer"</code>, <code>"character"</code>,
<code>"date"</code>, guessed in a similar way to the <code>guess_parser()</code> function.
</p>
</li>
<li> <p><code>value</code>, the token itself as a character string, unchanged from its
representation in the original file.
</p>
</li>
</ul>
<p>If there are parsing problems, a warning tells you
how many, and you can retrieve the details with <code>problems()</code>.
</p>


<h3>See Also</h3>

<p><code>melt_table()</code> to melt fixed width files where each
column is separated by whitespace, and <code>melt_fwf()</code> for the conventional
way to read rectangular data from fixed width files.
</p>


<h3>Examples</h3>

<pre><code class="language-R">fwf_sample &lt;- meltr_example("fwf-sample.txt")
writeLines(readLines(fwf_sample))

# You can specify column positions in several ways:
# 1. Guess based on position of empty columns
melt_fwf(fwf_sample, fwf_empty(fwf_sample, col_names = c("first", "last", "state", "ssn")))
# 2. A vector of field widths
melt_fwf(fwf_sample, fwf_widths(c(20, 10, 12), c("name", "state", "ssn")))
# 3. Paired vectors of start and end positions
melt_fwf(fwf_sample, fwf_positions(c(1, 30), c(10, 42), c("name", "ssn")))
# 4. Named arguments with start and end positions
melt_fwf(fwf_sample, fwf_cols(name = c(1, 10), ssn = c(30, 42)))
# 5. Named arguments with column widths
melt_fwf(fwf_sample, fwf_cols(name = 20, state = 10, ssn = 12))
</code></pre>


</div>