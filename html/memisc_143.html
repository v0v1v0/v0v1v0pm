<div class="container">

<table style="width: 100%;"><tr>
<td>collect</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Collect Objects</h2>

<h3>Description</h3>

<p><code>collect</code> gathers several objects into one, matching the
elements or subsets of the objects by <code>names</code> or <code>dimnames</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">collect(...,names=NULL,inclusive=TRUE)
## Default S3 method:
collect(...,names=NULL,inclusive=TRUE)
## S3 method for class 'array'
collect(...,names=NULL,inclusive=TRUE)
## S3 method for class 'matrix'
collect(...,names=NULL,inclusive=TRUE)
## S3 method for class 'table'
collect(...,names=NULL,sourcename=".origin",fill=0)
## S3 method for class 'data.frame'
collect(...,names=NULL,inclusive=TRUE,
                                  fussy=FALSE,warn=TRUE,
                                  detailed.warnings=FALSE,use.last=FALSE,
                                  sourcename=".origin")
## S3 method for class 'data.set'
collect(...,names=NULL,inclusive=TRUE,
                                  fussy=FALSE,warn=TRUE,
                                  detailed.warnings=FALSE,use.last=FALSE,
                                  sourcename=".origin")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>more atomic vectors, arrays, matrices, tables, data.frames or data.sets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>optional character vector; in case of the default and array methods,
giving <code>dimnames</code> for the new dimension that identifies the
collected objects; in case of the data.frame and data.set methods,
levels of a factor indentifying the collected objects.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inclusive</code></td>
<td>
<p>logical, defaults to TRUE; should unmatched elements included? See details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fussy</code></td>
<td>
<p>logical, defaults to FALSE; should it count as an error, if variables with same
names of collected data.frames/data.sets have different attributes?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>logical, defaults to TRUE; should an warning be given, if variables with same
names of collected data.frames/data.sets have different attributes?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detailed.warnings</code></td>
<td>
<p>logical, whether the attributes of each
variable should be printed if they differ, and if <code>warn</code> or
<code>fuzzy</code> is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.last</code></td>
<td>
<p>logical, defaults to FALSE. If the function is
applied to data frames or similar objects, attributes of variables
may differ between data frames (or other objects, respectively). If
this argument is TRUE, then the attributes are harmonised based on
the variables in the last data frame/object, otherwise the
attributes of variables in the first data frame/object are used for harmonisation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sourcename</code></td>
<td>
<p>name of the factor that identifies the collected data.frames or data.sets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>numeric; with what to fill empty table cells, defaults to zero, assuming
the table contains counts</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>x</code> and all following ... arguments are vectors of the same mode (numeric,character, or logical)
the result is a matrix with as many columns as vectors. If argument <code>inclusive</code> is TRUE,
then the number of rows equals the number of names that appear at least once in each of the
vector names and the matrix is filled with <code>NA</code> where necessary,
otherwise the number of rows equals the number of names that are present in <em>all</em>
vector names.
</p>
<p>If <code>x</code> and all ... arguments are matrices or arrays of the same mode (numeric,character, or logical)
and <code class="reqn">n</code> dimension the result will be a <code class="reqn">n+1</code> dimensional array or table. The extend of the
<code class="reqn">n+1</code>th dimension equals the number of matrix, array or table arguments,
the extends of the lower dimension depends on the <code>inclusive</code> argument:
either they equal to the number of dimnames that appear at least once for each given
dimension and the array is filled with <code>NA</code> where necessary,
or they equal to the number of dimnames that appear in all arguments
for each given dimension.
</p>
<p>If <code>x</code> and all ... arguments are data frames or data sets, the
result is a data frame or data set.
The number of variables of the resulting data frame or data set depends on
the <code>inclusive</code> argument. If it is true, the number of variables
equals the number of variables that appear in each of the arguments at least once
and variables are filled with <code>NA</code> where necessary, otherwise the
number of variables equals the number of variables that are present in
all arguments.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- c(a=1,b=2)
y &lt;- c(a=10,c=30)

x
y

collect(x,y)
collect(x,y,inclusive=FALSE)

X &lt;- matrix(1,nrow=2,ncol=2,dimnames=list(letters[1:2],LETTERS[1:2]))
Y &lt;- matrix(2,nrow=3,ncol=2,dimnames=list(letters[1:3],LETTERS[1:2]))
Z &lt;- matrix(3,nrow=2,ncol=3,dimnames=list(letters[1:2],LETTERS[1:3]))

X
Y
Z

collect(X,Y,Z)
collect(X,Y,Z,inclusive=FALSE)

X &lt;- matrix(1,nrow=2,ncol=2,dimnames=list(a=letters[1:2],b=LETTERS[1:2]))
Y &lt;- matrix(2,nrow=3,ncol=2,dimnames=list(a=letters[1:3],c=LETTERS[1:2]))
Z &lt;- matrix(3,nrow=2,ncol=3,dimnames=list(a=letters[1:2],c=LETTERS[1:3]))

collect(X,Y,Z)
collect(X,Y,Z,inclusive=FALSE)

df1 &lt;- data.frame(a=rep(1,5),b=rep(1,5))
df2 &lt;- data.frame(a=rep(2,5),b=rep(2,5),c=rep(2,5))
collect(df1,df2)
collect(df1,df2,inclusive=FALSE)

data(UCBAdmissions)
Male &lt;- as.table(UCBAdmissions[,1,])
Female &lt;- as.table(UCBAdmissions[,2,])
collect(Male,Female,sourcename="Gender")
collect(unclass(Male),unclass(Female))

Male1 &lt;- as.table(UCBAdmissions[,1,-1])
Female2 &lt;- as.table(UCBAdmissions[,2,-2])
Female3 &lt;- as.table(UCBAdmissions[,2,-3])
collect(Male=Male1,Female=Female2,sourcename="Gender")
collect(Male=Male1,Female=Female3,sourcename="Gender")
collect(Male=Male1,Female=Female3,sourcename="Gender",fill=NA)

f1 &lt;- gl(3,5,labels=letters[1:3])
f2 &lt;- gl(3,6,labels=letters[1:3])
collect(f1=table(f1),f2=table(f2))

ds1 &lt;- data.set(x = 1:3)
ds2 &lt;- data.set(x = 4:9,
                y = 1:6)
collect(ds1,ds2)

</code></pre>


</div>