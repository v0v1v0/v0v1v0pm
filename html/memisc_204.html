<div class="container">

<table style="width: 100%;"><tr>
<td>foreach</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Loop over Variables in a Data Frame or Environment</h2>

<h3>Description</h3>

<p><code>foreach</code> evaluates an expression given as untagged argument by substituting
in variables. The expression may also contain assignments, which take effect in
the caller's environment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  foreach(...,.sorted,.outer=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>tagged and untagged arguments.
The tagged arguments define the 'variables' that are looped over,
the first untagged argument defines the expression wich is
evaluated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.sorted</code></td>
<td>
<p>an optional logical value; relevant only
when a range of variable is specified using the column operator
"<code>:</code>". Decises whether variable names should be sorted
alphabetically before the range of variables are created.
</p>
<p>If this argument missing, its default value is TRUE, if <code>foreach()</code> is called
in the global environment, otherwise it is FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.outer</code></td>
<td>
<p>an optional logical value; if TRUE, each combination of
the variables is used to evaluate the expression,
if FALSE (the default) then the variables all need to have
the same length and the corresponding values of the
variables are used in the evaluation of the expression.
</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">x &lt;- 1:3
y &lt;- -(1:3)
z &lt;- c("Uri","Schwyz","Unterwalden")
print(x)
print(y)
print(z)
foreach(var=c(x,y,z),          # assigns names
  names(var) &lt;- letters[1:3]   # to the elements of x, y, and z
  )
print(x)
print(y)
print(z)

ds &lt;- data.set(
        a = c(1,2,3,2,3,8,9),
        b = c(2,8,3,2,1,8,9),
        c = c(1,3,2,1,2,8,8)
      )
print(ds)
ds &lt;- within(ds,{ 
      description(a) &lt;- "First item in questionnaire"
      description(b) &lt;- "Second item in questionnaire"
      description(c) &lt;- "Third item in questionnaire"
      
      wording(a) &lt;- "What number do you like first?"
      wording(b) &lt;- "What number do you like second?"
      wording(c) &lt;- "What number do you like third?"

      foreach(x=a:c,{ # Lazy data documentation:
        labels(x) &lt;- c(    # a,b,c get value labels in one statement
                         one = 1,
                         two = 2,
                       three = 3,
                "don't know" = 8,
         "refused to answer" = 9)
        missing.values(x) &lt;- c(8,9)
        })
      })
      
codebook(ds)

# The colon-operator respects the order of the variables
# in the data set, if .sorted=FALSE
with(ds[c(3,1,2)],
     foreach(x=a:c,
             print(description(x))
            ))

# Since .sorted=TRUE, the colon operator creates a range 
# of alphabetically sorted variables.
with(ds[c(3,1,2)],
     foreach(x=a:c,
             print(description(x)),
             .sorted=TRUE
            ))

# The variables in reverse order
with(ds,
     foreach(x=c:a,
             print(description(x))
            ))

# The colon operator can be combined with the 
# concatenation function
with(ds,
     foreach(x=c(a:b,c,c,b:a),
             print(description(x))
            ))

# Variables can also be selected by regular expressions.
with(ds,
     foreach(x=rx("[a-b]"),
             print(description(x))
            ))

# A demonstration for '.outer=TRUE'
foreach(l=letters[1:2],
        i=1:3,
        cat(paste0(l,i,"\n")),
        .outer=TRUE)

</code></pre>


</div>