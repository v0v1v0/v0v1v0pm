<div class="container">

<table style="width: 100%;"><tr>
<td>genTable</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic Tables and Data Frames of Descriptive Statistics</h2>

<h3>Description</h3>

<p><code>genTable</code> creates a table of arbitrary summaries conditional on
given values of independent variables given by a formula.
</p>
<p><code>Aggregate</code> does the same, but returns a <code>data.frame</code> instead.
</p>
<p><code>fapply</code> is a generic function that dispatches on its <code>data</code>
argument. It is called internally by <code>Aggregate</code> and <code>genTable</code>.
Methods for this function can be used to adapt <code>Aggregate</code> and
<code>genTable</code> to data sources other than data frames.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Aggregate(formula, data=parent.frame(), subset=NULL,
          names=NULL, addFreq=TRUE, drop = TRUE, as.vars=1,
          ...)

genTable(formula, data=parent.frame(), subset=NULL,
         names=NULL, addFreq=TRUE,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula. The right hand side includes one or more
grouping variables separated by '+'. These may be factors, numeric,
or character vectors. The left hand side may be empty,
a numerical variable, a factor, or an expression.
See details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an environment or data frame or an object coercable into a data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>an optional character vector giving names to the
result(s) yielded by the expression on the left hand side of <code>formula</code>.
This argument may be redundant if the left hand side results in is a named vector.
(See the example below.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addFreq</code></td>
<td>
<p>a logical value. If <code>TRUE</code> and
<code>data</code> is a table or a data frame with a variable
named "Freq", a call to
<code>table</code>, <code>Table</code>, <code>percent</code>, or <code>nvalid</code>
is supplied by an additional argument <code>Freq</code>
and a call to <code>table</code> is translated into
a call to <code>Table</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, empty groups (i.e. when
there are no observations in the aggregated data frame that contain
the defining combination of values or factor levels of the
conditioning variables in <code>by</code>) are dropped from the result of
<code>Aggregate</code>. Otherwise, result are filled with <code>NA</code>, where appropriate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.vars</code></td>
<td>
<p>an integer; relevant only if the left hand side of the formula returns
an array or a matrix - which dimension (rows, columns, or layers etc.) will transformed to
variables? Defaults to columns in case of matrices and to the highest dimensional extend
in case of arrays.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments, passed to methods or ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If an expression is given as left hand side of the formula, its
value is computed for any combination of values of the values on the
right hand side. If the right hand side is a dot, then all
variables in <code>data</code> are added to the right hand side of the
formula.
</p>
<p>If no expression is given as left hand side,
then the frequency counts for the respective
value combinations of the right hand variables are computed.
</p>
<p>If a single factor is on the left hand side, then the left hand side is
translated into an appropriate
call to <code>table()</code>. Note that also in this case <code>addFreq</code> takes effect.
</p>
<p>If a single numeric variable is on the left hand side, frequency
counts weighted by this variable are computed. In these cases,
<code>genTable</code> is equivalent to <code>xtabs</code> and
<code>Aggregate</code> is equivalent to <code>as.data.frame(xtabs(...))</code>.
</p>


<h3>Value</h3>

<p><code>Aggregate</code>
results in a data frame with conditional summaries and unique value combinations
of conditioning variables.
</p>
<p><code>genTable</code> returns a table, that is, an array with class <code>"table"</code>.
</p>


<h3>See Also</h3>

<p>aggregate.data.frame, xtabs</p>


<h3>Examples</h3>

<pre><code class="language-R">ex.data &lt;- expand.grid(mu=c(0,100),sigma=c(1,10))[rep(1:4,rep(100,4)),]
ex.data &lt;- within(ex.data,
                  x&lt;-rnorm(
                    n=nrow(ex.data),
                    mean=mu,
                    sd=sigma
                    )
                  )

Aggregate(~mu+sigma,data=ex.data)
Aggregate(mean(x)~mu+sigma,data=ex.data)
Aggregate(mean(x)~mu+sigma,data=ex.data,name="Average")
Aggregate(c(mean(x),sd(x))~mu+sigma,data=ex.data)
Aggregate(c(Mean=mean(x),StDev=sd(x),N=length(x))~mu+sigma,data=ex.data)
genTable(c(Mean=mean(x),StDev=sd(x),N=length(x))~mu+sigma,data=ex.data)

Aggregate(table(Admit)~.,data=UCBAdmissions)
Aggregate(Table(Admit,Freq)~.,data=UCBAdmissions)
Aggregate(Admit~.,data=UCBAdmissions)
Aggregate(percent(Admit)~.,data=UCBAdmissions)
Aggregate(percent(Admit)~Gender,data=UCBAdmissions)
Aggregate(percent(Admit)~Dept,data=UCBAdmissions)
Aggregate(percent(Gender)~Dept,data=UCBAdmissions)
Aggregate(percent(Admit)~Dept,data=UCBAdmissions,Gender=="Female")
genTable(percent(Admit)~Dept,data=UCBAdmissions,Gender=="Female")
</code></pre>


</div>