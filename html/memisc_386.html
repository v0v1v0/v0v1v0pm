<div class="container">

<table style="width: 100%;"><tr>
<td>recode</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Recode Items, Factors and Numeric Vectors</h2>

<h3>Description</h3>

<p><code>recode</code> substitutes old values of a factor or a numeric
vector by new ones, just like the recoding facilities in some
commercial statistical packages.
</p>


<h3>Usage</h3>

<pre><code class="language-R">recode(x,...,
       copy=getOption("recode_copy",identical(otherwise,"copy")),
       otherwise=NA)
## S4 method for signature 'vector'
recode(x,...,
    copy=getOption("recode_copy",identical(otherwise,"copy")),
    otherwise=NA)
## S4 method for signature 'factor'
recode(x,...,
    copy=getOption("recode_copy",identical(otherwise,"copy")),
    otherwise=NA)
## S4 method for signature 'item'
recode(x,...,
    copy=getOption("recode_copy",identical(otherwise,"copy")),
    otherwise=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>One or more assignment expressions, each 
of the form <code>new.value &lt;- old.values</code>.
<code>new.value</code> should be a scalar numeric value
or character string. If one of the <code>new.value</code>s
is a character string, the return value
of <code>recode</code> will be a factor and each <code>new.value</code>
will be coerced to a character string that labels a level of the factor.
</p>
<p>Each <code>old.value</code> in an assignment expression may be a
(numeric or character) vector. If <code>x</code> is numeric such an
assignment expression may have the form <code>new.value &lt;- range(lower,upper)</code>
In that case, values between <code>lower</code> and <code>upper</code> are exchanged by
<code>new.value</code>. If one of the arguments to <code>range</code> is <code>min</code>,
it is substituted by the minimum of <code>x</code>.
If one of the arguments to <code>range</code> is <code>max</code>,
it is substituted by the maximum of <code>x</code>.
</p>
<p>In case of the method for <code>labelled</code> vectors, the <em>tags</em> of
arguments of the form <code>tag = new.value &lt;- old.values</code>
will define the labels of the new codes.
</p>
<p>If the <code>old.values</code> of different assignment expressions overlap,
an error will be raised because the recoding is ambigous.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy</code></td>
<td>
<p>logical; should those values of <code>x</code> not given an
explicit new code copied into the resulting vector?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>otherwise</code></td>
<td>
<p>a character string or some other value
that the result may obtain. If equal to <code>NA</code> or <code>"NA"</code>,
original codes not given an explicit new code are recoded into
<code>NA</code>. If equal to <code>"copy"</code>,
original codes not given an explicit new code are copied.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>recode</code> relies on the lazy evaluation mechanism of <em>R</em>:
Arguments are not evaluated until required by the function they are given to.
<code>recode</code> does not cause arguments that appear in <code>...</code> to be evaluated.
Instead, <code>recode</code> parses the <code>...</code> arguments. Therefore, although
expressions like <code>1 &lt;- 1:4</code> would cause an error action, if evaluated
at any place elsewhere in <em>R</em>, they will not cause an error action,
if given to <code>recode</code> as an argument. However, a call of the
form <code>recode(x,1=1:4)</code>, would be a syntax error.
</p>
<p>If John Fox' package "car" is installed, <code>recode</code> will also be callable
with the syntax of the <code>recode</code> function of that package.
</p>


<h3>Value</h3>

<p>A numerical vector, factor or an <code>item</code> object.
</p>


<h3>See Also</h3>

<p><code>recode</code> of package "car".
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- as.item(sample(1:6,20,replace=TRUE),
        labels=c( a=1,
                  b=2,
                  c=3,
                  d=4,
                  e=5,
                  f=6))
print(x)


codebook(
    recode(x,
           a = 1 &lt;- 1:2,
           b = 2 &lt;- 4:6))


codebook(
    recode(x,
           a = 1 &lt;- 1:2,
           b = 2 &lt;- 4:6,
           copy = TRUE))

# Note the handling of labels if the recoding rules are bijective
codebook(
    recode(x,
           1 &lt;- 2,
           2 &lt;- 1,
           copy=TRUE))

codebook(
    recode(x,
           a = 1 &lt;- 2,
           b = 2 &lt;- 1,
           copy=TRUE))


# A recoded version of x is returned
# containing the values 1, 2, 3, which are
# labelled as "A", "B", "C".
recode(x,
  A = 1 &lt;- range(min,2),
  B = 2 &lt;- 3:4,
  C = 3 &lt;- range(5,max), # this last comma is ignored
  )

# This causes an error action: the sets
# of original values overlap.
try(recode(x,
  A = 1 &lt;- range(min,2),
  B = 2 &lt;- 2:4,
  C = 3 &lt;- range(5,max)
  ))

recode(x,
  A = 1 &lt;- range(min,2),
  B = 2 &lt;- 3:4,
  C = 3 &lt;- range(5,6),
  D = 4 &lt;- 7
  )
  
# This results in an all-missing vector:
recode(x,
  D = 4 &lt;- 7,
  E = 5 &lt;- 8
  )

f &lt;- as.factor(x)
x &lt;- as.integer(x)

recode(x,
  1 &lt;- range(min,2),
  2 &lt;- 3:4,
  3 &lt;- range(5,max)
  )

# This causes another error action:
# the third argument is an invalid
# expression for a recoding.
try(recode(x,
  1 &lt;- range(min,2),
  3:4,
  3 &lt;- range(5,max)
  ))

# The new values are character strings,
# therefore a factor is returned.
recode(x,
  "a" &lt;- range(min,2),
  "b" &lt;- 3:4,
  "c" &lt;- range(5,6)
  )
  
recode(x,
  1 &lt;- 1:3,
  2 &lt;- 4:6
  )
  
recode(x,
  4 &lt;- 7,
  5 &lt;- 8,
  otherwise = "copy"
  )

recode(f,
  "A" &lt;- c("a","b"),
  "B" &lt;- c("c","d"),
  otherwise="copy"
  )

recode(f,
  "A" &lt;- c("a","b"),
  "B" &lt;- c("c","d"),
  otherwise="C"
  )
 
recode(f,
  "A" &lt;- c("a","b"),
  "B" &lt;- c("c","d")
  )

DS &lt;- data.set(x=as.item(sample(1:6,20,replace=TRUE),
        labels=c( a=1,
                  b=2,
                  c=3,
                  d=4,
                  e=5,
                  f=6)))
print(DS)

DS &lt;- within(DS,{
    xf &lt;- recode(x,
                 "a" &lt;- range(min,2),
                 "b" &lt;- 3:4,
                 "c" &lt;- range(5,6)
                 )
    xn &lt;- x@.Data
    xc &lt;- recode(xn,
                 "a" &lt;- range(min,2),
                 "b" &lt;- 3:4,
                 "c" &lt;- range(5,6)
                 )
    xc &lt;- as.character(x)
    xcc &lt;- recode(xc,
                  1 &lt;- letters[1:2],
                  2 &lt;- letters[3:4],
                  3 &lt;- letters[5:6]
                  )
})

DS

DS &lt;- within(DS,{
    xf &lt;- recode(x,
                 "a" &lt;- range(min,2),
                 "b" &lt;- 3:4,
                 "c" &lt;- range(5,6)
                 )
    x1 &lt;- recode(x,
                 1 &lt;- range(1,2),
                 2 &lt;- range(3,4),
                 copy=TRUE
                 )
    xf1 &lt;- recode(x,
                 "A" &lt;- range(1,2),
                 "B" &lt;- range(3,4),
                 copy=TRUE
                 )
})
DS
codebook(DS)

DF &lt;- data.frame(x=rep(1:6,4,replace=TRUE))
DF &lt;- within(DF,{
    xf &lt;- recode(x,
                 "a" &lt;- range(min,2),
                 "b" &lt;- 3:4,
                 "c" &lt;- range(5,6)
                 )
    x1 &lt;- recode(x,
                 1 &lt;- range(1,2),
                 2 &lt;- range(3,4),
                 copy=TRUE
                 )
    xf1 &lt;- recode(x,
                 "A" &lt;- range(1,2),
                 "B" &lt;- range(3,4),
                 copy=TRUE
                 )
    xf2 &lt;- recode(x,
                 "B" &lt;- range(3,4),
                 "A" &lt;- range(1,2),
                 copy=TRUE
                 )
})
DF
codebook(DF)

</code></pre>


</div>