<div class="container">

<table style="width: 100%;"><tr>
<td>importers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Object Oriented Interface to Foreign Files</h2>

<h3>Description</h3>

<p>Importer objects are objects that refer to an external
data file. Currently only Stata files,
SPSS system, portable, and fixed-column files are supported.
</p>
<p>Data are actually imported by ‘translating’ an
importer file into a <code>data.set</code> using
<code>as.data.set</code> or <code>subset</code>.
</p>
<p>The <code>importer</code> mechanism is more flexible and extensible
than <code>read.spss</code> and  <code>read.dta</code>
of package "foreign", as most of the parsing of the file headers is done in R.
It is also adapted to efficiently load large data sets.
Most importantly, importer objects support the
<code>labels</code>, <code>missing.values</code>,
and <code>description</code>s, provided by this package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spss.file(file,...)

spss.fixed.file(file,
  columns.file,
  varlab.file=NULL,
  codes.file=NULL,
  missval.file=NULL,
  count.cases=TRUE,
  to.lower=getOption("spss.fixed.to.lower",FALSE),
  iconv=TRUE,
  encoded=getOption("spss.fixed.encoding","cp1252"),
  negative2missing = FALSE)

spss.portable.file(file,
  varlab.file=NULL,
  codes.file=NULL,
  missval.file=NULL,
  count.cases=TRUE,
  to.lower=getOption("spss.por.to.lower",FALSE),
  iconv=TRUE,
  encoded=getOption("spss.por.encoding","cp1252"),
  negative2missing = FALSE)

spss.system.file(file,
  varlab.file=NULL,
  codes.file=NULL,
  missval.file=NULL,
  count.cases=TRUE,
  to.lower=getOption("spss.sav.to.lower",FALSE),
  iconv=TRUE,
  encoded=getOption("spss.sav.encoding","cp1252"),
  ignore.scale.info = FALSE,
  negative2missing = FALSE)

Stata.file(file,
           iconv=TRUE,
           encoded=if(new_format)
                        getOption("Stata.new.encoding","utf-8")
                   else getOption("Stata.old.encoding","cp1252"),
           negative2missing = FALSE)

## The most important methods for "importer" objects are:
## S3 method for class 'spss.system.importer'
subset(x, subset, select, drop = FALSE, ...)
## S3 method for class 'spss.portable.importer'
subset(x, subset, select, drop = FALSE, ...)
## S3 method for class 'spss.fixed.importer'
subset(x, subset, select, drop = FALSE, ...)
## S3 method for class 'Stata.importer'
subset(x, subset, select, drop = FALSE, ...)
## S3 method for class 'Stata_new.importer'
subset(x, subset, select, drop = FALSE, ...)

## S4 method for signature 'importer'
as.data.set(x,row.names=NULL,optional=NULL,
                    compress.storage.modes=FALSE,...)

## S4 method for signature 'importer'
head(x,n=20,...)
## S4 method for signature 'importer'
tail(x,n=20,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>character string; the path to the file containing
the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments. <code>spss.file()</code> passes them on to
<code>spss.portable.file()</code> of  <code>spss.system.file()</code>. Other
function ignore further arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns.file</code></td>
<td>
<p>character string; the path to an
SPSS/PSPP syntax file with a <code>DATA LIST FIXED</code> statement</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varlab.file</code></td>
<td>
<p>character string; the path to an
SPSS/PSPP syntax file with a <code>VARIABLE LABELS</code> statement</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>codes.file</code></td>
<td>
<p>character string; the path to an
SPSS/PSPP syntax file with a <code>VALUE LABELS</code> statement</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missval.file</code></td>
<td>
<p>character string; the path to an
SPSS/PSPP syntax file with a <code>MISSING VALUES</code> statement</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count.cases</code></td>
<td>
<p>logical; should cases in file be counted? This
takes effect only if the data file does not already contain information
about the number of cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to.lower</code></td>
<td>
<p>logical; should variable names changed to lower
case?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iconv</code></td>
<td>
<p>logical; should strings (in labels and
variables) changed into encoding of the platform?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>encoded</code></td>
<td>
<p>a cacharacter string; the way characters are encoded
in the improrted file. For the available encoding options
see <code>?iconvlist</code>. Using this argument for
<code>spss.system.file</code> this is only a fallback, as the function
uses the encoding information present in the file if it is
present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negative2missing</code></td>
<td>
<p>logical; should negative values be marked
as missing values? This is the convention of some newer data sets that
are available e.g. from the GESIS data archive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.scale.info</code></td>
<td>
<p>logical; should information about measuremnt
scale levels provided in the file be ignored?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object that inherits from class <code>"importer"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>a logical vector or an expression containing variables
from the external data file that evaluates to logical. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p>a vector of variable names from the external data file.
This may also be a named vector, where the names give
the names into which the variables from the external data
file are renamed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>a logical value, that determines what happens if
only one column is selected. If TRUE and only one column
is selected, <code>subset</code> returns only a single <code>item</code>
object and not a <code>data.set</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>ignored, present only for compatibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optional</code></td>
<td>
<p>ignored, present only for compatibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compress.storage.modes</code></td>
<td>
<p>logical value; if TRUE floating point values
are converted to integers if possible without loss of information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer; the number of rows to be shown by <code>head</code> or <code>tail</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A call to a ‘constructor’ for an importer object, that is,
<code>spss.fixed.file</code>, <code>spss.portable.file</code>, <code>spss.sysntax.file</code>,
or <code>Stata.file</code>,
causes R to read in the header of the data file and/or
the syntax files that contain information about
the variables, such as the columns that they occupy
(in case of <code>spss.fixed.file</code>), variable labels,
value labels and missing values.
</p>
<p>The information in the file header and/or the accompagnying
files is then processed to prepare the file for importing.
Thus the inner structure of an <code>importer</code> object may
well vary according to what type of file is to imported and
what additional information is given.
</p>
<p>The <code>as.data.set</code> and <code>subset</code> methods
for <code>"importer"</code> objects internally use the
generic functions <code>seekData</code>, <code>readData</code>, <code>readSlice</code>,
and <code>readChunk</code>, which have methods for the
subclasses of <code>"importer"</code>.
These functions are not callable
from outside the package, however.
</p>
<p>The <code>subset</code> method for <code>"importer"</code> objects reads in
the data ‘chunk-wise’ to create the subset of observations if
the option <code>"subset.chunk.size"</code> is set to a non-<code>NULL</code>
value, e.g. by <code>options(subset.chunk.size=1000)</code>. This may be
useful in case of very large data sets from which only a tiny subset
of observations is needed for analysis.
</p>
<p>Since the functions described here are more or less complete rewrite
based on the description of the file structure provided
by the documenation for PSPP, they are perhaps not as thorougly tested as the 
functions in the <code>foreign</code> package, apart from the frequent use
by the author of this package.
</p>


<h3>Value</h3>

<p><code>spss.fixed.file</code>, <code>spss.portable.file</code>,
<code>spss.system.file</code>, and <code>Stata.file</code>
return, respectively, objects of class
<code>"spss.fixed.importer"</code>, <code>"spss.portable.importer"</code>,
<code>"spss.system.importer"</code>, <code>"Stata.importer"</code>, or <code>"Stata_new.importer"</code>,
which, by inheritance, are also objects of class <code>"importer"</code>.
<code>"Stata.importer"</code> is for files in the format of Stata versions up
to 12, while <code>"Stata_new.importer"</code> is for files in the newer
format of Stata versions from 13.
</p>
<p>Objects of class <code>"importer"</code> have at least the following two slots:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>ptr</code></td>
<td>
<p>an external pointer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variables</code></td>
<td>
<p>a list of objects of class <code>"item.vector"</code> which
provides a ‘prototype’ for the <code>"data.set"</code> set objects returned
by the <code>as.data.set</code> and <code>subset</code> methods for objects of
class <code>"importer"</code> </p>
</td>
</tr>
</table>
<p>The <code>as.data.frame</code> for <code>importer</code> objects does
the actual data import and returns a data frame. Note that in contrast
to <code>read.spss</code>, the variable names of the
resulting data frame will be lower case, unless the importer function
is called with <code>to.lower=FALSE</code>. If long variable names
are defined (in case of a PSPP/SPSS system file), they take
precedence and are <em>not</em> coerced to lower case.
</p>


<h3>See Also</h3>

 <p><code>codebook</code>, <code>description</code>,
<code>read.spss</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Extract American National Election Study of 1948
nes1948.por &lt;- unzip(system.file("anes/NES1948.ZIP",package="memisc"),
                     "NES1948.POR",exdir=tempfile())

# Get information about the variables contained.
nes1948 &lt;- spss.portable.file(nes1948.por)

# The data are not yet loaded:
show(nes1948)

# ... but one can see what variables are present:
description(nes1948)

# Now a subset of the data is loaded:
vote.socdem.48 &lt;- subset(nes1948,
              select=c(
                  V480018,
                  V480029,
                  V480030,
                  V480045,
                  V480046,
                  V480047,
                  V480048,
                  V480049,
                  V480050
                  ))

# Let's make the names more descriptive:
vote.socdem.48 &lt;- rename(vote.socdem.48,
                  V480018 = "vote",
                  V480029 = "occupation.hh",
                  V480030 = "unionized.hh",
                  V480045 = "gender",
                  V480046 = "race",
                  V480047 = "age",
                  V480048 = "education",
                  V480049 = "total.income",
                  V480050 = "religious.pref"
        )

# It is also possible to do both
# in one step:
# vote.socdem.48 &lt;- subset(nes1948,
#              select=c(
#                  vote           = V480018,
#                  occupation.hh  = V480029,
#                  unionized.hh   = V480030,
#                  gender         = V480045,
#                  race           = V480046,
#                  age            = V480047,
#                  education      = V480048,
#                  total.income   = V480049,
#                  religious.pref = V480050
#                  ))



# We examine the data more closely:
codebook(vote.socdem.48)

# ... and conduct some analyses.
#
t(genTable(percent(vote)~occupation.hh,data=vote.socdem.48))

# We consider only the two main candidates.
vote.socdem.48 &lt;- within(vote.socdem.48,{
  truman.dewey &lt;- vote
  valid.values(truman.dewey) &lt;- 1:2
  truman.dewey &lt;- relabel(truman.dewey,
              "VOTED - FOR TRUMAN" = "Truman",
              "VOTED - FOR DEWEY"  = "Dewey")
  })

summary(truman.relig.glm &lt;- glm((truman.dewey=="Truman")~religious.pref,
    data=vote.socdem.48,
    family="binomial",
))
</code></pre>


</div>