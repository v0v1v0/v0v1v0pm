<div class="container">

<table style="width: 100%;"><tr>
<td>Means</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Means for groups of observations</h2>

<h3>Description</h3>

<p>The function <code>Means()</code> creates a table of group
means, optionally with standard errors, confidence intervals, and
numbers of valid observations.</p>


<h3>Usage</h3>

<pre><code class="language-R">Means(data, ...)
## S3 method for class 'data.frame'
Means(data,
    by, weights=NULL, subset=NULL,
    default=NA,
    se=FALSE, ci=FALSE, ci.level=.95,
    counts=FALSE, ...)
## S3 method for class 'formula'
Means(data, subset, weights, ...)
## S3 method for class 'numeric'
Means(data, ...)
## S3 method for class 'means.table'
as.data.frame(x, row.names=NULL, optional=TRUE, drop=TRUE, ...)
## S3 method for class 'xmeans.table'
as.data.frame(x, row.names=NULL, optional=TRUE, drop=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an object usually containing data, or a formula.
</p>
<p>If <code>data</code> is a numeric vector or an object that can be coerced
into a data frame, it is changed into a data frame and the data
frame method of <code>Means()</code> is applied to it.
</p>
<p>If <code>data</code> is a formula, then a data frame is constructed from
the variables in the formula and <code>Means</code> is applied to this
data frame, while the formula is passed on as a <code>by=</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>a formula, a vector of variable names or a data frame or
list of factors.
</p>
<p>If <code>by</code> is a vector of variable names,
they are extracted from <code>data</code> to define the groups for which
means are computed, while the variables for which the means are
computed are those not named in <code>by</code>.
</p>
<p>If <code>by</code> is a data frame or a list of factors,
these are used to defined the groups for which means are computed,
while the variables for which the means are
computed are those not in <code>by</code>.
</p>
<p>If <code>by</code> is a formula, its left-hand side determines the
variables of which means are computed, while its right-hand side
determines the factors that define the groups.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of weights, usually a variable in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional logical vector to select observations,
usually the result of an expression in variables from <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default</code></td>
<td>
<p>a default value used for empty cells without
observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>a logical value, indicates whether standard errors should be
computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>a logical value, indicates whether limits of confidence
intervals should be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>a number, the confidence level of the confidence interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p>a logical value, indicates whether numbers of valid
observations should be reported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>for <code>as.data.frame()</code>, a result of <code>Means()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>an optional character vector. This argmument presently is
inconsequential and only included for reasons of compatiblity
with the standard methods of <code>as.data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optional</code></td>
<td>
<p>an optional logical value. This argmument presently is
inconsequential and only included for reasons of compatiblity
with the standard methods of <code>as.data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>a logical value, determines whether "empty cells" should
be dropped from the resulting data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments, either ignored or passed on to other
methods where applicable.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An array that inherits classes "means.table" and "table". If
<code>Means</code> was called with <code>se=TRUE</code> or <code>ci=TRUE</code>
then the result additionally inherits class "xmeans.table".
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Preparing example data
USstates &lt;- as.data.frame(state.x77)
USstates &lt;- within(USstates,{
    region &lt;- state.region
    name &lt;- state.name
    abb &lt;- state.abb
    division &lt;- state.division
})
USstates$w &lt;- sample(runif(n=6),size=nrow(USstates),replace=TRUE)

# Using the data frame method
Means(USstates[c("Murder","division","region")],by=c("division","region"))
Means(USstates[c("Murder","division","region")],by=USstates[c("division","region")])
Means(USstates[c("Murder")],1)
Means(USstates[c("Murder","region")],by=c("region"))

# Using the formula method
# One 'dependent' variable
Means(Murder~1, data=USstates)
Means(Murder~division, data=USstates)
Means(Murder~division, data=USstates,weights=w)
Means(Murder~division+region, data=USstates)
as.data.frame(Means(Murder~division+region, data=USstates))

# Standard errors and counts
Means(Murder~division, data=USstates, se=TRUE, counts=TRUE)
drop(Means(Murder~division, data=USstates, se=TRUE, counts=TRUE))
as.data.frame(Means(Murder~division, data=USstates, se=TRUE, counts=TRUE))

# Confidence intervals
Means(Murder~division, data=USstates, ci=TRUE)
drop(Means(Murder~division, data=USstates, ci=TRUE))
as.data.frame(Means(Murder~division, data=USstates, ci=TRUE))

# More than one dependent variable
Means(Murder+Illiteracy~division, data=USstates)
as.data.frame(Means(Murder+Illiteracy~division, data=USstates))

# Confidence intervals
Means(Murder+Illiteracy~division, data=USstates, ci=TRUE)
as.data.frame(Means(Murder+Illiteracy~division, data=USstates, ci=TRUE))

# Some 'non-standard' but still valid usages:
with(USstates,
     Means(Murder~division+region,subset=region!="Northeast"))

with(USstates,
     Means(Murder,by=list(division,region)))
</code></pre>


</div>