<div class="container">

<table style="width: 100%;"><tr>
<td>codeplan</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Describe structure of Data Sets and Importers</h2>

<h3>Description</h3>

<p>The function <code>codeplan()</code> creates a data frame that
describes the structure of an item list (a <code>data.set</code> object or
an <code>importer</code> object), so that this structure can be stored and
and recovered. The resulting data frame has a particular print method
that delimits the output to one line per variable.
</p>
<p>With <code>setCodeplan</code> an item list structure (as returned by <code>codeplan()</code>)
can be applied to a data frame or data set. It is also possible to use an
assignment like <code>codeplan(x) &lt;- value</code> to a similar effect.
</p>


<h3>Usage</h3>

<pre><code class="language-R">codeplan(x)
## S4 method for signature 'item.list'
codeplan(x)
## S4 method for signature 'item'
codeplan(x)
setCodeplan(x,value)
## S4 method for signature 'data.frame,codeplan'
setCodeplan(x,value)
## S4 method for signature 'data.frame,NULL'
setCodeplan(x,value)
## S4 method for signature 'data.set,codeplan'
setCodeplan(x,value)
## S4 method for signature 'data.set,NULL'
setCodeplan(x,value)
## S4 method for signature 'item,codeplan'
setCodeplan(x,value)
## S4 method for signature 'item,NULL'
setCodeplan(x,value)
## S4 method for signature 'atomic,codeplan'
setCodeplan(x,value)
## S4 method for signature 'atomic,NULL'
setCodeplan(x,value)
codeplan(x) &lt;- value
read_codeplan(filename,type)
write_codeplan(x,filename,type,pretty)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>for <code>codeplan(x)</code> an object that inherits from class <code>"item.list"</code>,
i.e. can be a <code>"data.set"</code> object or an <code>"importer"</code>
object, it can also be an object that inherits from class
<code>"item"</code>.
For <code>write_codeplan</code> an object from class <code>"codeplan"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>an object as it would be returned by <code>codeplan(x)</code>
or <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>a character string, the name of the file that is to be
read or to be written.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a character string (either "yaml" or "json") oder NULL (the default), gives the type
of the file into which the codeplan is written or from
which it is read.
If <code>type</code> is NULL then the file type is inferred from
the file name ending (".yaml" or ",yml" for "yaml",
".json" for "json").
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pretty</code></td>
<td>
<p>a logical value, whether the JSON output created by <code>write_codeplan(...)</code> should be prettified.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If applicable, <code>codeplan</code> returns a list with
additional S3 class attribute <code>"codeplan"</code>. For arguments for
which the relevant information does not exist, the function returns <code>NULL</code>.
</p>
<p>The list has at least one element or several elements, named after the
variable in the "item.list" or "data.set" <code>x</code>. Each list element
is a list itself with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>annotation</code></td>
<td>
<p>a named character vector,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>a named list of labels and labelled values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value.filter</code></td>
<td>
<p>a list with at least two elements named
"class" and "filter", and optionally another element named
"range". The "class" element determines the class of the
value filter and equals either "missing.values", "valid.values",
or "valid.range". An element named "range" may only be needed
if "class" is "missing.values", as it is possible (like in SPSS)
to have <em>both</em> individual missing values and a range of
missing values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>a character string that describes storage mode, such as <code>"character"</code>,
<code>"integer"</code>, or <code>"numeric"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measurement</code></td>
<td>
<p>a character string with the measurement level,
<code>"nominal"</code>, <code>"ordinal"</code>, <code>"interval"</code>, or
<code>"ratio"</code>.</p>
</td>
</tr>
</table>
<p>If <code>codeplan(x)&lt;-value</code> or <code>setCodeplan(x,value)</code> is used
and <code>value</code> is <code>NULL</code>, all the special information about
annotation, labels, value filters, etc. is removed from the resulting
object, which then is usually a mere atomic vector or data frame.
</p>


<h3>Examples</h3>

<pre><code class="language-R">Data1 &lt;- data.set(
          vote = sample(c(1,2,3,8,9,97,99),size=300,replace=TRUE),
          region = sample(c(rep(1,3),rep(2,2),3,99),size=300,replace=TRUE),
          income = exp(rnorm(300,sd=.7))*2000
          )

Data1 &lt;- within(Data1,{
  description(vote) &lt;- "Vote intention"
  description(region) &lt;- "Region of residence"
  description(income) &lt;- "Household income"
  foreach(x=c(vote,region),{
    measurement(x) &lt;- "nominal"
    })
  measurement(income) &lt;- "ratio"
  labels(vote) &lt;- c(
                    Conservatives         =  1,
                    Labour                =  2,
                    "Liberal Democrats"   =  3,
                    "Don't know"          =  8,
                    "Answer refused"      =  9,
                    "Not applicable"      = 97,
                    "Not asked in survey" = 99)
  labels(region) &lt;- c(
                    England               =  1,
                    Scotland              =  2,
                    Wales                 =  3,
                    "Not applicable"      = 97,
                    "Not asked in survey" = 99)
  foreach(x=c(vote,region,income),{
    annotation(x)["Remark"] &lt;- "This is not a real survey item, of course ..."
    })
  missing.values(vote) &lt;- c(8,9,97,99)
  missing.values(region) &lt;- c(97,99)
})
cpData1 &lt;- codeplan(Data1)

Data2 &lt;- data.frame(
          vote = sample(c(1,2,3,8,9,97,99),size=300,replace=TRUE),
          region = sample(c(rep(1,3),rep(2,2),3,99),size=300,replace=TRUE),
          income = exp(rnorm(300,sd=.7))*2000
          )
codeplan(Data2) &lt;- cpData1
codeplan(Data2)
codebook(Data2)

# Note the difference between 'as.data.frame' and setting
# the codeplan to NULL:
Data2df &lt;- as.data.frame(Data2)
codeplan(Data2) &lt;- NULL
str(Data2)
str(Data2df)
codeplan(Data2) &lt;- NULL # Does not change anything

# Codeplans of survey items can also be inquired and manipulated:
vote &lt;- Data1$vote
str(vote)
cp.vote &lt;- codeplan(vote)
codeplan(vote) &lt;- NULL
str(vote)
codeplan(vote) &lt;- cp.vote
vote

fn.json &lt;- paste0(tempfile(),".json")
write_codeplan(codeplan(Data1),filename=fn.json)
codeplan(Data2) &lt;- read_codeplan(fn.json)
codeplan(Data2)
</code></pre>


</div>