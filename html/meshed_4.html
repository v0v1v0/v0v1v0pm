<div class="container">

<table style="width: 100%;"><tr>
<td>rmeshedgp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Prior sampling from a Meshed Gaussian Process
</h2>

<h3>Description</h3>

<p>Generates samples from a (univariate) MGP assuming a cubic directed acyclic graph and axis-parallel domain partitioning.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rmeshedgp(coords, theta, 
  axis_partition = NULL, block_size = 100, 
  n_threads=1, cache=TRUE, verbose=FALSE, debug=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>

<p>matrix of spatial or spatiotemporal coordinates with <code class="reqn">d=2</code> or <code class="reqn">d=3</code> columns for spatial or spatiotemporal data, respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>

<p>vector with covariance parameters. If <code class="reqn">d=2</code> and <code>theta</code> is a 2-dimensional vector then <code class="reqn">\theta = (\phi, \sigma^2)</code> where <code class="reqn">\phi</code> is the spatial decay and <code class="reqn">\sigma^2</code> is the spatial variance in the exponential covariance model. If <code class="reqn">d=2</code> and <code>theta</code> is a 3-dimensional vector then <code class="reqn">\theta = (\phi, \nu, \sigma^2)</code> and a Matern model with smoothness <code class="reqn">\nu</code> is used instead. If <code class="reqn">d=3</code>, <code>theta</code> must be a 4-dimensional vector and <code class="reqn">\theta=(a, \phi, b, \sigma^2)</code> using Gneiting's non-separable spatiotemporal covariance detailed below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axis_partition</code></td>
<td>

<p>integer vector of length <code class="reqn">d</code> with the number of intervals along which each axis should be partitioned. The domain will be partitioned into <code>prod(axis_partition)</code> blocks. This argument can be left blank when using <code>block_size</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block_size</code></td>
<td>

<p>integer specifying the (approximate) size of the blocks, i.e. how many spatial or spatiotemporal locations should be included in each block. Note: larger values correspond to an MGP that is closer to a full GP, but require more expensive computations. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_threads</code></td>
<td>

<p>integer number of OpenMP threads. This is ineffective if <code>meshed</code> was not compiled with OpenMP support.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache</code></td>
<td>

<p>bool: whether to use cache. Some computational speedup is associated to <code>cache=TRUE</code> if <code>coords</code> are a grid. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>bool: print some messages.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>

<p>bool: print more messages.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Gaussian processes (GPs) lack in scalability to big datasets due to the assumed unrestricted dependence across the spatial or spatiotemporal domain.
<em>Meshed</em> GPs instead use a directed acyclic graph (DAG) with patterns, called <em>mesh</em>, to simplify the dependence structure across the domain. Each DAG node corresponds to a partition of the domain. MGPs can be interpreted as approximating the GP they originate from, or as standalone processes that can be sampled from. This function samples random MGPs and can thus be used to generate big spatial or spatiotemporal data. 
The only requirement to sample from a MGP compared to a standard GP is the specification of the domain partitioning strategy. Here, either <code>axis_partition</code> or <code>block_size</code> can be used; the default <code>block_size=100</code> can be used to quickly sample smooth surfaces at millions of locations. 
</p>
<p>Just like in a standard GP, one needs a covariance function or kernel which can be set as follows. 
For spatial data (<code class="reqn">d=2</code>), the length of <code>theta</code> determines which model is used (see above). Letting <code class="reqn">h = \| s-s' \|</code> where <code class="reqn">s</code> and <code class="reqn">s'</code> are locations in the spatial domain, the exponential covariance is defined as: 
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \sigma^2 \exp \{ - \phi h \},</code>
</p>

<p>whereas the Matern model is
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \sigma^2  \frac{2^{1-\nu}}{\Gamma(\nu)} \phi^{\nu} h^{\nu} K_{\nu} ( \phi h ),
  </code>
</p>

<p>where <code class="reqn">K_{\nu}</code> is the modified Bessel function of the second kind of order <code class="reqn">\nu</code>.
For spatiotemporal data (<code class="reqn">d=3</code>) the covariance function between locations <code class="reqn">(s, t)</code> and <code class="reqn">(s', t')</code> with distance <code class="reqn">h = \| s-s' \|</code> and time lag <code class="reqn">u = \| t-t' \|</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn"> C(h, u) = \sigma^2 / (a u + 1) \exp \{ -\phi h (a u + 1)^{-b/2} \}, </code>
</p>

<p>which is a special case of non-separable spacetime covariance as introduced by Gneiting (2002).
</p>


<h3>Value</h3>

<p>data.frame with the (reordered) supplied coordinates in the first <code>d</code> columns, and the MGP sample in the last column, labeled <code>w</code>.
</p>


<h3>Author(s)</h3>

<p>Michele Peruzzi &lt;michele.peruzzi@duke.edu&gt;
</p>


<h3>References</h3>

<p>Gneiting, T (2002) Nonseparable, Stationary Covariance Functions for Space-Time Data. <em>Journal of the American Statistical Association</em>. <a href="https://doi.org/10.1198/016214502760047113">doi:10.1198/016214502760047113</a>
</p>
<p>Peruzzi, M., Banerjee, S., and Finley, A.O. (2020)
Highly Scalable Bayesian Geostatistical Modeling via Meshed Gaussian Processes on Partitioned Domains. <em>Journal of the American Statistical Association</em>, in press. <a href="https://doi.org/10.1080/01621459.2020.1833889">doi:10.1080/01621459.2020.1833889</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  
library(ggplot2)
library(magrittr)
library(meshed)

# spatial domain (we choose a grid to make a nice image later)
# this generates a dataset of size 6400
xx &lt;- seq(0, 1, length.out=80)
coords &lt;- expand.grid(xx, xx) %&gt;%
  as.matrix()

raster_plot &lt;- function(df){
  ggplot(df, aes(Var1, Var2, fill=w)) +
    geom_raster() +
    scale_fill_viridis_c() +
    theme_minimal() }

# spatial data, exponential covariance
# phi=14, sigma^2=2
simdata &lt;- rmeshedgp(coords, c(14, 2))
raster_plot(simdata)

# spatial data, matern covariance
# phi=14, nu=1, sigma^2=2
simdata &lt;- rmeshedgp(coords, c(14, 1, 2))
raster_plot(simdata)

# spacetime data, gneiting's covariance
# 64000 locations
stcoords &lt;- expand.grid(xx, xx, seq(0, 1, length.out=10))

# it should take less than a couple of seconds
simdata &lt;- rmeshedgp(stcoords, c(1, 14, .5, 2))
# plot data at 7th time period
raster_plot(simdata %&gt;% dplyr::filter(Var3==unique(Var3)[7])) 

</code></pre>


</div>