<div class="container">

<table style="width: 100%;"><tr>
<td>spmeshed</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Posterior sampling for models based on MGPs</h2>

<h3>Description</h3>

<p>Fits Bayesian multivariate spatial or spatiotemporal regression models with latent MGPs via Markov chain Monte Carlo.</p>


<h3>Usage</h3>

<pre><code class="language-R">spmeshed(y, x, coords, k=NULL,
       family = "gaussian",
       axis_partition = NULL, 
       block_size = 30,
       grid_size = NULL,
       grid_custom = NULL,
       n_samples = 1000,
       n_burnin = 100,
       n_thin = 1,
       n_threads = 4,
       verbose = 0,
       predict_everywhere = FALSE,
       settings = list(adapting=TRUE, forced_grid=NULL, 
                          cache=NULL, ps=TRUE, saving=TRUE, low_mem=FALSE, hmc=4),
       prior = list(beta=NULL, tausq=NULL, sigmasq = NULL,
                          phi=NULL, a=NULL, nu = NULL,
                          toplim = NULL, btmlim = NULL, set_unif_bounds=NULL),
       starting = list(beta=NULL, tausq=NULL, theta=NULL, lambda=NULL, v=NULL, 
                       a=NULL, nu = NULL,
                       mcmcsd=.05, 
                       mcmc_startfrom=0),
       debug = list(sample_beta=TRUE, sample_tausq=TRUE, 
                    sample_theta=TRUE, sample_w=TRUE, sample_lambda=TRUE,
                    verbose=FALSE, debug=FALSE),
       indpart=FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>matrix of multivariate outcomes with <code class="reqn">n</code> rows and <code class="reqn">q</code> columns. Each row of <code>y</code> corresponds to a row of <code>coords</code>. <code>NA</code> values are accepted in any combination and will be predicted via MCMC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>matrix of covariates with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>matrix of coordinates with <code class="reqn">n</code> rows and <code class="reqn">d=2</code> or <code class="reqn">d=3</code> columns for spatial or spacetime regression, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer <code class="reqn">k\leq q</code>, number of latent processes to use for the linear model of coregionalization. If unspecified, this is set to <code class="reqn">q</code><code>=ncol(y)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a vector with length <code class="reqn">1</code> or <code class="reqn">q</code> whose elements corresponds to the data types of columns of <code>y</code>. Available choices are <code>gaussian</code>, <code>poisson</code>, <code>binomial</code>, <code>beta</code> for outcomes that are continuous, count, binary, or <code class="reqn">(0,1)</code> proportions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axis_partition</code></td>
<td>
<p>integer vector of size <code class="reqn">d</code>: number of intervals each coordinate axis is split into</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block_size</code></td>
<td>
<p>integer approximate size of the blocks after domain partitioning. Only used if <code>axis_partition</code> is not specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_size</code></td>
<td>
<p>integer vector of size <code class="reqn">d</code>: number of 'knots' of the reference grid along each axis. 
This grid is then partitioned using either <code>axis_partition</code> or <code>block_size</code>.
If unspecified, this is set so that the eventual grid size is close to <code class="reqn">n</code>.
This parameter is ignored if <code>settings$forced_grid=FALSE</code> in which case the data are assumed to be on a grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_custom</code></td>
<td>
<p>list with elements <code>grid</code> and <code>axis_interval_partition</code>. <code>grid</code> is a data.frame with the user supplied grid of knots. It is possible to include covariate values for the grid locations as additional columns, as long as their number matches <code>ncol(x)</code> - this is useful to make raster images of predictions. <code>axis_interval_partition</code> is the user supplied set of cuts for each coordinate axis (Note: these are the actual cutpoints along the axes, not the number of cuts). If left empty, <code>axis_partition</code> will be used to partition the custom grid. No checks are made on the validity of this grid. This parameter is ignored if <code>settings$forced_grid=FALSE</code> in which case the data are assumed to be on a grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_samples</code></td>
<td>
<p>integer number of MCMC samples at which all the unknowns are stored (including the latent effects).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_burnin</code></td>
<td>
<p>integer number of MCMC samples to discard at the beginning of the chain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_thin</code></td>
<td>
<p>integer thinning parameter for the MCMC chain. Only the chain of latent effects (<code class="reqn">w</code>) is thinned to save memory in big data problems. Chains for other unknowns are not thinned and thus will be of length <code>n_thin * n_samples</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_threads</code></td>
<td>
<p>integer number of OpenMP threads. This is ineffective if <code>meshed</code> was not compiled with OpenMP support.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>integer. If <code>verbose&lt;=20</code>, then this is the number of times a message is displayed during MCMC. If <code>verbose&gt;20</code>, then this is the number of MCMC iterations to wait until the next message update. If <code>verbose=Inf</code>, then a message will be printed at each MCMC iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict_everywhere</code></td>
<td>
<p>bool used if settings$forced_grid=T. Should predictions be made at the reference grid locations? If not, predictions will be made only at the supplied NA values of Y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>settings</code></td>
<td>
<p>list: <code>settings$adapting</code> turns the adaptation of MCMC on/off, <code>settings$forced_grid</code> determines whether or not to use the data grid or a forced grid; if unspecified, the function will try to see what the data look like. Note: if <code>forced_grid=FALSE</code> and <code class="reqn">n</code> is very large and <code class="reqn">coords</code> are irregularly spaced, then expect slowdowns in preprocessing and consider using <code>forced_grid=TRUE</code> instead. <code>settings$saving</code> will save model data if set to <code>TRUE</code>. <code>settings$low_mem</code> will only save <code>beta_mcmc</code>, <code>lambda_mcmc</code>, <code>v_mcmc</code>, <code>tausq_mcmc</code> (and not <code>w_mcmc</code> and <code>lp_mcmc</code>, which can be recovered from the others), thereby using less memory. All fitted predictions remain available in <code>yhat_mcmc</code> for convenience. <code>settings$ps</code> (default <code>TRUE</code>) determines whether to use the PS parametrization (Peruzzi et al 2021). <code>settings$hmc</code>, used if any outcome is not Gaussian, (1: MALA, 2: NUTS, 3: RM-MALA, 4: Simplified manifold preconditioning (default))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>list: setup for priors of unknown parameters. <code>prior$phi</code> needs to be specified as the support of the Uniform prior for <code class="reqn">\phi</code>. There is currently limited functionality here and some inputs are currently ignored. Defaults are: a vague Gaussian for <code class="reqn">\beta</code>, <code class="reqn">\tau^2_i \sim IG(2,1)</code>, <code class="reqn">\theta_j \sim IG(2,2)</code>, all subject to change.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starting</code></td>
<td>
<p>list: setup for starting values of unknown parameters. <code>starting$mcmcsd</code> is the initial standard deviation of proposals. <code>starting$mcmc_startfrom</code> is input to the adaptive MCMC and can be used to manually restart MCMC. There is currently limited functionality here and some parameters may be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>list: setup for debugging things. Some parts of MCMC can be turned off here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indpart</code></td>
<td>
<p>bool defaults to <code>FALSE</code>. If <code>TRUE</code>, this computes an independent partition model.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function targets the following model:
</p>
<p style="text-align: center;"><code class="reqn"> y(s) = x(s)^\top \beta + \Lambda v(s) + \epsilon(s), </code>
</p>

<p>where <code class="reqn">y(s)</code> is a <code class="reqn">q</code>-dimensional vector of outcomes at spatial location <code class="reqn">s</code>, <code class="reqn">x(s)</code> is a <code class="reqn">p</code>-dimensional vector of covariates with static coefficients <code class="reqn">\beta</code>, <code class="reqn">\Lambda</code> is a matrix of factor loadings of size <code class="reqn">(q, k)</code>, <code class="reqn">v(s)</code> is a <code class="reqn">k</code>-dimensional vector which collects the realization of independent Gaussian processes <code class="reqn">v_j \sim spmeshed(0, C_j)</code> for <code class="reqn">j=1, \dots, k</code> and where <code class="reqn">C_j(s, s')</code> is a correlation function. <code class="reqn">s</code> is a coordinate in space (<code class="reqn">d=2</code>) or space plus time (<code class="reqn">d=3</code>). The Meshed GP implemented here associates an axis-parallel tessellation of the domain to a cubic directed acyclic graph (mesh).
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coordsdata</code></td>
<td>
<p>data.frame including the original <code class="reqn">n</code> coordinates plus the <code class="reqn">n_g</code> knot coordinates if the model was run on a forced grid. The additional column <code>forced_grid</code> has value 1 if the corresponding coordinate is a knot in the forced grid. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>savedata</code></td>
<td>
<p>Available if <code>settings$saving==TRUE</code>. Needed for making predictions using <code>predict()</code> after MCMC. Note: <code>NA</code> values of the output are automatically and more efficiently predicted when running <code>spmeshed</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yhat_mcmc</code></td>
<td>
<p>list of length <code>n_samples</code> whose elements are matrices with <code class="reqn">n + n_g</code> rows and <code class="reqn">q</code> columns. Each matrix in the list is a posterior predictive sample of the latent spatial process. <code class="reqn">n_g = 0</code> if the data grid is being used. Given the possibly large <code class="reqn">n</code>, only the thinned chain is output for <code class="reqn">y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v_mcmc</code></td>
<td>
<p>list of length <code>n_samples</code> whose elements are matrices with <code class="reqn">n + n_g</code> rows and <code class="reqn">k</code> columns. Each matrix in the list is a posterior sample of the <code class="reqn">k</code> latent spatial process. <code class="reqn">n_g = 0</code> if the data grid is being used. Given the possibly large <code class="reqn">n</code>, only the thinned chain is output for <code class="reqn">v</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w_mcmc</code></td>
<td>
<p>list of length <code>n_samples</code> whose elements are matrices with <code class="reqn">n + n_g</code> rows and <code class="reqn">q</code> columns. Each matrix in the list is a posterior sample of <code class="reqn">w = \Lambda v</code>. <code class="reqn">n_g = 0</code> if the data grid is being used. Given the possibly large <code class="reqn">n</code>, only the thinned chain is output for <code class="reqn">w</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lp_mcmc</code></td>
<td>
<p>list of length <code>n_samples</code> whose elements are matrices with <code class="reqn">n + n_g</code> rows and <code class="reqn">q</code> columns. Each matrix in the list is a posterior sample of the linear predictor <code class="reqn">X\beta + \Lambda v</code>. <code class="reqn">n_g = 0</code> if the data grid is being used. Given the possibly large <code class="reqn">n</code>, only the thinned chain is output for <code class="reqn">w</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_mcmc</code></td>
<td>
<p>array of size <code>(p, q, n_thin*n_samples)</code> with the posterior sample for the static regression coefficients <code class="reqn">\beta</code>. The <code class="reqn">j</code>th column of each matrix (<code class="reqn">p</code> rows and <code class="reqn">q</code> columns) corresponds to the <code class="reqn">p</code> linear effects on the <code class="reqn">j</code>th outcome. The full chain minus burn-in is returned NOT thinned since <code>p</code> and <code>q</code> are relatively small.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tausq_mcmc</code></td>
<td>
<p>matrix of size <code>(q, n_thin*n_samples)</code>. Each row corresponds to the full MCMC chain for the nugget <code class="reqn">\tau^2_j</code> of the <code class="reqn">j</code>th outcome in the coregionalization/factor model. The full chain minus burn-in is returned NOT thinned since <code>q</code> is relatively small.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta_mcmc</code></td>
<td>
<p>array of size <code>(h, k, n_thin*n_samples)</code> with the posterior sample for the correlation function parameters <code class="reqn">\theta</code>. <code>h</code> is 2 for spatial data (corresponding to the spatial decay of the exponential covariance (<code class="reqn">\phi_i, i=1, \dots, k</code>), and the variance <code class="reqn">\sigma^2_i, i=1, \dots, k</code>), 4 for spacetime data (corresponding to temporal decay, spatial decay, and separability â€“ these are referred to as <code class="reqn">a_i</code>, <code class="reqn">\phi_i</code>, and <code class="reqn">\beta_i, i=1, \dots, k</code>, in Gneiting (2002), see <a href="https://doi.org/10.1198/016214502760047113">doi:10.1198/016214502760047113</a>, plus the variance <code class="reqn">\sigma^2, i=1, \dots, k</code>). The full chain minus burn-in is returned NOT thinned since <code>h</code> and <code>k</code> are relatively small. If <code>settings$ps=TRUE</code>, the MCMC output for <code class="reqn">\sigma^2_i</code> (last row of <code>theta_mcmc</code>) should be discarded and <code class="reqn">\Lambda</code> used instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_mcmc</code></td>
<td>
<p>array of size <code>(q, k, n_thin*n_samples)</code>. Each matrix (of size <code class="reqn">(q,k)</code>) is a posterior sample for <code class="reqn">\Lambda</code> in the coregionalization/factor model. In univariate models, this is usually called <code class="reqn">\sigma</code>. The full chain minus burn-in is returned NOT thinned since <code>q</code> and <code>k</code> are relatively small.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paramsd</code></td>
<td>
<p>Cholesky factorization of the proposal covariance for adaptive MCMC, after adaptation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>Total number of MCMC iterations performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc_time</code></td>
<td>
<p>Time in seconds taken for MCMC (not including preprocessing).</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Michele Peruzzi <a href="mailto:michele.peruzzi@duke.edu">michele.peruzzi@duke.edu</a>
</p>


<h3>References</h3>

<p>Peruzzi, M., Banerjee, S., and Finley, A.O. (2022)
Highly Scalable Bayesian Geostatistical Modeling via Meshed Gaussian Processes on Partitioned Domains. <em>Journal of the American Statistical Association</em>, 117(538):969-982. <a href="https://doi.org/10.1080/01621459.2020.1833889">doi:10.1080/01621459.2020.1833889</a>
</p>
<p>Peruzzi, M., Banerjee, S., Dunson, D.B., and Finley, A.O.  (2021)
Grid-Parametrize-Split (GriPS) for Improved Scalable Inference in Spatial Big Data Analysis. <a href="https://arxiv.org/abs/2101.03579">https://arxiv.org/abs/2101.03579</a>
</p>
<p>Peruzzi, M. and Dunson, D.B. (2022)
Spatial meshing for general Bayesian multivariate models. <a href="https://arxiv.org/abs/2201.10080">https://arxiv.org/abs/2201.10080</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# toy example with tiny dataset and short MCMC
# on a univariate outcome
library(magrittr)
library(dplyr)
library(ggplot2)
library(meshed)

set.seed(2021)

SS &lt;- 12
n &lt;- SS^2 # total n. locations, including missing ones

coords &lt;- expand.grid(xx &lt;- seq(0,1,length.out=SS), xx) %&gt;% 
  as.matrix()

# generate data
sigmasq &lt;- 2.3
phi &lt;- 6
tausq &lt;- .1
B &lt;- c(-1,.5,1)

CC &lt;- sigmasq * exp(-phi * as.matrix(dist(coords)))
LC &lt;- t(chol(CC))
w &lt;- LC %*% rnorm(n)
p &lt;- length(B)
X &lt;- rnorm(n * p) %&gt;% matrix(ncol=p)
y_full &lt;- X %*% B + w + tausq^.5 * rnorm(n)

set_missing &lt;- rbinom(n, 1, 0.1)

simdata &lt;- data.frame(coords,
                      y_full = y_full,
                      w_latent = w) %&gt;%
  mutate(y_observed = ifelse(set_missing==1, NA, y_full))

# MCMC setup
mcmc_keep &lt;- 500
mcmc_burn &lt;- 100
mcmc_thin &lt;- 2

y &lt;- simdata$y_observed
ybar &lt;- mean(y, na.rm=TRUE)

meshout &lt;- spmeshed(y-ybar, X, coords,
                    axis_partition=c(4,4),
                    n_samples = mcmc_keep, 
                    n_burn = mcmc_burn, 
                    n_thin = mcmc_thin, 
                    prior=list(phi=c(1,15)),
                    verbose = 0,
                    n_threads = 1)

# posterior means
best_post_mean &lt;- meshout$beta_mcmc %&gt;% apply(1:2, mean)
  
# process means
wmesh &lt;- data.frame(w_mgp = meshout$w_mcmc %&gt;% summary_list_mean())
# predictions
ymesh &lt;- data.frame(y_mgp = meshout$yhat_mcmc %&gt;% summary_list_mean())

outdf &lt;- 
  meshout$coordsdata %&gt;% 
  cbind(ymesh, wmesh) 

# plot predictions
pred_plot &lt;- outdf %&gt;% 
  ggplot(aes(Var1, Var2, color=y_mgp)) +
  geom_point() +
  scale_color_viridis_c()

# plot latent process
latent_plot &lt;- outdf %&gt;% 
  ggplot(aes(Var1, Var2, color=w_mgp)) +
  geom_point() + 
  scale_color_viridis_c()

# estimation of regression coefficients
plot(density(meshout$beta_mcmc[1,1,]))
abline(v=B[1], col="red")


</code></pre>


</div>