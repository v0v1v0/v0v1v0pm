<div class="container">

<table style="width: 100%;"><tr>
<td>cat_match</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>cat_match</h2>

<h3>Description</h3>

<p><code>cat_match()</code> matches the contents of a messy vector with
the closest match in a clean vector. The closest match can be found
using a variety of different string distance measurement options.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cat_match(
  messy_v,
  clean_v,
  return_dists = TRUE,
  return_lists = NA,
  pick_lists = FALSE,
  threshold = NA,
  method = "jw",
  q = 1,
  p = 0,
  bt = 0,
  useBytes = FALSE,
  weight = c(d = 1, i = 1, t = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>messy_v</code></td>
<td>
<p>The messy string vector that will be restructured. This can come in the form
of a column of a dataframe or a lone vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clean_v</code></td>
<td>
<p>The clean string vector that will be referenced to perform the restructing.
Again, this argument can be a dataframe column or vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_dists</code></td>
<td>
<p>If set to TRUE the distance between the matched strings will
be returned as a third column in the output dataframe, Default: TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_lists</code></td>
<td>
<p>Return list of top X matches, Default: NA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pick_lists</code></td>
<td>
<p>Set to TRUE to manually choose matches, Default: F</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>The maximum distance that will form a match. If this argument
is specified, any element in the messy vector that has no match closer than
the threshold distance will be replaced with NA. Default: NA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The type of string distance calculation to use. Possible methods
are : osa, lv, dl, hamming, lcs, qgram, cosine, jaccard, jw, and soundex.
See package stringdist for more information. Default: 'jw'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Size of the q-gram used in string distance calculation. Default: 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Only used with method "jw", the Jaro-Winkler penatly size. Default: 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bt</code></td>
<td>
<p>Only used with method "jw" with p &gt; 0, Winkler's boost threshold. Default: 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useBytes</code></td>
<td>
<p>Whether or not to perform byte-wise comparison. Default: FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>Only used with methods "osa" or "dl", a vector representing the
penalty for deletion, insertion, substitution, and transposition,
in that order. Default: c(d = 1, i = 1, t = 1)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When dealing with messy categorical string data, string distance
matching can be an easy and efficient cleaning tool. A variety of string
distance calculation algorithms have been developed for different types of data,
and these algorithms can be used to detect and remedy problems with categorical
string data.
</p>
<p>By providing a correctly spelled and specified vector of categories to be compared
against a vector of messy strings, a cleaned vector of categories can be generated
by finding the correctly specificed string most similar to a messy string. This
method works particularly well for messy user-inputted data that often suffers
from transposition or misspelling errors.
</p>
<p><code>cat_match()</code> is meant as an exploratory tool to discover how the elements
of two vectors will match using string distance measures, and has added functionality
to solve issues by hand and create a dataframe that can be used to create custom
matches between the clean and messy vectors.
</p>


<h3>Value</h3>

<p>Returns a dataframe with each unique value in the bad vector and it's
closest match in the good vector. If return_dists is TRUE the distances between
the matches are added as a column.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(interactive()){
 messy_trees = c("red oak", "williw", "hemluck", "white elm",
 "fir tree", "birch tree", "pone", "dagwood", "mople")
 clean_trees = c("oak", "willow", "hemlock", "elm", "fir", "birch", "pine", "dogwood", "maple")
 matched_trees = cat_match(messy_trees, clean_trees)
 }
</code></pre>


</div>