<div class="container">

<table style="width: 100%;"><tr>
<td>waves</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fourier transform functions</h2>

<h3>Description</h3>

<p>Use <code>fft()</code> to fit, filter and reconstruct signals in the frequency domain, as
well as to compute the wave envelope.
</p>


<h3>Usage</h3>

<pre><code class="language-R">FitWave(y, k = 1)

BuildWave(
  x,
  amplitude,
  phase,
  k,
  wave = list(amplitude = amplitude, phase = phase, k = k),
  sum = TRUE
)

FilterWave(y, k, action = sign(k[k != 0][1]))

WaveEnvelope(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>numeric vector to transform</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>numeric vector of wave numbers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector of locations (in radians)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amplitude</code></td>
<td>
<p>numeric vector of amplitudes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase</code></td>
<td>
<p>numeric vector of phases</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wave</code></td>
<td>
<p>optional list output from <code>FitWave</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sum</code></td>
<td>
<p>whether to perform the sum or not (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>action</code></td>
<td>
<p>integer to disambiguate action for k = 0 (see Details)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>FitWave</code> performs a fourier transform of the input vector
and returns a list of parameters for each wave number kept.
The  amplitude (A), phase (<code class="reqn">\phi</code>) and wave number (k) satisfy:
</p>
<p style="text-align: center;"><code class="reqn">y = \sum A cos((x - \phi)k)</code>
</p>

<p>The phase is calculated so that it lies between 0 and <code class="reqn">2\pi/k</code> so it
represents the location (in radians) of the first maximum of each wave number.
For the case of k = 0 (the mean), phase is arbitrarily set to 0.
</p>
<p><code>BuildWave</code> is <code>FitWave</code>'s inverse. It reconstructs the original data for
selected wavenumbers. If <code>sum</code> is <code>TRUE</code> (the default) it performs the above
mentioned sum and returns a single vector. If is <code>FALSE</code>, then it returns a list
of k vectors consisting of the reconstructed signal of each wavenumber.
</p>
<p><code>FilterWave</code> filters or removes wavenumbers specified in <code>k</code>. If <code>k</code> is positive,
then the result is the reconstructed signal of <code>y</code> only for wavenumbers
specified in <code>k</code>, if it's negative, is the signal of <code>y</code> minus the wavenumbers
specified in <code>k</code>. The argument <code>action</code> must be be manually set to <code>-1</code> or <code>+1</code>
if <code>k=0</code>.
</p>
<p><code>WaveEnvelope</code> computes the wave envelope of <code>y</code> following Zimin (2003). To compute
the envelope of only a restricted band, first filter it with <code>FilterWave</code>.
</p>


<h3>Value</h3>

<p><code>FitWaves</code> returns a a named list with components
</p>

<dl>
<dt>k</dt>
<dd>
<p>wavenumbers</p>
</dd>
<dt>amplitude</dt>
<dd>
<p>amplitude of each wavenumber</p>
</dd>
<dt>phase</dt>
<dd>
<p>phase of each wavenumber in radians</p>
</dd>
<dt>r2</dt>
<dd>
<p>explained variance of each wavenumber</p>
</dd>
</dl>
<p><code>BuildWave</code> returns a vector of the same length of x with the reconstructed
vector if <code>sum</code> is <code>TRUE</code> or, instead, a list with components
</p>

<dl>
<dt>k</dt>
<dd>
<p>wavenumbers</p>
</dd>
<dt>x</dt>
<dd>
<p>the vector of locations</p>
</dd>
<dt>y</dt>
<dd>
<p>the reconstructed signal of each wavenumber</p>
</dd>
</dl>
<p><code>FilterWave</code> and <code>WaveEnvelope</code> return a vector of the same length as <code>y</code>
'
</p>


<h3>References</h3>

<p>Zimin, A.V., I. Szunyogh, D.J. Patil, B.R. Hunt, and E. Ott, 2003: Extracting Envelopes of Rossby Wave Packets. Mon. Wea. Rev., 131, 1011â€“1017, <a href="https://doi.org/10.1175/1520-0493%282003%29131%3C1011%3AEEORWP%3E2.0.CO%3B2">doi:10.1175/1520-0493(2003)131&lt;1011:EEORWP&gt;2.0.CO;2</a>
</p>


<h3>See Also</h3>

<p>Other meteorology functions: 
<code>Derivate()</code>,
<code>EOF()</code>,
<code>GeostrophicWind()</code>,
<code>WaveFlux()</code>,
<code>thermodynamics</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

# Build a wave with specific wavenumber profile
waves &lt;- list(k = 1:10,
              amplitude = rnorm(10)^2,
              phase = runif(10, 0, 2*pi/(1:10)))
x &lt;- BuildWave(seq(0, 2*pi, length.out = 60)[-1], wave = waves)

# Just fancy FFT
FitWave(x, k = 1:10)

# Extract only specific wave components
plot(FilterWave(x,  1), type = "l")
plot(FilterWave(x,  2), type = "l")
plot(FilterWave(x,  1:4), type = "l")

# Remove components from the signal
plot(FilterWave(x,  -4:-1), type = "l")

# The sum of the two above is the original signal (minus floating point errors)
all.equal(x, FilterWave(x,  1:4) + FilterWave(x,  -4:-1))

# The Wave envelopes shows where the signal is the most "wavy".
plot(x, type = "l", col = "grey")
lines(WaveEnvelope(x), add = TRUE)

# Examples with real data
data(geopotential)
library(data.table)
# January mean of geopotential height
jan &lt;- geopotential[month(date) == 1, .(gh = mean(gh)), by = .(lon, lat)]

# Stationary waves for each latitude
jan.waves &lt;- jan[, FitWave(gh, 1:4), by = .(lat)]
library(ggplot2)
ggplot(jan.waves, aes(lat, amplitude, color = factor(k))) +
    geom_line()

# Build field of wavenumber 1
jan[, gh.1 := BuildWave(lon*pi/180, wave = FitWave(gh, 1)), by = .(lat)]
ggplot(jan, aes(lon, lat)) +
    geom_contour(aes(z = gh.1, color = after_stat(level))) +
    coord_polar()

# Build fields of wavenumber 1 and 2
waves &lt;- jan[, BuildWave(lon*pi/180, wave = FitWave(gh, 1:2), sum = FALSE), by = .(lat)]
waves[, lon := x*180/pi]
ggplot(waves, aes(lon, lat)) +
    geom_contour(aes(z = y, color = after_stat(level))) +
    facet_wrap(~k) +
    coord_polar()

# Field with waves 0 to 2 filtered
jan[, gh.no12 := gh - BuildWave(lon*pi/180, wave = FitWave(gh, 0:2)), by = .(lat)]
ggplot(jan, aes(lon, lat)) +
    geom_contour(aes(z = gh.no12, color = after_stat(level))) +
    coord_polar()

# Much faster
jan[, gh.no12 := FilterWave(gh, -2:0), by = .(lat)]
ggplot(jan, aes(lon, lat)) +
    geom_contour(aes(z = gh.no12, color = after_stat(level))) +
    coord_polar()

# Using positive numbers returns the field
jan[, gh.only12 := FilterWave(gh, 2:1), by = .(lat)]
ggplot(jan, aes(lon, lat)) +
    geom_contour(aes(z = gh.only12, color = after_stat(level))) +
    coord_polar()

# Compute the envelope of the geopotential
jan[, envelope := WaveEnvelope(gh.no12), by = .(lat)]
ggplot(jan[lat == -60], aes(lon, gh.no12)) +
    geom_line() +
    geom_line(aes(y = envelope), color = "red")

</code></pre>


</div>