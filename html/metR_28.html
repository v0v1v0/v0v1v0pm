<div class="container">

<table style="width: 100%;"><tr>
<td>EOF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Empirical Orthogonal Function</h2>

<h3>Description</h3>

<p>Computes Singular Value Decomposition (also known as Principal Components
Analysis or Empirical Orthogonal Functions).
</p>


<h3>Usage</h3>

<pre><code class="language-R">EOF(
  formula,
  n = 1,
  data = NULL,
  B = 0,
  probs = c(lower = 0.025, mid = 0.5, upper = 0.975),
  rotate = NULL,
  suffix = "PC",
  fill = NULL,
  engine = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula to build the matrix that will be used in the SVD
decomposition (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>which singular values to return (if <code>NULL</code>, returns all)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data.frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>number of bootstrap samples used to estimate confidence intervals.
Ignored if &lt;= 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>the probabilities of the lower and upper values of estimated
confidence intervals. If named, it's names will be used as column names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotate</code></td>
<td>
<p>a function to apply to the loadings to rotate them. E.g. for
varimax rotation use <code>stats::varimax</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>character to name the principal components</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>value to infill implicit missing values or <code>NULL</code> if the
data is dense.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>engine</code></td>
<td>
<p>function to use to compute SVD. If <code>NULL</code> it uses irlba::irlba
(if installed) if the largest singular value to compute is lower than half the maximum
possible value, otherwise it uses base::svd. If the user provides a function,
it needs to be a drop-in replacement for base::svd (the same arguments and
output format).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Singular values can be computed over matrices so <code>formula</code> denotes how
to build a matrix from the data. It is a formula of the form VAR ~ LEFT | RIGHT
(see Formula::Formula) in which VAR is the variable whose values will
populate the matrix, and LEFT represent the variables used to make the rows
and RIGHT, the columns of the matrix. Think it like "VAR <em>as a function</em> of
LEFT <em>and</em> RIGHT". The variable combination used in this formula <em>must</em> identify
an unique value in a cell.
</p>
<p>So, for example, <code>v ~ x + y | t</code> would mean that there is one value of <code>v</code> for
each combination of <code>x</code>, <code>y</code> and <code>t</code>, and that there will be one row for
each combination of <code>x</code> and <code>y</code> and one row for each <code>t</code>.
</p>
<p>In the result, the left and right vectors have dimensions of the LEFT and RIGHT
part of the <code>formula</code>, respectively.
</p>
<p>It is much faster to compute only some singular vectors, so is advisable not
to set n to <code>NULL</code>. If the irlba package is installed, EOF uses
irlba::irlba instead of base::svd since it's much faster.
</p>
<p>The bootstrapping procedure follows Fisher et.al. (2016) and returns the
standard deviation of each singular value.
</p>


<h3>Value</h3>

<p>An <code>eof</code> object which is just a named list of <code>data.table</code>s
</p>

<dl>
<dt>left</dt>
<dd>
<p>data.table with left singular vectors</p>
</dd>
<dt>right</dt>
<dd>
<p>data.table with right singular vectors</p>
</dd>
<dt>sdev</dt>
<dd>
<p>data.table with singular values, their explained variance,
and, optionally, quantiles estimated via bootstrap</p>
</dd>
</dl>
<p>There are some methods implemented
</p>

<ul>
<li> <p>summary
</p>
</li>
<li> <p>screeplot and the equivalent ggplot2::autoplot
</p>
</li>
<li> <p>cut.eof
</p>
</li>
<li> <p>predict
</p>
</li>
</ul>
<h3>References</h3>

<p>Fisher, A., Caffo, B., Schwartz, B., &amp; Zipunnikov, V. (2016). Fast, Exact Bootstrap Principal Component Analysis for p &gt; 1 million. Journal of the American Statistical Association, 111(514), 846â€“860. <a href="https://doi.org/10.1080/01621459.2015.1062383">doi:10.1080/01621459.2015.1062383</a>
</p>


<h3>See Also</h3>

<p>Other meteorology functions: 
<code>Derivate()</code>,
<code>GeostrophicWind()</code>,
<code>WaveFlux()</code>,
<code>thermodynamics</code>,
<code>waves</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# The Antarctic Oscillation is computed from the
# monthly geopotential height anomalies weighted by latitude.
library(data.table)
data(geopotential)
geopotential &lt;- copy(geopotential)
geopotential[, gh.t.w := Anomaly(gh)*sqrt(cos(lat*pi/180)),
      by = .(lon, lat, month(date))]

eof &lt;- EOF(gh.t.w ~ lat + lon | date, 1:5, data = geopotential,
           B = 100, probs = c(low = 0.1, hig = 0.9))

# Inspect the explained variance of each component
summary(eof)
screeplot(eof)

# Keep only the 1st.
aao &lt;- cut(eof, 1)

# AAO field
library(ggplot2)
ggplot(aao$left, aes(lon, lat, z = gh.t.w)) +
    geom_contour(aes(color = after_stat(level))) +
    coord_polar()

# AAO signal
ggplot(aao$right, aes(date, gh.t.w)) +
    geom_line()

# standard deviation, % of explained variance and
# confidence intervals.
aao$sdev

# Reconstructed fields based only on the two first
# principal components
field &lt;- predict(eof, 1:2)

# Compare it to the real field.
ggplot(field[date == date[1]], aes(lon, lat)) +
    geom_contour_fill(aes(z = gh.t.w), data = geopotential[date == date[1]]) +
    geom_contour2(aes(z = gh.t.w, linetype = factor(-sign(stat(level))))) +
    scale_fill_divergent()


</code></pre>


</div>