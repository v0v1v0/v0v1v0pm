<div class="container">

<table style="width: 100%;"><tr>
<td>ImputeEOF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Impute missing values</h2>

<h3>Description</h3>

<p>Imputes missing values via Data Interpolating Empirical Orthogonal Functions
(DINEOF).
</p>


<h3>Usage</h3>

<pre><code class="language-R">ImputeEOF(
  formula,
  max.eof = NULL,
  data = NULL,
  min.eof = 1,
  tol = 0.01,
  max.iter = 10000,
  validation = NULL,
  verbose = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula to build the matrix that will be used in the SVD
decomposition (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.eof, min.eof</code></td>
<td>
<p>maximum and minimum number of singular values used for
imputation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data.frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance used for determining convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>maximum iterations allowed for the algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validation</code></td>
<td>
<p>number of points to use in cross-validation (defaults to the
maximum of 30 or 10% of the non NA points)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical indicating whether to print progress</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Singular values can be computed over matrices so <code>formula</code> denotes how
to build a matrix from the data. It is a formula of the form VAR ~ LEFT | RIGHT
(see Formula::Formula) in which VAR is the variable whose values will
populate the matrix, and LEFT represent the variables used to make the rows
and RIGHT, the columns of the matrix.
Think it like "VAR <em>as a function</em> of LEFT <em>and</em> RIGHT".
</p>
<p>Alternatively, if <code>value.var</code> is not <code>NULL</code>, it's possible to use the
(probably) more familiar data.table::dcast formula interface. In that case,
<code>data</code> must be provided.
</p>
<p>If <code>data</code> is a matrix, the <code>formula</code> argument is ignored and the function
returns a matrix.
</p>


<h3>Value</h3>

<p>A vector of imputed values with attributes <code>eof</code>, which is the number of
singular values used in the final imputation; and <code>rmse</code>, which is the Root
Mean Square Error estimated from cross-validation.
</p>


<h3>References</h3>

<p>Beckers, J.-M., Barth, A., and Alvera-Azcárate, A.: DINEOF reconstruction of clouded images including error maps – application to the Sea-Surface Temperature around Corsican Island, Ocean Sci., 2, 183-199, <a href="https://doi.org/10.5194/os-2-183-2006">doi:10.5194/os-2-183-2006</a>, 2006.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(data.table)
data(geopotential)
geopotential &lt;- copy(geopotential)
geopotential[, gh.t := Anomaly(gh), by = .(lat, lon, month(date))]

# Add gaps to field
geopotential[, gh.gap := gh.t]
set.seed(42)
geopotential[sample(1:.N, .N*0.3), gh.gap := NA]

max.eof &lt;- 5    # change to a higher value
geopotential[, gh.impute := ImputeEOF(gh.gap ~ lat + lon | date, max.eof,
                                      verbose = TRUE, max.iter = 2000)]

library(ggplot2)
ggplot(geopotential[date == date[1]], aes(lon, lat)) +
    geom_contour(aes(z = gh.t), color = "black") +
    geom_contour(aes(z = gh.impute))

# Scatterplot with a sample.
na.sample &lt;- geopotential[is.na(gh.gap)][sample(1:.N, .N*0.1)]
ggplot(na.sample, aes(gh.t, gh.impute)) +
    geom_point()

# Estimated RMSE
attr(geopotential$gh.impute, "rmse")
# Real RMSE
geopotential[is.na(gh.gap), sqrt(mean((gh.t - gh.impute)^2))]


</code></pre>


</div>