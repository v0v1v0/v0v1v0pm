<div class="container">

<table style="width: 100%;"><tr>
<td>Derivate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Derivate a discrete variable using finite differences</h2>

<h3>Description</h3>

<p>Derivate a discrete variable using finite differences
</p>


<h3>Usage</h3>

<pre><code class="language-R">Derivate(
  formula,
  order = 1,
  cyclical = FALSE,
  fill = FALSE,
  data = NULL,
  sphere = FALSE,
  a = 6371000,
  equispaced = TRUE
)

Laplacian(
  formula,
  cyclical = FALSE,
  fill = FALSE,
  data = NULL,
  sphere = FALSE,
  a = 6371000,
  equispaced = TRUE
)

Divergence(
  formula,
  cyclical = FALSE,
  fill = FALSE,
  data = NULL,
  sphere = FALSE,
  a = 6371000,
  equispaced = TRUE
)

Vorticity(
  formula,
  cyclical = FALSE,
  fill = FALSE,
  data = NULL,
  sphere = FALSE,
  a = 6371000,
  equispaced = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula indicating dependent and independent variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>order of the derivative</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cyclical</code></td>
<td>
<p>logical vector of boundary condition for each independent variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>logical indicating whether to fill values at the boundaries
with forward and backwards differencing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>optional data.frame containing the variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sphere</code></td>
<td>
<p>logical indicating whether to use spherical coordinates
(see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>radius to use in spherical coordinates (defaults to Earth's radius)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equispaced</code></td>
<td>
<p>logical indicating whether points are equispaced or not.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Each element of the return vector is an estimation of
<code class="reqn">\frac{\partial^n x}{\partial y^{n}}</code> by
centred finite differences.
</p>
<p>If <code>sphere = TRUE</code>, then the first two independent variables are
assumed to be longitude and latitude (<strong>in that order</strong>) in degrees. Then, a
correction is applied to the derivative so that they are in the same units as
<code>a</code>.
</p>
<p>Using <code>fill = TRUE</code> will degrade the solution near the edges of a non-cyclical
boundary. Use with caution.
</p>
<p><code>Laplacian()</code>, <code>Divergence()</code> and <code>Vorticity()</code> are convenient wrappers that
call <code>Derivate()</code> and make the appropriate sums. For <code>Divergence()</code> and
<code>Vorticity()</code>, <code>formula</code> must be of the form <code>vx + vy ~ x + y</code>
(<strong>in that order</strong>).
</p>


<h3>Value</h3>

<p>If there is one independent variable and one dependent variable, a numeric
vector of the same length as the dependent variable.
If there are two or more independent variables or two or more dependent variables,
a list containing the directional derivatives of each dependent variables.
</p>


<h3>See Also</h3>

<p>Other meteorology functions: 
<code>EOF()</code>,
<code>GeostrophicWind()</code>,
<code>WaveFlux()</code>,
<code>thermodynamics</code>,
<code>waves</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data.table::setDTthreads(2)
theta &lt;- seq(0, 360, length.out = 20)*pi/180
theta &lt;- theta[-1]
x &lt;- cos(theta)
dx_analytical &lt;- -sin(theta)
dx_finitediff &lt;- Derivate(x ~ theta, cyclical = TRUE)[[1]]

plot(theta, dx_analytical, type = "l")
points(theta, dx_finitediff, col = "red")

# Curvature (Laplacian)
# Note the different boundary conditions for each dimension
variable &lt;- expand.grid(lon = seq(0, 360, by = 3)[-1],
                        lat = seq(-90, 90, by = 3))
variable$z &lt;- with(variable, cos(lat*pi/180*3) + sin(lon*pi/180*2))
variable &lt;- cbind(
     variable,
     as.data.frame(Derivate(z ~ lon + lat, data = variable,
                          cyclical = c(TRUE, FALSE), order = 2)))
library(ggplot2)
ggplot(variable, aes(lon, lat)) +
    geom_contour(aes(z = z)) +
    geom_contour(aes(z = z.ddlon + z.ddlat), color = "red")

# The same as
ggplot(variable, aes(lon, lat)) +
    geom_contour(aes(z = z)) +
    geom_contour(aes(z = Laplacian(z ~ lon + lat, cyclical = c(TRUE, FALSE))),
                 color = "red")

</code></pre>


</div>