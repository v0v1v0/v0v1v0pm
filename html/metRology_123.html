<div class="container">

<table style="width: 100%;"><tr>
<td>REML location estimate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Restricted maximum likelihood estimate of location
</h2>

<h3>Description</h3>

<p>Calculates REML estimate of location, with standard error, assuming 
a random-effects model
</p>


<h3>Usage</h3>

<pre><code class="language-R">	reml.loc(x, ..., na.rm = FALSE)

	## Default S3 method:
reml.loc(x, s, n = NULL, groups = NULL, na.rm = FALSE,
	          tol=.Machine$double.eps^0.5, REML=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector of mean values for groups, or (if <code>groups</code> 
is given) of individual observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>numeric vector of length <code>length(x)</code> of standard deviations or 
standard uncertainties associated with the values <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer giving the number of observations in each group. May be a vector 
of length <code>length(x)</code>. If <code>n</code> is <code>NULL</code>, <code>s</code> is interpreted as 
a vector of standard uncertainties or standard errors. <code>n</code> is recycled 
to <code>length(x)</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>factor, or vetor which can be coerced to factor, of groups. If 
present, <code>x</code> is interpreted as a vector of individual observations 
and <code>s</code> and <code>n</code> ignored, if present, with a warning. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical: if <code>TRUE</code>,  <code>NA</code> values are removed 
before processing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>numeric tolerance for convergence, used by <code>optimize()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>REML</code></td>
<td>
<p>logical: if <code>TRUE</code> (the default),  the function optimises the REML 
criterion (see Details). If FALSE, the maximum likelihood criterion is used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further parameters passed to <code>optimize()</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>reml.loc</code> finds an excess variance <code class="reqn">\tau^2</code> and location <code class="reqn">\mu</code> that maximise the 
restricted maximum likelihood criterion.
</p>
<p>The estimator assumes a model of the form
</p>
<p style="text-align: center;"><code class="reqn">x_i=\mu+b_i+e_i</code>
</p>

<p>in which <code class="reqn">b_i</code> is drawn from <code class="reqn">N(0, \tau^2)</code> and
<code class="reqn">e_i</code> is drawn from <code class="reqn">N(0, \sigma_i^2)</code>.
</p>
<p>By default the function maximises the data-dependent part of the negative log restricted likelihood:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2}  \left( \sum_{i=1}^{k}\frac{(x_i-mu)^2}{u_i^2}  + \sum_{i=1}^{k}log(u_i^2) + 
			 log\left(\sum_{i=1}^{k}(1/u_i^2)\right) \right)</code>
</p>

<p>where <code class="reqn">u_i=s_i^2 + \tau^2</code> and <code class="reqn">k</code> is the number of mean values.
If <code>REML=FALSE</code>, the final term is omitted to give the maximum likelihood criterion.
</p>
<p>This implementation permits input in the form of:
</p>

<ul>
<li>
<p> means <code>x</code> and standard errors <code>s</code>, in which case neither <code>n</code> nor 
<code>groups</code> are supplied;
</p>
</li>
<li>
<p> means <code>x</code>, standard deviations <code>s</code> and group size(s) <code>n</code>, 
standard errors then being calculated as <code>s/sqrt(n)</code>
</p>
</li>
<li>
<p> individual observations <code>x</code> with a groupinf factor <code>groups</code>, in 
which case standard errors are calculated from the groups using <code>tapply</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A loc.est object; see loc.est for details. In the returned object, individual
values <code>xi</code> are always input means (calculated from groups and <code>n</code> as 
necessary); <code>method.details</code> is returned as a list containing:
</p>

<dl>
<dt>mu</dt>
<dd>
<p>The estimated location.
</p>
</dd>
<dt>s</dt>
<dd>
<p>The standard error in the location.
</p>
</dd>
<dt>tau</dt>
<dd>
<p>The excess variance (as a standard deviation).
</p>
</dd>
<dt>REML</dt>
<dd>
<p>Logical, giving the value of REML used.
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>S L R Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>None, but see documentation for the metafor package for a more general implementation of REML.
</p>


<h3>See Also</h3>

<p><code>loc.est-class</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  #PCB measurements in a sediment from Key Comparison CCQM-K25
  #s are reported standard uncertainties
  pcb105 &lt;- data.frame(x=c(10.21, 10.9, 10.94, 10.58, 10.81, 9.62, 10.8),
               s=c(0.381, 0.250, 0.130, 0.410, 0.445, 0.196, 0.093))
               		
  with( pcb105, reml.loc(x, s) )

</code></pre>


</div>