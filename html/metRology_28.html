<div class="container">

<table style="width: 100%;"><tr>
<td>contribs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Extract contributions from an 'uncert' object.
</h2>

<h3>Description</h3>

<p>Extracts the individual nonzero contributions 
to the combined uncertainty in an 'uncert' object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">contribs(object, scope, as.sd = FALSE, keep.sign = TRUE, 
	simplify = TRUE, expand.dot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>An object of class <code>uncert</code> returned by <code>uncert</code> or  <code>uncertMC</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scope</code></td>
<td>

<p>An expression, one-sided formula or character vector describing the particular variables
for which contributions are desired. If missing, contributions for all variables
are returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.sd</code></td>
<td>
<p> logical; controls whether values are returned in the form of 
standard uncertainties or variance contributions. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.sign</code></td>
<td>
<p>logical; controls whether the sign of the cobntributions is appended to
the return value when <code>as.sd=TRUE</code>. See Details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p> logical. If <code>simplify=FALSE</code> the contribution matrix itself 
is returned. If <code>simplify=TRUE</code>, only the requested (by <code>scope</code>) 
nonzero elements of the contribution matrix are returned, as a vector.  
See Details for the treatment of off-diagonal terms
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand.dot</code></td>
<td>
<p>logical; if <code>TRUE</code>, ‘.’ in a formula <code>scope</code> is
expanded to all contributions including pairwise contributions. If <code>FALSE</code>,
the dot operator implies only the single-variable terms. See Details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>contribs</code> calculates the contribution matrix <code class="reqn">C</code> where 
<code class="reqn">C_{i,j}=(c_iu_i)(c_ju_j)r_{i,j}</code>. 
In general, these values are possibly negative (co)variance contributions 
to the variance (squared standard uncertainty) in <code class="reqn">y</code>. In GUM notation 
(‘the GUM’ is JCGM 100 (2008) - see references), the diagonal elements of 
<code>C</code> are squared standard uncertainties in <code class="reqn">y</code>. The form of the 
return value depends on <code>simplify</code>, <code>as.sd</code> and <code>keep.sign</code>.
</p>
<p>If <code>as.sd</code> is <code>FALSE</code> (the default), contributions <code class="reqn">C_{ij}</code>
are returned unchanged. For the diagonal elements of <code class="reqn">C</code> (contributions for 
individual individual terms), this form corresponds to squared standard uncertainties 
<code class="reqn">u_i^2(y)</code> in GUM notation. 
</p>
<p>If <code>as.sd=TRUE</code>, the magnitude of the value returned is <code class="reqn">\sqrt{|C_{ij}|}</code>.
For the diagonal elements of <code class="reqn">C</code> this corresponds to standard uncertainties 
<code class="reqn">u[i]{y}</code> in GUM notation.
</p>
<p>If <code>as.sd=TRUE</code>, <code>keep.sign</code> controls whether the values are signed or 
returned as absolute values. If <code>keep.sign=TRUE</code>, the value returned is 
<code class="reqn">sign(C_{ij}\sqrt{|C_{ij}|}{sign(C[i,j]sqrt( abs(C[i,j] ) )}</code>. If false, 
the absolute value is returned. Note that the sign is returned solely to indicate 
the direction of the original contribution. <code>keep.sign</code> has no effect if 
<code>as.sd=FALSE</code>.
</p>
<p>If <code>simplify=FALSE</code> (the default), the requested elements of the contribution matrix 
<code class="reqn">C</code> are returned as a matrix. If <code>simplify=FALSE</code>, the return value is a vector 
containing only those terms with nonzero values in the associated correlation matrix. 
The threshold for deciding a correlation is nonzero is that its magnitude is greater
than <code>2*.Machine$double.eps</code>.
</p>
<p>Off-diagonal terms for the same pair of variables are summed, that is, for 
the pair <code class="reqn">(C_{ij}, C_{ji}), j \neq i</code>
the (single) value returned is <code class="reqn">C_{i,j}+C_{j,i}=2C_{i,j}</code>. 
</p>
<p>The contributions returned can be limited to a chosen subset using <code>scope</code>; 
only the terms involving variables included in <code>scope</code> are returned. 
<code>scope</code> can be an expression, formula or character vector of variable names. 
If an expression or formula, only those contributions involving variables in 
the expression or formula are returned. 
</p>
<p>Any variable names in <code>scope</code> which are not present in 
<code>row.names(object$budget)</code> are silently ignored except for 
the formula specification which will return an error.
</p>
<p>If <code>simplify=FALSE</code>, the matrix returned always contains all contributions 
involving individual variables in <code>scope</code>. If <code>simplify=TRUE</code>, however, specifying
<code>scope</code> as a formula provides additional control over the returned contributions: 
</p>
<p>If a formula, <code>scope</code> accepts the usual model formula operators ‘.’, ‘+’, ‘-’,
‘*’ and ‘^’, but the interpretation is not quite identical to <code>lm</code>.
</p>
<p>First, if present, ‘.’ is taken by default as ‘all contributions’, implying 
all single terms and all pairwise terms (like ‘<code>.^2</code>)’ in other formula specifications). 
This can be disabled by specifying <code>expand.dot=FALSE</code>.
</p>
<p>The negation operator ‘-’ removes terms, but removing a single variable also removes any 
associated covariance contributions. For example, <code>scope=~.-A</code> is expanded to all single 
and pairwise contributions to the uncertanty budget that do not involve <code>A</code>.
</p>
<p>Interaction-like terms of the form <code>A:B</code> are interpreted as indicating the <em>total</em> 
off-diagonal contribution, that is, <code>A:B</code> is equivalent to <code>B:A</code> and the associated 
value returned is based on <code class="reqn">C_{i,j}+C_{j,i}</code>. 
</p>
<p>Cross-terms like <code>~A*B</code> are supported and expand, as usual, to <code>~A+B+A:B</code>. 
</p>
<p>Unlike the two other scope specifications, single terms in the formula do <em>not</em>
automatically imply off-diagonal terms; <code>A+B</code> will not return the off-diagonal contribution for 
<code>A</code> and <code>B</code>. Use <code>A*B</code> or <code>(A+B)^2</code> etc. to get off-diagonal contributions.  
Cross-terms of order above two are ignored so <code>A*B*C</code> safely returns only the set of 
individual and pairwise terms, but it is perhaps more precise to use <code>(A+B+C)^2</code>.
</p>
<p><code>I()</code> and other operators or functions are not supported.
</p>


<h3>Value</h3>

<p>A named vector or matrix of contributions. Names for off-diagonal contributions 
in the vector format are constructed from the names of the two contributing variables.
</p>


<h3>Author(s)</h3>

<p>S. L. R. Ellison <a href="mailto:s.ellison@lgc.co.uk">s.ellison@lgc.co.uk</a>
</p>


<h3>References</h3>

<p>JCGM 100 (2008) <em>Evaluation of measurement data - Guide to the expression
of uncertainty in measurement</em>. <a href="http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf">http://www.bipm.org/utils/common/documents/jcgm/JCGM_100_2008_E.pdf</a>. 
(JCGM 100:2008 is a public domain copy of ISO/IEC <em>Guide to the expression
of uncertainty in measurement</em> (1995) ). 
</p>


<h3>See Also</h3>

<p><code>uncert-class</code>,  <code>uncert</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  #Example with negative correlation
  x &lt;- list(a=1, b=3, c=2, d=11)
  u &lt;- lapply(x, function(x) x/10)
  u.cor&lt;-diag(1,4)
  u.cor[3,4]&lt;-u.cor[4,3]&lt;- -0.5
  u.form.c&lt;-uncert(~a+b*2+c*3+d/2, x, u, method="NUM", cor=u.cor)

  contribs(u.form.c, simplify=FALSE)
  contribs(u.form.c)
  contribs(u.form.c, as.sd=TRUE)
  contribs(u.form.c, as.sd=TRUE, keep.sign=FALSE)

  contribs(u.form.c, scope=c("a", "c", "d") )

  #Effects of formula specification for scope:
  contribs(u.form.c, ~.)           #All contributions
  contribs(u.form.c, ~(a+b+c+d)^2) #same as ~.
  contribs(u.form.c, ~a+b+c+d )    #single-variable contributions only
  contribs(u.form.c, ~., expand.dot=FALSE )    # as ~a+b+c+d
  contribs(u.form.c, ~.-d)         #Drops d and c:d
  contribs(u.form.c, ~.-c:d)
  contribs(u.form.c, ~c+d)
  contribs(u.form.c, ~c*d)

</code></pre>


</div>