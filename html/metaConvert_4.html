<div class="container">

<table style="width: 100%;"><tr>
<td>convert_df</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Automatically compute effect sizes from a well formatted dataset</h2>

<h3>Description</h3>

<p>Automatically compute effect sizes from a well formatted dataset
</p>


<h3>Usage</h3>

<pre><code class="language-R">convert_df(
  x,
  measure = c("d", "g", "md", "logor", "logrr", "logirr", "nnt", "r", "z", "logvr",
    "logcvr"),
  main_es = TRUE,
  es_selected = c("hierarchy", "minimum", "maximum"),
  split_adjusted = TRUE,
  format_adjusted = c("wide", "long"),
  verbose = TRUE,
  hierarchy = "means_sd &gt; means_se &gt; means_ci",
  rr_to_or = "metaumbrella",
  or_to_rr = "metaumbrella_cases",
  or_to_cor = "bonett",
  table_2x2_to_cor = "lipsey",
  smd_to_cor = "viechtbauer",
  pre_post_to_smd = "bonett",
  r_pre_post = 0.5,
  cor_to_smd = "viechtbauer",
  unit_type = "raw_scale",
  yates_chisq = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a well formatted dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measure</code></td>
<td>
<p>the effect size measure that will be estimated from the information stored in the dataset. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main_es</code></td>
<td>
<p>a logical variable indicating whether a main effect size should be selected when overlapping data are present. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>es_selected</code></td>
<td>
<p>the method used to select the main effect size when several information allows to estimate an effect size for the same association/comparison. Must be either "minimum" (the smallest effect size will be selected), "maximum" (the largest effect size will be selected) or "hierarchy" (the effect size computed from the information specified highest in the hierarchy will be selected). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_adjusted</code></td>
<td>
<p>a logical value indicating whether crude and adjusted effect sizes should be presented separately. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format_adjusted</code></td>
<td>
<p>presentation format of the adjusted effect sizes. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a logical variable indicating whether text outputs and messages should be generated. We recommend turning this option to FALSE only after having carefully read all the generated messages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hierarchy</code></td>
<td>
<p>a character string indicating the hierarchy in the information to be prioritized for the effect size calculations (see details). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rr_to_or</code></td>
<td>
<p>formula used to convert the <code>rr</code> value into an odds ratio.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>or_to_rr</code></td>
<td>
<p>formula used to convert the <code>or</code> value into a risk ratio.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>or_to_cor</code></td>
<td>
<p>formula used to convert the <code>or</code> value into a correlation coefficient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>table_2x2_to_cor</code></td>
<td>
<p>formula used to obtain a correlation coefficient from the contingency table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smd_to_cor</code></td>
<td>
<p>formula used to convert the <code>cohen_d</code> value into a coefficient correlation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre_post_to_smd</code></td>
<td>
<p>formula used to obtain a SMD from pre/post means and SD of two independent groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_pre_post</code></td>
<td>
<p>pre-post correlation across the two groups (use this argument only if the precise correlation in each group is unknown)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor_to_smd</code></td>
<td>
<p>formula used to convert a correlation coefficient value into a SMD.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit_type</code></td>
<td>
<p>the type of unit for the <code>unit_increase_iv</code> argument. Must be either "sd" or "value" (see <code>es_from_pearson_r</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yates_chisq</code></td>
<td>
<p>a logical value indicating whether the Chi square has been performed using Yate's correction for continuity.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function automatically computes or converts between 11 effect sizes
measures from any relevant type of input data stored in the
dataset you pass to this function.
</p>


<h4>Effect size measures</h4>

<p>Possible effect size measures are:
</p>

<ol>
<li>
<p> Cohen's d ("d")
</p>
</li>
<li>
<p> Hedges' g ("g")
</p>
</li>
<li>
<p> mean difference ("md")
</p>
</li>
<li>
<p> (log) odds ratio ("or" and "logor")
</p>
</li>
<li>
<p> (log) risk ratio ("rr" and "logrr")
</p>
</li>
<li>
<p> (log) incidence rate ratio ("irr" and "logirr")
</p>
</li>
<li>
<p> correlation coefficient ("r")
</p>
</li>
<li>
<p> transformed r-to-z correlation coefficient ("z")
</p>
</li>
<li>
<p> log variability ratio ("logvr")
</p>
</li>
<li>
<p> log coefficient of variation ("logcvr")
</p>
</li>
<li>
<p> number needed to treat ("nnt")
</p>
</li>
</ol>
<h4>Computation of a main effect size</h4>

<p>If you enter multiple types of input data
(e.g., means/sd of two groups and a student t-test value)
for the same comparison i.e., for the same row of the dataset,
the <code>convert_df()</code> function can have two behaviours.
If you set:
</p>

<ul>
<li> <p><code>main_es = FALSE</code> the function will estimate all possible effect sizes from all
types of input data (which implies that if a comparison has <strong>several types of input data</strong>,
it will result in <strong>multiple rows</strong> in the dataframe returned by the function)
</p>
</li>
<li> <p><code>main_es = TRUE</code> the function will select one effect size per comparison
(which implies that if a comparison has <strong>several types of input data</strong>,
it will result in a <strong>unique row</strong> in the dataframe returned by the function)
</p>
</li>
</ul>
<h4>Selection of input data for the computation of the main effect size</h4>

<p>If you choose to estimate one main effect size (i.e., by setting <code>main_es = TRUE</code>),
you have several options to select this main effect size.
If you set:
</p>

<ul>
<li> <p><code>es_selected = "hierarchy"</code>: the main effect size will be selected by prioritizing
specific types of input data over other (see next section "Hierarchy").
</p>
</li>
<li> <p><code>es_selected = "minimum"</code>: the main effect size will be selected by selecting
the lowest effect size available.
</p>
</li>
<li> <p><code>es_selected = "maximum"</code>: the main effect size will be selected by selecting
the highest effect size available.
</p>
</li>
</ul>
<h4>Hierarchy</h4>

<p>More than 70 different combinations of input data can be used to estimate an effect size.
You can retrieve the effect size measures estimated by each combination of input data
in the <code>see_input_data()</code> function.
</p>
<p>In the hierarchy argument, each type of input data should be separated by the symbol "&gt;".
You can prioritize some types of input data by placing them at the begining of the
hierarchy argument.
For example, if you set:
</p>

<ul>
<li> <p><code>hierarchy = "means_sd &gt; means_se &gt; student_t"</code>, the convert_df function will prioritize
the means + SD, then the means + SE, then the Student's t-test to estimate the main effect
size.
</p>
</li>
<li> <p><code>hierarchy = "2x2 &gt; or_se &gt; phi"</code>, the convert_df function will prioritize
the contigency table, then the odds ratio value + SE, then the phi coefficient to estimate
the main effect size.
</p>
</li>
</ul>
<p>Importantly, if none of the types of input data indicated in the <code>hierarchy</code> argument
can be used to estimate the target effect size measure,
the <code>convert_df()</code> function will automatically try to use other types of input
data to estimate an effect size.
</p>



<h4>Adjusted effect sizes</h4>

<p>Some datasets will be composed of crude (i.e., non-adjusted) types of input data
(such as standard means + SD, Student's t-test, etc.) and adjusted types of input data
(such as means + SE from an ANCOVA model, a t-test from an ANCOVA, etc.).
</p>
<p>In these situations, you can decide to:
</p>

<ul>
<li>
<p> treat crude and adjusted input data the same way <code>split_adjusted = FALSE</code>
</p>
</li>
<li>
<p> split calculations for crude and adjusted types of input data <code>split_adjusted = TRUE</code>
</p>
</li>
</ul>
<p>If you want to split the calculations, you can decide to present the final dataset:
</p>

<ul>
<li>
<p> in a long format (i.e., crude and adjusted effect sizes presented in separate rows <code>format_adjusted = "long"</code>)
</p>
</li>
<li>
<p> in a wide format (i.e., crude and adjusted effect sizes presented in separate columns <code>format_adjusted = "wide"</code>)
</p>
</li>
</ul>
<h3>Value</h3>

<p>The <code>convert_df()</code> function returns a list of
more than 70 dataframes
(one for each function automatically applied to the dataset).
These dataframes systematically contain the columns described in
<code>metaConvert-package</code>.
The list of dataframes can be easily converted to a single,
calculations-ready dataframe
using the summary function (see <code>summary.metaConvert</code>).
</p>


<h3>Examples</h3>

<pre><code class="language-R">res &lt;- convert_df(df.haza,
  measure = "g",
  split_adjusted = TRUE,
  es_selected = "minimum",
  format_adjusted = "long"
)
summary(res)
</code></pre>


</div>