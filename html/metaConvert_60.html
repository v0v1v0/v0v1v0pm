<div class="container">

<table style="width: 100%;"><tr>
<td>es_from_or_se</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert an odds ratio value and its standard error into several effect size measures</h2>

<h3>Description</h3>

<p>Convert an odds ratio value and its standard error into several effect size measures
</p>


<h3>Usage</h3>

<pre><code class="language-R">es_from_or_se(
  or,
  logor,
  logor_se,
  baseline_risk,
  small_margin_prop,
  n_exp,
  n_nexp,
  n_cases,
  n_controls,
  n_sample,
  or_to_rr = "metaumbrella_cases",
  or_to_cor = "pearson",
  reverse_or
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>or</code></td>
<td>
<p>odds ratio value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logor</code></td>
<td>
<p>log odds ratio value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logor_se</code></td>
<td>
<p>the standard error of the log odds ratio</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>baseline_risk</code></td>
<td>
<p>proportion of cases in the non-exposed group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>small_margin_prop</code></td>
<td>
<p>smallest margin proportion of cases/events in the underlying 2x2 table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_exp</code></td>
<td>
<p>number of participants in the exposed group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_nexp</code></td>
<td>
<p>number of participants in the non-exposed group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cases</code></td>
<td>
<p>number of cases/events across exposed/non-exposed groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_controls</code></td>
<td>
<p>number of controls/no-event across exposed/non-exposed groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_sample</code></td>
<td>
<p>total number of participants in the sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>or_to_rr</code></td>
<td>
<p>formula used to convert the <code>or</code> value into a risk ratio (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>or_to_cor</code></td>
<td>
<p>formula used to convert the <code>or</code> value into a correlation coefficient (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse_or</code></td>
<td>
<p>a logical value indicating whether the direction of the generated effect sizes should be flipped.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function converts the log odds ratio into a Risk ratio (RR), Cohen's d (D), Hedges' g (G)
and correlation coefficients (R/Z).
</p>
<p><strong>To estimate the Cohen's d value and its standard error</strong>
The following formulas are used (Cooper et al., 2019):
</p>
<p style="text-align: center;"><code class="reqn">d = \log(or) * \frac{\sqrt{3}}{\pi}</code>
</p>

<p style="text-align: center;"><code class="reqn">d\_se = \sqrt{\frac{logor\_se^2 * 3}{\pi^2}}</code>
</p>

<p><strong>To estimate the risk ratio and its standard error, various formulas can be used.</strong>
</p>
<p><strong>A.</strong> First, the approach described in Grant (2014) can be used.
However, in the paper, only the formula to convert an OR value to a RR value
is described.
To derive the variance, we used this formula to convert the bounds of the 95% CI, which
were then used to obtain the variance.
</p>
<p>This argument requires (or + baseline_risk + or_ci_lo + or_ci_up) to generate a RR.
The following formulas are used (br = baseline_risk):
</p>
<p style="text-align: center;"><code class="reqn">rr = \frac{or}{1 - br + br*or}</code>
</p>

<p style="text-align: center;"><code class="reqn">rr\_ci\_lo = \frac{or\_ci\_lo}{1 - br + br*or\_ci\_lo}</code>
</p>

<p style="text-align: center;"><code class="reqn">rr\_ci\_up = \frac{or\_ci\_up}{1 - br + br*or\_ci\_up}</code>
</p>

<p style="text-align: center;"><code class="reqn">logrr\_se = \frac{log(rr\_ci\_up) - log(rr\_ci\_lo)}{2 * qnorm(.975)}</code>
</p>

<p><strong>B.</strong> Second, the formulas implemented in the metaumbrella package can be used
(<code>or_to_rr = "metaumbrella_cases"</code> or <code>or_to_rr = "metaumbrella_exp"</code>).
This argument requires (or + logor_se + n_cases + n_controls) or (or + logor_se + n_exp + n_nexp)
to generate a RR.
More precisely, when the OR value and its standard error, plus either
(i) the number of cases and controls or
(ii) the number of participants in the exposed and non-exposed groups,
are available, we previously developed functions that simulate all combinations of the possible
number of cases and controls
in the exposed and non-exposed groups compatible with the actual value of the OR.
Then, the functions select the contingency table whose standard error coincides best with
the standard error reported.
The RR value and its standard are obtained from this estimated contingency table.
</p>
<p><strong>C.</strong> Third, it is possible to transpose the RR to a OR (<code>or_to_rr = "transpose"</code>).
This argument requires (or + logor_se) to generate a OR.
It is known that OR and RR are similar when the baseline risk is small.
Therefore, users can request to simply transpose the OR value &amp; standard error into a RR value &amp; standard error.
</p>
<p style="text-align: center;"><code class="reqn">rr = or</code>
</p>

<p style="text-align: center;"><code class="reqn">logrr\_se = logor\_se</code>
</p>

<p><strong>D.</strong> Fourth, it is possible to recreate the 2x2 table using the dipietrantonj's formulas (<code>or_to_rr = "dipietrantonj"</code>).
This argument requires (or + logor_ci_lo + logor_ci_lo) to generate a RR. Information on this approach can be retrieved in
Di Pietrantonj (2006).
</p>
<p><strong>To estimate the NNT, the formulas used are :</strong>
</p>
<p style="text-align: center;"><code class="reqn">\frac{(1 - br * (1 - or))}{(1 - br) * (br * (1 - or))}</code>
</p>

<p><strong>To estimate a correlation coefficient, various formulas can be used.</strong>
</p>
<p><strong>A.</strong> First, the approach described in Pearson (1900) can be used (<code>or_to_cor = "pearson"</code>).
This argument requires (or + logor_se) to generate a R/Z.
It converts the OR value and its standard error to a tetrachoric correlation.
Note that the formula assumes that each cell of the 2x2 used to estimate the OR has been added 1/2 before estimating the OR value and its standard error.
If it is not the case, formulas can produce slightly less accurate results.
</p>
<p style="text-align: center;"><code class="reqn">c = \frac{1}{2}</code>
</p>

<p style="text-align: center;"><code class="reqn">r = \cos{\frac{\pi}{1+or^c}}</code>
</p>

<p style="text-align: center;"><code class="reqn">r\_se = logor\_se * ((\pi * c * or^c) * \frac{\sin(\pi / (1+or^c))}{1+or^c})^2</code>
</p>

<p style="text-align: center;"><code class="reqn">or\_ci\_lo = exp(log(or) - qnorm(.975)*logor\_se)</code>
</p>

<p style="text-align: center;"><code class="reqn">or\_ci\_up = exp(log(or) + qnorm(.975)*logor\_se)</code>
</p>

<p style="text-align: center;"><code class="reqn">r\_ci\_lo = cos(\frac{\pi}{1 + or\_ci\_lo^c})</code>
</p>

<p style="text-align: center;"><code class="reqn">r\_ci\_up = cos(\frac{\pi}{1 + or\_ci\_up^c})</code>
</p>

<p style="text-align: center;"><code class="reqn">z = atanh(r)</code>
</p>

<p style="text-align: center;"><code class="reqn">z\_se = \sqrt{\frac{r\_se^2}{(1 - r^2)^2}}</code>
</p>

<p style="text-align: center;"><code class="reqn">z\_ci\_lo = atanh(r\_lo)</code>
</p>

<p style="text-align: center;"><code class="reqn">z\_ci\_up = atanh(r\_up)</code>
</p>

<p><strong>B.</strong> Second, the approach described in Digby (1983) can be used (<code>or_to_cor = "digby"</code>).
This argument requires (or + logor_se) to generate a R/Z.
It converts the OR value and its standard error to a tetrachoric correlation.
Note that the formula assumes that each cell of the 2x2 used to estimate the OR has been added 1/2 before estimating the OR value and its standard error.
If it is not the case, formulas can produce slightly less accurate results.
</p>
<p style="text-align: center;"><code class="reqn">c = \frac{3}{4}</code>
</p>

<p style="text-align: center;"><code class="reqn">r = \frac{or^c - 1}{or^c + 1}</code>
</p>

<p style="text-align: center;"><code class="reqn">r\_se = \sqrt{\frac{c^2}{4} * (1 - r^2)^2 * logor\_se}</code>
</p>

<p style="text-align: center;"><code class="reqn">z = atanh(r)</code>
</p>

<p style="text-align: center;"><code class="reqn">z\_se = \sqrt{\frac{r\_se^2}{(1 - r^2)^2}}</code>
</p>

<p style="text-align: center;"><code class="reqn">z\_ci\_lo = z - qnorm(.975)*\sqrt{\frac{c^2}{4} * logor\_se}</code>
</p>

<p style="text-align: center;"><code class="reqn">z\_ci\_up = z + qnorm(.975)*\sqrt{\frac{c^2}{4} * logor\_se}</code>
</p>

<p style="text-align: center;"><code class="reqn">r\_ci\_lo = tanh(z\_lo)</code>
</p>

<p style="text-align: center;"><code class="reqn">r\_ci\_up = tanh(z\_up)</code>
</p>

<p><strong>C.</strong> Third, the approach described in Bonett (2005) can be used (<code>or_to_cor = "bonett"</code>).
This argument requires (or + logor_se + n_cases + n_exp + small_margin_prop) to generate a R/Z.
Note that the formula assumes that each cell of the 2x2 used to estimate the OR has been added 1/2 before estimating the OR value and its standard error.
If it is not the case, formulas can produce slightly less accurate results.
</p>
<p style="text-align: center;"><code class="reqn">c = \frac{\frac{1 - |n\_exp - n\_cases|}{5} - (0.5 - small\_margin\_prop)^2}{2}</code>
</p>

<p style="text-align: center;"><code class="reqn">r = \cos{\frac{\pi}{1+or^c}}</code>
</p>

<p style="text-align: center;"><code class="reqn">r\_se = logor\_se * ((\pi * c * or^c) * \frac{\sin(\frac{\pi}{1+or^c})}{1+or^c})^2</code>
</p>

<p style="text-align: center;"><code class="reqn">or\_ci\_lo = exp(log(or) - qnorm(.975)*logor\_se)</code>
</p>

<p style="text-align: center;"><code class="reqn">or\_ci\_up = exp(log(or) + qnorm(.975)*logor\_se)</code>
</p>

<p style="text-align: center;"><code class="reqn">r\_ci\_lo = cos(\frac{\pi}{1 + or\_ci\_lo^c})</code>
</p>

<p style="text-align: center;"><code class="reqn">r\_ci\_up = cos(\frac{\pi}{1 + or\_ci\_up^c})</code>
</p>

<p style="text-align: center;"><code class="reqn">z = atanh(r)</code>
</p>

<p style="text-align: center;"><code class="reqn">z\_se = \sqrt{\frac{r\_se^2}{(1 - r^2)^2}} </code>
</p>

<p style="text-align: center;"><code class="reqn">z\_ci\_lo = atanh(r\_lo)</code>
</p>

<p style="text-align: center;"><code class="reqn">z\_ci\_up = atanh(r\_up)</code>
</p>

<p><strong>D.</strong> Last, the approach described in Cooper et al. (2019) can be used (<code>or_to_cor = "lipsey_cooper"</code>).
This argument requires (or + logor_se + n_exp + n_nexp) to generate a R/Z.
As shown above, the function starts to estimate a SMD from the OR.
Then, as described in <code>es_from_cohen_d</code>, it converts this Cohen's d value into a correlation
coefficient using the <code>"lipsey_cooper"</code> formulas.
</p>


<h3>Value</h3>

<p>This function estimates and converts between several effect size measures.
</p>

<table>
<tr>
<td style="text-align: left;">
<code>natural effect size measure</code> </td>
<td style="text-align: left;"> OR</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>converted effect size measure</code> </td>
<td style="text-align: left;"> RR + NNT</td>
</tr>
<tr>
<td style="text-align: left;">
 </td>
<td style="text-align: left;"> D + G + R + Z</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>required input data</code> </td>
<td style="text-align: left;"> See 'Section 2. Odds Ratio'</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> https://metaconvert.org/html/input.html</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>References</h3>

<p>Bonett, Douglas G. and Robert M. Price. (2005). Inferential Methods for the Tetrachoric Correlation Coefficient. Journal of Educational and Behavioral Statistics 30:213-25.
</p>
<p>Bonett, D. G., &amp; Price, R. M. (2007). Statistical inference for generalized Yule coefficients in 2× 2 contingency tables. Sociological methods &amp; research, 35(3), 429-446.
</p>
<p>Cooper, H., Hedges, L. V., &amp; Valentine, J. C. (Eds.). (2019). The handbook of research synthesis and meta-analysis. Russell Sage Foundation.
</p>
<p>Di Pietrantonj C. (2006). Four-fold table cell frequencies imputation in meta analysis. Statistics in medicine, 25(13), 2299–2322. https://doi.org/10.1002/sim.2287
</p>
<p>Digby, Peter G. N. (1983). Approximating the Tetrachoric Correlation Coefficient. Biometrics 39:753-7.
</p>
<p>Gosling, C. J., Solanes, A., Fusar-Poli, P., &amp; Radua, J. (2023). metaumbrella: the first comprehensive suite to perform data analysis in umbrella reviews with stratification of the evidence. BMJ mental health, 26(1), e300534. https://doi.org/10.1136/bmjment-2022-300534
</p>
<p>Grant R. L. (2014). Converting an odds ratio to a range of plausible relative risks for better communication of research findings. BMJ (Clinical research ed.), 348, f7450. https://doi.org/10.1136/bmj.f7450
</p>
<p>Pearson, K. (1900). Mathematical Contributions to the Theory of Evolution. VII: On the Correlation of Characters Not Quantitatively Measurable. Philosophical Transactions of the Royal Statistical Society of London, Series A 19:1-47
</p>
<p>Veroniki, A. A., Pavlides, M., Patsopoulos, N. A., &amp; Salanti, G. (2013). Reconstructing 2x2 contingency tables from odds ratios using the Di Pietrantonj method: difficulties, constraints and impact in meta-analysis results. Research synthesis methods, 4(1), 78–94. https://doi.org/10.1002/jrsm.1061
</p>


<h3>Examples</h3>

<pre><code class="language-R">es_from_or_se(or = 2.12, logor_se = 0.242, n_exp = 120, n_nexp = 44)
</code></pre>


</div>