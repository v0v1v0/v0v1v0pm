<div class="container">

<table style="width: 100%;"><tr>
<td>metaprop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Meta-analysis of single proportions</h2>

<h3>Description</h3>

<p>Calculation of an overall proportion from studies reporting a
single proportion. Inverse variance method and generalised linear
mixed model (GLMM) are available for pooling. For GLMMs, the
<code>rma.glmm</code> function from R package
<b>metafor</b> (Viechtbauer 2010) is called internally.
</p>


<h3>Usage</h3>

<pre><code class="language-R">metaprop(
  event,
  n,
  studlab,
  data = NULL,
  subset = NULL,
  exclude = NULL,
  cluster = NULL,
  rho = 0,
  method,
  sm = gs("smprop"),
  incr = gs("incr"),
  method.incr = gs("method.incr"),
  method.ci = gs("method.ci.prop"),
  level = gs("level"),
  common = gs("common"),
  random = gs("random") | !is.null(tau.preset),
  overall = common | random,
  overall.hetstat = if (is.null(gs("overall.hetstat"))) common | random else
    gs("overall.hetstat"),
  prediction = gs("prediction") | !missing(method.predict),
  method.tau = ifelse(!is.na(charmatch(tolower(method), "glmm", nomatch = NA)), "ML",
    gs("method.tau")),
  method.tau.ci = gs("method.tau.ci"),
  tau.preset = NULL,
  TE.tau = NULL,
  tau.common = gs("tau.common"),
  level.ma = gs("level.ma"),
  method.random.ci = gs("method.random.ci"),
  adhoc.hakn.ci = gs("adhoc.hakn.ci"),
  level.predict = gs("level.predict"),
  method.predict = gs("method.predict"),
  adhoc.hakn.pi = gs("adhoc.hakn.pi"),
  seed.predict = NULL,
  null.effect = NA,
  method.bias = gs("method.bias"),
  backtransf = gs("backtransf"),
  pscale = 1,
  text.common = gs("text.common"),
  text.random = gs("text.random"),
  text.predict = gs("text.predict"),
  text.w.common = gs("text.w.common"),
  text.w.random = gs("text.w.random"),
  title = gs("title"),
  complab = gs("complab"),
  outclab = "",
  subgroup,
  subgroup.name = NULL,
  print.subgroup.name = gs("print.subgroup.name"),
  sep.subgroup = gs("sep.subgroup"),
  test.subgroup = gs("test.subgroup"),
  prediction.subgroup = gs("prediction.subgroup"),
  seed.predict.subgroup = NULL,
  byvar,
  hakn,
  adhoc.hakn,
  keepdata = gs("keepdata"),
  warn = gs("warn"),
  warn.deprecated = gs("warn.deprecated"),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>event</code></td>
<td>
<p>Number of events.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>studlab</code></td>
<td>
<p>An optional vector with study labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An optional data frame containing the study
information, i.e., event and n.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An optional vector specifying a subset of studies to
be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>An optional vector specifying studies to exclude
from meta-analysis, however, to include in printouts and forest
plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>An optional vector specifying which estimates come
from the same cluster resulting in the use of a three-level
meta-analysis model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>Assumed correlation of estimates within a cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A character string indicating which method is to be
used for pooling of studies. One of <code>"Inverse"</code> and
<code>"GLMM"</code>, can be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sm</code></td>
<td>
<p>A character string indicating which summary measure
(<code>"PLOGIT"</code>, <code>"PAS"</code>, <code>"PFT"</code>, <code>"PLN"</code>, or
<code>"PRAW"</code>) is to be used for pooling of studies, see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incr</code></td>
<td>
<p>A numeric which is added to event number and sample
size of studies with zero or all events, i.e., studies with an
event probability of either 0 or 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.incr</code></td>
<td>
<p>A character string indicating which continuity
correction method should be used (<code>"only0"</code>,
<code>"if0all"</code>, or <code>"all"</code>), see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.ci</code></td>
<td>
<p>A character string indicating which method is used
to calculate confidence intervals for individual studies, see
Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>The level used to calculate confidence intervals for
individual studies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>common</code></td>
<td>
<p>A logical indicating whether a common effect
meta-analysis should be conducted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>A logical indicating whether a random effects
meta-analysis should be conducted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overall</code></td>
<td>
<p>A logical indicating whether overall summaries
should be reported. This argument is useful in a meta-analysis
with subgroups if overall results should not be reported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overall.hetstat</code></td>
<td>
<p>A logical value indicating whether to print
heterogeneity measures for overall treatment comparisons. This
argument is useful in a meta-analysis with subgroups if
heterogeneity statistics should only be printed on subgroup
level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction</code></td>
<td>
<p>A logical indicating whether a prediction
interval should be printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.tau</code></td>
<td>
<p>A character string indicating which method is
used to estimate the between-study variance <code class="reqn">\tau^2</code> and its
square root <code class="reqn">\tau</code> (see <code>meta-package</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.tau.ci</code></td>
<td>
<p>A character string indicating which method is
used to estimate the confidence interval of <code class="reqn">\tau^2</code> and
<code class="reqn">\tau</code> (see <code>meta-package</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.preset</code></td>
<td>
<p>Prespecified value for the square root of the
between-study variance <code class="reqn">\tau^2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TE.tau</code></td>
<td>
<p>Overall treatment effect used to estimate the
between-study variance tau-squared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.common</code></td>
<td>
<p>A logical indicating whether tau-squared should
be the same across subgroups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level.ma</code></td>
<td>
<p>The level used to calculate confidence intervals
for meta-analysis estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.random.ci</code></td>
<td>
<p>A character string indicating which method
is used to calculate confidence interval and test statistic for
random effects estimate (see <code>meta-package</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adhoc.hakn.ci</code></td>
<td>
<p>A character string indicating whether an
<em>ad hoc</em> variance correction should be applied in the case
of an arbitrarily small Hartung-Knapp variance estimate (see
<code>meta-package</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level.predict</code></td>
<td>
<p>The level used to calculate prediction
interval for a new study.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.predict</code></td>
<td>
<p>A character string indicating which method is
used to calculate a prediction interval (see
<code>meta-package</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adhoc.hakn.pi</code></td>
<td>
<p>A character string indicating whether an
<em>ad hoc</em> variance correction should be applied for
prediction interval (see <code>meta-package</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed.predict</code></td>
<td>
<p>A numeric value used as seed to calculate
bootstrap prediction interval (see <code>meta-package</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null.effect</code></td>
<td>
<p>A numeric value specifying the effect under the
null hypothesis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.bias</code></td>
<td>
<p>A character string indicating which test is to
be used. Either <code>"Begg"</code>, <code>"Egger"</code>, or
<code>"Thompson"</code>, can be abbreviated. See function
<code>metabias</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backtransf</code></td>
<td>
<p>A logical indicating whether results for
transformed proportions (argument <code>sm != "PRAW"</code>) should be
back transformed in printouts and plots. If TRUE (default),
results will be presented as proportions; otherwise transformed
proportions will be shown. See Details for presentation of
confidence intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pscale</code></td>
<td>
<p>A numeric defining a scaling factor for printing of
single event probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>text.common</code></td>
<td>
<p>A character string used in printouts and forest
plot to label the pooled common effect estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>text.random</code></td>
<td>
<p>A character string used in printouts and forest
plot to label the pooled random effects estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>text.predict</code></td>
<td>
<p>A character string used in printouts and forest
plot to label the prediction interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>text.w.common</code></td>
<td>
<p>A character string used to label weights of
common effect model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>text.w.random</code></td>
<td>
<p>A character string used to label weights of
random effects model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>title</code></td>
<td>
<p>Title of meta-analysis / systematic review.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complab</code></td>
<td>
<p>Comparison label.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outclab</code></td>
<td>
<p>Outcome label.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subgroup</code></td>
<td>
<p>An optional vector to conduct a meta-analysis with
subgroups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subgroup.name</code></td>
<td>
<p>A character string with a name for the
subgroup variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.subgroup.name</code></td>
<td>
<p>A logical indicating whether the name of
the subgroup variable should be printed in front of the group
labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep.subgroup</code></td>
<td>
<p>A character string defining the separator
between name of subgroup variable and subgroup label.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.subgroup</code></td>
<td>
<p>A logical value indicating whether to print
results of test for subgroup differences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction.subgroup</code></td>
<td>
<p>A logical indicating whether prediction
intervals should be printed for subgroups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed.predict.subgroup</code></td>
<td>
<p>A numeric vector providing seeds to
calculate bootstrap prediction intervals within subgroups. Must
be of same length as the number of subgroups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>byvar</code></td>
<td>
<p>Deprecated argument (replaced by 'subgroup').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hakn</code></td>
<td>
<p>Deprecated argument (replaced by 'method.random.ci').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adhoc.hakn</code></td>
<td>
<p>Deprecated argument (replaced by 'adhoc.hakn.ci').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepdata</code></td>
<td>
<p>A logical indicating whether original data (set)
should be kept in meta object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>A logical indicating whether the addition of
<code>incr</code> to studies with zero or all events should result in a
warning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn.deprecated</code></td>
<td>
<p>A logical indicating whether warnings should
be printed if deprecated arguments are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>An optional list to control the iterative process to
estimate the between-study variance <code class="reqn">\tau^2</code>. This argument
is passed on to <code>rma.uni</code> or
<code>rma.glmm</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to
<code>rma.glmm</code> function and to catch deprecated
arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function provides methods for common effect and random effects
meta-analysis of single proportions to calculate an overall
proportion. Note, you should use R function <code>metabin</code>
to compare proportions of pairwise comparisons instead of using
<code>metaprop</code> for each treatment arm separately which will break
randomisation in randomised controlled trials.
</p>
<p>The following transformations of proportions are
implemented to calculate an overall proportion:
</p>

<ul>
<li>
<p> Logit transformation (<code>sm = "PLOGIT"</code>, default)
</p>
</li>
<li>
<p> Arcsine transformation (<code>sm = "PAS"</code>)
</p>
</li>
<li>
<p> Freeman-Tukey Double arcsine transformation (<code>sm = "PFT"</code>)
</p>
</li>
<li>
<p> Log transformation (<code>sm = "PLN"</code>)
</p>
</li>
<li>
<p> No transformation (<code>sm = "PRAW"</code>)
</p>
</li>
</ul>
<p>List elements <code>TE</code>, <code>TE.common</code>, <code>TE.random</code>, etc.,
contain the transformed proportions. In printouts and plots these
values are back transformed if argument <code>backtransf = TRUE</code>
(default).
</p>
<p>A generalised linear mixed model (GLMM) - more specific, a random
intercept logistic regression model - can be utilised for the
meta-analysis of proportions (Stijnen et al., 2010). This is the
default method for the logit transformation (argument <code>sm =
"PLOGIT"</code>). Internally, the <code>rma.glmm</code>
function from R package <b>metafor</b> is called to fit a GLMM.
</p>
<p>Classic meta-analysis (Borenstein et al., 2010) utilising the
(un)transformed proportions and corresponding standard errors in
the inverse variance method is conducted by calling the
<code>metagen</code> function internally. This is the only
available method for all transformations but the logit
transformation. The classic meta-analysis model with logit
transformed proportions is used by setting argument <code>method =
"Inverse"</code>.
</p>
<p>A three-level random effects meta-analysis model (Van den Noortgate
et al., 2013) is utilized if argument <code>cluster</code> is used and at
least one cluster provides more than one estimate. Internally,
<code>rma.mv</code> is called to conduct the analysis and
<code>weights.rma.mv</code> with argument <code>type =
"rowsum"</code> is used to calculate random effects weights.
</p>
<p>Default settings are utilised for several arguments (assignments
using <code>gs</code> function). These defaults can be changed for
the current R session using the <code>settings.meta</code>
function.
</p>
<p>Furthermore, R function <code>update.meta</code> can be used to
rerun a meta-analysis with different settings.
</p>


<h4>Choice of transformation / meta-analysis method</h4>

<p>Contradictory recommendations on the use of transformations of
proportions have been published in the literature. For example,
Barendregt et al. (2013) recommend the use of the Freeman-Tukey
double arcsine transformation instead of the logit transformation
whereas Warton &amp; Hui (2011) strongly advise to use generalised
linear mixed models with the logit transformation instead of the
arcsine transformation.
</p>
<p>Schwarzer et al. (2019) describe seriously misleading results in a
meta-analysis with very different sample sizes due to problems with
the back-transformation of the Freeman-Tukey transformation which
requires a single sample size (Miller, 1978). Accordingly,
Schwarzer et al. (2019) also recommend to use GLMMs for the
meta-analysis of single proportions, however, admit that individual
study weights are not available with this method. Meta-analysts
which require individual study weights should consider the inverse
variance method with the arcsine or logit transformation.
</p>
<p>In order to prevent misleading conclusions for the Freeman-Tukey
double arcsine transformation, sensitivity analyses using other
transformations or using a range of sample sizes should be
conducted (Schwarzer et al., 2019).
</p>



<h4>Continuity correction</h4>

<p>Three approaches are available to apply a continuity correction:
</p>

<ul>
<li>
<p> Only studies with a zero cell count (<code>method.incr =
  "only0"</code>)
</p>
</li>
<li>
<p> All studies if at least one study has a zero cell count
(<code>method.incr = "if0all"</code>)
</p>
</li>
<li>
<p> All studies irrespective of zero cell counts
(<code>method.incr = "all"</code>)
</p>
</li>
</ul>
<p>If the summary measure is equal to "PLOGIT", "PLN", or "PRAW", the
continuity correction is applied if a study has either zero or all
events, i.e., an event probability of either 0 or 1.
</p>
<p>By default, 0.5 is used as continuity correction (argument
<code>incr</code>). This continuity correction is used both to calculate
individual study results with confidence limits and to conduct
meta-analysis based on the inverse variance method. For GLMMs no
continuity correction is used.
</p>



<h4>Confidence intervals for individual studies</h4>

<p>Various methods are available to calculate confidence intervals for
individual study results (see Agresti &amp; Coull 1998 and Newcombe
1988):
</p>

<ul>
<li>
<p> Clopper-Pearson interval also called 'exact' binomial
interval (<code>method.ci = "CP"</code>, default)
</p>
</li>
<li>
<p> Wilson Score interval (<code>method.ci = "WS"</code>)
</p>
</li>
<li>
<p> Wilson Score interval with continuity correction
(<code>method.ci = "WSCC"</code>)
</p>
</li>
<li>
<p> Agresti-Coull interval (<code>method.ci = "AC"</code>)
</p>
</li>
<li>
<p> Simple approximation interval (<code>method.ci = "SA"</code>)
</p>
</li>
<li>
<p> Simple approximation interval with continuity correction
(<code>method.ci = "SACC"</code>)
</p>
</li>
<li>
<p> Normal approximation interval based on summary measure,
i.e. defined by argument <code>sm</code> (<code>method.ci = "NAsm"</code>)
</p>
</li>
</ul>
<p>Note, with exception of the normal approximation based on the
summary measure, i.e. <code>method.ci = "NAsm"</code>, the same
confidence interval is calculated for individual studies for any
summary measure (argument <code>sm</code>) as only number of events and
observations are used in the calculation disregarding the chosen
transformation.
</p>
<p>Results will be presented for transformed proportions if argument
<code>backtransf = FALSE</code>. In this case, argument <code>method.ci =
"NAsm"</code> is used, i.e. confidence intervals based on the normal
approximation based on the summary measure.
</p>



<h4>Subgroup analysis</h4>

<p>Argument <code>subgroup</code> can be used to conduct subgroup analysis for
a categorical covariate. The <code>metareg</code> function can be
used instead for more than one categorical covariate or continuous
covariates.
</p>



<h4>Specify the null hypothesis of test for an overall proportion</h4>

<p>Argument <code>null.effect</code> can be used to specify the proportion
used under the null hypothesis in a test for an overall effect.
</p>
<p>By default (<code>null.effect = NA</code>), no hypothesis test is
conducted as it is unclear which value is a sensible choice for the
data at hand.  An overall proportion of 50%, for example, could be
tested by setting argument <code>null.effect = 0.5</code>.
</p>
<p>Note, all tests for an overall effect are two-sided with the
alternative hypothesis that the effect is unequal to
<code>null.effect</code>.
</p>



<h4>Exclusion of studies from meta-analysis</h4>

<p>Arguments <code>subset</code> and <code>exclude</code> can be used to exclude
studies from the meta-analysis. Studies are removed completely from
the meta-analysis using argument <code>subset</code>, while excluded
studies are shown in printouts and forest plots using argument
<code>exclude</code> (see Examples in <code>metagen</code>).
Meta-analysis results are the same for both arguments.
</p>



<h4>Presentation of meta-analysis results</h4>

<p>Internally, both common effect and random effects models are
calculated regardless of values choosen for arguments
<code>common</code> and <code>random</code>. Accordingly, the estimate
for the random effects model can be extracted from component
<code>TE.random</code> of an object of class <code>"meta"</code> even if
argument <code>random = FALSE</code>. However, all functions in R
package <b>meta</b> will adequately consider the values for
<code>common</code> and <code>random</code>. E.g. function
<code>print.meta</code> will not print results for the random
effects model if <code>random = FALSE</code>.
</p>
<p>Argument <code>pscale</code> can be used to rescale proportions, e.g.
<code>pscale = 1000</code> means that proportions are expressed as events
per 1000 observations. This is useful in situations with (very) low
event probabilities.
</p>
<p>A prediction interval will only be shown if <code>prediction =
TRUE</code>.
</p>



<h3>Value</h3>

<p>An object of class <code>c("metaprop", "meta")</code> with corresponding
generic functions (see <code>meta-object</code>).
</p>


<h3>Author(s)</h3>

<p>Guido Schwarzer <a href="mailto:guido.schwarzer@uniklinik-freiburg.de">guido.schwarzer@uniklinik-freiburg.de</a>
</p>


<h3>References</h3>

<p>Agresti A &amp; Coull BA (1998):
Approximate is better than "exact" for interval estimation of
binomial proportions.
<em>The American Statistician</em>,
<b>52</b>, 119–26
</p>
<p>Barendregt JJ, Doi SA, Lee YY, Norman RE, Vos T (2013):
Meta-analysis of prevalence.
<em>Journal of Epidemiology and Community Health</em>,
<b>67</b>, 974–8
</p>
<p>Borenstein M, Hedges LV, Higgins JP, Rothstein HR (2010):
A basic introduction to fixed-effect and random-effects models for
meta-analysis.
<em>Research Synthesis Methods</em>,
<b>1</b>, 97–111
</p>
<p>Freeman MF &amp; Tukey JW (1950):
Transformations related to the angular and the square root.
<em>Annals of Mathematical Statistics</em>,
<b>21</b>, 607–11
</p>
<p>Miller JJ (1978):
The inverse of the Freeman-Tukey double arcsine transformation.
<em>The American Statistician</em>,
<b>32</b>, 138
</p>
<p>Newcombe RG (1998):
Two-sided confidence intervals for the single proportion:
comparison of seven methods.
<em>Statistics in Medicine</em>,
<b>17</b>, 857–72
</p>
<p>Pettigrew HM, Gart JJ, Thomas DG (1986):
The bias and higher cumulants of the logarithm of a binomial
variate.
<em>Biometrika</em>,
<b>73</b>, 425–35
</p>
<p>Schwarzer G, Chemaitelly H, Abu-Raddad LJ, Rücker G (2019):
Seriously misleading results using inverse of Freeman-Tukey double
arcsine transformation in meta-analysis of single proportions.
<em>Research Synthesis Methods</em>,
<b>10</b>, 476–83
</p>
<p>Stijnen T, Hamza TH, Ozdemir P (2010):
Random effects meta-analysis of event outcome in the framework of
the generalized linear mixed model with applications in sparse
data.
<em>Statistics in Medicine</em>,
<b>29</b>, 3046–67
</p>
<p>Van den Noortgate W, López-López JA, Marín-Martínez F, Sánchez-Meca J (2013):
Three-level meta-analysis of dependent effect sizes.
<em>Behavior Research Methods</em>,
<b>45</b>, 576–94
</p>
<p>Viechtbauer W (2010):
Conducting meta-analyses in R with the metafor package.
<em>Journal of Statistical Software</em>,
<b>36</b>, 1–48
</p>
<p>Warton DI, Hui FKC (2011):
The arcsine is asinine: the analysis of proportions in ecology.
<em>Ecology</em>,
<b>92</b>, 3–10
</p>


<h3>See Also</h3>

<p><code>meta-package</code>, <code>update.meta</code>,
<code>metacont</code>, <code>metagen</code>,
<code>print.meta</code>, <code>forest.meta</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Meta-analysis using generalised linear mixed model
#
metaprop(4:1, 10 * 1:4)

# Apply various classic meta-analysis methods to estimate
# proportions
#
m1 &lt;- metaprop(4:1, 10 * 1:4, method = "Inverse")
m2 &lt;- update(m1, sm = "PAS")
m3 &lt;- update(m1, sm = "PRAW")
m4 &lt;- update(m1, sm = "PLN")
m5 &lt;- update(m1, sm = "PFT")
#
m1
m2
m3
m4
m5
#
forest(m1)
## Not run: 
forest(m2)
forest(m3)
forest(m3, pscale = 100)
forest(m4)
forest(m5)

## End(Not run)

# Do not back transform results, e.g. print logit transformed
# proportions if sm = "PLOGIT" and store old settings
#
oldset &lt;- settings.meta(backtransf = FALSE)
#
m6  &lt;- metaprop(4:1, c(10, 20, 30, 40), method = "Inverse")
m7  &lt;- update(m6, sm = "PAS")
m8  &lt;- update(m6, sm = "PRAW")
m9  &lt;- update(m6, sm = "PLN")
m10 &lt;- update(m6, sm = "PFT")
#
forest(m6)
## Not run: 
forest(m7)
forest(m8)
forest(m8, pscale = 100)
forest(m9)
forest(m10)

## End(Not run)

# Use old settings
#
settings.meta(oldset)

# Examples with zero events
#
m1 &lt;- metaprop(c(0, 0, 10, 10), rep(100, 4), method = "Inverse")
m2 &lt;- metaprop(c(0, 0, 10, 10), rep(100, 4), incr = 0.1, method = "Inverse")
#
m1
m2
#
## Not run: 
forest(m1)
forest(m2)

## End(Not run)

# Example from Miller (1978):
#
death &lt;- c(3, 6, 10, 1)
animals &lt;- c(11, 17, 21, 6)
#
m3 &lt;- metaprop(death, animals, sm = "PFT")
forest(m3)

# Data examples from Newcombe (1998)
# - apply various methods to estimate confidence intervals for
#   individual studies
#
event &lt;- c(81, 15, 0, 1)
n &lt;- c(263, 148, 20, 29)
#
m1 &lt;- metaprop(event, n, method.ci = "SA", method = "Inverse")
m2 &lt;- update(m1, method.ci = "SACC")
m3 &lt;- update(m1, method.ci = "WS")
m4 &lt;- update(m1, method.ci = "WSCC")
m5 &lt;- update(m1, method.ci = "CP")
#
lower &lt;- round(logit2p(rbind(NA, m1$lower, m2$lower, NA, m3$lower,
  m4$lower, NA, m5$lower)), 4)
upper &lt;- round(logit2p(rbind(NA, m1$upper, m2$upper, NA, m3$upper,
  m4$upper, NA, m5$upper)), 4)
#
tab1 &lt;- data.frame(
  scen1 = meta:::formatCI(lower[, 1], upper[, 1]),
  scen2 = meta:::formatCI(lower[, 2], upper[, 2]),
  scen3 = meta:::formatCI(lower[, 3], upper[, 3]),
  scen4 = meta:::formatCI(lower[, 4], upper[, 4])
  )
names(tab1) &lt;- c("r=81, n=263", "r=15, n=148",
  "r=0, n=20", "r=1, n=29")
row.names(tab1) &lt;- c("Simple", "- SA", "- SACC",
  "Score", "- WS", "- WSCC", "Binomial", "- CP")
tab1[is.na(tab1)] &lt;- ""
# Newcombe (1998), Table I, methods 1-5:
tab1

# Same confidence interval, i.e. unaffected by choice of summary
# measure
#
print(metaprop(event, n, method.ci = "WS", method = "Inverse"), ma = FALSE)
print(metaprop(event, n, sm = "PLN", method.ci = "WS"), ma = FALSE)
print(metaprop(event, n, sm = "PFT", method.ci = "WS"), ma = FALSE)
print(metaprop(event, n, sm = "PAS", method.ci = "WS"), ma = FALSE)
print(metaprop(event, n, sm = "PRAW", method.ci = "WS"), ma = FALSE)

# Different confidence intervals as argument sm = "NAsm"
#
print(metaprop(event, n, method.ci = "NAsm", method = "Inverse"), ma = FALSE)
print(metaprop(event, n, sm = "PLN", method.ci = "NAsm"), ma = FALSE)
print(metaprop(event, n, sm = "PFT", method.ci = "NAsm"), ma = FALSE)
print(metaprop(event, n, sm = "PAS", method.ci = "NAsm"), ma = FALSE)
print(metaprop(event, n, sm = "PRAW", method.ci = "NAsm"), ma = FALSE)

# Different confidence intervals as argument backtransf = FALSE.
# Accordingly, method.ci = "NAsm" used internally.
#
print(metaprop(event, n, method.ci = "WS", method = "Inverse"),
  ma = FALSE, backtransf = FALSE)
print(metaprop(event, n, sm = "PLN", method.ci = "WS"),
  ma = FALSE, backtransf = FALSE)
print(metaprop(event, n, sm = "PFT", method.ci = "WS"),
  ma = FALSE, backtransf = FALSE)
print(metaprop(event, n, sm = "PAS", method.ci = "WS"),
  ma = FALSE, backtransf = FALSE)
print(metaprop(event, n, sm = "PRAW", method.ci = "WS"),
  ma = FALSE, backtransf = FALSE)

# Same results (printed on original and log scale, respectively)
#
print(metaprop(event, n, sm = "PLN", method.ci = "NAsm"), ma = FALSE)
print(metaprop(event, n, sm = "PLN"), ma = FALSE, backtransf = FALSE)
# Results for first study (on log scale)
round(log(c(0.3079848, 0.2569522, 0.3691529)), 4)

# Print results as events per 1000 observations
#
print(metaprop(6:8, c(100, 1200, 1000), method = "Inverse"),
  pscale = 1000, digits = 1)

</code></pre>


</div>