<div class="container">

<table style="width: 100%;"><tr>
<td>metacoder</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Metacoder</h2>

<h3>Description</h3>

<p>A package for planning and analysis of amplicon metagenomics research projects.
</p>


<h3>Details</h3>

<p>The goal of the <code>metacoder</code> package is to provide a set of tools for:
</p>

<ul>
<li>
<p> Standardized parsing of taxonomic information from diverse resources.
</p>
</li>
<li>
<p> Visualization of statistics distributed over taxonomic classifications.
</p>
</li>
<li>
<p> Evaluating potential metabarcoding primers for taxonomic specificity.
</p>
</li>
<li>
<p> Providing flexible functions for analyzing taxonomic and abundance data.
</p>
</li>
</ul>
<p>To accomplish these goals, <code>metacoder</code> leverages resources from other R packages, interfaces with
external programs, and provides novel functions where needed to allow for entire analyses within R.
</p>


<h3>Documentation</h3>

<p>The full documentation can be found online at <a href="https://grunwaldlab.github.io/metacoder_documentation/">https://grunwaldlab.github.io/metacoder_documentation/</a>.
</p>
<p>There is also a short vignette included for offline use that can be accessed  by the following code:
</p>
<p><code>browseVignettes(package = "metacoder")</code>
</p>
<p><strong>Plotting:</strong>
</p>

<ul>
<li> <p><code>heat_tree</code>
</p>
</li>
<li> <p><code>heat_tree_matrix</code>
</p>
</li>
</ul>
<p><strong>In silico PCR:</strong>
</p>

<ul><li> <p><code>primersearch</code>
</p>
</li></ul>
<p><strong>Analysis:</strong>
</p>

<ul>
<li> <p><code>calc_taxon_abund</code>
</p>
</li>
<li> <p><code>calc_obs_props</code>
</p>
</li>
<li> <p><code>rarefy_obs</code>
</p>
</li>
<li> <p><code>compare_groups</code>
</p>
</li>
<li> <p><code>zero_low_counts</code>
</p>
</li>
<li> <p><code>calc_n_samples</code>
</p>
</li>
<li> <p><code>filter_ambiguous_taxa</code>
</p>
</li>
</ul>
<p><strong>Parsers:</strong>
</p>

<ul>
<li> <p><code>parse_greengenes</code>
</p>
</li>
<li> <p><code>parse_mothur_tax_summary</code>
</p>
</li>
<li> <p><code>parse_mothur_taxonomy</code>
</p>
</li>
<li> <p><code>parse_newick</code>
</p>
</li>
<li> <p><code>parse_phyloseq</code>
</p>
</li>
<li> <p><code>parse_phylo</code>
</p>
</li>
<li> <p><code>parse_qiime_biom</code>
</p>
</li>
<li> <p><code>parse_rdp</code>
</p>
</li>
<li> <p><code>parse_silva_fasta</code>
</p>
</li>
<li> <p><code>parse_unite_general</code>
</p>
</li>
</ul>
<p><strong>Writers:</strong>
</p>

<ul>
<li> <p><code>write_greengenes</code>
</p>
</li>
<li> <p><code>write_mothur_taxonomy</code>
</p>
</li>
<li> <p><code>write_rdp</code>
</p>
</li>
<li> <p><code>write_silva_fasta</code>
</p>
</li>
<li> <p><code>write_unite_general</code>
</p>
</li>
</ul>
<p><strong>Database querying:</strong>
</p>

<ul><li> <p><code>ncbi_taxon_sample</code>
</p>
</li></ul>
<h3>Main classes</h3>

<p>These are the classes users would typically interact with:
</p>
<p>* [taxon]: A class used to define a single taxon. Many other classes in the
'taxaâ€œ package include one or more objects of this class.
* : Stores one or more [taxon] objects. This is just a thin wrapper
for a list of [taxon] objects.
* [hierarchy]: A class containing an ordered list of [taxon] objects that
represent a hierarchical classification.
* [hierarchies]: A list of taxonomic classifications.  This is just a thin wrapper
for a list of [hierarchy] objects.
* [taxonomy]: A taxonomy composed of [taxon] objects organized in a tree
structure. This differs from the [hierarchies] class in how the [taxon]
objects are stored. Unlike a [hierarchies] object, each unique taxon is
stored only once and the relationships between taxa are stored in an
edgelist.
* [taxmap]: A class designed to store a taxonomy and associated
user-defined data. This class builds on the [taxonomy] class. User defined
data can be stored in the list 'obj$data', where 'obj' is a taxmap
object. Any number of user-defined lists, vectors, or tables mapped
to taxa can be manipulated in a cohesive way such that relationships
between taxa and data are preserved.
</p>


<h3>Minor classes</h3>

<p>These classes are mostly components for the larger classes above and would
not typically be used on their own.
</p>
<p>* [taxon_database]: Used to store information about taxonomy databases.
* [taxon_id]: Used to store taxon IDs, either arbitrary or from a
particular taxonomy database.
* [taxon_name]: Used to store taxon names, either arbitrary or from a
particular taxonomy database.
* [taxon_rank]: Used to store taxon ranks (e.g. species, family), either
arbitrary or from a particular taxonomy database.
</p>


<h3>Major manipulation functions</h3>

<p>These are some of the more important functions used to filter data in classes
that store multiple taxa, like [hierarchies], [taxmap], and [taxonomy].
</p>
<p>* [filter_taxa]: Filter taxa in a [taxonomy] or [taxmap] object with a
series of conditions. Relationships between remaining taxa and user-defined
data are preserved (There are many options controlling this).
* [filter_obs]: Filter user-defined data [taxmap] object with a series of
conditions. Relationships between remaining taxa and user-defined data are
preserved (There are many options controlling this);
* [sample_n_taxa]: Randomly sample taxa. Has same abilities as
[filter_taxa].
* [sample_n_obs]: Randomly sample observations. Has same abilities as
[filter_obs].
* [mutate_obs]: Add datasets or columns to datasets in the 'data' list of
[taxmap] objects.
* [pick]: Pick out specific taxa, while others are dropped in [hierarchy]
and [hierarchies] objects.
* [pop]: Pop out taxa (drop them) in [hierarchy] and [hierarchies] objects.
* [span]: Select a range of taxa, either by two names, or relational
operators in [hierarchy] and [hierarchies] objects.
</p>


<h3>Mapping functions</h3>

<p>There are lots of functions for getting information for each taxon.
</p>
<p>* [subtaxa]: Return data for the subtaxa of each taxon in an [taxonomy] or
[taxmap] object.
* [supertaxa]: Return data for the supertaxa of each taxon in an [taxonomy]
or [taxmap] object.
* [roots]: Return data for the roots of each taxon in an [taxonomy] or
[taxmap] object.
* [leaves]: Return data for the leaves of each taxon in an [taxonomy] or
[taxmap] object.
* [obs]: Return user-specific data for each taxon and all of its subtaxa in
an [taxonomy] or [taxmap] object.
</p>


<h3>The kind of classes used</h3>

<p>Note, this is mostly of interest to developers and advanced users.
</p>
<p>The classes in the 'taxa' package are mostly
[R6](https://adv-r.hadley.nz/r6.html) classes ([R6Class]). A few of the
simpler ones ( and [hierarchies]) are
[S3](https://adv-r.hadley.nz/s3.html) instead. R6 classes are different than
most R objects because they are
[mutable](https://en.wikipedia.org/wiki/Immutable_object) (e.g. A function
can change its input without returning it). In this, they are more similar
to class systems in
[object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming)
languages like python. As in other object-oriented class systems, functions
are thought to "belong" to classes (i.e. the data), rather than functions
existing independently of the data. For example, the function 'print' in R
exists apart from what it is printing, although it will change how it prints
based on what the class of the data is that is passed to it. In fact, a user
can make a custom print method for their own class by defining a function
called 'print.myclassname'. In contrast, the functions that operate on R6
functions are "packaged" with the data they operate on. For example, a print
method of an object for an R6 class might be called like
'my_data$print()' instead of 'print(my_data)'.
</p>


<h3>The two ways to call functions</h3>

<p>Note, you will need to read the previous section to fully understand this one.
</p>
<p>Since the R6 function syntax (e.g. 'my_data$print()') might be confusing to
many R users, all functions in 'taxa' also have S3 versions. For example,
the [filter_taxa()] function can be called on a [taxmap] object called
'my_obj' like 'my_obj$filter_taxa(...)' (the R6 syntax) or
'filter_taxa(my_obj, ...)' (the S3 syntax). For some functions, these two
way of calling the function can have different effect. For functions that do
not returned a modified version of the input (e.g. [subtaxa()]), the two ways have identical behavior.
However, functions like [filter_taxa()], that modify their inputs, actually
change the object passed to them as the first argument as well as returning that
object. For example,
</p>
<p>'my_obj &lt;- filter_taxa(my_obj, ...)'
</p>
<p>and
</p>
<p>'my_obj$filter_taxa(...)'
</p>
<p>and
</p>
<p>'new_obj &lt;- my_obj$filter_taxa(...)'
</p>
<p>all replace 'my_obj' with the filtered result, but
</p>
<p>'new_obj &lt;- filter_taxa(my_obj, ...)'
</p>
<p>will not modify 'my_obj'.
</p>


<h3>Non-standard evaluation</h3>

<p>This is a rather advanced topic.
</p>
<p>Like packages such as 'ggplot2' and [dplyr], the 'taxa' package uses
non-standard evaluation to allow code
to be more readable and shorter. In effect, there are variables that only
"exist" inside a function call and depend on what is passed to that function
as the first parameter (usually a class object). For example, in the 'dpylr'
function [filter()], column names can be used as if they were independent
variables. See '?dpylr::filter' for examples of this. The 'taxa' package builds on this idea.
</p>
<p>For many functions that work on [taxonomy] or [taxmap] objects (e.g. [filter_taxa]),
some functions that return per-taxon information (e.g. [taxon_names()]) can
be referred to by just the name of the function. When one of these functions
are referred to by name, the function is run on the relevant object and its
value replaces the function name. For example,
</p>
<p>'new_obj &lt;- filter_taxa(my_obj, taxon_names == "Bacteria")'
</p>
<p>is identical to:
</p>
<p>'new_obj &lt;- filter_taxa(my_obj, taxon_names(my_obj) == "Bacteria")'
</p>
<p>which is identical to:
</p>
<p>'new_obj &lt;- filter_taxa(my_obj, my_obj$taxon_names() == "Bacteria")'
</p>
<p>which is identical to:
</p>
<p>'my_names &lt;- taxon_names(my_obj)'
</p>
<p>'new_obj &lt;- filter_taxa(my_obj, my_names == "Bacteria")'
</p>
<p>For 'taxmap' objects, you can also use names of user defined lists, vectors,
and the names of columns in user-defined tables that are stored in the
'obj$data' list. See [filter_taxa()] for examples. You can even add your own
functions that are called by name by adding them to the 'obj$funcs' list.
For any object with functions that use non-standard evaluation, you can see
what values can be used  with [all_names()] like 'all_names(obj)'.
</p>


<h3>Dependencies and inspiration</h3>

<p>Various elements of the 'taxa' package were inspired by the [dplyr] and
[taxize] packages. This package started as parts of the 'metacoder' and
'binomen' packages. There are also many dependencies that make 'taxa'
possible.
</p>


<h3>Feedback and contributions</h3>

<p>Find a problem? Have a suggestion? Have a question? Please submit an issue
at our [GitHub repository](https://github.com/ropensci/taxa):
</p>
<p>[https://github.com/ropensci/taxa/issues](https://github.com/ropensci/taxa/issues)
</p>
<p>A GitHub account is free and easy to set up. We welcome feedback! If you
don't want to use GitHub for some reason, feel free to email us. We do
prefer posting to github since it allows others that might have the same
issue to see our conversation. It also helps us keep track of what problems
we need to address.
</p>
<p>Want to contribute code or make a change to the code? Great, thank you!
Please [fork](https://help.github.com/articles/fork-a-repo/) our GitHub
repository and submit a [pull request](https://help.github.com/articles/about-pull-requests/).
</p>


<h3>Author(s)</h3>

<p>Zachary Foster and Niklaus Grunwald
</p>


</div>