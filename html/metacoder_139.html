<div class="container">

<table style="width: 100%;"><tr>
<td>parse_dada2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert the output of dada2 to a taxmap object</h2>

<h3>Description</h3>

<p>Convert the ASV table and taxonomy table returned by dada2 into a taxmap object. An example of
the input format can be found by following the dada2 tutorial here:
shttps://benjjneb.github.io/dada2/tutorial.html
</p>


<h3>Usage</h3>

<pre><code class="language-R">parse_dada2(
  seq_table,
  tax_table,
  class_key = "taxon_name",
  class_regex = "(.*)",
  include_match = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>seq_table</code></td>
<td>
<p>The ASV abundance matrix, with rows as samples and columns as ASV ids or
sequences</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tax_table</code></td>
<td>
<p>The table with taxonomic classifications for ASVs, with ASVs in rows and
taxonomic ranks as columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class_key</code></td>
<td>
<p>('character' of length 1) The identity of the capturing groups defined using
'class_regex'. The length of 'class_key' must be equal to the number of capturing groups
specified in 'class_regex'. Any names added to the terms will be used as column names in the
output. At least one '"taxon_name"' must be specified. Only '"info"' can be used multiple
times. Each term must be one of those described below: * 'taxon_name': The name of a taxon. Not
necessarily unique, but are interpretable by a particular 'database'. Requires an internet
connection. * 'taxon_rank': The rank of the taxon. This will be used to add rank info into the
output object that can be accessed by 'out$taxon_ranks()'. * 'info': Arbitrary taxon info you
want included in the output. Can be used more than once.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class_regex</code></td>
<td>
<p>('character' of length 1) A regular expression with capturing groups
indicating the locations of data for each taxon in the 'class' term in the 'key' argument. The
identity of the information must be specified using the 'class_key' argument. The 'class_sep'
option can be used to split the classification into data for each taxon before matching. If
'class_sep' is 'NULL', each match of 'class_regex' defines a taxon in the classification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_match</code></td>
<td>
<p>('logical' of length 1) If 'TRUE', include the part of the input matched by
'class_regex' in the output object.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>taxmap</code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code>extract_tax_data()</code>,
<code>lookup_tax_data()</code>,
<code>parse_edge_list()</code>,
<code>parse_greengenes()</code>,
<code>parse_mothur_tax_summary()</code>,
<code>parse_mothur_taxonomy()</code>,
<code>parse_newick()</code>,
<code>parse_phylo()</code>,
<code>parse_phyloseq()</code>,
<code>parse_qiime_biom()</code>,
<code>parse_rdp()</code>,
<code>parse_silva_fasta()</code>,
<code>parse_tax_data()</code>,
<code>parse_ubiome()</code>,
<code>parse_unite_general()</code>
</p>


</div>