<div class="container">

<table style="width: 100%;"><tr>
<td>calc_group_stat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply a function to groups of columns</h2>

<h3>Description</h3>

<p>For a given table in a <code>taxmap</code> object, apply a function to
rows in groups of columns. The result of the function is used to create new
columns. This is equivalent to splitting columns of a table by a factor and
using <code>apply</code> on each group.
</p>


<h3>Usage</h3>

<pre><code class="language-R">calc_group_stat(
  obj,
  data,
  func,
  groups = NULL,
  cols = NULL,
  other_cols = FALSE,
  out_names = NULL,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>A <code>taxmap</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p>The function to apply. It should take a vector and return a
single value. For example, <code>max</code> or <code>mean</code> could
be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt>
<dd>
<p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt>
<dd>
<p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt>
<dd>
<p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt>
<dd>
<p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The "taxon_id" column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt>
<dd>
<p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt>
<dd>
<p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt>
<dd>
<p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt>
<dd>
<p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt>
<dd>
<p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataset</code></td>
<td>
<p>DEPRECIATED. use "data" instead.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code>calc_diff_abund_deseq2()</code>,
<code>calc_group_mean()</code>,
<code>calc_group_median()</code>,
<code>calc_group_rsd()</code>,
<code>calc_n_samples()</code>,
<code>calc_obs_props()</code>,
<code>calc_prop_samples()</code>,
<code>calc_taxon_abund()</code>,
<code>compare_groups()</code>,
<code>counts_to_presence()</code>,
<code>rarefy_obs()</code>,
<code>zero_low_counts()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Parse data for examples
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")

# Apply a function to every value without grouping 
calc_group_stat(x, "tax_data", function(v) v &gt; 3)

# Calculate the means for each group
calc_group_stat(x, "tax_data", mean, groups = hmp_samples$sex)

# Calculate the variation for each group
calc_group_stat(x, "tax_data", sd, groups = hmp_samples$body_site)

# Different ways to use only some columns
calc_group_stat(x, "tax_data", function(v) v &gt; 3,
                cols = c("700035949", "700097855", "700100489"))
calc_group_stat(x, "tax_data", function(v) v &gt; 3,
                cols = 4:6)
calc_group_stat(x, "tax_data", function(v) v &gt; 3,
                cols = startsWith(colnames(x$data$tax_data), "70001"))

# Including all other columns in ouput
calc_group_stat(x, "tax_data", mean, groups = hmp_samples$sex,
                other_cols = TRUE)

# Inlcuding specific columns in output
calc_group_stat(x, "tax_data", mean, groups = hmp_samples$sex,
                other_cols = 2)
calc_group_stat(x, "tax_data", mean, groups = hmp_samples$sex,
                other_cols = "otu_id")

# Rename output columns
calc_group_stat(x, "tax_data", mean, groups = hmp_samples$sex,
               out_names = c("Women", "Men"))


## End(Not run)
</code></pre>


</div>