<div class="container">

<table style="width: 100%;"><tr>
<td>filter_obs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter observations with a list of conditions</h2>

<h3>Description</h3>

<p>Filter data in a [taxmap()] object (in 'obj$data') with a
set of conditions.  See
[dplyr::filter()] for the inspiration for this function and more
information. Calling the function using the 'obj$filter_obs(...)' style
edits "obj" in place, unlike most R functions. However, calling the function
using the ‘filter_obs(obj, ...)' imitates R’s traditional copy-on-modify
semantics, so "obj" would not be changed; instead a changed version would be
returned, like most R functions.
</p>
<pre>
obj$filter_obs(data, ..., drop_taxa = FALSE, drop_obs = TRUE,
               subtaxa = FALSE, supertaxa = TRUE, reassign_obs = FALSE)
filter_obs(obj, data, ..., drop_taxa = FALSE, drop_obs = TRUE,
           subtaxa = FALSE, supertaxa = TRUE, reassign_obs = FALSE)</pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>An object of type [taxmap()]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Dataset names, indexes, or a logical vector that indicates which datasets in
'obj$data' to filter. If multiple datasets are filterd at once, then they must be the same
length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>One or more filtering conditions. Any variable name that appears
in [all_names()] can be used as if it was a vector on its own. Each
filtering condition can be one of two things:
* 'integer': One or more dataset indexes.
* 'logical': A 'TRUE'/'FALSE' vector of length equal to the number of
items in the dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop_taxa</code></td>
<td>
<p>('logical' of length 1) If 'FALSE', preserve taxa
even if all of their observations are filtered out. If 'TRUE', remove
taxa for which all observations were filtered out. Note that only taxa that
are unobserved due to this filtering will be removed; there might be other
taxa without observations to begin with that will not be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop_obs</code></td>
<td>
<p>('logical') This only has an effect when 'drop_taxa' is
'TRUE'. When 'TRUE', observations for other data sets (i.e. not 'data')
assigned to taxa that are removed when filtering 'data' are also removed.
Otherwise, only data for taxa that are not present in all other data sets
will be removed. This option can be either simply 'TRUE'/'FALSE', meaning
that all data sets will be treated the same, or a logical vector can be
supplied with names corresponding one or more data sets in 'obj$data'. For
example, 'c(abundance = TRUE, stats = FALSE)' would remove observations in
'obj$data$abundance', but not in 'obj$data$stats'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subtaxa</code></td>
<td>
<p>('logical' or 'numeric' of length 1) This only has an effect
when 'drop_taxa' is 'TRUE'. If 'TRUE', include subtaxa of taxa passing the
filter. Positive numbers indicate the number of ranks below the target taxa
to return. '0' is equivalent to 'FALSE'. Negative numbers are equivalent to
'TRUE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>supertaxa</code></td>
<td>
<p>('logical'  or 'numeric' of length 1) This only has an
effect when 'drop_taxa' is 'TRUE'. If 'TRUE', include supertaxa of taxa
passing the filter. Positive numbers indicate the number of ranks above the
target taxa to return. '0' is equivalent to 'FALSE'. Negative numbers are
equivalent to 'TRUE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reassign_obs</code></td>
<td>
<p>('logical') This only has an effect when 'drop_taxa' is
'TRUE'. If 'TRUE', observations assigned to removed taxa will be reassigned
to the closest supertaxon that passed the filter. If there are no supertaxa
of such an observation that passed the filter, they will be filtered out if
'drop_obs' is 'TRUE'. This option can be either simply 'TRUE'/'FALSE',
meaning that all data sets will be treated the same, or a logical vector
can be supplied with names corresponding one or more data sets in
'obj$data'. For example, 'c(abundance = TRUE, stats = FALSE)' would
reassign observations in 'obj$data$abundance', but not in 'obj$data$stats'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>DEPRECIATED. use "data" instead.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of type [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code>arrange_obs()</code>,
<code>arrange_taxa()</code>,
<code>filter_taxa()</code>,
<code>mutate_obs()</code>,
<code>sample_frac_obs()</code>,
<code>sample_frac_taxa()</code>,
<code>sample_n_obs()</code>,
<code>sample_n_taxa()</code>,
<code>select_obs()</code>,
<code>transmute_obs()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Filter by row index
filter_obs(ex_taxmap, "info", 1:2)

# Filter by TRUE/FALSE
filter_obs(ex_taxmap, "info", dangerous == FALSE)
filter_obs(ex_taxmap, "info", dangerous == FALSE, n_legs &gt; 0)
filter_obs(ex_taxmap, "info", n_legs == 2)

# Remove taxa whose obserservations were filtered out
filter_obs(ex_taxmap, "info", n_legs == 2, drop_taxa = TRUE)

# Preserve other data sets while removing taxa
filter_obs(ex_taxmap, "info", n_legs == 2, drop_taxa = TRUE,
           drop_obs = c(abund = FALSE))

# When filtering taxa, do not return supertaxa of taxa that are preserved
filter_obs(ex_taxmap, "info", n_legs == 2, drop_taxa = TRUE,
           supertaxa = FALSE)

# Filter multiple datasets at once
filter_obs(ex_taxmap, c("info", "phylopic_ids", "foods"), n_legs == 2)

</code></pre>


</div>