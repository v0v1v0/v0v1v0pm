<div class="container">

<table style="width: 100%;"><tr>
<td>selmodel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Selection Models</h2>

<h3>Description</h3>

<p>Function to fit selection models. <script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></p>


<h3>Usage</h3>

<pre><code class="language-R">selmodel(x, ...)

## S3 method for class 'rma.uni'
selmodel(x, type, alternative="greater", prec, delta,
         steps, decreasing=FALSE, verbose=FALSE, digits, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>"rma.uni"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character string to specify the type of selection model. Possible options are <code>"beta"</code>, <code>"halfnorm"</code>, <code>"negexp"</code>, <code>"logistic"</code>, <code>"power"</code>, <code>"negexppow"</code>, <code>"stepfun"</code>, <code>"trunc"</code>, and <code>"truncest"</code>. Can be abbreviated. See ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>character string to specify the sidedness of the hypothesis when testing the observed outcomes. Possible options are <code>"greater"</code> (the default), <code>"less"</code>, or <code>"two.sided"</code>. Can be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prec</code></td>
<td>
<p>optional character string to specify the measure of precision (only relevant for selection models that can incorporate this into the selection function). Possible options are <code>"sei"</code>, <code>"vi"</code>, <code>"ninv"</code>, or <code>"sqrtninv"</code>. See ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>optional numeric vector (of the same length as the number of selection model parameters) to fix the corresponding \(\delta\) value(s). A \(\delta\) value can be fixed by setting the corresponding element of this argument to the desired value. A \(\delta\) value will be estimated if the corresponding element is set equal to <code>NA</code>. See ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>numeric vector of one or more values that can or must be specified for certain selection functions. See ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>logical to specify whether the \(\delta\) values in a step function selection model must be a monotonically decreasing function of the p-values (the default is <code>FALSE</code>). Only relevant when <code>type="stepfun"</code>. See ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical to specify whether output should be generated on the progress of the model fitting (the default is <code>FALSE</code>). Can also be an integer. Values &gt; 1 generate more verbose output. See ‘Note’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>optional integer to specify the number of decimal places to which the printed results should be rounded. If unspecified, the default is to take the value from the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>optional list of control values for the estimation algorithm. See ‘Note’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Selection models are a general class of models that attempt to model the process by which the studies included in a meta-analysis may have been influenced by some form of publication bias. If a particular selection model is an adequate approximation for the underlying selection process, then the model provides estimates of the parameters of interest (e.g., the average true outcome and the amount of heterogeneity in the true outcomes) that are ‘corrected’ for this selection process (i.e., they are estimates of the parameters in the population of studies before any selection has taken place). The present function fits a variety of such selection models. To do so, one should pass an object fitted with the <code>rma.uni</code> function to the first argument. The model that will then be fitted is of the same form as the original model combined with the specific selection model chosen (see below for possible options). For example, if the original model was a random-effects model, then a random-effects selection model will be fitted. Similarly, if the original model included moderators, then they will also be accounted for in the selection model fitted. Model fitting is done via maximum likelihood (ML) estimation over the fixed- and random-effects parameters (e.g., \(\mu\) and \(\tau^2\) in a random-effects model) and the selection model parameters.
</p>
<p>Argument <code>type</code> determines the specific type of selection model that should be fitted. Many selection models are based on the idea that selection may haven taken place based on the p-values of the studies. In particular, let \(y_i\) and \(v_i\) denote the observed outcome and the corresponding sampling variance of the \(i\textrm{th}\) study. Then \(z_i = y_i / \sqrt{v_i}\) is the (Wald-type) test statistic for testing the null hypothesis \(\mbox{H}_0{:}\; \theta_i = 0\) and \(p_i = 1 - \Phi(z_i)\) (if <code>alternative="greater"</code>), \(p_i = \Phi(z_i)\) (if <code>alternative="less"</code>), or \(p_i = 2(1 - \Phi(|z_i|))\) (if <code>alternative="two.sided"</code>) the corresponding (one- or two-sided) p-value, where \(\Phi()\) denotes the cumulative distribution function of a standard normal distribution. Finally, let \(w(p_i)\) denote some function that specifies the relative likelihood of selection given the p-value of a study.
</p>
<p>If \(w(p_i) &gt; w(p_{i'})\) when \(p_i &lt; p_{i'}\) (i.e., \(w(p_i)\) is larger for smaller p-values), then <code>alternative="greater"</code> implies selection in favor of increasingly significant positive outcomes, <code>alternative="less"</code> implies selection in favor of increasingly significant negative outcomes, and <code>alternative="two.sided"</code> implies selection in favor of increasingly significant outcomes regardless of their direction.
</p>


<h4>Beta Selection Model</h4>

<p>When <code>type="beta"</code>, the function can be used to fit the ‘beta selection model’ by Citkowicz and Vevea (2017). For this model, the selection function is given by \[w(p_i) = p_i^{\delta_1 - 1} \times (1 - p_i)^{\delta_2 - 1}\] where \(\delta_1 &gt; 0\) and \(\delta_2 &gt; 0\). The null hypothesis \(\mbox{H}_0{:}\; \delta_1 = \delta_2 = 1\) represents the case where there is no selection according to the model. The figure below illustrates with some examples how the relative likelihood of selection can depend on the p-value for various combinations of \(\delta_1\) and \(\delta_2\). Note that the model allows for a non-monotonic selection function.
</p>
<p><img src="../help/figures/selmodel-beta.png" width="600" alt="selmodel-beta.png"></p>



<h4>Half-Normal, Negative-Exponential, Logistic, and Power Selection Models</h4>

<p>Preston et al. (2004) suggested the first three of the following selection functions:
</p>

<table>
<tr>
<td style="text-align: left;">
      <b>name</b>          </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <b><code>type</code></b> </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <b>selection function</b> </td>
</tr>
<tr>
<td style="text-align: left;">
      half-normal          </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code>"halfnorm"</code>  </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> \(w(p_i) = \exp(-\delta \times p_i^2)\) </td>
</tr>
<tr>
<td style="text-align: left;">
      negative-exponential </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code>"negexp"</code>    </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> \(w(p_i) = \exp(-\delta \times p_i)\) </td>
</tr>
<tr>
<td style="text-align: left;">
      logistic             </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code>"logistic"</code>  </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> \(w(p_i) = 2 \times \exp(-\delta \times p_i) / (1 + \exp(-\delta \times p_i))\) </td>
</tr>
<tr>
<td style="text-align: left;">
      power                </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code>"power"</code>     </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> \(w(p_i) = (1-p_i)^\delta\)</td>
</tr>
</table>
<p>The power selection model is added here as it has similar properties as the models suggested by Preston et al. (2004). For all models, assume \(\delta \ge 0\), so that all functions imply a monotonically decreasing relationship between the p-value and the selection probability. For all functions, \(\mbox{H}_0{:}\; \delta = 0\) implies no selection. The figure below shows the relative likelihood of selection as a function of the p-value for \(\delta = 0\) and for the various selection functions when \(\delta = 6\).
</p>
<p><img src="../help/figures/selmodel-preston.png" width="600" alt="selmodel-preston.png"></p>
<p>Here, these functions are extended to allow for the possibility that \(w(p_i) = 1\) for p-values below a certain significance threshold denoted by \(\alpha\) (e.g., to model the case that the relative likelihood of selection is equally high for all significant studies but decreases monotonically for p-values above the significance threshold). To fit such a selection model, one should specify the \(\alpha\) value (with \(0 &lt; \alpha &lt; 1\)) via the <code>steps</code> argument. There should be at least one observed p-value below and one observed p-value above the chosen threshold to fit these models. The figure below shows some examples of the relative likelihood of selection when <code>steps=.05</code>.
</p>
<p><img src="../help/figures/selmodel-preston-step.png" width="600" alt="selmodel-preston-step.png"></p>
<p>Preston et al. (2004) also suggested selection functions where the relatively likelihood of selection not only depends on the p-value, but also the precision (e.g., standard error) of the estimate (if two studies have similar p-values, it may be plausible to assume that the larger / more precise study has a higher probability of selection). These selection functions (plus the corresponding power function) are given by:
</p>

<table>
<tr>
<td style="text-align: left;">
      <b>name</b>          </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <b><code>type</code></b> </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <b>selection function</b> </td>
</tr>
<tr>
<td style="text-align: left;">
      half-normal          </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code>"halfnorm"</code>  </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> \(w(p_i) = \exp(-\delta \times \mathrm{prec}_i \times p_i^2)\) </td>
</tr>
<tr>
<td style="text-align: left;">
      negative-exponential </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code>"negexp"</code>    </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> \(w(p_i) = \exp(-\delta \times \mathrm{prec}_i \times p_i)\) </td>
</tr>
<tr>
<td style="text-align: left;">
      logistic             </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code>"logistic"</code>  </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> \(w(p_i) = 2 \times \exp(-\delta \times \mathrm{prec}_i \times p_i) / (1 + \exp(-\delta \times \mathrm{prec}_i \times p_i))\) </td>
</tr>
<tr>
<td style="text-align: left;">
      power                </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> <code>"power"</code>     </td>
<td style="text-align: left;">   </td>
<td style="text-align: left;"> \(w(p_i) = (1-p_i)^{\delta \times \mathrm{prec}_i}\)</td>
</tr>
</table>
<p>where \(\mathrm{prec}_i = \sqrt{v_i}\) (i.e., the standard error of the \(i\textrm{th}\) study) according to Preston et al. (2004). Here, this idea is generalized to allow the user to specify the specific measure of precision to use (via the <code>prec</code> argument). Possible options are:
</p>

<ul>
<li> <p><code>prec="sei"</code> for the standard errors,
</p>
</li>
<li> <p><code>prec="vi"</code> for the sampling variances,
</p>
</li>
<li> <p><code>prec="ninv"</code> for the inverse of the sample sizes,
</p>
</li>
<li> <p><code>prec="sqrtninv"</code> for the inverse square root of the sample sizes.
</p>
</li>
</ul>
<p>Using some function of the sample sizes as a measure of precision is only possible when information about the sample sizes is actually stored within the object passed to the <code>selmodel</code> function. See ‘Note’.
</p>
<p>Note that \(\mathrm{prec}_i\) is really a measure of imprecision (with higher values corresponding to lower precision). Also, regardless of the specific measure chosen, the values are actually rescaled with \(\mathrm{prec}_i = \mathrm{prec}_i / \max(\mathrm{prec}_i)\) inside of the function, such that \(\mathrm{prec}_i = 1\) for the least precise study and \(\mathrm{prec}_i &lt; 1\) for the remaining studies (the rescaling does not actually change the fit of the model, it only helps to improve the stability of model fitting algorithm). The figure below shows some examples of the relative likelihood of selection using these selection functions for two different precision values (note that lower values of \(\mathrm{prec}\) lead to a higher likelihood of selection).
</p>
<p><img src="../help/figures/selmodel-preston-prec.png" width="600" alt="selmodel-preston-prec.png"></p>
<p>One can also use the <code>steps</code> argument as described above in combination with these selection functions (studies with p-values below the chosen threshold then have \(w(p_i) = 1\) regardless of their exact p-value or precision).
</p>



<h4>Negative Exponential Power Selection Model</h4>

<p>As an extension of the half-normal and negative-exponential models, one can also choose <code>type="negexppow"</code> for a ‘negative exponential power selection model’. The selection function for this model is given by \[w(p_i) = \exp(-\delta_1 \times p_i^{1/\delta_2})\] where \(\delta_1 \ge 0\) and \(\delta_2 \ge 0\) (see Begg &amp; Mazumdar, 1994, although here a different parameterization is used, such that increasing \(\delta_2\) leads to more severe selection). The figure below shows some examples of this selection function when holding \(\delta_1\) constant while increasing \(\delta_2\).
</p>
<p><img src="../help/figures/selmodel-negexppow.png" width="600" alt="selmodel-negexppow.png"></p>
<p>This model affords greater flexibility in the shape of the selection function, but requires the estimation of the additional power parameter (the half-normal and negative-exponential models are therefore special cases when fixing \(\delta_2\) to 0.5 or 1, respectively). \(\mbox{H}_0{:}\; \delta_1 = 0\) again implies no selection, but so does \(\mbox{H}_0{:}\; \delta_2 = 0\).
</p>
<p>One can again use the <code>steps</code> argument to specify a single significance threshold, \(\alpha\), so that \(w(p_i) = 1\) for p-values below this threshold and otherwise \(w(p_i)\) follows the selection function as given above. One can also use the <code>prec</code> argument to specify a measure of precision in combination with this model, which leads to the selection function \[w(p_i) = \exp(-\delta_1 \times \mathrm{prec}_i \times p_i^{1/\delta_2})\] and hence is the logical extension of the negative exponential power selection model that also incorporates some measure of precision into the selection process.
</p>



<h4>Step Function Selection Models</h4>

<p>When <code>type="stepfun"</code>, the function can be used to fit ‘step function models’ as described by Iyengar and Greenhouse (1988), Hedges (1992), Vevea and Hedges (1995), Vevea and Woods (2005), and others. For these models, one must specify one or multiple values via the <code>steps</code> argument, which define intervals in which the relative likelihood of selection is constant. Let \[\alpha_1 &lt; \alpha_2 &lt; \ldots &lt; \alpha_c\] denote these cutpoints sorted in increasing order, with the constraint that \(\alpha_c = 1\) (if the highest value specified via <code>steps</code> is not 1, the function will automatically add this cutpoint), and define \(\alpha_0 = 0\). The selection function is then given by \(w(p_i) = \delta_j\) for \(\alpha_{j-1} &lt; p_i \le \alpha_j\) where \(\delta_j \ge 0\). To make the model identifiable, we set \(\delta_1 = 1\). The \(\delta_j\) values therefore denote the likelihood of selection in the various intervals relative to the interval for p-values between 0 and \(\alpha_1\). Hence, the null hypothesis \(\mbox{H}_0{:}\; \delta_j = 1\) for \(j = 1, \ldots, c\) implies no selection.
</p>
<p>For example, if <code>steps=c(.05, .10, .50, 1)</code>, then \(\delta_2\) is the likelihood of selection for p-values between .05 and .10, \(\delta_3\) is the likelihood of selection for p-values between .10 and .50, and \(\delta_4\) is the likelihood of selection for p-values between .50 and 1 relative to the likelihood of selection for p-values between 0 and .05. The figure below shows the corresponding selection function for some arbitrarily chosen \(\delta_j\) values.
</p>
<p><img src="../help/figures/selmodel-stepfun.png" width="600" alt="selmodel-stepfun.png"></p>
<p>There should be at least one observed p-value within each interval to fit this model. If there are no p-values between \(\alpha_0 = 0\) and \(\alpha_1\) (i.e., within the first interval for which \(\delta_1 = 1\)), then estimates of \(\delta_2, \ldots, \delta_c\) will try to drift to infinity. If there are no p-values between \(\alpha_{j-1}\) and \(\alpha_j\) for \(j = 2, \ldots, c\), then \(\delta_j\) will try to drift to zero. In either case, results should be treated with great caution. A common practice is then to collapse and/or adjust the intervals until all intervals contain at least one study. By setting <code>ptable=TRUE</code>, the function just returns the p-value table and does not attempt any model fitting.
</p>
<p>Note that when <code>alternative="greater"</code> or <code>alternative="less"</code> (i.e., when we assume that the relative likelihood of selection is not only related to the p-values of the studies, but also the directionality of the outcomes), then it would usually make sense to divide conventional levels of significance (e.g., .05) by 2 before passing these values to the <code>steps</code> argument. For example, if we think that studies were selected for positive outcomes that are significant at two-tailed \(\alpha = .05\), then we should use <code>alternative="greater"</code> in combination with <code>steps=c(.025, 1)</code>.
</p>
<p>When specifying a single cutpoint in the context of a random-effects model (typically <code>steps=c(.025, 1)</code> with either <code>alternative="greater"</code> or <code>alternative="less"</code>), this model is sometimes called the ‘three-parameter selection model’ (3PSM), corresponding to the parameters \(\mu\), \(\tau^2\), and \(\delta_2\) (e.g., Carter et al., 2019; McShane et al., 2016; Pustejovsky &amp; Rodgers, 2019). The same idea but in the context of an equal-effects model was also described by Iyengar and Greenhouse (1988).
</p>
<p>Note that \(\delta_j\) (for \(j = 2, \ldots, c\)) can be larger than 1 (implying a greater likelihood of selection for p-values in the corresponding interval relative to the first interval). With <code>control=list(delta.max=1)</code>, one can enforce that the likelihood of selection for p-values above the first cutpoint can never be greater than the likelihood of selection for p-values below it. This constraint should be used with caution, as it may force \(\delta_j\) estimates to fall on the boundary of the parameter space. Alternatively, one can set <code>decreasing=TRUE</code>, in which case the \(\delta_j\) values must be a monotonically decreasing function of the p-values (which also forces \(\delta_j \le 1\)). This feature should be considered experimental.
</p>
<p>One of the challenges when fitting this model with many cutpoints is the large number of parameters that need to be estimated (which is especially problematic when the number of studies is small). An alternative approach suggested by Vevea and Woods (2005) is to fix the \(\delta_j\) values to some a priori chosen values instead of estimating them. One can then conduct a sensitivity analysis by examining the results (e.g., the estimates of \(\mu\) and \(\tau^2\) in a random-effects model) for a variety of different sets of \(\delta_j\) values (reflecting more or less severe forms of selection). This can be done by specifying the \(\delta_j\) values via the <code>delta</code> argument. Table 1 in Vevea and Woods (2005) provides some illustrative examples of moderate and severe selection functions for one- and two-tailed selection. The code below creates a data frame that contains these functions.
</p>
<pre>tab &lt;- data.frame(
  steps = c(0.005, 0.01, 0.05, 0.10, 0.25, 0.35, 0.50, 0.65, 0.75, 0.90, 0.95, 0.99, 0.995, 1),
  delta.mod.1 = c(1, 0.99, 0.95, 0.80, 0.75, 0.65, 0.60, 0.55, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50),
  delta.sev.1 = c(1, 0.99, 0.90, 0.75, 0.60, 0.50, 0.40, 0.35, 0.30, 0.25, 0.10, 0.10, 0.10, 0.10),
  delta.mod.2 = c(1, 0.99, 0.95, 0.90, 0.80, 0.75, 0.60, 0.60, 0.75, 0.80, 0.90, 0.95, 0.99, 1.00),
  delta.sev.2 = c(1, 0.99, 0.90, 0.75, 0.60, 0.50, 0.25, 0.25, 0.50, 0.60, 0.75, 0.90, 0.99, 1.00))</pre>
<p>The figure below shows the corresponding selection functions.
</p>
<p><img src="../help/figures/selmodel-stepfun-fixed.png" width="600" alt="selmodel-stepfun-fixed.png"></p>
<p>These four functions are “merely examples and should not be regarded as canonical” (Vevea &amp; Woods, 2005).
</p>



<h4>Truncated Distribution Selection Model</h4>

<p>When <code>type="trunc"</code>, the model assumes that the relative likelihood of selection depends not on the p-value but on the value of the observed effect size or outcome of a study. Let \(y_c\) denote a single cutpoint (which can be specified via argument <code>steps</code> and which is assumed to be 0 when unspecified). Let \[w(y_i) = \left\{ \begin{matrix} \; 1 &amp; \textrm{if} \; y_i &gt; y_c \\ \; \delta_1 &amp; \textrm{if} \; y_i \le y_c \\ \end{matrix} \right.\] denote the selection function when <code>alternative="greater"</code> and \[w(y_i) = \left\{ \begin{matrix} \; 1 &amp; \textrm{if} \; y_i &lt; y_c \\ \; \delta_1 &amp; \textrm{if} \; y_i \ge y_c \\ \end{matrix} \right.\] when <code>alternative="less"</code> (note that <code>alternative="two.sided"</code> is not an option for this type of selection model). Therefore, when <code>alternative="greater"</code>, \(\delta_1\) denotes the likelihood of selection for observed effect sizes or outcomes that fall below the chosen cutpoint relative to those that fall above it (and vice-versa when <code>alternative="less"</code>). Hence, the null hypothesis \(\mbox{H}_0{:}\; \delta_1 = 1\) implies no selection.
</p>
<p>In principle, it is also possible to obtain a maximum likelihood estimate of the cutpoint. For this, one can set <code>type="truncest"</code>, in which case the selection function is given by \[w(y_i) = \left\{ \begin{matrix} \; 1 &amp; \textrm{if} \; y_i &gt; \delta_2 \\ \; \delta_1 &amp; \textrm{if} \; y_i \le \delta_2 \\ \end{matrix} \right.\] when <code>alternative="greater"</code> and analogously when <code>alternative="less"</code>. Therefore, instead of specifying the cutpoint via the <code>steps</code> argument, it is estimated via \(\delta_2\). Note that estimating both \(\delta_1\) and \(\delta_2\) simultaneously is typically very difficult (the likelihood surface is often quite rugged with multiple local optima) and will require a large number of studies. The implementation of this selection function should be considered experimental.
</p>
<p>Models similar to those described above were proposed by Rust et al. (1990) and Formann (2008), but made various simplifying assumptions (e.g., Formann assumed \(\delta_1 = 0\)) and did not account for the heteroscedastic nature of the sampling variances of the observed effect sizes or outcomes, nor did they allow for heterogeneity in the true effects or the influence of moderators.
</p>



<h3>Value</h3>

<p>An object of class <code>c("rma.uni","rma")</code>. The object is a list containing the same components as a regular <code>c("rma.uni","rma")</code> object, but the parameter estimates are based on the selection model. Most importantly, the following elements are modified based on the selection model:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>estimated coefficients of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>standard errors of the coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zval</code></td>
<td>
<p>test statistics of the coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval</code></td>
<td>
<p>corresponding p-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.lb</code></td>
<td>
<p>lower bound of the confidence intervals for the coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.ub</code></td>
<td>
<p>upper bound of the confidence intervals for the coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vb</code></td>
<td>
<p>variance-covariance matrix of the estimated coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2</code></td>
<td>
<p>estimated amount of (residual) heterogeneity. Always <code>0</code> when <code>method="EE"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.tau2</code></td>
<td>
<p>standard error of the estimated amount of (residual) heterogeneity.</p>
</td>
</tr>
</table>
<p>In addition, the object contains the following additional elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>estimated selection model parameter(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.delta</code></td>
<td>
<p>corresponding standard error(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zval.delta</code></td>
<td>
<p>corresponding test statistic(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval.delta</code></td>
<td>
<p>corresponding p-value(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.lb.delta</code></td>
<td>
<p>lower bound of the confidence intervals for the parameter(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.ub.delta</code></td>
<td>
<p>upper bound of the confidence intervals for the parameter(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LRT</code></td>
<td>
<p>test statistic of the likelihood ratio test for the selection model parameter(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LRTdf</code></td>
<td>
<p>degrees of freedom for the likelihood ratio test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LRTp</code></td>
<td>
<p>p-value for the likelihood ratio test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LRT.tau2</code></td>
<td>
<p>test statistic of the likelihood ratio test for testing \(\mbox{H}_0{:}\; \tau^2 = 0\) (<code>NA</code> when fitting an equal-effects model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LRTp.tau2</code></td>
<td>
<p>p-value for the likelihood ratio test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ptable</code></td>
<td>
<p>frequency table for the observed p-values falling into the intervals defined by the <code>steps</code> argument (<code>NA</code> when <code>steps</code> is not specified).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>some additional elements/values.</p>
</td>
</tr>
</table>
<h3>Methods</h3>

<p>The results of the fitted model are formatted and printed with the <code>print</code> function. The estimated selection function can be drawn with <code>plot</code>.
</p>
<p>The <code>profile</code> function can be used to obtain a plot of the log-likelihood as a function of \(\tau^2\) and/or the selection model parameter(s) of the model. Corresponding confidence intervals can be obtained with the <code>confint</code> function.
</p>


<h3>Note</h3>

<p>Model fitting is done via numerical optimization over the model parameters. By default, <code>optim</code> with method <code>"BFGS"</code> is used for the optimization. One can also chose a different optimizer from <code>optim</code> via the <code>control</code> argument (e.g., <code>control=list(optimizer="Nelder-Mead")</code>). Besides one of the methods from <code>optim</code>, one can also choose the quasi-Newton algorithm in <code>nlminb</code>, one of the optimizers from the <code>minqa</code> package (i.e., <code>uobyqa</code>, <code>newuoa</code>, or <code>bobyqa</code>), one of the (derivative-free) algorithms from the <code>nloptr</code> package, the Newton-type algorithm implemented in <code>nlm</code>, the various algorithms implemented in the <code>dfoptim</code> package (<code>hjk</code> for the Hooke-Jeeves, <code>nmk</code> for the Nelder-Mead, and <code>mads</code> for the Mesh Adaptive Direct Searches algorithm), the quasi-Newton type optimizers <code>ucminf</code> and <code>lbfgsb3c</code> and the subspace-searching simplex algorithm <code>subplex</code> from the packages of the same name, the Barzilai-Borwein gradient decent method implemented in <code>BBoptim</code>, or the parallelized version of the L-BFGS-B algorithm implemented in <code>optimParallel</code> from the package of the same name.
</p>
<p>The optimizer name must be given as a character string (i.e., in quotes). Additional control parameters can be specified via the <code>control</code> argument (e.g., <code>control=list(maxit=1000, reltol=1e-8)</code>). For <code>nloptr</code>, the default is to use the BOBYQA implementation from that package with a relative convergence criterion of <code>1e-8</code> on the function value (i.e., log-likelihood), but this can be changed via the <code>algorithm</code> and <code>ftop_rel</code> arguments (e.g., <code>control=list(optimizer="nloptr", algorithm="NLOPT_LN_SBPLX", ftol_rel=1e-6)</code>). For <code>optimParallel</code>, the control argument <code>ncpus</code> can be used to specify the number of cores to use for the parallelization (e.g., <code>control=list(optimizer="optimParallel", ncpus=2)</code>). With <code>parallel::detectCores()</code>, one can check on the number of available cores on the local machine.
</p>
<p>All selection models (except for <code>type="stepfun"</code>, <code>type="trunc"</code>, and <code>type="truncest"</code>) require repeated evaluations of an integral, which is done via adaptive quadrature as implemented in the <code>integrate</code> function. One can adjust the arguments of the <code>integrate</code> function via control element <code>intCtrl</code>, which is a list of named arguments (e.g., <code>control = list(intCtrl = list(rel.tol=1e-4, subdivisions=100))</code>).
</p>
<p>The starting values for the fixed effects, the \(\tau^2\) value (only relevant in random/mixed-effects selection models), and the \(\delta\) parameter(s) are chosen automatically by the function, but one can also set the starting values manually via the <code>control</code> argument by specifying a vector of the appropriate length for <code>beta.init</code>, a single value for <code>tau2.init</code>, and a vector of the appropriate length for <code>delta.init</code>.
</p>
<p>By default, the \(\delta\) parameter(s) are constrained to a certain range, which improves the stability of the optimization algorithm. For all models, the maximum is set to <code>100</code> and the minimum to <code>0</code> (except for <code>type="beta"</code>, where the minimum for both parameters is <code>1e-5</code>, and when <code>type="stepfun"</code> with <code>decreasing=TRUE</code>, in which case the maximum is set to 1). These defaults can be changed via the <code>control</code> argument by specifying a scalar or a vector of the appropriate length for <code>delta.min</code> and/or <code>delta.max</code>. For example, <code>control=list(delta.max=Inf)</code> lifts the upper bound. Note that when a parameter estimate drifts close to its imposed bound, a warning will be issued.
</p>
<p>A difficulty with fitting the beta selection model (i.e., <code>type="beta"</code>) is the behavior of \(w(p_i)\) when \(p_i = 0\) or \(p_i = 1\). When \(\delta_1 &lt; 1\) or \(\delta_2 &lt; 1\), then this leads to selection weights equal to infinity, which causes problems when computing the likelihood function. Following Citkowicz and Vevea (2017), this problem can be avoided by censoring p-values too close to 0 or 1. The specific censoring point can be set via the <code>pval.min</code> element of the <code>control</code> argument. The default for this selection model is <code>control=list(pval.min=1e-5)</code>. A similar issue arises for the power selection model (i.e., <code>type="power"</code>) when \(p_i = 1\). Again, <code>pval.min=1e-5</code> is used to circumvent this issue. For all other selection models, the default is <code>pval.min=0</code>.
</p>
<p>The variance-covariance matrix corresponding to the estimates of the fixed effects, the \(\tau^2\) value (only relevant in random/mixed-effects selection models), and the \(\delta\) parameter(s) is obtained by inverting the Hessian, which is numerically approximated using the <code>hessian</code> function from the <code>numDeriv</code> package. This may fail, leading to <code>NA</code> values for the standard errors and hence test statistics, p-values, and confidence interval bounds. One can set control argument <code>hessianCtrl</code> to a list of named arguments to be passed on to the <code>method.args</code> argument of the <code>hessian</code> function (the default is <code>control=list(hessianCtrl=list(r=6))</code>). One can also set <code>control=list(hesspack="pracma")</code> in which case the <code>hessian</code> function from the <code>pracma</code> package is used instead for approximating the Hessian. When \(\tau^2\) is estimated to be smaller than either \(10^{-4}\) or \(\min(v_1, \ldots, v_k)/10\) (where \(v_i\) denotes the sampling variances of the \(i\textrm{th}\) study), then \(\tau^2\) is effectively treated as zero for computing the standard errors (which helps to avoid numerical problems in approximating the Hessian). This cutoff can be adjusted via the <code>tau2tol</code> control argument (e.g., <code>control=list(tau2tol=0)</code> to switch off this behavior). Similarly, for <code>type="beta"</code> and <code>type="stepfun"</code>, \(\delta\) estimates below \(10^{-4}\) are treated as effectively zero for computing the standard errors. In this case, the corresponding standard errors are <code>NA</code>. This cutoff can be adjusted via the <code>deltatol</code> control argument (e.g., <code>control=list(deltatol=0)</code> to switch off this behavior).
</p>
<p>Information on the progress of the optimization algorithm can be obtained by setting <code>verbose=TRUE</code> (this won't work when using parallelization). One can also set <code>verbose</code> to an integer (<code>verbose=2</code> yields even more information and <code>verbose=3</code> also show the progress visually by drawing the selection function as the optimization proceeds).
</p>
<p>For selection functions where the <code>prec</code> argument is relevant, using a function of the sample sizes as the measure of precision (i.e., <code>prec="ninv"</code> or <code>prec="sqrtninv"</code>) is only possible when information about the sample sizes is actually stored within the object passed to the <code>selmodel</code> function. That should automatically be the case when the observed effect sizes or outcomes were computed with the <code>escalc</code> function or when the observed effect sizes or outcomes were computed within the model fitting function. On the other hand, this will not be the case when <code>rma.uni</code> was used together with the <code>yi</code> and <code>vi</code> arguments and the <code>yi</code> and <code>vi</code> values were <em>not</em> computed with <code>escalc</code>. In that case, it is still possible to pass information about the sample sizes to the <code>rma.uni</code> function (e.g., use <code>rma.uni(yi, vi, ni=ni, data=dat)</code>, where data frame <code>dat</code> includes a variable called <code>ni</code> with the sample sizes).
</p>
<p>Finally, the automatic rescaling of the chosen precision measure can be switched off by setting <code>scaleprec=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Viechtbauer <a href="mailto:wvb@metafor-project.org">wvb@metafor-project.org</a> <a href="https://www.metafor-project.org">https://www.metafor-project.org</a>
</p>


<h3>References</h3>

<p>Begg, C. B., &amp; Mazumdar, M. (1994). Operating characteristics of a rank correlation test for publication bias. <em>Biometrics</em>, <b>50</b>(4), 1088–1101. <code style="white-space: pre;">⁠https://doi.org/10.2307/2533446⁠</code>
</p>
<p>Carter, E. C., Schönbrodt, F. D., Gervais, W. M., &amp; Hilgard, J. (2019). Correcting for bias in psychology: A comparison of meta-analytic methods. <em>Advances in Methods and Practices in Psychological Science</em>, <b>2</b>(2), 115–144. <code style="white-space: pre;">⁠https://doi.org/10.1177/2515245919847196⁠</code>
</p>
<p>Citkowicz, M., &amp; Vevea, J. L. (2017). A parsimonious weight function for modeling publication bias. <em>Psychological Methods</em>, <b>22</b>(1), 28–41. <code style="white-space: pre;">⁠https://doi.org/10.1037/met0000119⁠</code>
</p>
<p>Formann, A. K. (2008). Estimating the proportion of studies missing for meta-analysis due to publication bias. <em>Contemporary Clinical Trials</em>, <b>29</b>(5), 732–739. <code style="white-space: pre;">⁠https://doi.org/10.1016/j.cct.2008.05.004⁠</code>
</p>
<p>Hedges, L. V. (1992). Modeling publication selection effects in meta-analysis. <em>Statistical Science</em>, <b>7</b>(2), 246–255. <code style="white-space: pre;">⁠https://doi.org/10.1214/ss/1177011364⁠</code>
</p>
<p>Iyengar, S., &amp; Greenhouse, J. B. (1988). Selection models and the file drawer problem. <em>Statistical Science</em>, <b>3</b>(1), 109–117. <code style="white-space: pre;">⁠https://doi.org/10.1214/ss/1177013012⁠</code>
</p>
<p>McShane, B. B., Bockenholt, U., &amp; Hansen, K. T. (2016). Adjusting for publication bias in meta-analysis: An evaluation of selection methods and some cautionary notes. <em>Perspectives on Psychological Science</em>, <b>11</b>(5), 730–749. <code style="white-space: pre;">⁠https://doi.org/10.1177/1745691616662243⁠</code>
</p>
<p>Preston, C., Ashby, D., &amp; Smyth, R. (2004). Adjusting for publication bias: Modelling the selection process. <em>Journal of Evaluation in Clinical Practice</em>, <b>10</b>(2), 313–322. <code style="white-space: pre;">⁠https://doi.org/10.1111/j.1365-2753.2003.00457.x⁠</code>
</p>
<p>Pustejovsky, J. E., &amp; Rodgers, M. A. (2019). Testing for funnel plot asymmetry of standardized mean differences. <em>Research Synthesis Methods</em>, <b>10</b>(1), 57–71. <code style="white-space: pre;">⁠https://doi.org/10.1002/jrsm.1332⁠</code>
</p>
<p>Rust, R. T., Lehmann, D. R. &amp; Farley, J. U. (1990). Estimating publication bias in meta-analysis. <em>Journal of Marketing Research</em>, <b>27</b>(2), 220–226. <code style="white-space: pre;">⁠https://doi.org/10.1177/002224379002700209⁠</code>
</p>
<p>Vevea, J. L., &amp; Hedges, L. V. (1995). A general linear model for estimating effect size in the presence of publication bias. <em>Psychometrika</em>, <b>60</b>(3), 419–435. <code style="white-space: pre;">⁠https://doi.org/10.1007/BF02294384⁠</code>
</p>
<p>Vevea, J. L., &amp; Woods, C. M. (2005). Publication bias in research synthesis: Sensitivity analysis using a priori weight functions. <em>Psychological Methods</em>, <b>10</b>(4), 428–443. <code style="white-space: pre;">⁠https://doi.org/10.1037/1082-989X.10.4.428⁠</code>
</p>


<h3>See Also</h3>

<p><code>rma.uni</code> for the function to fit models which can be extended with selection models.
</p>


<h3>Examples</h3>

<pre><code class="language-R">############################################################################

### example from Citkowicz and Vevea (2017) for beta selection model

# copy data into 'dat' and examine data
dat &lt;- dat.baskerville2012
dat

# fit random-effects model
res &lt;- rma(smd, se^2, data=dat, method="ML", digits=3)
res

# funnel plot
funnel(res, ylim=c(0,0.6), xlab="Standardized Mean Difference")

# fit beta selection model
## Not run: 
sel &lt;- selmodel(res, type="beta")
sel

# plot the selection function
plot(sel, ylim=c(0,40))

## End(Not run)

# fit mixed-effects meta-regression model with 'blind' dummy variable as moderator
res &lt;- rma(smd, se^2, data=dat, mods = ~ blind, method="ML", digits=3)
res

# predicted average effect for studies that do not and that do use blinding
predict(res, newmods=c(0,1))

# fit beta selection model
## Not run: 
sel &lt;- selmodel(res, type="beta")
sel
predict(sel, newmods=c(0,1))

## End(Not run)

############################################################################

### example from Preston et al. (2004)

# copy data into 'dat' and examine data
dat &lt;- dat.hahn2001
dat

### meta-analysis of (log) odds rations using the Mantel-Haenszel method
res &lt;- rma.mh(measure="OR", ai=ai, n1i=n1i, ci=ci, n2i=n2i, data=dat, digits=2, slab=study)
res

# calculate log odds ratios and corresponding sampling variances
dat &lt;- escalc(measure="OR", ai=ai, n1i=n1i, ci=ci, n2i=n2i, data=dat, drop00=TRUE)
dat

# fit equal-effects model
res &lt;- rma(yi, vi, data=dat, method="EE")

# predicted odds ratio (with 95% CI)
predict(res, transf=exp, digits=2)

# funnel plot
funnel(res, atransf=exp, at=log(c(0.01,0.1,1,10,100)), ylim=c(0,2))

# fit half-normal, negative-exponential, logistic, and power selection models
## Not run: 
sel1 &lt;- selmodel(res, type="halfnorm", alternative="less")
sel2 &lt;- selmodel(res, type="negexp",   alternative="less")
sel3 &lt;- selmodel(res, type="logistic", alternative="less")
sel4 &lt;- selmodel(res, type="power",    alternative="less")

# plot the selection functions
plot(sel1)
plot(sel2, add=TRUE, col="blue")
plot(sel3, add=TRUE, col="red")
plot(sel4, add=TRUE, col="green")

# add legend
legend("topright", inset=0.02, lty="solid", lwd=2, col=c("black","blue","red","green"),
       legend=c("Half-normal", "Negative-exponential", "Logistic", "Power"))

# show estimates of delta (and corresponding SEs)
tab &lt;- data.frame(delta = c(sel1$delta, sel2$delta, sel3$delta, sel4$delta),
                  se    = c(sel1$se.delta, sel2$se.delta, sel3$se.delta, sel4$se.delta))
rownames(tab) &lt;- c("Half-normal", "Negative-exponential", "Logistic", "Power")
round(tab, 2)

# predicted odds ratios (with 95% CI)
predict(res,  transf=exp, digits=2)
predict(sel1, transf=exp, digits=2)
predict(sel2, transf=exp, digits=2)
predict(sel3, transf=exp, digits=2)
predict(sel4, transf=exp, digits=2)

## End(Not run)

# fit selection models including standard error as precision measure (note: using
# scaleprec=FALSE here since Preston et al. (2004) did not use the rescaling)
## Not run: 
sel1 &lt;- selmodel(res, type="halfnorm", prec="sei", alternative="less", scaleprec=FALSE)
sel2 &lt;- selmodel(res, type="negexp",   prec="sei", alternative="less", scaleprec=FALSE)
sel3 &lt;- selmodel(res, type="logistic", prec="sei", alternative="less", scaleprec=FALSE)
sel4 &lt;- selmodel(res, type="power",    prec="sei", alternative="less", scaleprec=FALSE)

# show estimates of delta (and corresponding SEs)
tab &lt;- data.frame(delta = c(sel1$delta, sel2$delta, sel3$delta, sel4$delta),
                  se    = c(sel1$se.delta, sel2$se.delta, sel3$se.delta, sel4$se.delta))
rownames(tab) &lt;- c("Half-normal", "Negative-exponential", "Logistic", "Power")
round(tab, 2)

# predicted odds ratio (with 95% CI)
predict(res,  transf=exp, digits=2)
predict(sel1, transf=exp, digits=2)
predict(sel2, transf=exp, digits=2)
predict(sel3, transf=exp, digits=2)
predict(sel4, transf=exp, digits=2)

## End(Not run)

############################################################################

### meta-analysis on the effect of environmental tobacco smoke on lung cancer risk

# copy data into 'dat' and examine data
dat &lt;- dat.hackshaw1998
dat

# fit random-effects model
res &lt;- rma(yi, vi, data=dat, method="ML")
res

# funnel plot
funnel(res, atransf=exp, at=log(c(0.25,0.5,1,2,4,8)), ylim=c(0,0.8))

# step function selection model
## Not run: 
sel &lt;- selmodel(res, type="stepfun", alternative="greater", steps=c(.025,.10,.50,1))
sel

# plot the selection function
plot(sel)

# truncated distribution selection model (with steps=0 by default)
sel &lt;- selmodel(res, type="trunc")
sel

## End(Not run)

############################################################################

### validity of student ratings example from Vevea &amp; Woods (2005)

# copy data into 'dat' and examine data
dat &lt;- dat.cohen1981
dat[c(1,4,5)]

# calculate r-to-z transformed correlations and corresponding sampling variances
dat &lt;- escalc(measure="ZCOR", ri=ri, ni=ni, data=dat[c(1,4,5)])
dat

# fit random-effects model
res &lt;- rma(yi, vi, data=dat, method="ML", digits=3)
res

# predicted average correlation (with 95% CI)
predict(res, transf=transf.ztor)

# funnel plot
funnel(res, ylim=c(0,0.4))

# selection functions from Vevea &amp; Woods (2005)
tab &lt;- data.frame(
   steps = c(0.005, 0.01, 0.05, 0.10, 0.25, 0.35, 0.50, 0.65, 0.75, 0.90, 0.95, 0.99, 0.995, 1),
   delta.mod.1 = c(1, 0.99, 0.95, 0.80, 0.75, 0.65, 0.60, 0.55, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50),
   delta.sev.1 = c(1, 0.99, 0.90, 0.75, 0.60, 0.50, 0.40, 0.35, 0.30, 0.25, 0.10, 0.10, 0.10, 0.10),
   delta.mod.2 = c(1, 0.99, 0.95, 0.90, 0.80, 0.75, 0.60, 0.60, 0.75, 0.80, 0.90, 0.95, 0.99, 1.00),
   delta.sev.2 = c(1, 0.99, 0.90, 0.75, 0.60, 0.50, 0.25, 0.25, 0.50, 0.60, 0.75, 0.90, 0.99, 1.00))

# apply step function model with a priori chosen selection weights
## Not run: 
sel &lt;- lapply(tab[-1], function(delta) selmodel(res, type="stepfun", steps=tab$steps, delta=delta))

# estimates (transformed correlation) and tau^2 values
sav &lt;- data.frame(estimate = round(c(res$beta, sapply(sel, function(x) x$beta)), 2),
                  varcomp  = round(c(res$tau2, sapply(sel, function(x) x$tau2)), 3))
sav

## End(Not run)

############################################################################
</code></pre>


</div>