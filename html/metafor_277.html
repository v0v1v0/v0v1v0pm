<div class="container">

<table style="width: 100%;"><tr>
<td>vif</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Variance Inflation Factors for 'rma' Objects</h2>

<h3>Description</h3>

<p>Function to compute (generalized) variance inflation factors (VIFs) for objects of class <code>"rma"</code>. <script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script></p>


<h3>Usage</h3>

<pre><code class="language-R">vif(x, ...)

## S3 method for class 'rma'
vif(x, btt, att, table=FALSE, reestimate=FALSE, sim=FALSE, progbar=TRUE,
    seed=NULL, parallel="no", ncpus=1, cl, digits, ...)

## S3 method for class 'vif.rma'
print(x, digits=x$digits, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>"rma"</code> (for <code>vif</code>) or <code>"vif.rma"</code> (for <code>print</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>btt</code></td>
<td>
<p>optional vector of indices (or list thereof) to specify a set of coefficients for which a generalized variance inflation factor (GVIF) should be computed. Can also be a string to <code>grep</code> for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>att</code></td>
<td>
<p>optional vector of indices (or list thereof) to specify a set of scale coefficients for which a generalized variance inflation factor (GVIF) should be computed. Can also be a string to <code>grep</code> for. Only relevant for location-scale models (see <code>rma.uni</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>table</code></td>
<td>
<p>logical to specify whether the VIFs should be added to the model coefficient table (the default is <code>FALSE</code>). Only relevant when <code>btt</code> (or <code>att</code>) is not specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reestimate</code></td>
<td>
<p>logical to specify whether the model should be reestimated when removing moderator variables from the model for computing a (G)VIF (the default is <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>logical to specify whether the distribution of each (G)VIF under independence should be simulated (the default is <code>FALSE</code>). Can also be an integer to specify how many values to simulate (when <code>sim=TRUE</code>, the default is <code>1000</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progbar</code></td>
<td>
<p>logical to specify whether a progress bar should be shown when <code>sim=TRUE</code> (the default is <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>optional value to specify the seed of the random number generator when <code>sim=TRUE</code> (for reproducibility).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>character string to specify whether parallel processing should be used (the default is <code>"no"</code>). For parallel processing, set to either <code>"snow"</code> or <code>"multicore"</code>. See ‘Note’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>integer to specify the number of processes to use in the parallel processing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>optional cluster to use if <code>parallel="snow"</code>. If unspecified, a cluster on the local machine is created for the duration of the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>optional integer to specify the number of decimal places to which the printed results should be rounded. If unspecified, the default is to take the value from the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function computes (generalized) variance inflation factors (VIFs) for meta-regression models. Hence, the model specified via argument <code>x</code> must include moderator variables (and more than one for this to be useful, as the VIF for a model with a single moderator variable will always be equal to 1).
</p>


<h4>VIFs for Individual Coefficients</h4>

<p>By default (i.e., if <code>btt</code> is not specified), VIFs are computed for the individual model coefficients.
</p>
<p>Let \(b_j\) denote the estimate of the \(j\textrm{th}\) model coefficient of a particular meta-regression model and \(\mbox{Var}[b_j]\) its variance (i.e., the corresponding diagonal element from the matrix obtained with the <code>vcov</code> function). Moreover, let \(b'_j\) denote the estimate of the same model coefficient if the other moderator variables in the model had <em>not</em> been included in the model and \(\mbox{Var}[b'_j]\) the corresponding variance. Then the VIF for the model coefficient is given by \[\mbox{VIF}[b_j] = \frac{\mbox{Var}[b_j]}{\mbox{Var}[b'_j]},\] which indicates the inflation in the variance of the estimated model coefficient due to potential collinearity of the \(j\textrm{th}\) moderator variable with the other moderator variables in the model. Taking the square root of a VIF gives the corresponding standard error inflation factor (SIF).
</p>



<h4>GVIFs for Sets of Coefficients</h4>

<p>If the model includes factors (coded in terms of multiple dummy variables) or other sets of moderator variables that belong together (e.g., for polynomials or cubic splines), one may want to examine how much the variance in all of the coefficients in the set is jointly impacted by collinearity with the other moderator variables in the model. For this, we can compute a generalized variance inflation factor (GVIF) (Fox &amp; Monette, 1992) by setting the <code>btt</code> argument equal to the indices of those coefficients for which the GVIF should be computed. The square root of a GVIF indicates the inflation in the confidence ellipse/(hyper)ellipsoid for the set of coefficients corresponding to the set due to collinearity. However, to make this value more directly comparable to SIFs (based on single coefficients), the function computes the generalized standard error inflation factor (GSIF) by raising the GVIF to the power of \(1/(2m)\) (where \(m\) denotes the number of coefficients in the set). One can also specify a list of indices/strings, in which case GVIFs/GSIFs of all list elements will be computed. See ‘Examples’.
</p>
<p>For location-scale models fitted with the <code>rma.uni</code> function, one can use the <code>att</code> argument in an analogous manner to specify the indices of the scale coefficients for which a GVIF should be computed.
</p>



<h4>Re-Estimating the Model</h4>

<p>The way the VIF is typically computed for a particular model coefficient (or a set thereof for a GVIF) makes use of some clever linear algebra to avoid having to re-estimate the model when removing the other moderator variables from the model. This speeds up the computations considerably. However, this assumes that the other moderator variables do not impact other aspects of the model, in particular the amount of residual heterogeneity (or, more generally, any variance/correlation components in a more complex model, such as those that can be fitted with the <code>rma.mv</code> function).
</p>
<p>For a more accurate (but slower) computation of each (G)VIF, one can set <code>reestimate=TRUE</code>, in which case the model is refitted to account for the impact that removal of the other moderator variables has on all aspects of the model. Note that refitting may fail, in which case the corresponding (G)VIF will be missing.
</p>



<h4>Interpreting the Size of (G)VIFs</h4>

<p>A large VIF value suggests that the precision with which we can estimate a particular model coefficient (or a set thereof for a GVIF) is negatively impacted by multicollinearity among the moderator variables. However, there is no specific cutoff for determining whether a particular (G)VIF is ‘large’. Sometimes, values such as 5 or 10 have been suggested as rules of thumb, but such cutoffs are essentially arbitrary.
</p>



<h4>Simulating the Distribution of (G)VIFs Under Independence</h4>

<p>As a more principled approach, we can simulate the distribution of a particular (G)VIF under independence and then examine how extreme the actually observed (G)VIF value is under this distribution. The distribution is simulated by randomly reshuffling the columns of the model matrix (to break any dependence between the moderators) and recomputing the (G)VIF. When setting <code>sim=TRUE</code>, this is done 1000 times (but one can also set <code>sim</code> to an integer to indicate how many (G)VIF values should be simulated).
</p>
<p>The way the model matrix is reshuffled depends on how the model was fitted. When the model was specified as a formula via the <code>mods</code> argument and the data was supplied via the <code>data</code> argument, then each column of the data frame specified via <code>data</code> is reshuffled and the formula is evaluated within the reshuffled data (creating the corresponding reshuffled model matrix). This way, factor/character variables are properly reshuffled and derived terms (e.g., interactions, polynomials, splines) are correct constructed. This is the recommended approach.
</p>
<p>On the other hand, if the model matrix was directly supplied to the <code>mods</code> argument, then each column of the matrix is directly reshuffled. This is not recommended, since this approach cannot account for any inherent relationships between variables in the model matrix (e.g., an interaction term is the product of two variables and should not be reshuffled by itself).
</p>
<p>Once the distribution of a (G)VIF under independence has been simulated, the proportion of simulated values that are smaller than the actually observed (G)VIF value is computed. If the proportion is close to 1, then this indicates that the actually observed (G)VIF value is extreme.
</p>
<p>The general principle underlying the simulation approach is the same as that underlying Horn's parallel analysis (1965) for determining the number of components / factors to keep in a principal component / factor analysis.
</p>



<h3>Value</h3>

<p>An object of class <code>"vif.rma"</code>. The object is a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>vif</code></td>
<td>
<p>a list of data frames with the (G)VIFs and (G)SIFs and some additional information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vifs</code></td>
<td>
<p>a vector with just the (G)VIFs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>table</code></td>
<td>
<p>the model coefficient table (only when <code>table=TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>a matrix with the simulated (G)VIF values (only when <code>sim=TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop</code></td>
<td>
<p>vector with the proportions of simulated values that are smaller than the actually observed (G)VIF values (only when <code>sim=TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>some additional elements/values.</p>
</td>
</tr>
</table>
<p>When <code>x</code> was a location-scale model object and (G)VIFs can be computed for both the location and the scale coefficients, then the object is a list with elements <code>beta</code> and <code>alpha</code>, where each element is an <code>"vif.rma"</code> object as described above.
</p>
<p>The results are formatted and printed with the <code>print</code> function. To format the results as a data frame, one can use the <code>as.data.frame</code> function. When <code>sim=TRUE</code>, the distribution of each (G)VIF can be plotted with the <code>plot</code> function.
</p>


<h3>Note</h3>

<p>If the original model fitted involved redundant predictors that were dropped from the model, then <code>sim=TRUE</code> cannot be used. In this case, one should remove any redundancies in the original model fitted before using this method.
</p>
<p>When using <code>sim=TRUE</code>, the model needs to be refitted (by default) 1000 times. When <code>sim=TRUE</code> is combined with <code>reestimate=TRUE</code>, then this value needs to be multiplied by the total number of (G)VIF values that are computed by the function. Hence, the combination of <code>sim=TRUE</code> with <code>reestimate=TRUE</code> is computationally expensive, especially for more complex models where model fitting can be slow.
</p>
<p>When refitting the model fails, the simulated (G)VIF value(s) will be missing. It can also happen that one or multiple model coefficients become inestimable due to redundancies in the model matrix after the reshuffling. In this case, the corresponding simulated (G)VIF value(s) will be set to <code>Inf</code> (as that is the value of (G)VIFs in the limit as we approach perfect multicollinearity).
</p>
<p>On machines with multiple cores, one can try to speed things up by delegating the model fitting to separate worker processes, that is, by setting <code>parallel="snow"</code> or <code>parallel="multicore"</code> and <code>ncpus</code> to some value larger than 1. Parallel processing makes use of the <code>parallel</code> package, using the <code>makePSOCKcluster</code> and <code>parLapply</code> functions when <code>parallel="snow"</code> or using <code>mclapply</code> when <code>parallel="multicore"</code> (the latter only works on Unix/Linux-alikes). With <code>parallel::detectCores()</code>, one can check on the number of available cores on the local machine.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Viechtbauer <a href="mailto:wvb@metafor-project.org">wvb@metafor-project.org</a> <a href="https://www.metafor-project.org">https://www.metafor-project.org</a>
</p>


<h3>References</h3>

<p>Belsley, D. A., Kuh, E., &amp; Welsch, R. E. (1980). <em>Regression diagnostics</em>. New York: Wiley.
</p>
<p>Fox, J., &amp; Monette, G. (1992). Generalized collinearity diagnostics. <em>Journal of the American Statistical Association</em>, <b>87</b>(417), 178–183. <code style="white-space: pre;">⁠https://doi.org/10.2307/2290467⁠</code>
</p>
<p>Horn, J. L. (1965). A rationale and test for the number of factors in factor analysis. <em>Psychometrika</em>, <b>30</b>(2), 179–185. <code style="white-space: pre;">⁠https://doi.org/10.1007/BF02289447⁠</code>
</p>
<p>Stewart, G. W. (1987). Collinearity and least squares regression. <em>Statistical Science</em>, <b>2</b>(1), 68-84. <code style="white-space: pre;">⁠https://doi.org/10.1214/ss/1177013439⁠</code>
</p>
<p>Wax, Y. (1992). Collinearity diagnosis for a relative risk regression-analysis: An application to assessment of diet cancer relationship in epidemiologic studies. <em>Statistics in Medicine</em>, <b>11</b>(10), 1273–1287. <code style="white-space: pre;">⁠https://doi.org/10.1002/sim.4780111003⁠</code>
</p>
<p>Viechtbauer, W. (2010). Conducting meta-analyses in R with the metafor package. <em>Journal of Statistical Software</em>, <b>36</b>(3), 1–48. <code style="white-space: pre;">⁠https://doi.org/10.18637/jss.v036.i03⁠</code>
</p>
<p>Viechtbauer, W., &amp; López-López, J. A. (2022). Location-scale models for meta-analysis. <em>Research Synthesis Methods</em>. <b>13</b>(6), 697–715. <code style="white-space: pre;">⁠https://doi.org/10.1002/jrsm.1562⁠</code>
</p>


<h3>See Also</h3>

<p><code>rma.uni</code>, <code>rma.glmm</code>, and <code>rma.mv</code> for functions to fit models for which variance inflation factors can be computed.
</p>
<p><code>plot</code> for the plot method and <code>as.data.frame</code> for the method to format the results as a data frame.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### copy data from Bangert-Drowns et al. (2004) into 'dat'
dat &lt;- dat.bangertdrowns2004

### fit mixed-effects meta-regression model
res &lt;- rma(yi, vi, mods = ~ length + wic + feedback + info + pers + imag + meta, data=dat)

### get variance inflation factors
vif(res)

### use the simulation approach to analyze the size of the VIFs
## Not run: 
vif(res, sim=TRUE, seed=1234)

## End(Not run)

### get variance inflation factors using the re-estimation approach
vif(res, reestimate=TRUE)

### show that VIFs are not influenced by scaling of the predictors
u &lt;- scale # to standardize the predictors
res &lt;- rma(yi, vi, mods = ~ u(length) + u(wic) + u(feedback) + u(info) +
                            u(pers) + u(imag) + u(meta), data=dat)
vif(res, reestimate=TRUE)

### get full table
vif(res, reestimate=TRUE, table=TRUE)

### calculate log risk ratios and corresponding sampling variances
dat &lt;- escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)

### fit meta-regression model where one predictor (alloc) is a three-level factor
res &lt;- rma(yi, vi, mods = ~ ablat + alloc + year, data=dat)

### get variance inflation factors for all individual coefficients
vif(res, table=TRUE)

### generalized variance inflation factor for the 'alloc' factor
vif(res, btt=3:4)

### can also specify a string to grep for
vif(res, btt="alloc")

### can also specify a list for the 'btt' argument (and use the simulation approach)
## Not run: 
vif(res, btt=list(2,3:4,5), sim=TRUE, seed=1234)

## End(Not run)
</code></pre>


</div>