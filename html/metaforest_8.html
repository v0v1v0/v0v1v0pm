<div class="container">

<table style="width: 100%;"><tr>
<td>PartialDependence</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PartialDependence: Partial dependence plots</h2>

<h3>Description</h3>

<p>Partial dependence plots
</p>


<h3>Usage</h3>

<pre><code class="language-R">PartialDependence(
  x,
  vars = NULL,
  pi = NULL,
  rawdata = FALSE,
  bw = FALSE,
  resolution = NULL,
  moderator = NULL,
  mod_levels = NULL,
  output = "plot",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Model object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>Character vector containing the moderator names for which to plot
partial dependence plots. If empty, all moderators are plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi</code></td>
<td>
<p>Numeric (0-1). What percentile interval should be plotted for the
partial dependence predictions? Defaults to NULL. To obtain a 95% interval,
set to <code>.95</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rawdata</code></td>
<td>
<p>Logical, indicating whether to plot weighted raw data.
Defaults to FALSE. Uses the same weights as the model object passed to the
<code>x</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>Logical, indicating whether the plot should be black and white, or
color.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resolution</code></td>
<td>
<p>Integer vector of length two, giving the resolution of the
partial predictions. The first element indicates the resolution of the
partial predictions; for Monte-Carlo integration, the second element gives
the number of rows of the data to be sampled without replacement when
averaging over values of the other predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moderator</code></td>
<td>
<p>Atomic character vector, referencing the name of one
variable in the model. Results in partial prediction plots, conditional on
the moderator. If <code>moderator</code> references a factor variable, separate
lines/boxplots are plotted for each factor level. If <code>moderator</code>
references a numeric variable, heatmaps are plotted - unless the moderator is
categorized using the <code>mod_levels</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod_levels</code></td>
<td>
<p>Vector. If <code>moderator</code> is continuous, specify
thresholds for the <code>cut</code> function. The continuous moderator
is categorized, and predictions are based on the median moderator value
within each category. You can call <code>quantile</code> to cut the
moderator at specific quantiles. If <code>moderator</code> is a factor variable,
you can use <code>mod_levels</code> to specify a character vector with the factor
levels to retain in the plot (i.e., dropping the other factor levels).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>Character. What type of output should be returned? Defaults to
<code>"plot"</code>, which returns and plots a gtable object. To obtain a list of
<code>ggplot</code> objects instead, provide the argument <code>"list"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed to and from functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Plots partial dependence plots (predicted effect size as a function of the
value of each predictor variable) for a MetaForest- or rma model object. For
rma models, it is advisable to mean-center numeric predictors, and to not
include plot_int effects, except when the rma model is bivariate, and the
<code>plot_int</code> argument is set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A gtable object.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#' # Partial dependence plot for MetaForest() model:
set.seed(42)
data &lt;- SimulateSMD(k_train = 200, model = es * x[, 1] + es * x[, 2] + es *
                                           x[, 1] * x[, 2])$training
data$X2 &lt;- cut(data$X2, breaks = 2, labels = c("Low", "High"))
mf.random &lt;- MetaForest(formula = yi ~ ., data = data,
                        whichweights = "random", method = "DL",
                        tau2 = 0.2450)
# Examine univariate partial dependence plot for all variables in the model:
PartialDependence(mf.random, pi = .8)
# Examine bivariate partial dependence plot the plot_int between X1 and X2:
pd.plot &lt;- PartialDependence(mf.random, vars = c("X1", "X2"), plot_int = TRUE)
# Save to pdf file
pdf("pd_plot.pdf")
grid.draw(pd.plot)
dev.off()
# Partial dependence plot for metafor rma() model:
dat &lt;- escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
dat$yi &lt;- as.numeric(dat$yi)
dat$alloc &lt;- factor(dat$alloc)
dat$ablat_d &lt;- cut(dat$ablat, breaks = 2, labels = c("low", "high"))
# Demonstrate partial dependence plot for a bivariate plot_int
rma.model.int &lt;- rma(yi, vi, mods=cbind(ablat, tpos),
                     data=dat, method="REML")
PartialDependence(rma.model.int, rawdata = TRUE, pi = .95,
                  plot_int = TRUE)

# Compare partial dependence for metaforest and rma
dat2 &lt;- dat
dat2[3:7] &lt;- lapply(dat2[3:7],
                    function(x){as.numeric(scale(x, scale = FALSE))})
mf.model.all &lt;- MetaForest(yi ~ ., dat2[, c(3:11)])
rma.model.all &lt;- rma(dat$yi, dat2$vi,
                  mods = model.matrix(yi~., dat2[, c(3:10)])[, -1],
                  method="REML")
PartialDependence(mf.model.all, rawdata = TRUE, pi = .95)
PartialDependence(rma.model.all, rawdata = TRUE, pi = .95)

## End(Not run)
</code></pre>


</div>