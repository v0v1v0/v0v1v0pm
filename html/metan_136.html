<div class="container">

<table style="width: 100%;"><tr>
<td>impute_missing_val</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Missing value imputation</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
</p>
<p>Impute the missing entries of a matrix with missing values using different
algorithms. See <strong>Details</strong> section for more details
</p>


<h3>Usage</h3>

<pre><code class="language-R">impute_missing_val(
  .data,
  naxis = 1,
  algorithm = "EM-SVD",
  tol = 1e-10,
  max_iter = 1000,
  simplified = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>A matrix to impute the missing entries. Frequently a two-way
table of genotype means in each environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>naxis</code></td>
<td>
<p>The rank of the Singular Value Approximation. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>The algorithm to impute missing values. Defaults to
<code>"EM-SVD"</code>. Other possible values are <code>"EM-AMMI"</code> and
<code>"colmeans"</code>. See <strong>Details</strong> section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The convergence tolerance for the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>The maximum number of steps to take. If <code>max_iter</code> is
achieved without convergence, the algorithm will stop with a warning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplified</code></td>
<td>
<p>Valid argument when <code>algorithm = "EM-AMMI"</code>. IF
<code>FALSE</code> (default), the current effects of rows and columns change from
iteration to iteration. If <code>TRUE</code>, the general mean and effects of
rows and columns are computed in the first iteration only, and in next
iterations uses these values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical argument. If <code>verbose = FALSE</code> the code will run
silently.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong><code>EM-AMMI</code> algorithm</strong>
</p>
<p>The <code>EM-AMMI</code> algorithm completes a data set with missing values according to both
main and interaction effects. The algorithm works as follows (Gauch and
Zobel, 1990):
</p>

<ol>
<li>
<p> The initial values are calculated as the grand mean increased by main
effects of rows and main effects of columns. That way, the matrix of
observations is pre-filled in.
</p>
</li>
<li>
<p> The parameters of the AMMI model are estimated.
</p>
</li>
<li>
<p> The adjusted means are calculated based on the AMMI model with
<code>naxis</code> principal components.
</p>
</li>
<li>
<p> The missing cells are filled with the adjusted means.
</p>
</li>
<li>
<p> The root mean square error of the predicted values (<code>RMSE_p</code>) is
calculated with the two lasts iteration steps. If <code>RMSE_p &gt; tol</code>, the
steps 2 through 5 are repeated. Declare convergence if <code>RMSE_p &lt; tol</code>.
If <code>max_iter</code> is achieved without convergence, the algorithm will stop
with a warning.
</p>
</li>
</ol>
<p><strong><code>EM-SVD</code> algorithm</strong>
</p>
<p>The <code>EM-SVD</code> algorithm impute the missing entries using a low-rank Singular
Value Decomposition approximation estimated by the Expectation-Maximization
algorithm. The algorithm works as follows (Troyanskaya et al., 2001).
</p>

<ol>
<li>
<p> Initialize all <code>NA</code> values to the column means.
</p>
</li>
<li>
<p> Compute the first <code>naxis</code> terms of the SVD of the completed matrix
</p>
</li>
<li>
<p> Replace the previously missing values with their approximations from the SVD
</p>
</li>
<li>
<p> The root mean square error of the predicted values (<code>RMSE_p</code>) is
calculated with the two lasts iteration steps. If <code>RMSE_p &gt; tol</code>, the
steps 2 through 3 are repeated. Declare convergence if <code>RMSE_p &lt; tol</code>.
If <code>max_iter</code> is achieved without convergence, the algorithm will stop
with a warning.
</p>
</li>
</ol>
<p><strong><code>colmeans</code> algorithm</strong>
</p>
<p>The <code>colmeans</code> algorithm simply impute the missing entires using the
column mean of the respective entire. Thus, there is no iteractive process.
</p>


<h3>Value</h3>

<p>An object of class <code>imv</code> with the following values:
</p>

<ul>
<li> <p><strong>.data</strong> The imputed matrix
</p>
</li>
<li> <p><strong>pc_ss</strong> The sum of squares representing variation explained by the
principal components
</p>
</li>
<li> <p><strong>iter</strong> The final number of iterations.
</p>
</li>
<li> <p><strong>Final_RMSE</strong> The maximum change of the estimated values for missing cells in the last step of iteration.
</p>
</li>
<li> <p><strong>final_axis</strong> The final number of principal component axis.
</p>
</li>
<li> <p><strong>convergence</strong> Logical value indicating whether the modern converged.
</p>
</li>
</ul>
<h3>References</h3>

<p>Gauch, H. G., &amp; Zobel, R. W. (1990). Imputing missing yield trial data.
Theoretical and Applied Genetics, 79(6), 753-761.
<a href="https://doi.org/10.1007/BF00224240">doi:10.1007/BF00224240</a>
</p>
<p>Troyanskaya, O., Cantor, M., Sherlock, G., Brown, P., Hastie, T., Tibshirani,
R., . Altman, R. B. (2001). Missing value estimation methods for DNA
microarrays. Bioinformatics, 17(6), 520-525.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(metan)
mat &lt;- (1:20) %*% t(1:10)
mat
# 10% of missing values at random
miss_mat &lt;- random_na(mat, prop = 10)
miss_mat
mod &lt;- impute_missing_val(miss_mat)
mod$.data

</code></pre>


</div>