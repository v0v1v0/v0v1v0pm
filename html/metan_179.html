<div class="container">

<table style="width: 100%;"><tr>
<td>path_coeff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Path coefficients with minimal multicollinearity</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
</p>

<ul>
<li> <p><code>path_coeff()</code> computes a path analysis using a data frame as input data.
</p>
</li>
<li> <p><code>path_coeff_seq()</code> computes a sequential path analysis using primary and secondary traits.
</p>
</li>
<li> <p><code>path_coeff_mat()</code> computes a path analysis using correlation matrices as
input data.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">path_coeff(
  .data,
  resp,
  pred = everything(),
  by = NULL,
  exclude = FALSE,
  correction = NULL,
  knumber = 50,
  brutstep = FALSE,
  maxvif = 10,
  missingval = "pairwise.complete.obs",
  plot_res = FALSE,
  verbose = TRUE,
  ...
)

path_coeff_mat(cor_mat, resp, correction = NULL, knumber = 50, verbose = TRUE)

path_coeff_seq(.data, resp, chain_1, chain_2, by = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>The data. Must be a data frame or a grouped data passed from
<code>dplyr::group_by()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resp</code></td>
<td>
<p>&lt;<code>tidy-select</code>&gt; The dependent trait.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>&lt;<code>tidy-select</code>&gt; The predictor traits. set to
<code>everything()</code>, i.e., the predictor traits are all the numeric traits in
the data except that in <code>resp</code>. To select multiple traits, use a
comma-separated vector of names, (e.g., <code>pred = c(V1, V2, V2)</code>), an
interval of trait names, (e.g., <code>pred = c(V1:V3)</code>), or even a select helper
(e.g., <code>pred = starts_with("V")</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>One variable (factor) to compute the function by. It is a shortcut
to <code>dplyr::group_by()</code>. To compute the statistics by more than
one grouping variable use that function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>Logical argument, set to false. If <code>exclude = TRUE</code>, then
the traits in <code>pred</code> are deleted from the data, and the analysis
will use as predictor those that remained, except that in <code>resp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>
<p>Set to <code>NULL</code>. A correction value (k) that will be
added into the diagonal elements of the <strong>X'X</strong> matrix aiming at
reducing the harmful problems of the multicollinearity in path analysis
(Olivoto et al., 2017)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knumber</code></td>
<td>
<p>When <code>correction = NULL</code>, a plot showing the values of
direct effects in a set of different k values (0-1) is produced.
<code>knumber</code> is the number of k values used in the range of 0 to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>brutstep</code></td>
<td>
<p>Logical argument, set to <code>FALSE</code>. If true, then an
algorithm will select a subset of variables with minimal multicollinearity
and fit a set of possible models. See the <strong>Details</strong> section for more
information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxvif</code></td>
<td>
<p>The maximum value for the Variance Inflation Factor (cut point)
that will be accepted. See the <strong>Details</strong> section for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missingval</code></td>
<td>
<p>How to deal with missing values. For more information,
please see <code>stats::cor()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_res</code></td>
<td>
<p>If <code>TRUE</code>, create a scatter plot of residual against
predicted value and a normal Q-Q plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>verbose = TRUE</code> then some results are shown in the
console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Depends on the function used:
</p>

<ul>
<li>
<p> For <code>path_coeff()</code> additional arguments passed on to <code>stats::plot.lm()</code>.
</p>
</li>
<li>
<p> For <code>path_coeff_seq()</code> additional arguments passed on to path_coeff.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor_mat</code></td>
<td>
<p>Matrix of correlations containing both dependent and
independent traits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chain_1, chain_2</code></td>
<td>
<p>&lt;<code>tidy-select</code>&gt; The traits used
in the first (primary) and second (secondary) chain.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In <code>path_coeff()</code>, when <code>brutstep = TRUE</code>, an algorithm to
select a set of predictors with minimal multicollinearity and high
explanatory power is implemented. first, the algorithm will select a set of
predictors with minimal multicollinearity. The selection is based on the
variance inflation factor (VIF). An iterative process is performed until
the maximum VIF observed is less than <code>maxvif</code>. The variables selected
in this iterative process are then used in a series of stepwise-based
regressions. The first model is fitted and p-1 predictor variables are
retained (p is the number of variables selected in the iterative process.
The second model adjusts a regression considering p-2 selected variables,
and so on until the last model, which considers only two variables. Three
objects are created. <code>Summary</code>, with the process summary,
<code>Models</code>, containing the aforementioned values for all the adjusted
models; and <code>Selectedpred</code>, a vector with the name of the selected
variables in the iterative process.
</p>


<h3>Value</h3>

<p>Depends on the function used:
</p>

<ul>
<li> <p><code>path_coeff()</code>, returns a list with the following items:
</p>

<ul>
<li> <p><strong>Corr.x</strong> A correlation matrix between the predictor variables.
</p>
</li>
<li> <p><strong>Corr.y</strong> A vector of correlations between each predictor variable
with the dependent variable.
</p>
</li>
<li> <p><strong>Coefficients</strong> The path coefficients. Direct effects are the
diagonal elements, and the indirect effects those in the off-diagonal
elements (lines).
</p>
</li>
<li> <p><strong>Eigen</strong> Eigenvectors and eigenvalues of the <code>Corr.x.</code>
</p>
</li>
<li> <p><strong>VIF</strong> The Variance Inflation Factors.
</p>
</li>
<li> <p><strong>plot</strong> A ggplot2-based graphic showing the direct effects in 21
different k values.
</p>
</li>
<li> <p><strong>Predictors</strong> The predictor variables used in the model.
</p>
</li>
<li> <p><strong>CN</strong> The Condition Number, i.e., the ratio between the highest and
lowest eigenvalue.
</p>
</li>
<li> <p><strong>Det</strong> The matrix determinant of the <code>Corr.x.</code>.
</p>
</li>
<li> <p><strong>R2</strong> The coefficient of determination of the model.
</p>
</li>
<li> <p><strong>Residual</strong> The residual effect of the model.
</p>
</li>
<li> <p><strong>Response</strong> The response variable.
</p>
</li>
<li> <p><strong>weightvar</strong> The order of the predictor variables with the highest
weight (highest eigenvector) in the lowest eigenvalue.
</p>
</li>
</ul>
</li>
<li> <p><code>path_coeff_seq()</code> returns a list with the following objects
</p>

<ul>
<li> <p><strong>resp_fc</strong> an object of class <code>path_coeff</code> with the results for the
analysis with dependent trait and first chain predictors.
</p>
</li>
<li> <p><strong>resp_sc</strong> an object of class <code>path_coeff</code> with the results for the
analysis with dependent trait and second chain predictors.
</p>
</li>
<li> <p><strong>resp_sc2</strong> The path coefficients of second chain predictors and the
dependent trait through the first chain predictors
</p>
</li>
<li> <p><strong>fc_sc_list</strong> A list of objects with the path analysis using each trait
in the first chain as dependent and second chain as predictors.
</p>
</li>
<li> <p><strong>fc_sc_coef</strong> The coefficients between first- and second-chain traits.
</p>
</li>
<li> <p><strong>cor_mat</strong> A correlation matrix between the analyzed traits.
If <code>.data</code> is a grouped data passed from <code>dplyr::group_by()</code>
then the results will be returned into a list-column of data frames.
</p>
</li>
</ul>
</li>
</ul>
<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>References</h3>

<p>Olivoto, T., V.Q. Souza, M. Nardino, I.R. Carvalho, M. Ferrari, A.J.
Pelegrin, V.J. Szareski, and D. Schmidt. 2017. Multicollinearity in path
analysis: a simple method to reduce its effects. Agron. J. 109:131-142.
<a href="https://doi.org/10.2134/agronj2016.04.0196">doi:10.2134/agronj2016.04.0196</a>
</p>
<p>Olivoto, T., M. Nardino, I.R. Carvalho, D.N. Follmann, M. Ferrari, et al.
2017. REML/BLUP and sequential path analysis in estimating genotypic values
and interrelationships among simple maize grain yield-related traits. Genet.
Mol. Res. 16(1): gmr16019525. <a href="https://doi.org/10.4238/gmr16019525">doi:10.4238/gmr16019525</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(metan)

# Using KW as the response variable and all other ones as predictors
pcoeff &lt;- path_coeff(data_ge2, resp = KW)

# The same as above, but using the correlation matrix
cor_mat &lt;- cor(data_ge2 %&gt;% select_numeric_cols())
pcoeff2 &lt;- path_coeff_mat(cor_mat, resp = KW)

# Declaring the predictors
# Create a residual plot with 'plot_res = TRUE'
pcoeff3&lt;- path_coeff(data_ge2,
                      resp = KW,
                      pred = c(PH, EH, NKE, TKW),
                      plot_res = TRUE)

# Selecting a set of predictors with minimal multicollinearity
# Maximum variance Inflation factor of 5
pcoeff4 &lt;- path_coeff(data_ge2,
                     resp = KW,
                     brutstep = TRUE,
                     maxvif = 5)


# When one analysis should be carried out for each environment
# Using the forward-pipe operator %&gt;%
pcoeff5 &lt;- path_coeff(data_ge2, resp = KW, by = ENV)


# sequential path analysis
# KW as dependent trait
# NKE and TKW as primary predictors
# PH, EH, EP, and EL as secondary traits
pcoeff6 &lt;-
 path_coeff_seq(data_ge2,
               resp = KW,
               chain_1 = c(NKE, TKW),
               chain_2 = c(PH, EH, EP, EL))
pcoeff6$resp_sc$Coefficients
pcoeff6$resp_sc2


</code></pre>


</div>