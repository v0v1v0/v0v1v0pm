<div class="container">

<table style="width: 100%;"><tr>
<td>clustering</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Clustering analysis</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
Performs clustering analysis with selection of variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">clustering(
  .data,
  ...,
  by = NULL,
  scale = FALSE,
  selvar = FALSE,
  verbose = TRUE,
  distmethod = "euclidean",
  clustmethod = "average",
  nclust = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>The data to be analyzed. It can be a data frame, possible with
grouped data passed from <code>dplyr::group_by()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>The variables in <code>.data</code> to compute the distances. Set to
<code>NULL</code>, i.e., all the numeric variables in <code>.data</code> are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>One variable (factor) to compute the function by. It is a shortcut
to <code>dplyr::group_by()</code>. To compute the statistics by more than
one grouping variable use that function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Should the data be scaled before computing the distances? Set to
FALSE. If TRUE, then, each observation will be divided by the standard
deviation of the variable \(Z_{ij} = X_{ij} / sd_j\)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selvar</code></td>
<td>
<p>Logical argument, set to <code>FALSE</code>. If <code>TRUE</code>, then an
algorithm for selecting variables is implemented. See the section
<strong>Details</strong> for additional information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical argument. If <code>TRUE</code> (default) then the results
for variable selection are shown in the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distmethod</code></td>
<td>
<p>The distance measure to be used. This must be one of
<code>'euclidean'</code>, <code>'maximum'</code>, <code>'manhattan'</code>,
<code>'canberra'</code>, <code>'binary'</code>, <code>'minkowski'</code>, <code>'pearson'</code>,
<code>'spearman'</code>, or <code>'kendall'</code>. The last three are
correlation-based distance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustmethod</code></td>
<td>
<p>The agglomeration method to be used. This should be one of
<code>'ward.D'</code>, <code>'ward.D2'</code>, <code>'single'</code>, <code>'complete'</code>,
<code>'average'</code> (= UPGMA), <code>'mcquitty'</code> (= WPGMA), <code>'median'</code> (=
WPGMC) or <code>'centroid'</code> (= UPGMC).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nclust</code></td>
<td>
<p>The number of clusters to be formed. Set to <code>NA</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>selvar = TRUE</code> a variable selection algorithm is executed. The
objective is to select a group of variables that most contribute to explain
the variability of the original data. The selection of the variables is based
on eigenvalue/eigenvectors solution based on the following steps.
</p>

<ol>
<li>
<p> compute the distance matrix and the cophenetic correlation with the original
variables (all numeric variables in dataset);
</p>
</li>
<li>
<p> compute the eigenvalues and eigenvectors of the correlation matrix between
the variables;
</p>
</li>
<li>
<p> Delete the variable with the largest weight (highest eigenvector in
the lowest eigenvalue);
</p>
</li>
<li>
<p> Compute the distance matrix and cophenetic correlation with the remaining
variables;
</p>
</li>
<li>
<p> Compute the Mantel's correlation between the obtained distances matrix and
the original distance matrix;
</p>
</li>
<li>
<p> Iterate steps 2 to 5 <em>p</em> - 2 times, where <em>p</em> is the number of original
variables.
</p>
</li>
</ol>
<p>At the end of the <em>p</em> - 2 iterations, a summary of the models is returned.
The distance is calculated with the variables that generated the model with
the largest cophenetic correlation. I suggest a careful evaluation aiming at
choosing a parsimonious model, i.e., the one with the fewer number of
variables, that presents acceptable cophenetic correlation and high
similarity with the original distances.
</p>


<h3>Value</h3>


<ul>
<li> <p><strong>data</strong> The data that was used to compute the distances.
</p>
</li>
<li> <p><strong>cutpoint</strong> The cutpoint of the dendrogram according to Mojena (1977).
</p>
</li>
<li> <p><strong>distance</strong> The matrix with the distances.
</p>
</li>
<li> <p><strong>de</strong> The distances in an object of class <code>dist</code>.
</p>
</li>
<li> <p><strong>hc</strong> The hierarchical clustering.
</p>
</li>
<li> <p><strong>Sqt</strong> The total sum of squares.
</p>
</li>
<li> <p><strong>tab</strong> A table with the clusters and similarity.
</p>
</li>
<li> <p><strong>clusters</strong> The sum of square and the mean of the clusters for each
variable.
</p>
</li>
<li> <p><strong>cofgrap</strong> If <code>selectvar = TRUE</code>, then, <code>cofpgrap</code> is a
ggplot2-based graphic showing the cophenetic correlation for each model
(with different number of variables). Else, will be a <code>NULL</code> object.
</p>
</li>
<li> <p><strong>statistics</strong> If <code>selectvar = TRUE</code>, then, <code>statistics</code> shows
the summary of the models fitted with different number of variables,
including cophenetic correlation, Mantel's correlation with the original
distances (all variables) and the p-value associated with the Mantel's
test. Else, will be a <code>NULL</code> object.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>References</h3>

<p>Mojena, R. 2015. Hierarchical grouping methods and stopping
rules: an evaluation. Comput. J. 20:359-363. <a href="https://doi.org/10.1093/comjnl/20.4.359">doi:10.1093/comjnl/20.4.359</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(metan)

# All rows and all numeric variables from data
d1 &lt;- clustering(data_ge2)

# Based on the mean for each genotype
mean_gen &lt;-
 data_ge2 %&gt;%
 mean_by(GEN) %&gt;%
 column_to_rownames("GEN")

d2 &lt;- clustering(mean_gen)


# Select variables for compute the distances
d3 &lt;- clustering(mean_gen, selvar = TRUE)

# Compute the distances with standardized data
# Define 4 clusters
d4 &lt;- clustering(data_ge,
                 by = ENV,
                 scale = TRUE,
                 nclust = 4)


</code></pre>


</div>