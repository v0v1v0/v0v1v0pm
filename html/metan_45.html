<div class="container">

<table style="width: 100%;"><tr>
<td>colindiag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Collinearity Diagnostics</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
</p>
<p>Perform a (multi)collinearity diagnostic of a correlation matrix of predictor
variables using several indicators, as shown by Olivoto et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class="language-R">colindiag(.data, ..., by = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>The data to be analyzed. It must be a symmetric correlation
matrix, or a data frame, possible with grouped data passed from
<code>dplyr::group_by()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Variables to use in the correlation. If <code>...</code> is null then
all the numeric variables from <code>.data</code> are used. It must be a single
variable name or a comma-separated list of unquoted variables names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>One variable (factor) to compute the function by. It is a shortcut
to <code>dplyr::group_by()</code>. To compute the statistics by more than
one grouping variable use that function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>If a correlation matrix is provided, then <code>n</code> is the number of
objects used to compute the correlation coefficients.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>.data</code> is a grouped data passed from <code>dplyr::group_by()</code>
then the results will be returned into a list-column of data frames.
</p>

<ul>
<li> <p><strong>cormat</strong> A symmetric Pearson's coefficient correlation matrix
between the variables
</p>
</li>
<li> <p><strong>corlist</strong> A hypothesis testing for each of the correlation
coefficients
</p>
</li>
<li> <p><strong>evalevet</strong> The eigenvalues with associated eigenvectors of the
correlation matrix
</p>
</li>
<li> <p><strong>VIF</strong> The Variance Inflation Factors, being the diagonal elements of
the inverse of the correlation matrix.
</p>
</li>
<li> <p><strong>CN</strong> The Condition Number of the correlation matrix, given by the
ratio between the largest and smallest eigenvalue.
</p>
</li>
<li> <p><strong>det</strong> The determinant of the correlation matrix.
</p>
</li>
<li> <p><strong>ncorhigh</strong> Number of correlation greather than |0.8|.
</p>
</li>
<li> <p><strong>largest_corr</strong> The largest correlation (in absolute value) observed.
</p>
</li>
<li> <p><strong>smallest_corr</strong> The smallest correlation (in absolute value)
observed.
</p>
</li>
<li> <p><strong>weight_var</strong> The variables with largest eigenvector (largest weight)
in the eigenvalue of smallest value, sorted in decreasing order.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>References</h3>

<p>Olivoto, T., V.Q. Souza, M. Nardino, I.R. Carvalho, M. Ferrari, A.J.
Pelegrin, V.J. Szareski, and D. Schmidt. 2017. Multicollinearity in path
analysis: a simple method to reduce its effects. Agron. J. 109:131-142.
<a href="https://doi.org/10.2134/agronj2016.04.0196">doi:10.2134/agronj2016.04.0196</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Using the correlation matrix
library(metan)

cor_iris &lt;- cor(iris[,1:4])
n &lt;- nrow(iris)

col_diag &lt;- colindiag(cor_iris, n = n)


# Using a data frame
col_diag_gen &lt;- data_ge2 %&gt;%
                group_by(GEN) %&gt;%
                colindiag()

# Diagnostic by levels of a factor
# For variables with "N" in variable name
col_diag_gen &lt;- data_ge2 %&gt;%
                group_by(GEN) %&gt;%
                colindiag(contains("N"))

</code></pre>


</div>