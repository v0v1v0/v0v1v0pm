<div class="container">

<table style="width: 100%;"><tr>
<td>bayes_parobs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit Bayesian Inference for Meta-Regression</h2>

<h3>Description</h3>

<p>This is a function for running the Markov chain Monte Carlo algorithm for the <em>Bayesian inference for multivariate meta-regression with a partially observed within-study sample covariance matrix</em> model. The first six arguments are required.
fmodel can be one of 5 numbers: 1, 2, 3, 4, and 5. The first model, fmodel = 1 denoted by M1, indicates that the <code class="reqn">\Sigma_{kt}</code>
are diagonal matrices with zero covariances. M2 indicates that <code class="reqn">\Sigma_{kt}</code> are all equivalent but allowed to be full symmetric
positive definite. M3 is where <code class="reqn">\Sigma_{kt}</code> are allowed to differ across treatments, i.e., <code class="reqn">\Sigma_{kt}=\Sigma_t</code>.
M4 assumes thata the correlation matrix, <code class="reqn">\rho</code>, is identical for all trials/treatments, but the variances are allowed to vary.
Finally, M5 assumes a hierarchical model where <code class="reqn">(\Sigma_{kt} | \Sigma)</code> follows an inverse-Wishart distribution with fixed
degrees of freedom and scale matrix <code class="reqn">\Sigma</code>. <code class="reqn">\Sigma</code> then follows another inverse-Wishart distribution with fixed parameters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bayes_parobs(
  Outcome,
  SD,
  XCovariate,
  WCovariate,
  Treat,
  Trial,
  Npt,
  fmodel = 1,
  prior = list(),
  mcmc = list(),
  control = list(),
  init = list(),
  Treat_order = NULL,
  Trial_order = NULL,
  group = NULL,
  group_order = NULL,
  scale_x = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Outcome</code></td>
<td>
<p>the aggregate mean of the responses for each arm of every study.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SD</code></td>
<td>
<p>the standard deviation of the responses for each arm of every study.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>XCovariate</code></td>
<td>
<p>the aggregate covariates for the fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WCovariate</code></td>
<td>
<p>the aggregate covariates for the random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Treat</code></td>
<td>
<p>the treatment identifiers. This is equivalent to the arm number of each study. The number of unique treatments must be equal across trials. The elements within will be coerced to consecutive integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Trial</code></td>
<td>
<p>the trial identifiers. This is equivalent to the arm labels in each study. The elements within will be coerced to consecutive integers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Npt</code></td>
<td>
<p>the number of observations/participants for a unique <code style="white-space: pre;">⁠(k,t)⁠</code>, or each arm of every trial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fmodel</code></td>
<td>
<p>the model number. The possible values for <code>fmodel</code> are 1 to 5, each indicating a different prior specification for <code class="reqn">\Sigma_{kt}</code>. It will default to M1, <code>fmodel=1</code> if not specified at function call. See the following model descriptions. The objects enclosed in parentheses at the end of every bullet point are the hyperparameters associated with each model.
</p>

<ul>
<li> <p><code>fmodel=1</code> - <code class="reqn">\Sigma_{kt} = diag(\sigma_{kt,11}^2,\ldots,\sigma_{kt,JJ}^2)</code> where <code class="reqn">\sigma_{kt,jj}^2 \sim IG(a_0,b_0)</code> and <code class="reqn">IG(a,b)</code> is <a href="https://en.wikipedia.org/wiki/Inverse-gamma_distribution">the inverse-gamma distribution</a>. This specification is useful if the user does not care about the correlation recovery. (<code>c0</code>, <code>dj0</code>, <code>a0</code>, <code>b0</code>, <code>Omega0</code>)
</p>
</li>
<li> <p><code>fmodel=2</code> - <code class="reqn">\Sigma_{kt}=\Sigma</code> for every combination of <code class="reqn">(k,t)</code> and <code class="reqn">\Sigma^{-1}\sim Wish_{s_0}(\Sigma_0)</code>. This specification assumes that the user has prior knowledge that the correlation structure does not change across the arms included. (<code>c0</code>, <code>dj0</code>, <code>s0</code>, <code>Omega0</code>, <code>Sigma0</code>)
</p>
</li>
<li> <p><code>fmodel=3</code> - <code class="reqn">\Sigma_{kt}=\Sigma_t</code> and <code class="reqn">\Sigma_t^{-1}\sim  Wish_{s_0}(\Sigma_0)</code>. This is a relaxed version of <code>fmodel=2</code>, allowing the correlation structure to differ across trials but forcing it to stay identical within a trial. (<code>c0</code>, <code>dj0</code>, <code>s0</code>, <code>Omega0</code>, <code>Sigma0</code>)
</p>
</li>
<li> <p><code>fmodel=4</code> - <code class="reqn">\Sigma_{kt}=\delta_{kt} \rho \delta_{kt}</code> where <code class="reqn">\delta_{kt}=diag(\Sigma_{kt,11}^{1/2},\ldots,\Sigma_{kt,JJ}^{1/2})</code>, and <code class="reqn">\rho</code> is the correlation matrix. This specification allows the variances to vary across arms but requires that the correlations be the same. This is due to the lack of correlation information in the data, which would in turn lead to the nonidentifiability of the correlations if they were allowed to vary. However, this still is an ambitious model which permits maximal degrees of freedom in terms of variance and correlation estimation. (<code>c0</code>, <code>dj0</code>, <code>a0</code>, <code>b0</code>, <code>Omega0</code>)
</p>
</li>
<li> <p><code>fmodel=5</code> - The fifth model is hierarchical and thus may require more data than the others: <code class="reqn">(\Sigma_{kt}^{-1}\mid \Sigma)\sim  Wish_{\nu_0}((\nu_0-J-1)^{-1}\Sigma^{-1})</code> and <code class="reqn">\Sigma \sim  Wish_{d_0}(\Sigma_0)</code>. <code class="reqn">\Sigma_{kt}</code> encodes the within-treatment-arm variation while <code class="reqn">\Sigma</code> captures the between-treatment-arm variation. The hierarchical structure allows the "borrowing of strength" across treatment arms. (<code>c0</code>, <code>dj0</code>, <code>d0</code>, <code>nu0</code>, <code>Sigma0</code>, <code>Omega0</code>)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>(Optional) a list of hyperparameters. Despite <code>theta</code> in every model, each <code>fmodel</code>, along with the <code>group</code> argument, requires a different set of hyperparameters. See <code>fmodel</code> for the model specifications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>(Optional) a list for MCMC specification. <code>ndiscard</code> is the number of burn-in iterations. <code>nskip</code> configures the thinning of the MCMC. For instance, if <code>nskip=5</code>, <code>bayes_parobs</code> will save the posterior sample every 5 iterations. <code>nkeep</code> is the size of the posterior sample. The total number of iterations will be <code>ndiscard + nskip * nkeep</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>(Optional) a list of tuning parameters for <a href="https://en.wikipedia.org/wiki/Metropolis-Hastings_algorithm">the Metropolis-Hastings algorithm</a>. <code>Rho</code>, <code>R</code>, and <code>delta</code> are sampled through either localized Metropolis algorithm or delayed rejection robust adaptive Metropolis algorithm. <code style="white-space: pre;">⁠*_stepsize⁠</code> with the asterisk replaced with one of the names above specifies the stepsize for determining the sample evaluation points in the localized Metropolis algorithm. <code>sample_Rho</code> can be set to <code>FALSE</code> to suppress the sampling of <code>Rho</code> for <code>fmodel=4</code>. When <code>sample_Rho</code> is <code>FALSE</code>, <code class="reqn">\rho</code> will be fixed using the value given by the <code>init</code> argument, which defaults to <code class="reqn">0.5 I+0.511'</code> where <code class="reqn">1</code> is the vector of ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>(Optional) a list of initial values for the parameters to be sampled: <code>theta</code>, <code>gamR</code>, <code>Omega</code>, and <code>Rho</code>. The initial value for <code>Rho</code> will be effective only if <code>fmodel=4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Treat_order</code></td>
<td>
<p>(Optional) a vector of unique treatments to be used for renumbering the <code>Treat</code> vector. The first element will be assigned treatment zero, potentially indicating placebo. If not provided, the numbering will default to an alphabetical/numerical order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Trial_order</code></td>
<td>
<p>(Optional) a vector of unique trials. The first element will be assigned zero. If not provided, the numbering will default to an alphabetical/numerical order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>(Optional) a vector containing binary variables for <code class="reqn">u_{kt}</code>. If not provided, <code>bayes_parobs</code> will assume that there is no grouping and set <code class="reqn">u_{kt}=0</code> for all <code style="white-space: pre;">⁠(k,t)⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_order</code></td>
<td>
<p>(Optional) a vector of unique group labels. The first element will be assigned zero. If not provided, the numbering will default to an alphabetical/numerical order. <code>group_order</code> will take effect only if <code>group</code> is provided by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_x</code></td>
<td>
<p>(Optional) a logical variable indicating whether <code>XCovariate</code> should be scaled/standardized. The effect of setting this to <code>TRUE</code> is not limited to merely standardizing <code>XCovariate</code>. The following generic functions will scale the posterior sample of <code>theta</code> back to its original unit: <code>plot</code>, <code>fitted</code>, <code>summary</code>, and <code>print</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>(Optional) a logical variable indicating whether to print the progress bar during the MCMC sampling.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>bayes_parobs</code> returns an object of class <code>"bayesparobs"</code>. The functions <code>summary</code> or <code>print</code> are used to obtain and print a summary of the results. The generic accessor function <code>fitted</code> extracts the posterior mean, posterior standard deviation, and the interval estimates of the value returned by <code>bayes_parobs</code>.
</p>
<p>An object of class <code>bayesparobs</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>Outcome</code> - the aggregate response used in the function call.
</p>
</li>
<li> <p><code>SD</code> - the standard deviation used in the function call.
</p>
</li>
<li> <p><code>Npt</code> - the number of participants for <code style="white-space: pre;">⁠(k,t)⁠</code> used in the function call.
</p>
</li>
<li> <p><code>XCovariate</code> - the aggregate design matrix for fixed effects used in the function call. Depending on <code>scale_x</code>, this may differ from the matrix provided at function call.
</p>
</li>
<li> <p><code>WCovariate</code> - the aggregate design matrix for random effects.
</p>
</li>
<li> <p><code>Treat</code> - the <em>renumbered</em> treatment indicators. Depending on <code>Treat_order</code>, it may differ from the vector provided at function call.
</p>
</li>
<li> <p><code>Trial</code> - the <em>renumbered</em> trial indicators. Depending on <code>Trial_order</code>, it may differ from the vector provided at function call.
</p>
</li>
<li> <p><code>group</code> - the <em>renumbered</em> grouping indicators in the function call. Depending on <code>group_order</code>, it may differ from the vector provided at function call. If <code>group</code> was missing at function call, <code>bayes_parobs</code> will assign <code>NULL</code> for <code>group</code>.
</p>
</li>
<li> <p><code>TrtLabels</code> - the vector of treatment labels corresponding to the renumbered <code>Treat</code>. This is equivalent to <code>Treat_order</code> if it was given at function call.
</p>
</li>
<li> <p><code>TrialLabels</code> - the vector of trial labels corresponding to the renumbered <code>Trial</code>. This is equivalent to <code>Trial_order</code> if it was given at function call.
</p>
</li>
<li> <p><code>GroupLabels</code> - the vector of group labels corresponding to the renumbered <code>group</code>. This is equivalent to <code>group_order</code> if it was given at function call. If <code>group</code> was missing at function call, <code>bayes_parobs</code> will assign <code>NULL</code> for <code>GroupLabels</code>.
</p>
</li>
<li> <p><code>K</code> - the total number of trials.
</p>
</li>
<li> <p><code>T</code> - the total number of treatments.
</p>
</li>
<li> <p><code>fmodel</code> - the model number as described <a href="#model-spec">here</a>.
</p>
</li>
<li> <p><code>scale_x</code> - a Boolean indicating whether <code>XCovariate</code> has been scaled/standardized.
</p>
</li>
<li> <p><code>prior</code> - the list of hyperparameters used in the function call.
</p>
</li>
<li> <p><code>control</code> - the list of tuning parameters used for MCMC in the function call.
</p>
</li>
<li> <p><code>mcmctime</code> - the elapsed time for the MCMC algorithm in the function call. This does not include all the other preprocessing and post-processing outside of MCMC.
</p>
</li>
<li> <p><code>mcmc</code> - the list of MCMC specification used in the function call.
</p>
</li>
<li> <p><code>mcmc.draws</code> - the list containing the MCMC draws. The posterior sample will be accessible here.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Daeyoung Lim, <a href="mailto:daeyoung.lim@uconn.edu">daeyoung.lim@uconn.edu</a>
</p>


<h3>References</h3>

<p>Yao, H., Kim, S., Chen, M. H., Ibrahim, J. G., Shah, A. K., &amp; Lin, J. (2015). Bayesian inference for multivariate meta-regression with a partially observed within-study sample covariance matrix. <em>Journal of the American Statistical Association</em>, <strong>110(510)</strong>, 528-544.
</p>


<h3>See Also</h3>

<p><code>bmeta_analyze</code> for using the <code>Formula</code> interface
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(metapack)
data("cholesterol")
Outcome &lt;- model.matrix(~ 0 + pldlc + phdlc + ptg, data = cholesterol)
SD &lt;- model.matrix(~ 0 + sdldl + sdhdl + sdtg, data = cholesterol)
Trial &lt;- cholesterol$trial
Treat &lt;- cholesterol$treat
Npt &lt;- cholesterol$n
XCovariate &lt;- model.matrix(~ 0 + bldlc + bhdlc + btg + age + durat +
 white + male + dm, data = cholesterol)
WCovariate &lt;- model.matrix(~ treat, data = cholesterol)

fmodel &lt;- 1
set.seed(2797542)
fit &lt;- bayes_parobs(Outcome, SD, XCovariate, WCovariate, Treat, Trial,
   Npt, fmodel, mcmc = list(ndiscard = 1, nskip = 1, nkeep = 1),
   scale_x = TRUE, group = cholesterol$onstat, verbose = FALSE)
</code></pre>


</div>