<div class="container">

<table style="width: 100%;"><tr>
<td>metami</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiple Imputation for Missing Data in Meta-Analysis</h2>

<h3>Description</h3>

<p>Multiple imputation allows for the uncertainty about the missing data by generating several different plausible imputed data sets and appropriately combining results obtained from each of them. Let  <code class="reqn">\hat{\theta}_{*m}</code> be the estimated coefficient from the <code class="reqn">m</code>th imputed dataset for one of the <code class="reqn">p</code> dimensions in the multivariate outcome, where <code class="reqn">m=1,\dots,M</code>. The coefficient from MI <code class="reqn">\bar{\theta}</code> is  simply just an arithmetic mean of the individual coefficients estimated from each of the <code class="reqn">M</code> meta-analysis. We have
</p>
<p style="text-align: center;"><code class="reqn">\bar{\theta}=\frac{\sum_{m=1}^{M}\hat{\theta}_{*m}}{M}.</code>
</p>

<p>Estimation of the standard error for each variable is little more complicated. Let <code class="reqn">V_W</code> be the within imputation variance, which is the average of the variance of the estimated coefficient from each imputed dateset:
</p>
<p style="text-align: center;"><code class="reqn">V_W=\frac{\sum_{m=1}^{M}V ({\hat{\theta}_{*m}})}{M},</code>
</p>

<p>where <code class="reqn">V ({\hat{\theta}_{*m}})</code> is the variance of the estimator calculated from generalized least squares methods using the imputed dataset. Let <code class="reqn">V_B</code> be the between imputation variance, which is calculated as
</p>
<p style="text-align: center;"><code class="reqn">V_B=\frac{\sum_{m=1}^{M}({\hat{\theta}_{*m}}-\bar{\theta})^2}{M-1}.</code>
</p>

<p>From <code class="reqn">V_W</code> and <code class="reqn">V_B</code>, the variance of the pooled coefficients is calculated as
</p>
<p style="text-align: center;"><code class="reqn">V(\bar{\theta})=V_W+V_B+\frac{V_B}{M}</code>
</p>

<p>The above variance is statistically principled since <code class="reqn">V_W</code> reflects the sampling variance and <code class="reqn">V_B</code> reflects the extra variance due to the missing data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">metami(data, M = 20, vcov = "r.vcov",
        r.n.name, ef.name, x.name = NULL,
        rvcov.method = "average", rvcov.zscore = TRUE,
        type = NULL,
        d = NULL, sdt = NULL, sdc = NULL,
        nt = NULL, nc = NULL,
        st = NULL, sc = NULL,
        n_rt = NA, n_rc = NA,
        r = NULL,
        func = "mixmeta",
        formula = NULL,
        method = "fixed",
        pool.seq = NULL,
        return.mi = FALSE,
        ci.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data </code></td>
<td>
<p> A  <code class="reqn">N \times p</code> data frame that contains effect sizes and predictors for meta-regression, if any.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p> Number of imputed data sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov </code></td>
<td>
<p> Method for computing effect sizes; options including <code>vcov = "r.vcov"</code> for correlation coefficients and <code>vcov = "mix.vcov"</code> for other types of effect sizes. See <code>r.vcov</code> and <code>mix.vcov</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r.n.name </code></td>
<td>
<p> A string defining the column name for sample sizes in <code>data</code> when the effect sizes are correlation coefficients (<code>vcov = "r.vcov"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ef.name </code></td>
<td>
<p> A <code class="reqn">p</code>-dimensional vector that stores the column names for sample sizes in <code>data</code> when the effect sizes are correlation coefficients (<code>vcov = "r.vcov"</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.name </code></td>
<td>
<p> A vector that stores the column names in <code>data</code> for predictors for meta-regression. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rvcov.method</code></td>
<td>
<p>Method used for <code>r.vcov</code>; options including <code>"average"</code> and <code>"each"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rvcov.zscore </code></td>
<td>
<p> Whether the correlation coefficients in <code>data</code> are already transformed into Fisher's <code class="reqn">z</code> scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type </code></td>
<td>
<p> A <code class="reqn">p</code>-dimensional vector indicating types of effect sizes for the argument <code>vcov = "mix.vcov"</code>. <code>"MD"</code> stands for mean difference, <code>"SMD"</code> stands for standardized mean difference, <code>"logOR"</code> stands for log odds ratio, <code>"logRR"</code> stands for log risk ratio, and <code>"RD"</code> stands for risk difference. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d </code></td>
<td>
<p> A <code class="reqn">p</code>-dimensional vector that stores the column names in <code>data</code> for continuous effect sizes such as MD or SMD. If outcome <code class="reqn">j</code> is dichotomous, NA has to be imputed in for <code class="reqn">d[j]</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdt </code></td>
<td>
<p> A <code class="reqn">p</code>-dimensional vector that stores the column names in <code>data</code> for the sample standard deviations of each outcome from the treatment group. If outcome <code class="reqn">j</code> is dichotomous, NA has to be imputed in for <code class="reqn">d[j]</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdc </code></td>
<td>
<p> A vector defined in a similar way as <code>sdt</code> for the control group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nt </code></td>
<td>
<p> A <code class="reqn">p</code>-dimensional vector that stores the column names in <code>data</code> for sample sizes of <code class="reqn">p</code> outcomes from treatment group. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc </code></td>
<td>
<p> A vector defined in a similar way as <code>nt</code> for the control group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>st </code></td>
<td>
<p> A <code class="reqn">p</code>-dimensional vector that stores the column names in <code>data</code> for the number of participants with event for all outcomes (dichotomous) in the treatment group. If outcome <code class="reqn">j</code> is dichotomous, NA has to be imputed in for <code class="reqn">st[j]</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sc </code></td>
<td>
<p> A vector defined in a similar way as <code>st</code> for the control group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_rt</code></td>
<td>
<p>A <code class="reqn">N</code>-dimensional list of <code class="reqn">p \times p</code> correlation matrices storing sample sizes in the treatment group reporting pairwise outcomes in the off-diagonal elements. See <code>mix.vcov</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_rc</code></td>
<td>
<p> A list defined in a similar way as <code>n_rt</code> for the control group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>A <code class="reqn">N</code>-dimensional list of <code class="reqn">p \times p</code> correlation matrices for the <code class="reqn">p</code> outcomes from the <code class="reqn">N</code> studies. See <code>mix.vcov</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p> A string defining the function to be used for fitting the meta-analysis. Options include <code>func = "metafixed"</code> for fixed-effect meta-analysis (see <code>metafixed</code> for details). <code>func = "mixmeta"</code>, for which the <code>mixmeta</code> package must be installed beforehand, and <code>func = "meta"</code>, for which the <code>metaSEM</code> package must be installed beforehand. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p> Formula used for the function  <code>func = "mixmeta"</code> from the <code>mixmeta</code> package when <code>func = "mixmeta"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> Method used for the function  <code>func = "mixmeta"</code> from the <code>mixmeta</code> package when <code>func = "mixmeta"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pool.seq</code></td>
<td>
<p> A numeric vector indicating if the results are pooled from subsets of the <code>M</code> data sets. By default, the results are only pooled from all <code>M</code> data sets. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.mi</code></td>
<td>
<p> Should the <code>M</code> imputed data sets be returned?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p> Significant level for the pooled confidence intervals. The default is 0.05. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For the imputation phase, this function imports the <code>mice</code> package that imputes incomplete multivariate data by chained equations. The pooling phase is performed via the Rubin's rules.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p> A data.frame that contains the pooled results from the <code>M</code> imputed data sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>results.mi</code></td>
<td>
<p> A <code class="reqn">M</code>-dimensional list of results from each imputed data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.mi </code></td>
<td>
<p> A <code class="reqn">M</code>-dimensional list of imputed data sets if the argument <code>return.mi = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result.seq</code></td>
<td>
<p> A list of results from the pooled results from the subsets of the <code>M</code> imputed data sets if the argument <code>pool.seq = TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Min Lu
</p>


<h3>References</h3>

<p>Lu, M. (2023). Computing within-study covariances, data visualization, and missing data solutions for multivariate meta-analysis with metavcov. <em>Frontiers in Psychology</em>, 14:1185012.
</p>
<p>Van Buuren, S. and Groothuis-Oudshoorn, K., 2011. mice: Multivariate imputation by chained equations in R. <em>Journal of statistical software</em>, 45(1), pp.1-67.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#####################################################################################
# Example: Craft2003 data
# Preparing input arguments for meta.mi() and fixed-effect model
#####################################################################################
# prepare a dataset with missing values and input arguments for meta.mi
Craft2003.mnar &lt;- Craft2003[, c(2, 4:10)]
Craft2003.mnar[sample(which(Craft2003$C4 &lt; 0), 6), "C4"] &lt;- NA
dat &lt;- Craft2003.mnar
n.name &lt;- "N"
ef.name &lt;- c("C1", "C2", "C3", "C4", "C5", "C6")
# fixed-effect model
obj &lt;- metami(dat, M = 2, vcov = "r.vcov",
             n.name, ef.name,
             func = "metafixed")

########################
# Plotting the result
########################
computvcov &lt;- r.vcov(n = Craft2003$N,
                     corflat = subset(Craft2003.mnar, select = C1:C6),
                     method = "average")
plotCI(y = computvcov$ef, v = computvcov$list.vcov,
        name.y = NULL, name.study = Craft2003$ID,
        y.all = obj$coefficients[,1],
        y.all.se = obj$coefficients[,2])

########################
# Pooling from subsets
########################
# o1 &lt;- metami(dat, M = 10, vcov = "r.vcov",
#               n.name, ef.name,
#               func = "metafixed",
#               pool.seq = c(5, 10))
# pooled results from M = 5 imputed data sets
# o1$result.seq$M5$coefficients
# pooled results from M = 10 imputed data sets
# o1$result.seq$M10$coefficients
#########################################################################################
# Running random-effects and meta-regression model using packages "mixmeta" or "metaSEM"
#########################################################################################
# Restricted maximum likelihood (REML) estimator from the mixmeta package
# library(mixmeta)
# o2 &lt;- metami(dat, M = 10, vcov = "r.vcov",
#                     n.name, ef.name,
#                     formula = as.formula(cbind(C1, C2, C3, C4, C5, C6) ~ 1),
#                     func = "mixmeta",
#                     method = "reml")
# maximum likelihood estimators from the metaSEM package
# library(metaSEM)
# o3 &lt;- metami(dat, M = 10, vcov = "r.vcov",
#               n.name, ef.name,
#               func = "meta")

# meta-regression
# library(metaSEM)
# o4 &lt;- metami(dat, M = 10, vcov = "r.vcov",
#                     n.name, ef.name, x.name = "p_male",
#                     func = "meta")
# library(mixmeta)
# o5 &lt;- metami(dat, M = 20, vcov = "r.vcov",
#               n.name, ef.name, x.name = "p_male",
#               formula = as.formula(cbind(C1, C2, C3, C4, C5, C6) ~ p_male ),
#               func = "mixmeta",
#               method = "reml")
#####################################################################################
# Example: Geeganage2010 data
# Preparing input arguments for meta.mi() and fixed-effect model
#####################################################################################
# Geeganage2010.mnar &lt;- Geeganage2010
# Geeganage2010.mnar$MD_SBP[sample(1:nrow(Geeganage2010),7)] &lt;- NA
# r12 &lt;- 0.71
# r13 &lt;- 0.5
# r14 &lt;- 0.25
# r23 &lt;- 0.6
# r24 &lt;- 0.16
# r34 &lt;- 0.16
# r &lt;- vecTosm(c(r12, r13, r14, r23, r24, r34))
# diag(r) &lt;- 1
# mix.r &lt;- lapply(1:nrow(Geeganage2010), function(i){r})
# o &lt;- metami(data = Geeganage2010.mnar, M = 10, vcov = "mix.vcov",
#               ef.name = c("MD_SBP", "MD_DBP", "RD_DD", "lgOR_D"),
#               type = c("MD", "MD", "RD", "lgOR"),
#               d = c("MD_SBP", "MD_DBP", NA, NA),
#               sdt = c("sdt_SBP", "sdt_DBP", NA, NA),
#               sdc = c("sdc_SBP", "sdc_DBP", NA, NA),
#               nt = c("nt_SBP", "nt_DBP", "nt_DD", "nt_D"),
#               nc = c("nc_SBP", "nc_DBP", "nc_DD", "nc_D"),
#               st = c(NA, NA, "st_DD", "st_D"),
#               sc = c(NA, NA, "sc_DD", "sc_D"),
#               r = mix.r,
#               func = "metafixed")
</code></pre>


</div>