<div class="container">

<table style="width: 100%;"><tr>
<td>mix.vcov</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computing Variance-Covariance Matrices for Effect Sizes of the Same or Different Types</h2>

<h3>Description</h3>

<p>The function <code>r.vcov</code> computes effect sizes and variance-covariance matrices between effect sizes of the same of different types. Effect sizes include mean difference (MD), standardized mean difference (SMD), log odds ratio (logOR), log risk ratio (logRR), and risk difference (RD). Formulas are in Table I of Wei et al.'s paper (2013).
</p>


<h3>Usage</h3>

<pre><code class="language-R">mix.vcov(d, r, nt, nc,
         st, sc, n_rt = NA, n_rc = NA,
         sdt, sdc, type,
         name = NULL, na.impute = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d </code></td>
<td>
<p> A <code class="reqn">N \times p</code> matrix or data frame with mean differences (MD) and/or standard mean differences (SMD) from the <code class="reqn">N</code> studies. <code>d[i,j]</code> is the value from study <code class="reqn">i</code> for outcome <code class="reqn">j</code>. If outcome <code class="reqn">j</code> is not MD or SMD, NA has to be imputed in column <code class="reqn">j</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r </code></td>
<td>
<p> A <code class="reqn">N</code>-dimensional list of <code class="reqn">p \times p</code> correlation matrices for the <code class="reqn">p</code> outcomes from the <code class="reqn">N</code> studies. <code>r[[k]][i,j]</code> is the correlation coefficient between outcome <code class="reqn">i</code> and outcome <code class="reqn">j</code> from study <code class="reqn">k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nt </code></td>
<td>
<p> A <code class="reqn">N \times p</code> matrix storing sample sizes in the treatment group reporting the  <code class="reqn">p</code> outcomes. <code>nt[i,j]</code> is the sample size from study <code class="reqn">i</code> reporting outcome <code class="reqn">j</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc </code></td>
<td>
<p> A matrix defined in a similar way as <code>nt</code> for the control group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>st </code></td>
<td>
<p> A <code class="reqn">N \times p</code> matrix recording number of participants with event for all outcomes (dichotomous) in treatment group. <code>st[i,j]</code> reports number of participants with event for outcome <code class="reqn">j</code> in treatment group for study <code class="reqn">i</code>. If outcome <code class="reqn">j</code> is not dichotomous, NA has to be imputed in column <code class="reqn">j</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sc </code></td>
<td>
<p> Defined in a similar way as <code>st</code> for the control group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_rt </code></td>
<td>
<p>A <code class="reqn">N</code>-dimensional list of <code class="reqn">p \times p</code> matrices storing sample sizes in the treatment group reporting pairwise outcomes in the off-diagonal elements. <code>n_rt[[k]][i,j]</code> is the sample size reporting both outcome <code class="reqn">i</code> and outcome <code class="reqn">j</code> from study <code class="reqn">k</code>. Diagonal elements of these matrices are discarded. The default value is <code>NA</code>, which means that the smaller sample size reporting the corresponding two outcomes is imputed: i.e. <code>n_rt[[k]][i,j]=min(nt[k,i],nt[k,j])</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_rc </code></td>
<td>
<p> A list defined in a similar way as <code>n_rt</code> for the control group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdt </code></td>
<td>
<p> A <code class="reqn">N \times p</code> matrix storing sample standard deviations for each outcome from treatment group. <code>sdt[i,j]</code> is the sample standard deviation from study <code class="reqn">i</code> for outcome <code class="reqn">j</code>. If outcome <code class="reqn">j</code> is not continuous such as MD or SMD, NA has to be imputed in the <code class="reqn">j</code>th column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdc </code></td>
<td>
<p> A matrix defined in a similar way as <code>sdt</code> for the control group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type </code></td>
<td>
<p> A <code class="reqn">p</code>-dimensional vector indicating types of effect sizes. <code>"MD"</code> stands for mean difference, <code>"SMD"</code> stands for standardized mean difference, <code>"logOR"</code> stands for log odds ratio, <code>"logRR"</code> stands for log risk ratio, and <code>"RD"</code> stands for risk difference. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name </code></td>
<td>
<p> A <code class="reqn">p</code>-dimensional vector storing names for the effect sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.impute </code></td>
<td>
<p> Missing values in <code>d</code> can be imputed by a numeric value, such as zero by setting <code>na.impute = 0</code>. With the default setting <code>na.impute = NA</code>, missing values are not imputed. If specifying <code>na.impute = "average"</code>, missing values are imputed by the mean of <code>d</code> that is sample-size weighted from the complete records. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code> ef</code></td>
<td>
<p>A <code class="reqn">N \times p</code> data frame whose columns are computed effect sizes according to the input argument <code>"type"</code>. SMD will be converted to Hedges's g (Wei and Higgins, 2013).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.vcov </code></td>
<td>
<p> A <code class="reqn">N</code>-dimensional list of <code class="reqn">p(p+1)/2 \times p(p+1)/2</code> matrices of computed variance-covariance matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrix.vcov </code></td>
<td>
<p> A <code class="reqn">N \times p(p+1)/2</code> matrix whose rows are computed variance-covariance vectors.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Min Lu
</p>


<h3>References</h3>

<p>Lu, M. (2023). Computing within-study covariances, data visualization, and missing data solutions for multivariate meta-analysis with metavcov. <em>Frontiers in Psychology</em>, 14:1185012.
</p>
<p>Wei, Y., &amp;  Higgins, J. (2013). Estimating within study covariances in multivariate meta-analysis with multiple outcomes. <em>Statistics in Medicine, 32</em>(7), 119-1205.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#########################################################################
# Example: Geeganage2010 data
# Preparing covariances for a multivariate meta-analysis
# Choose variable SBP, DBP, DD, D with effect sizes "MD","MD","RD","lgOR"
#########################################################################
data(Geeganage2010)
## set the correlation coefficients list r
r12 &lt;- 0.71
r13 &lt;- 0.5
r14 &lt;- 0.25
r23 &lt;- 0.6
r24 &lt;- 0.16
r34 &lt;- 0.16
r &lt;- vecTosm(c(r12, r13, r14, r23, r24, r34))
diag(r) &lt;- 1
mix.r &lt;- lapply(1:nrow(Geeganage2010), function(i){r})
attach(Geeganage2010)
## compute variance co-variances
computvcov &lt;- mix.vcov(type = c("MD", "MD", "RD", "lgOR"),
                       d = cbind(MD_SBP, MD_DBP, NA, NA),
                       sdt = cbind(sdt_SBP, sdt_DBP, NA, NA),
                       sdc = cbind(sdc_SBP, sdc_DBP, NA, NA),
                       nt = cbind(nt_SBP, nt_DBP, nt_DD, nt_D),
                       nc = cbind(nc_SBP, nc_DBP, nc_DD, nc_D),
                       st = cbind(NA, NA, st_DD, st_D),
                       sc = cbind(NA, NA, sc_DD, sc_D),
                       r = mix.r,
                       name = c("MD.SBP", "MD.DBP", "RD.DD", "lgOR.D"))
# save different effect sizes in y
y &lt;- computvcov$ef
head(y)
# save variances and covariances of all the effect sizes in a matrix S
S &lt;- computvcov$matrix.vcov
S[1, ]
## fixed-effect model
MMA_FE &lt;- summary(metafixed(y = y, Slist = computvcov$list.vcov))
#######################################################################
# Running random-effects model using package "mixmeta" or "metaSEM"
#######################################################################
# Restricted maximum likelihood (REML) estimator from the mixmeta package
# library(mixmeta)
# mvmeta_RE &lt;- summary(mixmeta(cbind(MD.SBP, MD.DBP, RD.DD, lgOR.D) ~ 1,
#                            S = S, data = y, method = "reml"))
# mvmeta_RE

# maximum likelihood estimators from the metaSEM package
# library(metaSEM)
# metaSEM_RE &lt;- summary(meta(y = y, v = S))
# metaSEM_RE
##############################################################
# Plotting the result:
##############################################################
obj &lt;- MMA_FE
# obj &lt;- mvmeta_RE
# obj &lt;- metaSEM_RE
# pdf("CI.pdf", width = 4, height = 7)
plotCI(y = computvcov$ef, v = computvcov$list.vcov,
        name.y = NULL, name.study = Geeganage2010$studyID,
        y.all = obj$coefficients[,1],
        y.all.se = obj$coefficients[,2],
        hline = c(0, 0, 0, 1))
# dev.off()
</code></pre>


</div>