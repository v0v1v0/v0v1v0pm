<div class="container">

<table style="width: 100%;"><tr>
<td>pred.rfsi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Random Forest Spatial Interpolation (RFSI) prediction</h2>

<h3>Description</h3>

<p>Function for spatial/spatio-temporal prediction based on Random Forest Spatial Interpolation (RFSI) model (Sekulić et al. 2020).</p>


<h3>Usage</h3>

<pre><code class="language-R">pred.rfsi(model,
          data,
          obs.col=1,
          data.staid.x.y.z = NULL,
          newdata,
          newdata.staid.x.y.z = NULL,
          z.value = NULL,
          s.crs = NA,
          newdata.s.crs=NA,
          p.crs = NA,
          output.format = "data.frame",
          cpus = detectCores()-1,
          progress = TRUE,
          soil3d = FALSE, # soil RFSI
          depth.range = 0.1, # in units of depth
          no.obs = 'increase',
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>ranger; An RFSI model made by rfsi function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>sf-class, sftime-class, SpatVector-class or data.frame; Contains target variable (observations) and covariates used for RFSI prediction. If data.frame object, it should have next columns: station ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z) of the observation, and observation value (obs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.col</code></td>
<td>
<p>numeric or character; Column name or number showing position of the observation column in the <code>data</code>. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the station ID (staid), longitude (x), latitude (y) and 3rd component (z) columns in data.frame object (e.g. c(1,2,3,4)). If <code>data</code> is sf-class, sftime-class, or SpatVector-class object, <code>data.staid.x.y.z</code> is used to point staid and z position. Set z position to NA (e.g. c(1,2,3,NA)) or ommit it (e.g. c(1,2,3)) for spatial interpolation. Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>sf-class, sftime-class, SpatVector-class, SpatRaster-class or data.frame; Contains prediction locations and covariates used for RFSI prediction. If data.frame object, it should have next columns: prediction location ID (staid), longitude (x), latitude (y), 3rd component - time, depth, ... (z), and covariates (cov1, cov2, ...). Covariate names have to be the same as in the <code>model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata.staid.x.y.z</code></td>
<td>
<p>numeric or character vector; Positions or names of the prediction location ID (staid), longitude (x), latitude (y) and 3rd component (z) columns in data.frame <code>newdata</code> object (e.g. c(1,2,3,4)). If <code>newdata</code> is sf-class, sftime-class, SpatVector-class or SpatRaster-class object, <code>newdata.staid.x.y.z</code> is used to point staid and z position. Set z position to NA (e.g. c(1,2,3,NA)) or ommit it (e.g. c(1,2,3)) for spatial interpolation. Default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.value</code></td>
<td>
<p>vector; A vector of 3rd component - time, depth, ... (z) values if <code>newdata</code> is SpatRaster-class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.crs</code></td>
<td>
<p>st_crs or crs; Source CRS of <code>data</code>. If <code>data</code> contains crs, <code>s.crs</code> will not be used. Default is NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata.s.crs</code></td>
<td>
<p>st_crs or crs; Source CRS of <code>newdata</code>. If <code>newdata</code> contains crs, <code>newdata.s.crs</code> will not be used. Default is NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.crs</code></td>
<td>
<p>st_crs or crs; Projection CRS for <code>data</code> reprojection. If NA, <code>s.crs</code> will be used for distance calculation. Note that observations should be in projection for finding nearest observations based on Eucleadean distances (see function near.obs). Default is NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output.format</code></td>
<td>
<p>character; Format of the output, data.frame (default), sf-class, sftime-class, SpatVector-class, or SpatRaster-class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpus</code></td>
<td>
<p>numeric; Number of processing units. Default is detectCores()-1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>logical; If progress bar is shown. Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>soil3d</code></td>
<td>
<p>logical; If 3D soil modellig is performed and near.obs.soil function is used for finding n nearest observations and distances to them. In this case, z position of the <code>data.staid.x.y.z</code> points to the depth column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>depth.range</code></td>
<td>
<p>numeric; Depth range for location mid depth in which to search for nearest observations (see function near.obs.soil). It's in the mid depth units. Default is 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.obs</code></td>
<td>
<p>character; Possible values are <code>increase</code> (default) and <code>exactly</code>. If set to <code>increase</code>, in case if there is no <code>n.obs</code> observations in <code>depth.range</code> for a specific location, the <code>depth.range</code> is increased (multiplied by 2, 3, ...) until the number of observations are larger or equal to <code>n.obs</code>. If set to <code>exactly</code>, the function will raise an error when it come to the first location with no <code>n.obs</code> observations in specified <code>depth.range</code> (see function near.obs.soil).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to predict.ranger function, such as <code>type = "quantile"</code> and <code>quantiles = c(0.1,0.5,0.9)</code> for quantile regression, etc.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A data.frame, sf-class, sftime-class, SpatVector-class, or SpatRaster-class object (depends on <code>output.format</code> argument) with prediction - <code>pred</code> or <code>quantile..X.X</code> (quantile regression) columns.
</p>


<h3>Author(s)</h3>

<p>Aleksandar Sekulic <a href="mailto:asekulic@grf.bg.ac.rs">asekulic@grf.bg.ac.rs</a></p>


<h3>References</h3>

<p>Sekulić, A., Kilibarda, M., Heuvelink, G. B., Nikolić, M. &amp; Bajat, B. Random Forest Spatial Interpolation. Remote. Sens. 12, 1687, https://doi.org/10.3390/rs12101687 (2020).
</p>


<h3>See Also</h3>

<p><code>near.obs</code>
<code>rfsi</code>
<code>tune.rfsi</code>
<code>cv.rfsi</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ranger)
library(sp)
library(sf)
library(terra)
library(meteo)

# prepare data
demo(meuse, echo=FALSE)
meuse &lt;- meuse[complete.cases(meuse@data),]
data = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
fm.RFSI &lt;- as.formula("zinc ~ dist + soil + ffreq")

# fit the RFSI model
rfsi_model &lt;- rfsi(formula = fm.RFSI,
                   data = data, # meuse.df (use data.staid.x.y.z)
                   n.obs = 5, # number of nearest observations
                   cpus = 2, # detectCores()-1,
                   progress = TRUE,
                   # ranger parameters
                   importance = "impurity",
                   seed = 42,
                   num.trees = 250,
                   mtry = 5,
                   splitrule = "variance",
                   min.node.size = 5,
                   sample.fraction = 0.95,
                   quantreg = FALSE)
                   # quantreg = TRUE) # for quantile regression

rfsi_model
# OOB prediction error (MSE):       47758.14 
# R squared (OOB):                  0.6435869 
sort(rfsi_model$variable.importance)
sum("obs" == substr(rfsi_model$forest$independent.variable.names, 1, 3))

# Make RFSI prediction
newdata &lt;- terra::rast(meuse.grid)
class(newdata)

# prediction

rfsi_prediction &lt;- pred.rfsi(model = rfsi_model,
                             data = data, # meuse.df (use data.staid.x.y.z)
                             obs.col = "zinc",
                             newdata = newdata, # meuse.grid.df (use newdata.staid.x.y.z)
                             output.format = "SpatRaster", # "sf", # "SpatVector", 
                             zero.tol = 0,
                             cpus = 2, # detectCores()-1,
                             progress = TRUE,
                             # type = "quantiles", # for quantile regression
                             # quantiles = c(0.1, 0.5, 0.9) # for quantile regression
)
class(rfsi_prediction)
names(rfsi_prediction)
head(rfsi_prediction)
plot(rfsi_prediction)
plot(rfsi_prediction['pred'])

</code></pre>


</div>