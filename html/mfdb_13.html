<div class="container">

<table style="width: 100%;"><tr>
<td>gadget_stockfile</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gadget stock files</h2>

<h3>Description</h3>

<p>Structures representing a GADGET stock file
</p>


<h3>Usage</h3>

<pre><code class="language-R">gadget_stockfile_extremes(stock_name, data)
gadget_stockfile_refweight(stock_name, data)
gadget_stockfile_initialconditions(stock_name, data)
gadget_stockfile_recruitment(stock_name, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>stock_name</code></td>
<td>

<p>A name, e.g. <code>cod.imm</code>, used as the name for the stockfile
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>A data.frame used to generate the data. See details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The columns required in the <code>data</code> varies depends on which function you
are using.
</p>
<p><code>gadget_stockfile_extremes</code> requires <code>age</code> and <code>length</code> columns
and populates <code>minlength</code>, <code>minage</code>, <code>maxlength</code>, <code>maxage</code>.
The values are obtained by the grouping used, rather than the
maximum values in the data. If you want the minimum and maximum from the data,
query with <code>length = NULL, age = NULL</code>, so the table contains "all"
and the grouping contains the actual minimum and maximum.
</p>
<p><code>gadget_stockfile_refweight</code> requires a <code>length</code> column and a
<code>mean</code> column representing mean weight for that length group. It populates
the <code>refweightfile</code> and <code>dl</code>.
</p>
<p><code>gadget_stockfile_initialconditions</code> requires <code>area</code>, <code>age</code>,
<code>length</code>, <code>number</code> and <code>mean</code> (weight) columns. Populates
initialconditions <code>minlength</code>, <code>minage</code>, <code>maxlength</code>, <code>maxage</code>,
<code>dl</code> and the <code>numberfile</code>. As before, the min/max values are populated
using the groupings you specify, not the min/max available data.
</p>
<p><code>gadget_stockfile_recruitment</code> requires <code>year</code>, <code>step</code>, <code>area</code>,
<code>age</code>, <code>length</code>, <code>number</code> and <code>mean</code> (weight) columns. Populates
<code>doesrenew</code>, <code>minlength</code>, <code>maxlength</code>, <code>dl</code>, <code>numberfile</code>.
</p>


<h3>Value</h3>

<p>The return value is a <code>gadget_stockfile</code> object that can be written
to the filesystem with <code>gadget_dir_write</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
mdb &lt;- mfdb(tempfile(fileext = '.duckdb'))

# Define 2 areacells of equal size
mfdb_import_area(mdb, data.frame(name=c("divA", "divB"), size=1))

# Make up some samples
samples &lt;- expand.grid(
    year = 1998,
    month = c(1:12),
    areacell = c("divA", "divB"),
    species = 'COD',
    age = c(1:5),
    length = c(0,40,80))
samples$count &lt;- runif(nrow(samples), 20, 90)
mfdb_import_survey(mdb, data_source = "x", samples)

imm_data &lt;- mfdb_sample_meanweight(mdb, c('age', 'length'), list(
    age = NULL, # The age column will say 'all', but will know the min/max
    length = mfdb_step_interval('', 10, to = 100),
    species = 'COD'))

# Write both min/max and refweighfile into our gadget directory
component &lt;- gadget_stockfile_extremes('cod.imm', imm_data[[1]])
component

component &lt;- gadget_stockfile_refweight('cod.imm', imm_data[[1]])
component

gadget_dir_write(gadget_directory(tempfile()), component)

mfdb_disconnect(mdb)
</code></pre>


</div>