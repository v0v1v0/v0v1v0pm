<div class="container">

<table style="width: 100%;"><tr>
<td>transform_vector_fp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functions to transform a variable using fractional polynomial powers or acd</h2>

<h3>Description</h3>

<p>These functions generate fractional polynomials for a variable similar to
<code>fracgen</code> in Stata. <code>transform_vector_acd</code> generates the acd transformation
for a variable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">transform_vector_fp(
  x,
  power = 1,
  scale = 1,
  shift = 0,
  name = NULL,
  check_binary = TRUE
)

transform_vector_acd(
  x,
  power = c(1, 1),
  shift = 0,
  powers = NULL,
  scale = 1,
  acd_parameter = NULL,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector of a predictor variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p>a numeric vector indicating the FP power. Default is 1 (linear).
Must be a vector of length 2 for acd transformation. Ignores <code>NA</code>, unless
an ACD transformation is applied in which case power must be a numeric
vector of length 2, and <code>NA</code> indicated which parts are used for the final
FP.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>scaling factor for x of interest. Must be a positive integer
or <code>NULL</code>. Default is 1, meaning no scaling is applied.
If <code>NULL</code>, then scaling factors are automatically estimated by the
program.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>shift required for shifting x to positive values. Default is 0,
meaning no shift is applied. If <code>NULL</code> then the shift is estimated
automatically using the Royston and Sauerbrei formula iff any <code>x</code> &lt;= 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>character used to define names for the output matrix. Default
is <code>NULL</code>, meaning the output will have unnamed columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_binary</code></td>
<td>
<p>a logical indicating whether or not input <code>x</code> is checked
if it is a binary variable (i.e. has only two distinct values). The default
<code>TRUE</code> usually only needs to changed when this function is to be used to
transform data for predictions. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>powers</code></td>
<td>
<p>passed to <code>fit_acd()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acd_parameter</code></td>
<td>
<p>a list usually returned by <code>fit_acd()</code>. In particular,
it must have components that define <code>beta0</code>, <code>beta1</code>, <code>power</code>, <code>shift</code> and
<code>scale</code> which are to be applied when using the acd transformation in
new data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The fp transformation generally transforms <code>x</code> as follows. For each pi in
<code>power</code> = (p1, p2, ..., pn) it creates a variable x^pi and returns the
collection of variables as a matrix. It may process the data using
shifting and scaling as desired. Centering has to be done after the
data is transformed using these functions, if desired.
</p>
<p>A special case are repeated powers, i.e. when some pi = pj. In this case,
the fp transformations are given by x^pi and x^pi * log(x). In case
more than 2 powers are repeated they are repeatedly multiplied with
log(x) terms, e.g. pi = pj = pk leads to x^pi, x^pi * log(x) and
x^pi * log(x)^2.
</p>
<p>Note that the powers pi are assumed to be sorted. That is, this function
sorts them, then proceeds to compute the transformation. For example,
the output will be the same for <code>power = c(1, 1, 2)</code> and
<code>power = c(1, 2, 1)</code>. This is done to make sense of repeated powers and
to uniquely define FPs. In case an ACD transformation is used, there is a
specific order in which powers are processed, which is always the same (but
not necessarily sorted).
Thus, throughout the whole package powers will always be given and processed
in either sorted, or ACD specific order and the columns of the matrix
returned by this function will always align with the powers used
throughout this package.
</p>
<p>Binary variables are not transformed, unless <code>check_binary</code> is set to
<code>FALSE</code>. This is usually not necessary, the only special case to set it to
<code>FALSE</code> is when a single value is to be transformed during prediction (e.g.
to transform a reference value). When this is done, binary variables are
still returned unchanged, but a single value from a continuous variable will
be transformed as desired by the fitted transformations. For model fit,
<code>check_binary</code> should always be at its default value.
</p>


<h3>Value</h3>

<p>Returns a matrix of transformed variable(s). The number of columns
depends on the number of powers provided, the number of rows is equal to the
length of <code>x</code>. The columns are sorted by increased power.
If all powers are <code>NA</code>, then this function returns <code>NULL</code>.
In case an acd transformation is applied, the output is a list with two
entries. The first <code>acd</code> is the matrix of transformed variables, the acd
term is returned as the last column of the matrix (i.e. in case that the
power for the normal data is <code>NA</code>, then it is the only column in the matrix).
The second entry <code>acd_parameter</code> returns a list of estimated parameters
for the ACD transformation, or simply the input <code>acd_parameter</code> if it was
not <code>NULL</code>.
</p>


<h3>Functions</h3>


<ul><li> <p><code>transform_vector_acd()</code>: Function to generate acd transformation.
</p>
</li></ul>
<h3>Data processing</h3>

<p>An important note on data processing. Variables are shifted and scaled
before being transformed by any powers. That is to ensure positive values
and reasonable scales. Note that scaling does not change the estimated
powers, see also <code>find_scale_factor()</code>.
</p>
<p>However, they may be centered after transformation. This is not done by
these functions.
That is to ensure that the correlation between variables stay intact,
as centering before transformation would affect them. This is described
in Sauerbrei et al (2006), as well as in the Stata manual of <code>mfp</code>.
Also, centering is not recommended, and should only be done for the final
model if desired.
</p>


<h3>References</h3>

<p>Sauerbrei, W., Meier-Hirmer, C., Benner, A. and Royston, P., 2006.
<em>Multivariable regression model building by using fractional
polynomials: Description of SAS, STATA and R programs.
Comput Stat Data Anal, 50(12): 3464-85.</em>
</p>


<h3>Examples</h3>

<pre><code class="language-R">z = 1:10
transform_vector_fp(z)
transform_vector_acd(z)
</code></pre>


</div>