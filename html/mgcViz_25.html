<div class="container">

<table style="width: 100%;"><tr>
<td>l_densCheck</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Checking residuals conditional density</h2>

<h3>Description</h3>

<p>This layer calculates and plots how the empirical conditional density of
the residuals, r, differs from its theoretical or model-based counterpart,
along a covariate, x.
</p>


<h3>Usage</h3>

<pre><code class="language-R">l_densCheck(n = c(80, 80), bw = NULL, tol = 1e-06, dFun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>vector of two positive integers, indicating the number of grid points
at which the density is evaluated on the x and r axes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>vector with two positive entries, indicating the bandwidth to be used
by the kernel density estimator of <code>p(r|x)</code> along x and r.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>small positive numerical tolerance. The estimated density at a certain
location is set to <code>NA</code> (hence it will appear white) when it falls
below <code>tol/sqrt(2*pi*sig)</code>, where <code>sig</code> is the standard
deviation of the residuals. Set <code>tol</code> to -1 plot the density on
the whole x-y plane, no matter how low it is.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dFun</code></td>
<td>
<p>function used to compute the difference between the empirical (em) and theoretical (th)
conditional density of the residuals. By default it is <code>(sqrt(em)-sqrt(th))^(1/3)</code>,
where <code>th</code> is computed using either a uniform or a normal density, depending on the
type of residuals used in the check1D call. It should have as arguments three vectors: <code>.ed</code> (the empirical
conditional density), <code>.gr</code> (the points along the y-axis where the density is evaluated) and
<code>.y</code> (the residuals).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_raster</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This layer is mainly meant to work together with the check1D function. If check1D() is called with
residual type == "tunif" or "tnormal", then <code>l_densCheck</code> compares the conditional distribution
of the residuals with Unif(0, 1) or N(0, 1). By changing the distance function <code>dFun</code>
one could of course change both the distance metric and the reference distribution (see Examples below). <br><br>
WARNING: if check1D() is called with type != "tunif" or "tnormal", then the default distance used by l_densCheck is <br><code>dFun &lt;- function(.ed, .gr, .y)</code> <code>{</code><br><code>d &lt;- dnorm(.gr, 0, sd=sd(.y)) # sd=sd(.y) !!!</code><br><code>d &lt;- sqrt(.ed)-sqrt(d) </code><br><code>return(sign(d)*abs(d)^(1/3))</code><br><code>}</code> <br>
so the residuals are standardized using their own std dev <code>sd(.y)</code>.
Hence <code>l_densCheck</code> might not detect that the mean estimated variance
under the fitted model is different from the residuals variance.
Hence it is safer to use residual types "tunif" or "tnormal", or a
customized distance function dFun (see below for an example on how to do this).
</p>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(mgcViz);
# Dataset where variance increases linearly with x2, for x2 &gt; 0.2
n &lt;- 1e3
x1 &lt;- rnorm(1e3)
x2 &lt;- rnorm(1e3)
dat &lt;- data.frame("x1"=x1, 
                  "x2"=x2, "y"=sin(x1) + 0.5*x2^2 + pmax(x2, 0.2)*rnorm(n))
b &lt;- gam(y ~ s(x1)+s(x2), data=dat)
b &lt;- getViz(b)

# (Red) Blue indicates area where the empirical density 
# of the residuals is (lower) higher than it should be under 
# the model (residuals should be N(0, sigma) here).
# Here there are clear signs of heteroscedasticity: 
# the conditional variance is is increasing for x2 &gt; 0.2. 
check1D(b, "x2", type = "tnormal") + l_densCheck() + l_rug()

# Suppose we want to compare the conditional density of the standardized residuals
# not with a Gaussian, but with a Student-t density with 3 degree of freedom.
# We could achieve this as follows:
myDistance &lt;- function(.ed, .gr, .y){
  d &lt;- dt(.gr / sd(.y), df = 3)
  d &lt;- abs( sqrt(.ed) - sqrt(d) ) # We are using absolute difference between sqrt-densities 
}

check1D(b, "x2", type = "response") + l_densCheck(dFun = myDistance) + l_rug()
# NB comparing with a Student density is not useful for this example, but it illustrates
# how both the distance function and the reference density can be customized.

</code></pre>


</div>