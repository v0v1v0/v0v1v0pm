<div class="container">

<table style="width: 100%;"><tr>
<td>plotDiff.sos.smooth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plotting differences between two smooths on the sphere</h2>

<h3>Description</h3>

<p>This method can be used to plot the difference between two smooth
effects on the sphere. Mainly meant to be used with by-factor smooths.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'sos.smooth'
plotDiff(
  s1,
  s2,
  n = 40,
  too.far = 0.1,
  phi = 30,
  theta = 30,
  scheme = 0,
  trans = identity,
  unconditional = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>s1</code></td>
<td>
<p>a smooth effect object, extracted using sm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s2</code></td>
<td>
<p>another smooth effect object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sqrt of the number of grid points used to compute the effect plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>too.far</code></td>
<td>
<p>if greater than 0 then this is used to determine when a location is too far
from data to be plotted. This is useful since smooths tend to go wild
away from data. The data are scaled into the unit square before deciding
what to exclude, and too.far is a distance within the unit square.
Setting to zero can make plotting faster for large datasets, but care
then needed with interpretation of plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>one of the plotting angles, relevant only if <code>scheme = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>the other plotting angle, relevant only if <code>scheme = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scheme</code></td>
<td>
<p>if 0 the smooth effect is plotted on the sphere. If 1 the smooth effect is plotted
on the two hemispheres.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently unused.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let sd be the difference between the fitted smooths, that is: sd = s1 - s2.
sd is a vector of length n, and its covariance matrix is
Cov(sd) = X1\
where: X1 (X2) and Sig11 (Sig22) are the design matrix and the covariance matrix
of the coefficients of s1 (s2), while Sig12 is the cross-covariance matrix between
the coefficients of s1 and s2. To get the confidence intervals we need only diag(Cov(sd)),
which here is calculated efficiently (without computing the whole of Cov(sd)).
</p>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#### 1) Simulate data and add factors uncorrelated to the response
library(mgcViz)
set.seed(0)
n &lt;- 500

f &lt;- function(la,lo) { ## a test function...
  sin(lo)*cos(la-.3)
}

## generate with uniform density on sphere...  
lo &lt;- runif(n)*2*pi-pi ## longitude
la &lt;- runif(3*n)*pi-pi/2
ind &lt;- runif(3*n)&lt;=cos(la)
la &lt;- la[ind];
la &lt;- la[1:n]

ff &lt;- f(la,lo)
y &lt;- ff + rnorm(n)*.2 ## test data

## generate data for plotting truth...
lam &lt;- seq(-pi/2,pi/2,length=30)
lom &lt;- seq(-pi,pi,length=60)
gr &lt;- expand.grid(la=lam,lo=lom)
fz &lt;- f(gr$la,gr$lo)
zm &lt;- matrix(fz,30,60)

dat &lt;- data.frame(la = la *180/pi,lo = lo *180/pi,y=y)
dat$fac &lt;- as.factor( sample(c("A1", "A2", "A3"), nrow(dat), replace = TRUE) ) 

#### 2) fit spline on sphere model...
bp &lt;- gam(y~s(la,lo,bs="sos",k=60, by = fac),data=dat)
bp &lt;- getViz(bp)

# Extract the smooths correspoding to "A1" and "A3" and plot their difference
# Using scheme = 0 
pl0 &lt;- plotDiff(s1 = sm(bp, 1), s2 = sm(bp, 3))
pl0 + l_fitRaster() + l_fitContour() + l_coordContour() + l_bound()

# Plot p-values for significance of differences
pl0 + l_pvRaster() + l_pvContour(breaks=c(0.05, 0.1, 0.2, 0.3, 0.5))

# Using scheme = 1
pl1 &lt;- plotDiff(s1 = sm(bp, 1), s2 = sm(bp, 2), scheme = 1) 
pl1 + l_fitRaster() + l_fitContour()

# Plot p-values for significance of differences
pl1 + l_pvRaster() + l_pvContour(breaks=c(0.05, 0.1, 0.2, 0.3, 0.5))

## End(Not run)
</code></pre>


</div>