<div class="container">

<table style="width: 100%;"><tr>
<td>discr.test.one_sample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Discriminability One Sample Permutation Test</h2>

<h3>Description</h3>

<p>A function that performs a one-sample test for whether the discriminability differs from random chance.
</p>


<h3>Usage</h3>

<pre><code class="language-R">discr.test.one_sample(
  X,
  Y,
  is.dist = FALSE,
  dist.xfm = mgc.distance,
  dist.params = list(method = "euclidean"),
  dist.return = NULL,
  remove.isolates = TRUE,
  nperm = 500,
  no_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt>
<dd>
<p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt>
<dd>
<p>X is a distance matrix. Use flag <code>is.dist=TRUE</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p><code>[n]</code> a vector containing the sample ids for our <code>n</code> samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.dist</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.xfm</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See mgc.distance for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.params</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.return</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt>
<dd>
<p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt>
<dd>
<p>use <code>dist.xfm[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove.isolates</code></td>
<td>
<p>remove isolated samples from the dataset. Isolated samples are samples with only
one instance of their class appearing in the <code>Y</code> vector. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nperm</code></td>
<td>
<p>the number of permutations to perform. Defaults to <code>500</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no_cores</code></td>
<td>
<p>the number of cores to use for permutation test. Defaults to <code>1</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>the discriminability of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null</code></td>
<td>
<p>the discriminability scores under the null, computed via permutation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>the pvalue associated with the permutation test.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Performs a test of whether an observed discriminability is significantly different from chance, as described in Bridgeford et al. (2019).
With <code class="reqn">\hat D_X</code> the sample discriminability of <code class="reqn">X</code>:
</p>
<p style="text-align: center;"><code class="reqn">H_0: D_X = D_0</code>
</p>
<p> and:</p>
<p style="text-align: center;"><code class="reqn">H_A: D_X &gt; D_0</code>
</p>
<p> where <code class="reqn">D_0</code>
is the discriminability that would be observed by random chance.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>References</h3>

<p>Eric W. Bridgeford, et al. "Optimal Decisions for Reference Pipelines and Datasets: Applications in Connectomics." Bioarxiv (2019).
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
require(mgc)
n = 100; d=5

# simulation with a large difference between the classes
# meaning they are more discriminable
sim &lt;- discr.sims.linear(n=n, d=d, K=2, signal.lshift=10)
X &lt;- sim$X; Y &lt;- sim$Y

# p-value is small
discr.test.one_sample(X, Y)$p.value

## End(Not run)
</code></pre>


</div>