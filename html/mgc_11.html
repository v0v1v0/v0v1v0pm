<div class="container">

<table style="width: 100%;"><tr>
<td>discr.test.two_sample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Discriminability Two Sample Permutation Test</h2>

<h3>Description</h3>

<p>A function that takes two sets of paired data and tests of whether or not the data is more, less, or non-equally discriminable between the set of paired data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">discr.test.two_sample(
  X1,
  X2,
  Y,
  dist.xfm = mgc.distance,
  dist.params = list(method = "euclidian"),
  dist.return = NULL,
  remove.isolates = TRUE,
  nperm = 500,
  no_cores = 1,
  alt = "greater"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X1</code></td>
<td>
<p>is interpreted as a <code>[n x d]</code> data matrix with <code>n</code> samples in <code>d</code> dimensions. Should NOT be a distance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X2</code></td>
<td>
<p>is interpreted as a <code>[n x d]</code> data matrix with <code>n</code> samples in <code>d</code> dimensions. Should NOT be a distance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p><code>[n]</code> a vector containing the sample ids for our <code>n</code> samples. Should be matched such that <code>Y[i]</code> is the corresponding label for <code>X1[i,]</code> and <code>X2[i,]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.xfm</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See mgc.distance for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.params</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.return</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt>
<dd>
<p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt>
<dd>
<p>use <code>dist.xfm[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove.isolates</code></td>
<td>
<p>remove isolated samples from the dataset. Isolated samples are samples with only
one instance of their class appearing in the <code>Y</code> vector. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nperm</code></td>
<td>
<p>the number of permutations for permutation test. Defualts to <code>500</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no_cores</code></td>
<td>
<p>the number of cores to use for the permutations. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt</code></td>
<td>
<p>the alternative hypothesis. Can be that first dataset is more discriminable (<code>alt = 'greater'</code>), less discriminable (<code>alt = 'less'</code>),
or just non-equal (<code>alt = 'neq'</code>). Defaults to <code>"greater"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>the observed test statistic. the test statistic is the difference in discriminability of X1 vs X2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discr</code></td>
<td>
<p>the discriminabilities for each of the two data sets, as a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null</code></td>
<td>
<p>the null distribution of the test statistic, computed via permutation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>The p-value associated with the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt</code></td>
<td>
<p>The alternative hypothesis for the test.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A function that performs a two-sample test for whether the discriminability is different for that of
one dataset vs another, as described in Bridgeford et al. (2019). With <code class="reqn">\hat D_{X_1}</code> the sample discriminability of one approach, and <code class="reqn">\hat D_{X_2}</code> the sample discriminability of another approach:
</p>
<p style="text-align: center;"><code class="reqn">H_0: D_{X_1} = D_{X_2}</code>
</p>
<p> and:</p>
<p style="text-align: center;"><code class="reqn">H_A: D_{X_1} &gt; D_{X_2}</code>
</p>
<p>.
Also implemented are tests of <code class="reqn">&lt;</code> and <code class="reqn">\neq</code>.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>References</h3>

<p>Eric W. Bridgeford, et al. "Optimal Decisions for Reference Pipelines and Datasets: Applications in Connectomics." Bioarxiv (2019).
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
require(mgc)
require(MASS)

n = 100; d=5

# generate two subjects truths; true difference btwn
# subject 1 (column 1) and subject 2 (column 2)
mus &lt;- cbind(c(0, 0), c(1, 1))
Sigma &lt;- diag(2)  # dimensions are independent

# first dataset X1 contains less noise than X2
X1 &lt;- do.call(rbind, lapply(1:dim(mus)[2],
  function(k) {mvrnorm(n=50, mus[,k], 0.5*Sigma)}))
X2 &lt;- do.call(rbind, lapply(1:dim(mus)[2],
  function(k) {mvrnorm(n=50, mus[,k], 2*Sigma)}))
Y &lt;- do.call(c, lapply(1:2, function(i) rep(i, 50)))

# X1 should be more discriminable, as less noise
discr.test.two_sample(X1, X2, Y, alt="greater")$p.value  # p-value is small

## End(Not run)
</code></pre>


</div>