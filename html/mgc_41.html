<div class="container">

<table style="width: 100%;"><tr>
<td>mgc.test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>MGC Permutation Test</h2>

<h3>Description</h3>

<p>Test of Dependence using MGC Approach.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mgc.test(
  X,
  Y,
  is.dist.X = FALSE,
  dist.xfm.X = mgc.distance,
  dist.params.X = list(method = "euclidean"),
  dist.return.X = NULL,
  is.dist.Y = FALSE,
  dist.xfm.Y = mgc.distance,
  dist.params.Y = list(method = "euclidean"),
  dist.return.Y = NULL,
  nperm = 1000,
  option = "mgc",
  no_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt>
<dd>
<p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist.X=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt>
<dd>
<p>X is a distance matrix. Use flag <code>is.dist.X=TRUE</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt>
<dd>
<p>Y is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist.Y=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt>
<dd>
<p>Y is a distance matrix. Use flag <code>is.dist.Y=TRUE</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.dist.X</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.xfm.X</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See mgc.distance for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.params.X</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm.X</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.return.X</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm.X</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt>
<dd>
<p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt>
<dd>
<p>use <code>dist.xfm.X[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.dist.Y</code></td>
<td>
<p>a boolean indicating whether your <code>Y</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.xfm.Y</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>Y</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>dist.return.Y</code> return argument. See mgc.distance for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.params.Y</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm.Y</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.return.Y</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm.Y</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt>
<dd>
<p>use the return argument directly from <code>dist.xfm.Y(Y)</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt>
<dd>
<p>use <code>dist.xfm.Y(Y)[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nperm</code></td>
<td>
<p>specifies the number of replicates to use for the permutation test. Defaults to <code>1000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>option</code></td>
<td>
<p>is a string that specifies which global correlation to build up-on. Defaults to <code>'mgc'</code>.
</p>

<dl>
<dt><code>'mgc'</code></dt>
<dd>
<p>use the MGC global correlation.</p>
</dd>
<dt><code>'dcor'</code></dt>
<dd>
<p>use the dcor global correlation.</p>
</dd>
<dt><code>'mantel'</code></dt>
<dd>
<p>use the mantel global correlation.</p>
</dd>
<dt><code>'rank'</code></dt>
<dd>
<p>use the rank global correlation.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no_cores</code></td>
<td>
<p>the number of cores to use for the permutations. Defaults to <code>1</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>P-value of MGC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>is the sample MGC statistic within <code>[-1,1]</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.localCorr</code></td>
<td>
<p>P-value of the local correlations by double matrix index.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>localCorr</code></td>
<td>
<p>the local correlations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimalScale</code></td>
<td>
<p>the optimal scale identified by MGC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>option</code></td>
<td>
<p>specifies which global correlation was used</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A test of independence using the MGC approach, described in Vogelstein et al. (2019). For <code class="reqn">X \sim F_X</code>, <code class="reqn">Y \sim F_Y</code>:
</p>
<p style="text-align: center;"><code class="reqn">H_0: F_X \neq F_Y</code>
</p>
<p> and: </p>
<p style="text-align: center;"><code class="reqn">H_A: F_X = F_Y</code>
</p>

<p>Note that one should avoid report positive discovery via minimizing individual p-values of local correlations,
unless corrected for multiple hypotheses.
</p>
<p>For details on usage see the help vignette:
<code>vignette("mgc", package = "mgc")</code>
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford and C. Shen
</p>


<h3>References</h3>

<p>Joshua T. Vogelstein, et al. "Discovering and deciphering relationships across disparate data modalities." eLife (2019).
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(mgc)

n = 100; d = 2
data &lt;- mgc.sims.linear(n, d)
# note: on real data, one would put nperm much higher (at least 100)
# nperm is set to 10 merely for demonstration purposes
result &lt;- mgc.test(data$X, data$Y, nperm=10)

## End(Not run)
</code></pre>


</div>