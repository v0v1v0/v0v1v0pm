<div class="container">

<table style="width: 100%;"><tr>
<td>kernel_matW</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>kernel_matW
A function that returns a sparse weight matrix based computed with a specified
kernel (gauss,bisq,tcub,epane,rectangle,triangle) considering coordinates
provides in S and a given bandwidth. If NN&lt;nrow(S) only NN firts neighbours are considered.
If Type!='GD' then S should have additional columns and several
kernels and bandwidths should be be specified by the user.</h2>

<h3>Description</h3>

<p>kernel_matW
A function that returns a sparse weight matrix based computed with a specified
kernel (gauss,bisq,tcub,epane,rectangle,triangle) considering coordinates
provides in S and a given bandwidth. If NN&lt;nrow(S) only NN firts neighbours are considered.
If Type!='GD' then S should have additional columns and several
kernels and bandwidths should be be specified by the user.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kernel_matW(H,kernels,coord_i,coord_j=NULL,NN,ncolX=1,
Type='GD',adaptive=FALSE,diagnull=TRUE,rowNorm=TRUE,noisland=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>A vector of bandwidths</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernels</code></td>
<td>
<p>A vector of kernel types</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coord_i</code></td>
<td>
<p>A matrix with  variables used in kernel (reference)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coord_j</code></td>
<td>
<p>A matrix with  variables used in kernel (neighbors), default NULL (if NULL coord_j=coord_i)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NN</code></td>
<td>
<p>Number of spatial Neighbours for kernels computations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncolX</code></td>
<td>
<p>control parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Type</code></td>
<td>
<p>Type of Genelarized kernel product ('GD' only spatial,'GDC'
spatial + a categorical variable,'GDX' spatial + a continuous variable,
'GDT' spatial + a time index, and other combinations 'GDXXC','GDTX',...)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>A vector of boolean to choose adaptive version for each kernel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnull</code></td>
<td>
<p>Zero on diagonal, default FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rowNorm</code></td>
<td>
<p>A boolean, row normalization of weights, default TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noisland</code></td>
<td>
<p>A boolean to avoid isle with no neighbours for non adaptive kernel, default FALSE</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A sparse Matrix of weights (dgCMatrix).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 ## Creating a spatial weight matrix (sparce dgCMatrix) of 4 nearest neighbors with 0 in diagonal
 W=kernel_matW(H=4,kernels='rectangle',coord_i=coords,NN=4,adaptive=TRUE,diagnull=TRUE,rowNorm=TRUE)

</code></pre>


</div>