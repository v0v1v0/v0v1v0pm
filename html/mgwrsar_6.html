<div class="container">

<table style="width: 100%;"><tr>
<td>MGWRSAR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of linear and local linear model with spatial autocorrelation model (mgwrsar).</h2>

<h3>Description</h3>

<p>MGWRSAR is is a wrapper function for estimating linear and local linear models
with spatial autocorrelation (SAR models with spatially varying coefficients).
</p>


<h3>Usage</h3>

<pre><code class="language-R">MGWRSAR(formula,data,coords,fixed_vars=NULL,kernels,H,
Model='GWR',control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a dataframe or a spatial dataframe (sp package).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>default NULL, a dataframe or a matrix with coordinates, not
required if data is a spatial dataframe.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_vars</code></td>
<td>
<p>a vector with the names of spatiallay constant coefficient for
mixed model. All other variables present in formula are supposed to be spatially
varying. If empty or NULL (default), all variables in formula are supposed to be
spatially varying.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernels</code></td>
<td>
<p>A vector containing the kernel types. Possible types:
rectangle ("rectangle"), bisquare ("bisq"), tricube ("tcub"), epanechnikov ("epane"), gaussian
("gauss")) .</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>vector containing the bandwidth parameters for the kernel functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Model</code></td>
<td>
<p>character containing the type of model: Possible values are "OLS",
"SAR", "GWR" (default), "MGWR" , "MGWRSAR_0_0_kv","MGWRSAR_1_0_kv",
"MGWRSAR_0_kc_kv", "MGWRSAR_1_kc_kv", "MGWRSAR_1_kc_0". See Details for more
explanation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list of extra control arguments for MGWRSAR wrapper - see Details below</p>
</td>
</tr>
</table>
<h3>Details</h3>


<dl>
<dt>Z</dt>
<dd>
<p> a matrix of variables for genralized kernel product, default NULL.</p>
</dd>
<dt>W</dt>
<dd>
<p> a row-standardized spatial weight matrix for Spatial Aurocorrelation, default NULL.</p>
</dd>
<dt>type</dt>
<dd>
<p> verbose mode, default FALSE.</p>
</dd>
<dt>adaptive</dt>
<dd>
<p>A vector of boolean to choose adaptive version for each kernel.</p>
</dd>
<dt>kernel_w</dt>
<dd>
<p> the type of kernel for computing W, default NULL.</p>
</dd>
<dt>h_w</dt>
<dd>
<p> the bandwidth value for computing W, default 0.</p>
</dd>
<dt>Method</dt>
<dd>
<p> estimation technique for computing the models with Spatial Dependence. '2SLS' or 'B2SLS', default '2SLS'.</p>
</dd>
<dt>TP</dt>
<dd>
<p> A vector of target points, default NULL.</p>
</dd>
<dt>doMC</dt>
<dd>
<p>Parallel computation, default FALSE</p>
</dd>
<dt>ncore</dt>
<dd>
<p>number of CPU core for parallel computation, default 1</p>
</dd>
<dt>isgcv</dt>
<dd>
<p> computing LOOCV criteria (for example for selecting optimal bandwidth), default FALSE.</p>
</dd>
<dt>isfgcv</dt>
<dd>
<p> if TRUE, simplify the computation of CV criteria (remove or not i
when using local instruments for model with lambda spatially varying), default TRUE.</p>
</dd>
<dt>maxknn</dt>
<dd>
<p> when n &gt;NmaxDist, only the maxknn first neighbours are used for distance compution, default 500.</p>
</dd>
<dt>NmaxDist</dt>
<dd>
<p> when n &gt;NmaxDist only the maxknn first neighbours are used for distance compution, default 5000</p>
</dd>
<dt>verbose</dt>
<dd>
<p> verbose mode, default FALSE.</p>
</dd>
</dl>
<h3>Value</h3>

<p>MGWRSAR returns an object of class mgwrsar with at least the following components:
</p>

<dl>
<dt>Betav</dt>
<dd>
<p> matrix of coefficients of dim(n,kv) x kv.</p>
</dd>
<dt>Betac</dt>
<dd>
<p> vector of coefficients of length kc.</p>
</dd>
<dt>Model</dt>
<dd>
<p> The sum of square residuals.</p>
</dd>
<dt>Y</dt>
<dd>
<p> The dependent variable.</p>
</dd>
<dt>XC</dt>
<dd>
<p> The explanatory variables with constant coefficients.</p>
</dd>
<dt>XV</dt>
<dd>
<p> The explanatory variables with varying coefficients.</p>
</dd>
<dt>X</dt>
<dd>
<p> The explanatory variables.</p>
</dd>
<dt>W</dt>
<dd>
<p> The spatial weight matrix for spatial dependence.</p>
</dd>
<dt>isgcv</dt>
<dd>
<p> if gcv has been computed.</p>
</dd>
<dt>edf</dt>
<dd>
<p> The estimated degrees of freedom.</p>
</dd>
<dt>formula</dt>
<dd>
<p>The formula.</p>
</dd>
<dt>data</dt>
<dd>
<p> The dataframe used for computation.</p>
</dd>
<dt>Method</dt>
<dd>
<p> The type of model.</p>
</dd>
<dt>coords</dt>
<dd>
<p> The spatial coordinates of observations.</p>
</dd>
<dt>H</dt>
<dd>
<p> The bandwidth vector.</p>
</dd>
<dt>fixed_vars</dt>
<dd>
<p> The names of constant coefficients.</p>
</dd>
<dt>kernels</dt>
<dd>
<p> The kernel vector.</p>
</dd>
<dt>SSR</dt>
<dd>
<p> The sum of square residuals.</p>
</dd>
<dt>residuals</dt>
<dd>
<p> The vector of residuals.</p>
</dd>
<dt>fit</dt>
<dd>
<p> the vector of fitted values.</p>
</dd>
<dt>sev</dt>
<dd>
<p> local standard error of parameters.</p>
</dd>
<dt>get_ts</dt>
<dd>
<p>Boolean, if trace of hat matrix Tr(S) should be stored.</p>
</dd>
<dt>NN</dt>
<dd>
<p> Maximum number of neighbors for weights computation</p>
</dd>
</dl>
<p>MGWRSAR is is a wrapper function for estimating linear and local linear model
with spatial autocorrelation that  allows to estimate the following models :
<code class="reqn">y=\beta_c X_c+\,\epsilon_i</code> (OLS)
</p>
<p><code class="reqn">y=\beta_v(u_i,v_i) X_v+\,\epsilon_i</code> (GWR)
</p>
<p><code class="reqn">y=\beta_c X_c+\beta_v(u_i,v_i) X_v+\,\epsilon_i</code> (MGWR)
</p>
<p><code class="reqn">y=\lambda Wy+\beta_c X_c+\,\epsilon_i</code> (MGWR-SAR(0,k,0))
</p>
<p><code class="reqn">y=\lambda Wy+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(0,0,k))
</p>
<p><code class="reqn">y=\lambda Wy+\beta_c X_c+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(0,k_c,k_v))
</p>
<p><code class="reqn">y=\lambda(u_i,v_i) Wy+\beta_c X_c+\,\epsilon_i</code> (MGWR-SAR(1,k,0))
</p>
<p><code class="reqn">y=\lambda(u_i,v_i)Wy+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(1,0,k))
</p>
<p><code class="reqn">y=\lambda(u_i,v_i)Wy+\beta_cX_c+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(1,k_c,k_v))
</p>
<p>When model imply spatial autocorrelation, a row normalized spatial weight matrix must be provided.
2SLS and Best 2SLS method can be used.
When model imply local regression, a bandwidth and a kernel type must be provided. Optimal bandwidth can be estimated
using bandwidths_mgwrsar function.
When model imply mixed local regression, the names of stationary covariates must be provided.
</p>
<p>#' In addition to the ability of considering spatial autocorrelation in GWR/MGWR like models,
MGWRSAR function introduces several useful technics for estimating local regression with space coordinates:
</p>

<ul>
<li>
<p>it uses RCCP and RCCPeigen code that speed up computation and allows parallel computing via doMC package;
</p>
</li>
<li>
<p>it allows to drop out variables with not enough local variance in local regression, which allows to consider dummies in GWR/MGWR framework without trouble.
</p>
</li>
<li>
<p>it allows to drop out local outliers in local regression.
</p>
</li>
<li>
<p>it allows to consider additional variable for kernel, including  time (asymetric kernel) and categorical variables (see Li and Racine 2010). Experimental version.
</p>
</li>
</ul>
<h3>References</h3>

<p>Geniaux, G. and Martinetti, D. (2017). A new method for dealing simultaneously with spatial autocorrelation and spatial heterogeneity in regression models. Regional Science and Urban Economics. (https://doi.org/10.1016/j.regsciurbeco.2017.04.001)
</p>
<p>McMillen, D. and Soppelsa, M. E. (2015). A conditionally parametric probit model of
microdata land use in chicago. Journal of Regional Science, 55(3):391-415.
</p>
<p>Loader, C. (1999). Local regression and likelihood, volume 47. springer New York.
</p>
<p>Franke, R. and Nielson, G. (1980). Smooth interpolation of large sets of scattered data.
International journal for numerical methods in engineering, 15(11):1691-1704.
</p>


<h3>See Also</h3>

<p>bandwidths_mgwrsar, summary_mgwrsar, plot_mgwrsar, predict_mgwrsar, kernel_matW
</p>


<h3>Examples</h3>

<pre><code class="language-R">
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 ## Creating a spatial weight matrix (sparce dgCMatrix)
 ## of 4 nearest neighbors with 0 in diagonal
 W=kernel_matW(H=4,kernels='rectangle',coord_i=coords,NN=4,adaptive=TRUE,
 diagnull=TRUE,rowNorm=TRUE)
 mgwrsar_0_kc_kv&lt;-MGWRSAR(formula = 'Y_mgwrsar_0_kc_kv~X1+X2+X3', data = mydata,
 coords=coords, fixed_vars='X2',kernels=c('gauss'),H=20, Model = 'MGWRSAR_0_kc_kv',
 control=list(SE=FALSE,adaptive=TRUE,W=W))
 summary_mgwrsar(mgwrsar_0_kc_kv)

</code></pre>


</div>