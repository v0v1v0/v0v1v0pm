<div class="container">

<table style="width: 100%;"><tr>
<td>estimate.wqs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Weighted Quantile Sum (WQS) Regression</h2>

<h3>Description</h3>

<p>Performs weighted quantile sum (WQS) regression model for continuous, binary, and count outcomes that was extended from <code>wqs.est</code> (author: Czarnota) in the <span class="pkg">wqs</span> package. By default, if there is any missing data, the missing data is assumed to be censored and placed in the first quantile.  Accessory functions (print, coefficient, plot) also accompany each WQS object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimate.wqs(
  y,
  X,
  Z = NULL,
  proportion.train = 1L,
  n.quantiles = 4L,
  place.bdls.in.Q1 = if (anyNA(X)) TRUE else FALSE,
  B = 100L,
  b1.pos = TRUE,
  signal.fn = c("signal.none", "signal.converge.only", "signal.abs",
    "signal.test.stat"),
  family = c("gaussian", "binomial", "poisson"),
  offset = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Outcome: numeric vector or factor. Assumed to be complete, and missing outcomes are ignored. Assumed to follow an exponential family distribution given in <code>family</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Components/chemicals to be combined into an index; a numeric matrix or data-frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>Any covariates used. Ideally, a numeric matrix, but Z can be a factor, vector or data-frame. Assumed to be complete; observations with missing covariate values are ignored with a warning printed. If none, enter NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proportion.train</code></td>
<td>
<p>The proportion of data between 0 and 1 used to train the model. If proportion.train = 1L, all the data is used to both train and validate the model. Default: 1L.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.quantiles</code></td>
<td>
<p>An integer specifying the number of quantiles in categorizing the columns of X, e.g. in quartiles (q = 4), deciles (q = 10), or percentiles (q = 100). Default: 4L.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>place.bdls.in.Q1</code></td>
<td>
<p>Logical; if TRUE or X has any missing values, missing values in X are placed in the first quantile of the weighted sum.  Otherwise, the data is complete (no missing data) and the data is equally split into quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Number of bootstrap samples to be used in estimating the weights in the training dataset. In order to use WQS without bootstrapping, set B = 1. However, Carrico et al 2014 suggests that bootstrap some large number (like 100 or 1000) can increase component selection. In that spirit, we set the default to 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b1.pos</code></td>
<td>
<p>Logical; TRUE if the mixture index is expected to be positively related to the outcome (the default). If mixture index is expected to be inversely related to the outcome, put FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signal.fn</code></td>
<td>
<p>A character value indicating which signal function is used in calculating the mean weight. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The distribution of outcome y. A character value:
if equal to "gaussian" a linear model is implemented;
if equal to "binomial" a logistic model is implemented;
if equal to "poisson", a log-link (rate or count) model is implemented.
See <code>family</code> in the <span class="pkg">stats</span> package. Passed to <span class="pkg">glm2</span>. Default: "gaussian".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>The at-risk population used as a numeric vector of length equal to the number of subjects when modeling rates in Poisson regression. Passed to <span class="pkg">glm2</span>.  Default: If there is no offset, enter NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical; if TRUE, prints more information. Useful to check for any errors in the code. Default: FALSE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <cite>solnp</cite> algorithm, or a nonlinear optimization technique using augmented Lagrange method, is used to estimate the weights in the training set. If the log likelihood evaluated at the current parameters is too large (NaN), the log likelihood is reset to be 1e24.
A data-frame with object name <em>train.estimates</em> that summarizes statistics from the nonlinear regression is returned; it consists of these columns:
</p>

<dl>
<dt>beta1</dt>
<dd>
<p>estimate using solnp</p>
</dd>
<dt>beta1_glm, SE_beta1, test_stat, pvalue</dt>
<dd>
<p>estimates of WQS parameter in model using glm2.</p>
</dd>
<dt>convergence</dt>
<dd>
<p>logical, if TRUE the solnp solver has converged. See <cite>solnp</cite>.</p>
</dd>
<dt>weight estimates</dt>
<dd>
<p>estimates of weight for each bootstrap.</p>
</dd>
</dl>
<p>Signal functions allow the user to adjust what bootstraps are used in calculating the mean weight. Looking at a histogram of the overall mixture effect, which is an element after plotting a WQS object, may help you to choose a signal function. The <em>signal.fn</em> argument allows the user to choose between four signal functions:
</p>

<dl>
<dt>signal.none</dt>
<dd>
<p>Uses all bootstrap-estimated weights in calculating average weight.</p>
</dd>
<dt>signal.converge.only</dt>
<dd>
<p>Uses the estimated weights for the bootstrap samples that converged.</p>
</dd>
<dt>signal.abs</dt>
<dd>
<p>Applies more weight to the absolute value of test statistic for beta1, the overall mixture effect in the trained WQS model.</p>
</dd>
<dt>signal.test stat</dt>
<dd>
<p>Applies more weight to the absolute value of test statistic for beta1, the overall mixture effect in the trained WQS model.</p>
</dd>
</dl>
<p>This package uses the <cite>glm2</cite> function in the <span class="pkg">glm2</span> package to fit the validation model.
</p>
<p>The object is a member of the <em>"wqs"</em> class; accessory functions include <code>coef</code>(), <code>print</code>(), and <code>plot</code>().
</p>
<p>See example 1 in the vignette for details.
</p>


<h3>Value</h3>

<p><code>estimate.wqs</code> returns an object of class "wqs". A list with the following items: (** important) </p>

<dl>
<dt>call</dt>
<dd>
<p>The function call, processed by <span class="pkg">rlist</span>.</p>
</dd>
<dt>C</dt>
<dd>
<p>The number of chemicals in mixture, number of columns in X.</p>
</dd>
<dt>n</dt>
<dd>
<p>The sample size.</p>
</dd>
<dt>train.index</dt>
<dd>
<p>Vector, The numerical indices selected to form the training dataset. Useful to do side-by-side comparisons.</p>
</dd>
<dt>q.train</dt>
<dd>
<p>Matrix of quantiles used in training data. </p>
</dd>
<dt>q.valid</dt>
<dd>
<p>Matrix of quantiles used in validation data. </p>
</dd>
<dt>train.comparison</dt>
<dd>
<p>Data-frame that compares the training and validation datasets to validate equivalence </p>
</dd>
<dt>initial</dt>
<dd>
<p>Vector: Initial values used in WQS.</p>
</dd>
<dt>train.estimates</dt>
<dd>
<p>Data-frame with rows = B. Summarizes statistics from nonlinear regression in training dataset. See details.</p>
</dd>
<dt>processed.weights</dt>
<dd>
<p>** A C x 2 matrix, mean bootstrapped weights (and their standard errors) after filtering with the signal function (see <code>signal.fn</code>). Used to calculate the WQS index.</p>
</dd>
<dt>WQS</dt>
<dd>
<p>Vector of the weighted quantile sum estimate based on the processed weights. </p>
</dd>
<dt>fit</dt>
<dd>
<p>** glm2 object of the WQS model fit using the validation data. See <code>glm2{glm2}</code>.</p>
</dd>
<dt>boot.index</dt>
<dd>
<p>Matrix of bootstrap indices used in training dataset to estimate the weights. Its dimension is the length of training dataset with number of columns = B.</p>
</dd>
</dl>
<h3>Rate WQS Regression</h3>

<p>Rates can be modelled using the offset. The <em>offset</em> argument of <code>estimate.wqs()</code> function is on the normal scale, so please do not take a logarithm.  The objective function used to model the mean rate of the <em>ith</em> individual <code class="reqn">\lambda_i</code> with the offset is:
</p>
<p style="text-align: center;"><code class="reqn"> \lambda_i = offset * exp(\eta) </code>
</p>

<p>, where <code class="reqn">\eta</code> is the linear term of a regression.
</p>


<h3>Note</h3>

<p>No seed is set in this function.  Because bootstraps and splitting is random, a seed should be set before every use.
</p>


<h3>References</h3>

<p>Carrico, C., Gennings, C., Wheeler, D. C., &amp; Factor-Litvak, P. (2014). Characterization of Weighted Quantile Sum Regression for Highly Correlated Data in a Risk Analysis Setting. Journal of Agricultural, Biological, and Environmental Statistics, 20(1), 100–120. https://doi.org/10.1007/s13253-014-0180-3
</p>
<p>Czarnota, J., Gennings, C., Colt, J. S., De Roos, A. J., Cerhan, J. R., Severson, R. K., … Wheeler, D. C. (2015). Analysis of Environmental Chemical Mixtures and Non-Hodgkin Lymphoma Risk in the NCI-SEER NHL Study. Environmental Health Perspectives, 123(10), 965–970.  https://doi.org/10.1289/ehp.1408630
</p>
<p>Czarnota, J., Gennings, C., &amp; Wheeler, D. C. (2015). Assessment of Weighted Quantile Sum Regression for Modeling Chemical Mixtures and Cancer Risk. Cancer Informatics, 14, 159–171. https://doi.org/10.4137/CIN.S17295
</p>


<h3>See Also</h3>

<p>Other wqs: 
<code>analyze.individually()</code>,
<code>coef.wqs()</code>,
<code>do.many.wqs()</code>,
<code>estimate.wqs.formula()</code>,
<code>make.quantile.matrix()</code>,
<code>plot.wqs()</code>,
<code>print.wqs()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1: Binary outcome using the example simulated dataset in this package.
data(simdata87)
set.seed(23456)
W.bin4  &lt;- estimate.wqs(
  y = simdata87$y.scenario, X = simdata87$X.true[, 1:9],
  B = 10, family = "binomial",
  verbose = TRUE
)
W.bin4

# Example 2: Continuous outcome. Use WQSdata example from wqs package.
## Not run: 
if (requireNamespace("wqs", quietly = TRUE)) {
  library(wqs)
  data(WQSdata)
  set.seed(23456)
  W &lt;- wqs::wqs.est(WQSdata$y, WQSdata[, 1:9], B = 10)
  Wa &lt;- estimate.wqs (y = WQSdata$y, X = WQSdata[, 1:9], B = 10)
  Wa
} else {
  message("You need to install the package wqs for this example.")
}

## End(Not run)

## More examples are found 02_WQS_Examples.
## Also checked vs. Czarnota code, as well as thesis data, to verify results.

</code></pre>


</div>