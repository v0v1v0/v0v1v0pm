<div class="container">

<table style="width: 100%;"><tr>
<td>impute.boot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bootstrapping Imputation for Many Chemicals</h2>

<h3>Description</h3>

<p>If many chemicals have values below the detection limit, this function creates an imputed dataset using a bootstrap procedure as described in Lubin et al. 2004. It repeatedly invokes <code>impute.Lubin</code>().
</p>


<h3>Usage</h3>

<pre><code class="language-R">impute.boot(X, DL, Z = NULL, K = 5L, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A numeric vector, matrix, or data-frame of chemical concentration levels with n subjects and C chemicals to be imputed. Missing values are indicated by NA's.  Ideally, a numeric matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DL</code></td>
<td>
<p>The detection limit for each chemical as a numeric vector with length equal to C chemicals. Vector must be complete (no NA's); any chemical that has a missing detection limit is not imputed. If DL is a data-frame or matrix with 1 row or 1 column, it is forced as a numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>Any covariates used in imputing the chemical concentrations.  Ideally, a numeric matrix; however, Z can be a factor, vector, or data-frame. Assumed to be complete; observations with missing covariate variables are ignored in the imputation, with a warning printed. If none, enter NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>A natural number of imputed datasets to generate. Default: 5L.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical; if TRUE, prints more information. Useful to check for any errors in the code. Default: FALSE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Lubin et al. (2004) evaluate several imputation approaches and show that a multiple imputation procedure using bootstrapping creates unbiased estimates and nominal confidence intervals unless the proportion of missing data is extreme. The authors coded the multiple imputation procedure in a SAS macro that is currently available. We converted the SAS macro into R code.
</p>
<p>The <code>impute.Lubin</code>() function imputes a single chemical with missing values. The distribution for the interval-censored data <em>chemcol</em> is assumed to be   lognormal and censored between 0 and <em>DL</em>. After bootstrapping, the values BDL are imputed  using the inverse transform method. In other words, generate <code class="reqn">u_i \sim Unif( 0.0001, dlcol)</code> and assign value <code class="reqn">F^{-1}(u)</code> to <code class="reqn">x_{i}</code> for <code class="reqn">i = 1,...n_{0}</code> subjects with chemical values BDL.
</p>
<p>In order to impute a single chemical:
</p>

<ol>
<li>
<p> Input arguments.
</p>
</li>
<li>
<p> Obtain bootstrap samples.
</p>
</li>
<li>
<p> Generate weights vector.
</p>
</li>
<li>
<p> Use <code>Surv</code> function from Survival package to obtain survival object.
</p>
</li>
<li>
<p> Use <code>survreg</code> function from Survival package to obtain survival model.
</p>
</li>
<li>
<p> Sample from lognormal distribution with beta and variance from survival model as the parameters to obtain upper and lower bounds.
</p>
</li>
<li>
<p> Randomly generate value from uniform distribution between the previously obtained upper and lower bounds.
</p>
</li>
<li>
<p> Sample from the lognormal distribution to obtain the imputed data value associated with the above uniform value.
</p>
</li>
</ol>
<p><code>impute.boot()</code> repeatedly performs this procedure for all chemicals.
</p>


<h3>Value</h3>

<p>A list of: </p>

<dl>
<dt>X.imputed</dt>
<dd>
<p>A number of subjects (n) x number of chemicals (c) x K array of imputed X values.</p>
</dd>
<dt>bootstrap_index</dt>
<dd>
<p>A n x K matrix of bootstrap indices selected for the imputation.</p>
</dd>
<dt>indicator.miss</dt>
<dd>
<p>A check; the sum of imputed  missing values above detection limit,
which should be 0.</p>
</dd>
</dl>
<h3>Note</h3>

<p>Note #1: Code was adapted from Erin E. Donahue's original translation of the SAS macro developed from the paper.
</p>
<p>Note #2: No seed is set. Please set seed so the same bootstraps are selected.
</p>
<p>Note #3: If the length of the DL parameter is greater than the number of components, the smallest value is assumed to be a detection limit. A warning is printed to the screen.
</p>


<h3>References</h3>

<p>Lubin, J. H., Colt, J. S., Camann, D., Davis, S., Cerhan, J. R., Severson, R. K., … Hartge, P. (2004).
Epidemiologic Evaluation of Measurement Data in the Presence of Detection Limits. Environmental Health Perspectives,
112(17), 1691–1696. https://doi.org/10.1289/ehp.7199
</p>


<h3>See Also</h3>

<p>Other imputation: 
<code>impute.Lubin()</code>,
<code>impute.multivariate.bayesian()</code>,
<code>impute.sub()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("simdata87")
# Impute using one covariate.
l &lt;- impute.boot(X = simdata87$X.bdl, DL = simdata87$DL, Z = simdata87$Z.sim[, 1],
  K = 2, verbose = TRUE
)
apply(l$X.imputed, 2:3, summary)
</code></pre>


</div>