<div class="container">

<table style="width: 100%;"><tr>
<td>03change</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make Changes to Discretionary Characteristics of Missing Variables</h2>

<h3>Description</h3>

<p>These methods change the family, imputation method, size, type, and
so forth of a <code>missing_variable</code>. They are typically
called immediately before calling <code>mi</code> because they
affect how the conditional expectation of each <code>missing_variable</code>
is modeled.
</p>


<h3>Usage</h3>

<pre><code class="language-R">change(data, y, to, what, ...)
change_family(data, y, to, ...)
change_imputation_method(data, y, to, ...)
change_link(data, y, to, ...)
change_model(data, y, to, ...)
change_size(data, y, to, ...)
change_transformation(data, y, to, ...)
change_type(data, y, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>missing_data.frame</code> (typically) but can be missing for all but
the <code>change</code> function
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A character vector (typically) naming one or more <code>missing_variable</code>s
within the <code>missing_data.frame</code> specified by the <b>data</b> argument. 
Alternatively, <b>y</b> can be the name of a class that inherits from 
<code>missing_variable</code>, in which case all <code>missing_variable</code>s of
that class within <code>data</code> will be changed. Can also be an vector of integers or a 
logical vector indicating which <code>missing_variable</code>s to change.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>Typically a character string naming what is to be changed, such
as <code>"family"</code>, <code>"imputation_method"</code>, <code>"size"</code>, <code>"transformation"</code>, 
<code>"type"</code>, <code>"link"</code>, or <code>"model"</code>. Alternatively, it can be a scalar value, 
in which case all occurances of that value for the variable indicated by <code>y</code> will be changed to
the value indicated by <code>to</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>Typically a character string naming what <code>y</code> should be changed to, 
such as one of the admissible families, imputation methods, transformations, or types.
If missing, then possible choices for the <code>to</code> argument will be helpfully printed
on the screen. If <code>what</code> is a number, then <code>to</code> should be the number (or <code>NA</code>)
that the value designated by <code>what</code> will be recoded to. See the Details section for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments, not currently utilized</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In order to run <code>mi</code> correctly, data must first be specified to be ready for multiple imputation using the <code>missing_data.frame</code> function.  For each variable, <code>missing_data.frame</code> will record information required by <code>mi</code>: the variable's type, distribution family, and link function; whether a variable should be standardized or tranformed by a log function or square root; what specific model to use for the conditional distribution of the variable in the <code>mi</code> algorithm and how to draw imputed values from this model; and whether additional rows (for the purposes of prediction) are required. <code>missing_data.frame</code> will attempt to guess the correct type, family, and link for each variable based on its class in a regular <code>data.frame</code>.  These guesses can be checked with <code>show</code> and adjusted if necessary with <code>change</code>.  Any further additions to the model in regards to variable transformations, custom conditional models, or extra non-observed predictive cases must be specified with <code>change</code> before <code>mi</code> is run.
</p>
<p>In general, most users will only use the <code>change</code> command.  <code>change</code> will then call <code>change_family</code>, <code>change_imputation_method</code>, <code>change_link</code>, <code>change_model</code>, <code>change_size</code>, <code>change_transformation</code>, or <code>change_type</code> depending on what characteristic is specified with the <code>what</code> option. The other change_* functions can be called directly but are primarily intended to be called indirectly by the change function.
</p>

<dl>
<dt><code>what = "type"</code></dt>
<dd>
<p>Change the subclass of variable(s) <code>y</code>.  <code>to</code> should be a character vector whose elements are subclasses of the <code>missing_variable-class</code> and are documented further there. Among the most commonly used subclasses are <code>"unordered-categorical"</code>, <code>"ordered-categorical"</code>, <code>"binary"</code>, <code>"interval"</code>, <code>"continuous"</code>, <code>"count"</code>, and <code>"irrelevant"</code>.</p>
</dd>
<dt><code>what = "family"</code></dt>
<dd>
<p>Change the distribution family for variable(s) <code>y</code>. <code>to</code> must be of class <code>family</code> or a list where each element is of class <code>family</code>. If a variable is of <code>binary-class</code>, then the family must be <code>binomial</code> (the default) or possibly <code>quasibinomial</code>. If a variable is of <code>ordered-categorical-class</code> or <code>unordered-categorical-class</code>, use the <code>multinomial</code> family. If a variable is of <code>count-class</code>, then the family must be <code>quasipoisson</code> (the default) or <code>poisson</code>. If a variable is continuous, there are more choices for its family, but <code>gaussian</code> is the default and the others are not supported yet.</p>
</dd>
<dt><code>what = "link"</code></dt>
<dd>
<p>Change the link function for variable(s) <code>y</code>. <code>to</code> can be any of the supported link functions for the existing <b>family</b>. See <code>family</code> for details; however, not all of these link functions have appropriate <code>fit_model</code> and <code>mi-methods</code> yet.</p>
</dd>
<dt><code>what = "model"</code></dt>
<dd>
<p>Change the conditional model for variable <code>y</code>. It usually is not necessary to change the model, since it is actually determined by the class, family, and link function of the variable.  This option can be used, however, to employ models that are not among those listed above.<code>to</code> should be a character vector of length one indicating what model should be used during the imputation process. Valid choices for binary variables include <code>"logit"</code>, <code>"probit"</code> <code>"cauchit"</code>, <code>"cloglog"</code>, or quasilikelihoods <code>"qlogit"</code>, <code>"qprobit"</code>, <code>"qcauchit"</code>, <code>"qcloglog"</code>.  For ordinal variables, valid choices include <code>"ologit"</code>, <code>"oprobit"</code>, <code>"ocauchit"</code>, and <code>"ocloglog"</code>.  For count variables, valid choices include <code>"qpoisson"</code> and <code>"poisson"</code>. Currently the only valid option for gaussian variables is <code>"linear"</code>. To change the model for unordered-categorical variables, see the estimator slot in <code>missing_variable</code>.</p>
</dd>
<dt><code>what = "imputation_method"</code></dt>
<dd>
<p>Change the method for drawing imputed values from the conditional model specified for variable(s) <code>y</code>. <code>to</code> should be a character vector of length one or of the same length as <code>y</code> naming one of the following imputation methods: <code>"ppd"</code> (posterior predictive distribution), <code>"pmm"</code> (predictive mean matching), <code>"mean"</code> (mean imputation), <code>"median"</code> (median imputation), <code>"expectation"</code> (conditional expectation imputation).</p>
</dd>
<dt><code>what = "size"</code></dt>
<dd>
<p>Optionally add additional rows for the purposes of prediction.  <code>to</code> should be a single integer. If <code>to</code> is non-negative but less than the number of rows in the <code>missing_data.frame</code> given by the <code>data</code> argument, then <code>missing_data.frame</code> is augmented with <code>to</code> more rows, where all the additional observations are missing. If <code>to</code> is greater than the number of rows in the <code>missing_data.frame</code>given by the <code>data</code> argument, then the <code>missing_data.frame</code> is extended to have <code>to</code> rows, where the observations in the surplus rows are missing. If <code>to</code> is negative, then any additional rows in the <code>missing_data.frame</code> given by the <code>data</code> argument are removed to restore it to its original size.</p>
</dd>
<dt><code>what = "transformation"</code></dt>
<dd>
<p>Specify a particular transformation to be applied to variable(s) <code>y</code>. <code>to</code> should be a character vector of length one or of
the same length as <code>y</code> indicating what transformation function to use. Valid choices are <code>"identity"</code> for no transformation, <code>"standardize"</code> for standardization (using twice the standard deviation of the observed values), <code>"log"</code> for natural logarithm transformation, <code>"logshift"</code> for a <code>log(y + a)</code> transformation where <code>a</code> is a small constant, or <code>"sqrt"</code> for square-root transformation. Changing the transformation will also change the inverse transformation in the appropriate way. Any other value of <code>to</code> will produce an informative error message indicating that the transformation and inverse transformation need to be changed manually.</p>
</dd>
<dt>what = a value</dt>
<dd>
<p>Finally, if both <code>what</code> and <code>to</code> are values then the former is recoded to the latter for all
occurances within the missing variable indicated by <code>y</code>.</p>
</dd>
</dl>
<h3>Value</h3>

<p>If the <b>data</b> argument is not missing, then the method returns this argument with the 
specified changes. If <b>data</b> is missing, then the method returns an object that inherits 
from the <code>missing_variable-class</code> with the specified changes.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code>missing_variable</code>, <code>missing_data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># STEP 0: GET DATA
data(nlsyV, package = "mi")

# STEP 1: CONVERT IT TO A missing_data.frame
mdf &lt;- missing_data.frame(nlsyV)
show(mdf)

# STEP 2: CHANGE WHATEVER IS WRONG WITH IT
mdf &lt;- change(mdf, y = "momrace", what = "type", to = "un")
mdf &lt;- change(mdf, y = "income", what = "imputation_method", to = "pmm")
mdf &lt;- change(mdf, y = "binary", what = "family", to = binomial(link = "probit"))
mdf &lt;- change(mdf, y = 5, what = "transformation", to = "identity")
show(mdf)
</code></pre>


</div>