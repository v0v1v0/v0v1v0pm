<div class="container">

<table style="width: 100%;"><tr>
<td>01missing_variable</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "missing_variable" and Inherited Classes</h2>

<h3>Description</h3>

<p>The missing_variable class is essentially the data comprising a variable plus all
the metadata needed to understand how its missing values will be imputed. However, no variable is
merely of missing_variable class; rather every variable is of a class that inherits from the 
missing_variable class. Even if a variable has no missing values, it needs to be coerced to a class 
that inherits from the missing_variable class before it can be used to impute values of other 
missing_variables. Understanding the properties of different subclasses of the missing_variable class 
is essential for modeling and imputing them. The <code>missing_data.frame-class</code> is essentially
a list of objects that inherit from the missing_variable class, plus metadata need to understand how
these missing_variables relate to each other.  Most users will never need to call <code>missing_variable</code> directly since it is called by <code>missing_data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">missing_variable(y, type, ...)
## Hidden arugments not included in the signature:
## favor_ordered = TRUE, favor_positive = FALSE, 
## variable_name = deparse(substitute(y))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Can be any vector, some of whose values may be <code>NA</code>, which will
comprise the <b>raw_data</b> slot of a missing_variable (see the Slots section). It is 
recommended that this vector <em>not</em> have any transformations, such as a log-transformation. 
Any continuous variable can be transformed using the function in its <b>transformation</b> slot. 
The transformations and other discretionary aspects of a missing_variable are typically changed
by calling the <code>change</code> function on a <code>missing_data.frame</code> 
See the Slots section for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Missing or a character string among the classes that inherit from the missing_variable
class. If missing, the constructor will guess (sometimes incorrectly) based on the characteristics 
of the variable. The best way to improve the guessing of categorical variables is to 
use the <code>factor</code> function — possibly with <code>ordered = TRUE</code> — to create
(possibly ordered) factors that will correctly be coerced to objects of 
<code>unordered-categorical-class</code> and <code>ordered-categorical-class</code> respectively. 
If you fail to do so, the hidden arguments that are not included in the signature affect the guesses. 
If <code>favor_ordered = TRUE</code>, which is the default, it will tend to guess that variables with few 
unique values are should be coerced to <code>ordered-categorical-class</code> and 
<code>unordered-categorical-class</code> otherwise. If <code>favor_positive = FALSE</code>, which is the 
default, it will tend to guess that variables with many unique values are merely continuous, whether 
or not all the observed values are positive. If <code>favor_positive = TRUE</code> nonnegative or positive
variables will get coerced to
<code>nonnegative-continuous-class</code> or <code>positive-continuous-class</code>. See the Slots
section and the specific help pages for more details on the subclasses.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further hidden arguments that are not in the signature. The <code>favor_ordered</code> and
<code>favor_positive</code> arguments are documented immediately above. The <code>variable</code> name argument
can be used to control what gets put in the <b>variable_name</b> slot, see the Slots section below.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The missing_variable function returns an object that inherits from the missing_variable class.
</p>


<h3>Objects from the Classes</h3>

<p>The missing_variable class is virtual, so no objects 
may be created from it. However, the missing_variable generic function can be used to 
instantiate an object that inherits from the missing_variable class by specifying its 
<code>type</code> argument. A user would call the <code>missing_data.frame</code>
function on a <code>data.frame</code>, which in turn calls the missing_variable function
on each column of the <code>data.frame</code> using various heuristics to guess the
<code>type</code> argument.
</p>


<h3>Slots</h3>

<p>In the following table, indentation indicates inheritance from the class with less indentation, and
italics indicates that the class is virtual so no variables can be created with that class. Inherited
classes inherit the transformations, families, link functions, and <code>fit_model-methods</code>
from their parent class, although these are often superceeded by analogues that are tailored for the
inherited class. Also note, the default transformation for the continuous class is a standardization 
using <em>twice</em> the standard deviation of the observed values.
</p>
<p>The distinction between the transformation entailed by the <code>family</code> and the transformation
entailed by the function in the <b>tranformation</b> slot may be confusing at this point. The former pertains
to how the linear predictor of a variable is mapped to the space of a variable when it is on the left-hand
side of a generalized linear model. The latter pertains — for continuous variables only — to how the
values in the <b>raw_data</b> slot are mapped into those in the <b>data</b> and thus affects how a continuous 
variable enters into the model whether it is on the left or right-hand side. The classes are discussed in 
much more detail below.
</p>

<table>
<tr>
<td style="text-align: left;">
    <b>Class name [transformation]</b>   </td>
<td style="text-align: left;"> <b>Default family and link</b> </td>
<td style="text-align: left;"> <b>Default <code>fit_model</code></b> </td>
</tr>
<tr>
<td style="text-align: left;">
    <em>missing_variable</em>            </td>
<td style="text-align: left;"> none                  </td>
<td style="text-align: left;"> throws error </td>
</tr>
<tr>
<td style="text-align: left;">
     <em>categorical</em>                  </td>
<td style="text-align: left;"> none        </td>
<td style="text-align: left;"> throws error </td>
</tr>
<tr>
<td style="text-align: left;">
      unordered-categorical         </td>
<td style="text-align: left;"> <code>binomial(link = 'logit')</code> </td>
<td style="text-align: left;"> <code>multinom</code> </td>
</tr>
<tr>
<td style="text-align: left;">
      ordered-categorical           </td>
<td style="text-align: left;"> <code>binomial(link = 'logit')</code> </td>
<td style="text-align: left;"> <code>bayespolr</code> </td>
</tr>
<tr>
<td style="text-align: left;">
       binary              </td>
<td style="text-align: left;"> <code>binomial(link = 'logit')</code> </td>
<td style="text-align: left;"> <code>bayesglm</code> </td>
</tr>
<tr>
<td style="text-align: left;">
       interval            </td>
<td style="text-align: left;"> <code>gaussian{link = 'identity'}</code> </td>
<td style="text-align: left;"> <code>survreg</code> </td>
</tr>
<tr>
<td style="text-align: left;">
     continuous[standardize]                 </td>
<td style="text-align: left;"> <code>gaussian{link = 'identity'}</code> </td>
<td style="text-align: left;"> <code>bayesglm</code> </td>
</tr>
<tr>
<td style="text-align: left;">
      semi-continuous[identity]     </td>
<td style="text-align: left;">                                     </td>
<td style="text-align: left;">                             </td>
</tr>
<tr>
<td style="text-align: left;">
       nonnegative-continuous[logshift] </td>
<td style="text-align: left;">                     </td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
        SC_proportion[squeeze] </td>
<td style="text-align: left;">  <code>binomial(link = 'logit')</code> </td>
<td style="text-align: left;"> <code>betareg</code> </td>
</tr>
<tr>
<td style="text-align: left;">
      positive-continuous[<code>log</code>]           </td>
<td style="text-align: left;">                    </td>
<td style="text-align: left;">                              </td>
</tr>
<tr>
<td style="text-align: left;">
       proportion[identity] </td>
<td style="text-align: left;">              <code>binomial(link = 'logit')</code> </td>
<td style="text-align: left;"> <code>betareg</code> </td>
</tr>
<tr>
<td style="text-align: left;">
      bounded-continuous[identity]  </td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
     count                           </td>
<td style="text-align: left;"> <code>quasipoisson{link = 'log'}</code>     </td>
<td style="text-align: left;">      <code>bayesglm</code>    </td>
</tr>
<tr>
<td style="text-align: left;">
     irrelevant                      </td>
<td style="text-align: left;">                                       </td>
<td style="text-align: left;">      throws error                   </td>
</tr>
<tr>
<td style="text-align: left;">
      fixed                 </td>
<td style="text-align: left;">                               </td>
<td style="text-align: left;">      throws error                   </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<p>The missing_variable class is virtual and has the following slots (this information is primarily directed at developeRs):
</p>

<dl>
<dt>
<code>variable_name</code>:</dt>
<dd>
<p>Object of class <code>character</code> of length one naming the variable</p>
</dd>
<dt>
<code>raw_data</code>:</dt>
<dd>
<p>Object of class <code>"ANY"</code> representing the observations
on a variable, some of which may be <code>NA</code>. No method should ever change 
this slot at all. Instead, methods should change the <b>data</b> slot.</p>
</dd>
<dt>
<code>data</code>:</dt>
<dd>
<p>Object of class <code>"ANY"</code>, which is initially a copy of the
<b>raw_data</b> slot — transformed by the function in the <b>transformation</b> slot 
for continuous variables only — and whose <code>NA</code> values are replaced during
the multiple imputation process. See <code>mi</code></p>
</dd>
<dt>
<code>n_total</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code> which is the <code>length</code>
of the <b>data</b> slot</p>
</dd>
<dt>
<code>all_obs</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code> of length one indicating whether
all values of the <b>data</b> slot are observed and thus not <code>NA</code> </p>
</dd>
<dt>
<code>n_obs</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code> of length one indicating the number
of values of the <b>data</b> slot that are observed and thus not <code>NA</code> </p>
</dd>
<dt>
<code>which_obs</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code>, which is a vector indicating 
the positions of the observed values in the <b>data</b> slot</p>
</dd>
<dt>
<code>all_miss</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code> of length one indicating whether
all values of the <b>data</b> slot are <code>NA</code> </p>
</dd>
<dt>
<code>n_miss</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code> of length one indicating the number
of values of the <b>data</b> slot that are <code>NA</code> </p>
</dd>
<dt>
<code>which_miss</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code>, which is a vector indicating
the positions of the missing values in the <b>data</b> slot </p>
</dd>
<dt>
<code>n_extra</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code> of length one indicating how many
(missing) observations have been added to the end of the <b>data</b> slot that are not
included in the <b>raw_data</b> slot. Although the extra values will be imputed, they
are not considered to be “missing” for the purposes of defining the previous
three slots</p>
</dd>
<dt>
<code>which_extra</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code>, which is a vector indicating
the positions of the extra values at the end of the <b>data</b> slot </p>
</dd>
<dt>
<code>n_unpossible</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code> of length one indicating the
number of values that are logically or structurally unobservable</p>
</dd>
<dt>
<code>which_unpossible</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code> indicating the positions
of the unpossible values in the <b>data</b> slot </p>
</dd> 
<dt>
<code>n_drawn</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code> of length one which is the sum of
the <b>n_miss</b> and <b>n_extra</b> slots</p>
</dd>
<dt>
<code>which_drawn</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code> which is a vector concatinating
the <b>which_miss</b> and <b>which_extra</b> slots </p>
</dd>
<dt>
<code>imputation_method</code>:</dt>
<dd>
<p>Object of class <code>"character"</code> of length one indicating
how the <code>NA</code> values are to be imputed. Possibilities include “ppd” for
imputation from the posterior predictive distribution, “pmm” for imputation via
predictive mean matching, “mean” for mean-imputation, “median” for 
median-imputation, “expectation” for conditional mean-imputation. With enough
programming effort, other kinds of imputation can be defined and specified here.</p>
</dd>
<dt>
<code>family</code>:</dt>
<dd>
<p>Object of class <code>"WeAreFamily"</code> that will typically be passed to 
<code>glm</code> and similar functions during the multiple imputation process</p>
</dd>
<dt>
<code>known_families</code>:</dt>
<dd>
<p>Object of class <code>character</code> indicating the families
that are known to be supported for a class; see <code>family</code></p>
</dd>
<dt>
<code>known_links</code>:</dt>
<dd>
<p>Object of class <code>character</code> indicating what link functions
are known to be supported by the elements of the <b>known_families</b> slot; see 
<code>family</code></p>
</dd>
<dt>
<code>imputations</code>:</dt>
<dd>
<p>Object of class <code>"MatrixTypeThing"</code> with rows equal to the number
of iterations (initially zero) of the multiple imputation algorithm and columns equal to the 
<b>n_drawn</b> slot. The rows are appropriately extended and then filled by the 
<code>mi</code> function</p>
</dd>
<dt>
<code>done</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code> of length one indicating whether the
<code>NA</code> values in the <b>data</b> slot have been replaced by imputed values</p>
</dd>
<dt>
<code>parameters</code>:</dt>
<dd>
<p>Object of class <code>"MatrixTypeThing"</code> with rows equal to the number
of iterations (initially zero) of the multiple imputation algorithm and columns equal to the number 
of estimated parameters when modeling the <b>data</b> slot. The rows are appropriately extended
and then filled by the <code>mi</code> function</p>
</dd>
<dt>
<code>model</code>:</dt>
<dd>
<p>Object of class <code>"ANY"</code> which can be filled by an object that is output
by one of the <code>fit_model-methods</code>, which is done by default by <code>mi</code>
when all the iterations have completed</p>
</dd>
<dt>
<code>fitted</code>:</dt>
<dd>
<p>Object of class <code>"ANY"</code> although typically a vector or matrix that 
contains the fitted values of the model in the slot immediately above. Note that the
<b>fitted</b> slot is filled by default by <code>mi</code>, although the <b>model</b> slot
is left empty by default to save RAM.</p>
</dd>
<dt>
<code>estimator</code>:</dt>
<dd>
<p>Object of class <code>"character"</code> of length one indicating which pre-existing 
<code>fit_model</code> to use for an unordered-categorical variable.  Options are <code>"mnl"</code>, in which 
<code>multinom</code> from the <span class="pkg">nnet</span> package is used to fit the values of the unordered 
categorical variable; and <code>"rnl"</code>, in which each category is separately modeled as the positive 
binary outcome against all other categories using a <code>bayesglm</code> <code>fit_model</code> and 
the probabilities of each category are normalized to sum to 1 after each model is run. In general, 
<code>"rnl"</code> is slightly less accurate than <code>"mnl"</code>, but runs much more quickly especially when 
the unordered categorical variable has many unique categories.</p>
</dd>
</dl>
<p>The WeAreFamily class is a class union of <code>character</code> and <code>family</code>, while the
MatrixTypeThing class is a class union of <code>matrix</code> only at the moment.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code>missing_data.frame</code>, <code>categorical-class</code>,  <code>unordered-categorical-class</code>, 
<code>ordered-categorical-class</code>, <code>binary-class</code>, <code>interval-class</code>, 
<code>continuous-class</code>, <code>semi-continuous-class</code>, <code>nonnegative-continuous-class</code>,
<code>SC_proportion-class</code>, <code>censored-continuous-class</code>, 
<code>truncated-continuous-class</code>, <code>bounded-continuous-class</code>, 
<code>positive-continuous-class</code>, <code>proportion-class</code>, <code>count-class</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># STEP 0: GET DATA
data(nlsyV, package = "mi")

# STEP 0.5 CREATE A missing_variable (you never need to actually do this)
income &lt;- missing_variable(nlsyV$income, type = "continuous")
show(income)

# STEP 1: CONVERT IT TO A missing_data.frame
mdf &lt;- missing_data.frame(nlsyV) # this calls missing_variable() internally
show(mdf)
</code></pre>


</div>