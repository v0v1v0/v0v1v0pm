<div class="container">

<table style="width: 100%;"><tr>
<td>mice.impute.norm.nob</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Imputation by linear regression without parameter uncertainty</h2>

<h3>Description</h3>

<p>Imputes univariate missing data using linear regression analysis without
accounting for the uncertainty of the model parameters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mice.impute.norm.nob(y, ry, x, wy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector to be imputed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other named arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function creates imputations using the spread around the
fitted linear regression line of <code>y</code> given <code>x</code>, as
fitted on the observed data.
</p>
<p>This function is provided mainly to allow comparison between proper (e.g.,
as implemented in <code>mice.impute.norm</code> and improper (this function)
normal imputation methods.
</p>
<p>For large data, having many rows, differences between proper and improper
methods are small, and in those cases one may opt for speed by using
<code>mice.impute.norm.nob</code>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Warning</h3>

<p>The function does not incorporate the variability of the
regression weights, so it is not 'proper' in the sense of Rubin. For small
samples, variability of the imputed data is therefore underestimated.
</p>


<h3>Author(s)</h3>

<p>Gerko Vink, Stef van Buuren, Karin Groothuis-Oudshoorn, 2018
</p>


<h3>References</h3>

<p>Van Buuren, S., Groothuis-Oudshoorn, K. (2011). <code>mice</code>:
Multivariate Imputation by Chained Equations in <code>R</code>. <em>Journal of
Statistical Software</em>, <b>45</b>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>
<p>Brand, J.P.L. (1999). Development, Implementation and Evaluation of Multiple
Imputation Strategies for the Statistical Analysis of Incomplete Data Sets.
Ph.D. Thesis, TNO Prevention and Health/Erasmus University Rotterdam.
</p>


<h3>See Also</h3>

<p><code>mice</code>, <code>mice.impute.norm</code>
</p>
<p>Other univariate imputation functions: 
<code>mice.impute.cart()</code>,
<code>mice.impute.lasso.logreg()</code>,
<code>mice.impute.lasso.norm()</code>,
<code>mice.impute.lasso.select.logreg()</code>,
<code>mice.impute.lasso.select.norm()</code>,
<code>mice.impute.lda()</code>,
<code>mice.impute.logreg.boot()</code>,
<code>mice.impute.logreg()</code>,
<code>mice.impute.mean()</code>,
<code>mice.impute.midastouch()</code>,
<code>mice.impute.mnar.logreg()</code>,
<code>mice.impute.mpmm()</code>,
<code>mice.impute.norm.boot()</code>,
<code>mice.impute.norm.predict()</code>,
<code>mice.impute.norm()</code>,
<code>mice.impute.pmm()</code>,
<code>mice.impute.polr()</code>,
<code>mice.impute.polyreg()</code>,
<code>mice.impute.quadratic()</code>,
<code>mice.impute.rf()</code>,
<code>mice.impute.ri()</code>
</p>


</div>