<div class="container">

<table style="width: 100%;"><tr>
<td>mice.impute.quadratic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Imputation of quadratic terms</h2>

<h3>Description</h3>

<p>Imputes incomplete variable that appears as both
main effect and quadratic effect in the complete-data model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mice.impute.quadratic(y, ry, x, wy = NULL, quad.outcome = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector to be imputed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quad.outcome</code></td>
<td>
<p>The name of the outcome in the quadratic analysis as a
character string. For example, if the substantive model of interest is
<code>y ~ x + xx</code>, then <code>"y"</code> would be the <code>quad.outcome</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other named arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function implements the "polynomial combination" method.
First, the polynomial
combination <code class="reqn">Z = Y \beta_1 + Y^2 \beta_2</code> is formed.
<code class="reqn">Z</code> is imputed by
predictive mean matching, followed by a decomposition of the imputed
data <code class="reqn">Z</code>
into components <code class="reqn">Y</code> and <code class="reqn">Y^2</code>.
See Van Buuren (2012, pp. 139-141) and Vink
et al (2012) for more details. The method ensures that 1) the imputed data
for <code class="reqn">Y</code> and <code class="reqn">Y^2</code> are mutually consistent, and 2) that provides unbiased
estimates of the regression weights in a complete-data linear regression that
use both <code class="reqn">Y</code> and <code class="reqn">Y^2</code>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>
</p>


<h3>Note</h3>

<p>There are two situations to consider. If only the linear term <code>Y</code>
is present in the data, calculate the quadratic term <code>YY</code> after
imputation. If both the linear term <code>Y</code> and the the quadratic term
<code>YY</code> are variables in the data, then first impute <code>Y</code> by calling
<code>mice.impute.quadratic()</code> on <code>Y</code>, and then impute <code>YY</code> by
passive imputation as <code>meth["YY"] &lt;- "~I(Y^2)"</code>.  See example section
for details.  Generally, we would like <code>YY</code> to be present in the data if
we need to preserve quadratic relations between <code>YY</code> and any third
variables in the multivariate incomplete data that we might wish to impute.
</p>


<h3>Author(s)</h3>

<p>Mingyang Cai and Gerko Vink
</p>


<h3>See Also</h3>

<p><code>mice.impute.pmm</code>
Van Buuren, S. (2018).
<a href="https://stefvanbuuren.name/fimd/sec-knowledge.html#sec:quadratic"><em>Flexible Imputation of Missing Data. Second Edition.</em></a>
Chapman &amp; Hall/CRC. Boca Raton, FL.
</p>
<p>Vink, G., van Buuren, S. (2013). Multiple Imputation of Squared Terms.
<em>Sociological Methods &amp; Research</em>, 42:598-607.
</p>
<p>Other univariate imputation functions: 
<code>mice.impute.cart()</code>,
<code>mice.impute.lasso.logreg()</code>,
<code>mice.impute.lasso.norm()</code>,
<code>mice.impute.lasso.select.logreg()</code>,
<code>mice.impute.lasso.select.norm()</code>,
<code>mice.impute.lda()</code>,
<code>mice.impute.logreg.boot()</code>,
<code>mice.impute.logreg()</code>,
<code>mice.impute.mean()</code>,
<code>mice.impute.midastouch()</code>,
<code>mice.impute.mnar.logreg()</code>,
<code>mice.impute.mpmm()</code>,
<code>mice.impute.norm.boot()</code>,
<code>mice.impute.norm.nob()</code>,
<code>mice.impute.norm.predict()</code>,
<code>mice.impute.norm()</code>,
<code>mice.impute.pmm()</code>,
<code>mice.impute.polr()</code>,
<code>mice.impute.polyreg()</code>,
<code>mice.impute.rf()</code>,
<code>mice.impute.ri()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create Data
B1 &lt;- .5
B2 &lt;- .5
X &lt;- rnorm(1000)
XX &lt;- X^2
e &lt;- rnorm(1000, 0, 1)
Y &lt;- B1 * X + B2 * XX + e
dat &lt;- data.frame(x = X, xx = XX, y = Y)

# Impose 25 percent MCAR Missingness
dat[0 == rbinom(1000, 1, 1 - .25), 1:2] &lt;- NA

# Prepare data for imputation
ini &lt;- mice(dat, maxit = 0)
meth &lt;- c("quadratic", "~I(x^2)", "")
pred &lt;- ini$pred
pred[, "xx"] &lt;- 0

# Impute data
imp &lt;- mice(dat, meth = meth, pred = pred, quad.outcome = "y")

# Pool results
pool(with(imp, lm(y ~ x + xx)))

# Plot results
stripplot(imp)
plot(dat$x, dat$xx, col = mdc(1), xlab = "x", ylab = "xx")
cmp &lt;- complete(imp)
points(cmp$x[is.na(dat$x)], cmp$xx[is.na(dat$x)], col = mdc(2))
</code></pre>


</div>