<div class="container">

<table style="width: 100%;"><tr>
<td>micombine.cor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Inference for Correlations and Covariances for Multiply Imputed Datasets
</h2>

<h3>Description</h3>

<p>Statistical inference for correlations and covariances
for multiply imputed datasets
</p>


<h3>Usage</h3>

<pre><code class="language-R">micombine.cor(mi.res, variables=NULL, conf.level=0.95,
     method="pearson", nested=FALSE, partial=NULL )

micombine.cov(mi.res, variables=NULL, conf.level=0.95,
     nested=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mi.res</code></td>
<td>

<p>Object of class <code>mids</code> or <code>mids.1chain</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variables</code></td>
<td>

<p>Indices of variables for selection
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>

<p>Confidence level
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method for calculating correlations. Must be one
of <code>"pearson"</code> or <code>"spearman"</code>. The default is the
calculation of the Pearson correlation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nested</code></td>
<td>
<p>Logical indicating whether the input dataset stems from
a nested multiple imputation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial</code></td>
<td>
<p>Formula object for computing partial correlations. The
terms which should be residualized are written in the formula
object <code>partial</code>. Alternatively, it can be a vector of variables.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A data frame containing the coefficients (<code>r</code>, <code>cov</code>) and its
corresponding standard error (<code>rse</code>, <code>cov_se</code>),
fraction of missing information
(<code>fmi</code>) and a <code class="reqn">t</code> value (<code>t</code>).
</p>
<p>The corresponding coefficients can also be obtained as matrices
by requesting <code>attr(result,"r_matrix")</code>.
</p>


<h3>See Also</h3>

<p>See <code>stats::cor.test</code> for testing
correlation coefficients.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#############################################################################
# EXAMPLE 1: nhanes data | combination of correlation coefficients
#############################################################################

library(mice)
data(nhanes, package="mice")
set.seed(9090)

# nhanes data in one chain
imp.mi &lt;- miceadds::mice.1chain( nhanes, burnin=5, iter=20, Nimp=4,
                  method=rep("norm", 4) )

# correlation coefficients of variables 4, 2 and 3 (indexed in nhanes data)
res &lt;- miceadds::micombine.cor(mi.res=imp.mi, variables=c(4,2,3) )
  ##     variable1 variable2       r    rse fisher_r fisher_rse    fmi       t      p
  ##   1       chl       bmi  0.2458 0.2236   0.2510     0.2540 0.3246  0.9879 0.3232
  ##   2       chl       hyp  0.2286 0.2152   0.2327     0.2413 0.2377  0.9643 0.3349
  ##   3       bmi       hyp -0.0084 0.2198  -0.0084     0.2351 0.1904 -0.0358 0.9714
  ##     lower95 upper95
  ##   1 -0.2421  0.6345
  ##   2 -0.2358  0.6080
  ##   3 -0.4376  0.4239

# extract matrix with correlations and its standard errors
attr(res, "r_matrix")
attr(res, "rse_matrix")

# inference for covariance
res2 &lt;- miceadds::micombine.cov(mi.res=imp.mi, variables=c(4,2,3) )

# inference can also be conducted for non-imputed data
res3 &lt;- miceadds::micombine.cov(mi.res=nhanes, variables=c(4,2,3) )

# partial correlation residualizing bmi and chl
res4 &lt;- miceadds::micombine.cor(mi.res=imp.mi, variables=c("age","hyp" ),
                  partial=~bmi+chl )
res4
# alternatively, 'partial' can also be defined as c('age','hyp')

#############################################################################
# EXAMPLE 2: nhanes data | comparing different correlation coefficients
#############################################################################

library(psych)
library(mitools)

# imputing data
imp1 &lt;- mice::mice( nhanes,  method=rep("norm", 4 ) )
summary(imp1)

#*** Pearson correlation
res1 &lt;- miceadds::micombine.cor(mi.res=imp1, variables=c(4,2) )

#*** Spearman rank correlation
res2 &lt;- miceadds::micombine.cor(mi.res=imp1, variables=c(4,2),  method="spearman")

#*** Kendalls tau
# test of computation of tau for first imputed dataset
dat1 &lt;- mice::complete(imp1, action=1)
tau1 &lt;- psych::corr.test(x=dat1[,c(4,2)], method="kendall")
tau1$r[1,2]    # estimate
tau1$se     # standard error

# results of Kendalls tau for all imputed datasets
res3 &lt;- with( data=imp1,
        expr=psych::corr.test( x=cbind( chl, bmi ), method="kendall") )
# extract estimates
betas &lt;- lapply( res3$analyses, FUN=function(ll){ ll$r[1,2] } )
# extract variances
vars &lt;- lapply( res3$analyses, FUN=function(ll){ (ll$se[1,2])^2 } )
# Rubin inference
tau_comb &lt;- mitools::MIcombine( results=betas, variances=vars )
summary(tau_comb)

#############################################################################
# EXAMPLE 3: Inference for correlations for nested multiply imputed datasets
#############################################################################

library(BIFIEsurvey)
data(data.timss4, package="BIFIEsurvey" )
datlist &lt;- data.timss4

# object of class nested.datlist
datlist &lt;- miceadds::nested.datlist_create(datlist)
# inference for correlations
res2 &lt;- miceadds::micombine.cor(mi.res=datlist, variables=c("lang", "migrant", "ASMMAT"))

## End(Not run)
</code></pre>


</div>