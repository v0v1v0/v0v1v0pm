<div class="container">

<table style="width: 100%;"><tr>
<td>pool.mids.nmi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Pooling for Nested Multiple Imputation
</h2>

<h3>Description</h3>

<p>Statistical inference for scalar parameters for nested multiply imputed
datasets (Rubin, 2003; Harel &amp; Schafer, 2002, 2003; Reiter &amp; Raghanuthan, 2007;
Harel, 2007).
</p>
<p>The <code>NMIcombine</code> (<code>pool_nmi</code> as a synonym)
and <code>NMIextract</code> functions are extensions of
<code>mitools::MIcombine</code> and
<code>mitools::MIextract</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pool.mids.nmi(object, method="largesample")

NMIcombine( qhat, u=NULL, se=NULL, NMI=TRUE, comp_cov=TRUE, is_list=TRUE,
       method=1)

pool_nmi( qhat, u=NULL, se=NULL, NMI=TRUE, comp_cov=TRUE, is_list=TRUE,
       method=1)

NMIextract(results, expr, fun)

## S3 method for class 'mipo.nmi'
summary(object, digits=4, ...)

## S3 method for class 'mipo.nmi'
coef(object, ...)

## S3 method for class 'mipo.nmi'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class <code>mids.nmi</code>. For <code>summary</code> it must be an object
of class <code>mipo.nmi</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>For <code>pool.mids.nmi</code>: Method for calculating degrees of freedom. Until now, only the
method <code>"largesample"</code> is available. <br>
For <code>NMIcombine</code> and <code>pool_nmi</code>: Computation method of fraction of missing information.
<code>method=1</code> is due to Harel and Schafer (2003) or Shen (2007).
<code>method=2</code> is due to Harel and Schafer (2002) and is coherent to
the calculation for multiply imputed datasets, while the former method is not.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qhat</code></td>
<td>
<p>List of lists of parameter estimates. In case of an ordinary
imputation it can only be a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Optional list of lists of covariance matrices of parameter estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>Optional vector of standard errors. This argument overwrites
<code>u</code> if it is provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NMI</code></td>
<td>
<p>Optional logical indicating whether the <code>NMIcombine</code>
function should be applied for results of
nested multiply imputed datasets.
It is set to <code>FALSE</code> if only a list results of multiply imputed
datasets is available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp_cov</code></td>
<td>
<p>Optional logical indicating whether covariances between
parameter estimates should be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_list</code></td>
<td>
<p>Optional logical indicating whether <code>qhat</code> and <code>u</code>
are provided as lists as an input. If <code>is_list=FALSE</code>,
appropriate arrays can be used as input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>results</code></td>
<td>
<p>A list of objects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>An expression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>A function of one argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits after decimal for printing results in
<code>summary</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Object of class <code>mipo.nmi</code> with following entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>qhat</code></td>
<td>
<p>Estimated parameters in all imputed datasets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>Estimated covariance matrices of parameters in all imputed datasets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qbar</code></td>
<td>
<p>Estimated parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ubar</code></td>
<td>
<p>Average estimated variance within imputations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tm</code></td>
<td>
<p>Total variance of parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Degrees of freedom</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Total fraction of missing information</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_Between</code></td>
<td>
<p>Fraction of missing information of between imputed
datasets (first stage imputation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_Within</code></td>
<td>
<p>Fraction of missing information of within imputed
datasets (second stage imputation)</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Harel, O., &amp; Schafer, J. (2002). <em>Two stage multiple imputation</em>.
Joint Statistical Meetings - Biometrics Section.
</p>
<p>Harel, O., &amp; Schafer, J. (2003). <em>Multiple imputation in two stages</em>.
In Proceedings of Federal Committee on Statistical Methodology 2003 Conference.
</p>
<p>Harel, O. (2007). Inferences on missing information under multiple imputation
and two-stage multiple imputation. <em>Statistical Methodology, 4</em>(1), 75-89.
<a href="https://doi.org/10.1016/j.stamet.2006.03.002">doi:10.1016/j.stamet.2006.03.002</a>
</p>
<p>Reiter, J. P. and Raghunathan, T. E. (2007). The multiple adaptations of multiple
imputation. <em>Journal of the American Statistical Association, 102</em>(480), 1462-1471.
<a href="https://doi.org/10.1198/016214507000000932">doi:10.1198/016214507000000932</a>
</p>
<p>Rubin, D. B. (2003). Nested multiple imputation of NMES via partially
incompatible MCMC. <em>Statistica Neerlandica, 57</em>(1), 3-18.
<a href="https://doi.org/10.1111/1467-9574.00217">doi:10.1111/1467-9574.00217</a>
</p>


<h3>See Also</h3>

<p><code>mice::pool</code>,
<code>mitools::MIcombine</code>,
<code>mitools::MIextract</code>
</p>
<p><code>mice.nmi</code>,
<code>MIcombine.NestedImputationResultList</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#############################################################################
# EXAMPLE 1: Nested multiple imputation and statistical inference
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2
# remove first four variables
M &lt;- length(datlist)
for (ll in 1:M){
    datlist[[ll]] &lt;- datlist[[ll]][, -c(1:4) ]
               }

#***************
# (1) nested multiple imputation using mice
imp1 &lt;- miceadds::mice.nmi( datlist,  m=3, maxit=2 )
summary(imp1)

#***************
# (2) first linear regression: ASMMAT ~ migrant + female
res1 &lt;- with( imp1, stats::lm( ASMMAT ~ migrant + female ) ) # fit
pres1 &lt;- miceadds::pool.mids.nmi( res1 )  # pooling
summary(pres1)  # summary
coef(pres1)
vcov(pres1)

#***************
# (3) second linear regression: likesc ~ migrant + books
res2 &lt;- with( imp1, stats::lm( likesc ~ migrant + books  ) )
pres2 &lt;- miceadds::pool.mids.nmi( res2 )
summary(pres2)

#***************
# (4) some descriptive statistics using the mids.nmi object
res3 &lt;- with( imp1, c( "M_lsc"=mean(likesc), "SD_lsc"=stats::sd(likesc) ) )
pres3 &lt;- miceadds::NMIcombine( qhat=res3$analyses )
summary(pres3)

#*************
# (5) apply linear regression based on imputation list

# convert mids object to datlist
datlist2 &lt;- miceadds::mids2datlist( imp1 )
str(datlist2, max.level=1)

# double application of lapply to the list of list of nested imputed datasets
res4 &lt;- lapply( datlist2, FUN=function(dl){
    lapply( dl, FUN=function(data){
            stats::lm( ASMMAT ~ migrant + books, data=data )
                                } )
                }  )

# extract coefficients
qhat &lt;- lapply( res4, FUN=function(bb){
            lapply( bb, FUN=function(ww){
                    coef(ww)
                        } )
                } )
# shorter function
NMIextract( results=res4, fun=coef )

# extract covariance matrices
u &lt;- lapply( res4, FUN=function(bb){
            lapply( bb, FUN=function(ww){
                    vcov(ww)
                        } )
                } )
# shorter function
NMIextract( results=res4, fun=vcov )

# apply statistical inference using the NMIcombine function
pres4 &lt;- miceadds::NMIcombine( qhat=qhat, u=u )
summary(pres4)

#--- statistical inference if only standard errors are available
# extract standard errors
se &lt;- lapply( res4, FUN=function(bb){
            lapply( bb, FUN=function(ww){
                # ww &lt;- res4[[1]][[1]]
                sww &lt;- summary(ww)
                sww$coef[,"Std. Error"]
                        } )
                } )
se
# apply NMIcombine function
pres4b &lt;- miceadds::NMIcombine( qhat=qhat, se=se )
# compare results
summary(pres4b)
summary(pres4)

#############################################################################
# EXAMPLE 2: Some comparisons for a multiply imputed dataset
#############################################################################

library(mitools)
data(data.ma02)

# save dataset as imputation list
imp &lt;- mitools::imputationList( data.ma02 )
print(imp)
# save dataset as an mids object
imp1 &lt;- miceadds::datlist2mids( imp )

# apply linear model based on imputationList
mod &lt;- with( imp, stats::lm( read ~ hisei + female ) )
# same linear model based on mids object
mod1 &lt;- with( imp1, stats::lm( read ~ hisei + female ) )

# extract coefficients
cmod &lt;- mitools::MIextract( mod, fun=coef)
# extract standard errors
semod &lt;- lapply( mod, FUN=function(mm){
                smm &lt;- summary(mm)
                smm$coef[,"Std. Error"]
                        } )
# extract covariance matrix
vmod &lt;- mitools::MIextract( mod, fun=vcov)

#*** pooling with NMIcombine with se (1a) and vcov (1b) as input
pmod1a &lt;- miceadds::NMIcombine( qhat=cmod, se=semod, NMI=FALSE )
pmod1b &lt;- miceadds::NMIcombine( qhat=cmod, u=vmod, NMI=FALSE )
# use method 2 which should conform to MI inference of mice::pool
pmod1c &lt;- miceadds::NMIcombine( qhat=cmod, u=vmod, NMI=FALSE, method=2)

#*** pooling with mitools::MIcombine function
pmod2 &lt;- mitools::MIcombine( results=cmod, variances=vmod )
#*** pooling with mice::pool function
pmod3a &lt;- mice::pool( mod1 )
pmod3b &lt;- mice::pool( mod1, method="Rubin")

#--- compare results
summary(pmod1a)   # method=1  (the default)
summary(pmod1b)   # method=1  (the default)
summary(pmod1c)   # method=2
summary(pmod2)
summary(pmod3a)
summary(pmod3b)

## End(Not run)
</code></pre>


</div>