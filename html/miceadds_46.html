<div class="container">

<table style="width: 100%;"><tr>
<td>draw.pv.ctt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plausible Value Imputation Using a Known Measurement Error Variance
(Based on Classical Test Theory)
</h2>

<h3>Description</h3>

<p>This function provides unidimensional plausible value imputation with a
known measurement error variance or classical test theory (Mislevy, 1991).
The reliability of the scale is estimated by Cronbach's Alpha or can be
provided by the user.
</p>


<h3>Usage</h3>

<pre><code class="language-R">draw.pv.ctt(y, dat.scale=NULL, x=NULL, samp.pars=TRUE,
      alpha=NULL, sig.e=NULL, var.e=NULL, true.var=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>Vector of scale scores if <code>y</code> should not be used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat.scale</code></td>
<td>

<p>Matrix of item responses
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Matrix of covariates
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samp.pars</code></td>
<td>

<p>An optional logical indicating whether scale parameters
(reliability or measurement error standard deviation) should be sampled
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>Reliability estimate of the scale. The default of
<code>NULL</code> means that Cronbach's alpha will be used
as a reliability estimate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig.e</code></td>
<td>

<p>Optional vector of the standard deviation of the error.
Note that it is <em>not</em> the error variance.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.e</code></td>
<td>

<p>Optional vector of the variance of the error.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>true.var</code></td>
<td>

<p>True score variance
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The linear model is assumed for drawing plausible values of a variable
<code class="reqn">Y</code> contaminated by measurement error. Assuming <code class="reqn">Y=\theta + e</code>
and a linear regression model for <code class="reqn">\theta</code>
</p>
<p style="text-align: center;"><code class="reqn"> \theta=\bold{X} \beta + \epsilon</code>
</p>

<p>(plausible value) imputations from the posterior distribution
<code class="reqn">P( \theta | Y, \bold{X} )</code> are drawn. See Mislevy (1991) for details.
</p>


<h3>Value</h3>

<p>A vector with plausible values
</p>


<h3>Note</h3>

<p>Plausible value imputation is also labeled as multiple overimputation
(Blackwell, Honaker &amp; King, 2011).
</p>


<h3>References</h3>

<p>Blackwell, M., Honaker, J., &amp; King, G. (2011).
<em>Multiple overimputation: A unified approach to measurement error and
missing data</em>. Technical Report.
</p>
<p>Mislevy, R. J. (1991). Randomization-based inference about latent variables
from complex samples. <em>Psychometrika, 56</em>(2), 177-196.
<a href="https://doi.org/10.1007/BF02294457">doi:10.1007/BF02294457</a>
</p>


<h3>See Also</h3>

<p>See also
<code>sirt::plausible.value.imputation.raschtype</code>
for plausible value imputation.
</p>
<p>Plausible value imputations can be conducted in <span class="pkg">mice</span> using the
imputation method <code>mice.impute.plausible.values</code>.
</p>
<p>Plausible values can be drawn in <span class="pkg">Amelia</span> by specifying observation-level
priors, see <code>Amelia::moPrep</code> and
<code>Amelia::amelia</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

#############################################################################
# SIMULATED EXAMPLE 1: Scale scores
#############################################################################

set.seed(899)
n &lt;- 5000       # number of students
x &lt;- round( stats::runif( n, 0,1 ) )
y &lt;- stats::rnorm(n)
# simulate true score theta
theta &lt;- .6 + .4*x + .5 * y + stats::rnorm(n)
# simulate observed score by adding measurement error
sig.e &lt;- rep( sqrt(.40), n )
theta_obs &lt;- theta + stats::rnorm( n, sd=sig.e)

# calculate alpha
( alpha &lt;- stats::var( theta ) / stats::var( theta_obs ) )
# [1] 0.7424108
#=&gt; Ordinarily, sig.e or alpha will be known, assumed or estimated by using items,
#    replications or an appropriate measurement model.

# create matrix of predictors
X &lt;- as.matrix( cbind(x, y ) )

# plausible value imputation with scale score
imp1 &lt;- miceadds::draw.pv.ctt( y=theta_obs, x=X, sig.e=sig.e )
# check results
stats::lm( imp1 ~ x + y )

# imputation with alpha as an input
imp2 &lt;- miceadds::draw.pv.ctt( y=theta_obs, x=X, alpha=.74 )
stats::lm( imp2 ~ x + y )

#--- plausible value imputation in Amelia package
library(Amelia)

# define data frame
dat &lt;- data.frame( "x"=x, "y"=y, "theta"=theta_obs )
# generate observation-level priors for theta
priors &lt;- cbind( 1:n, 3, theta_obs, sig.e )
             # 3 indicates column index for theta
overimp &lt;- priors[,1:2]
# run Amelia
imp &lt;- Amelia::amelia( dat, priors=priors, overimp=overimp, m=10)
# create object of class datlist and evaluate results
datlist &lt;- miceadds::datlist_create( imp$imputations )
withPool_MI( with( datlist, stats::var(theta) ) )
stats::var(theta)       # compare with true variance
mod &lt;- with( datlist,  stats::lm( theta ~ x + y ) )
mitools::MIcombine(mod)

## End(Not run)
</code></pre>


</div>