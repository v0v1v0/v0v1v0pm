<div class="container">

<table style="width: 100%;"><tr>
<td>microbenchmark</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sub-millisecond accurate timing of expression evaluation.</h2>

<h3>Description</h3>

<p><code>microbenchmark</code> serves as a more accurate replacement of the
often seen <code>system.time(replicate(1000, expr))</code>
expression. It tries hard to accurately measure only the time it
takes to evaluate <code>expr</code>. To achieved this, the
sub-millisecond (supposedly nanosecond) accurate timing functions
most modern operating systems provide are used. Additionally all
evaluations of the expressions are done in C code to minimize any
overhead.
</p>


<h3>Usage</h3>

<pre><code class="language-R">microbenchmark(
  ...,
  list = NULL,
  times = 100L,
  unit = NULL,
  check = NULL,
  control = list(),
  setup = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Expressions to benchmark.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list</code></td>
<td>
<p>List of unevaluated expressions to benchmark.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Number of times to evaluate each expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit</code></td>
<td>
<p>Default unit used in <code>summary</code> and <code>print</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>A function to check if the expressions are equal. By default <code>NULL</code> which omits the check.
In addition to a function, a string can be supplied.
The string ‘equal’ will compare all values using <code>all.equal</code>, ‘equivalent’ will compare all values using <code>all.equal</code> and check.attributes = FALSE, and ‘identical’ will compare all values using <code>identical</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>List of control arguments. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>setup</code></td>
<td>
<p>An unevaluated expression to be run (untimed) before each benchmark expression.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is only meant for micro-benchmarking small pieces of
source code and to compare their relative performance
characteristics. You should generally avoid benchmarking larger
chunks of your code using this function. Instead, try using the R
profiler to detect hot spots and consider rewriting them in C/C++
or FORTRAN.
</p>
<p>The <code>control</code> list can contain the following entries:
</p>

<dl>
<dt>order</dt>
<dd>
<p>the order in which the expressions are evaluated.
“random” (the default) randomizes the execution order,
“inorder” executes each expression in order and
“block” executes all repetitions of each expression
as one block.</p>
</dd>
<dt>warmup</dt>
<dd>
<p>the number of iterations to run the timing code before
evaluating the expressions in .... These warm-up iterations are used
to estimate the timing overhead as well as spinning up the processor
from any sleep or idle states it might be in. The default value is 2.</p>
</dd>
</dl>
<h3>Value</h3>

<p>Object of class ‘microbenchmark’, a data frame with
columns <code>expr</code> and <code>time</code>. <code>expr</code> contains the
deparsed expression as passed to <code>microbenchmark</code> or the name
of the argument if the expression was passed as a named
argument. <code>time</code> is the measured execution time of the
expression in nanoseconds. The order of the observations in the
data frame is the order in which they were executed.
</p>


<h3>Note</h3>

<p>Depending on the underlying operating system, different
methods are used for timing. On Windows the
<code>QueryPerformanceCounter</code> interface is used to measure the
time passed. For Linux the <code>clock_gettime</code> API is used and on
Solaris the <code>gethrtime</code> function. Finally on MacOS X the,
undocumented, <code>mach_absolute_time</code> function is used to avoid
a dependency on the CoreServices Framework.
</p>
<p>Before evaluating each expression <code>times</code> times, the overhead
of calling the timing functions and the C function call overhead
are estimated. This estimated overhead is subtracted from each
measured evaluation time. Should the resulting timing be negative,
a warning is thrown and the respective value is replaced by
<code>0</code>. If the timing is zero, a warning is raised.
Should all evaluations result in one of the two error conditions described above, an error is raised.
</p>
<p>One platform on which the clock resolution is known to be too low to measure short runtimes with the required precision is 
Oracle®
Solaris 
on some 
SPARC®
hardware.
Reports of other platforms with similar problems are welcome.
Please contact the package maintainer.
</p>


<h3>Author(s)</h3>

<p>Olaf Mersmann
</p>


<h3>See Also</h3>

<p><code>print.microbenchmark</code> to display and
<code>boxplot.microbenchmark</code> or
<code>autoplot.microbenchmark</code> to plot the results.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Measure the time it takes to dispatch a simple function call
## compared to simply evaluating the constant \code{NULL}
f &lt;- function() NULL
res &lt;- microbenchmark(NULL, f(), times=1000L)

## Print results:
print(res)

## Plot results:
boxplot(res)

## Pretty plot:
if (requireNamespace("ggplot2")) {
  ggplot2::autoplot(res)
}

## Example check usage
my_check &lt;- function(values) {
  all(sapply(values[-1], function(x) identical(values[[1]], x)))
}

f &lt;- function(a, b)
  2 + 2

a &lt;- 2
## Check passes
microbenchmark(2 + 2, 2 + a, f(2, a), f(2, 2), check=my_check)
## Not run: 
a &lt;- 3
## Check fails
microbenchmark(2 + 2, 2 + a, f(2, a), f(2, 2), check=my_check)

## End(Not run)
## Example setup usage
set.seed(21)
x &lt;- rnorm(10)
microbenchmark(x, rnorm(10), check=my_check, setup=set.seed(21))
## Will fail without setup
## Not run: 
microbenchmark(x, rnorm(10), check=my_check)

## End(Not run)
## using check
a &lt;- 2
microbenchmark(2 + 2, 2 + a, sum(2, a), sum(2, 2), check='identical')
microbenchmark(2 + 2, 2 + a, sum(2, a), sum(2, 2), check='equal')
attr(a, 'abc') &lt;- 123
microbenchmark(2 + 2, 2 + a, sum(2, a), sum(2, 2), check='equivalent')
## check='equal' will fail due to difference in attribute
## Not run: 
microbenchmark(2 + 2, 2 + a, sum(2, a), sum(2, 2), check='equal')

## End(Not run)
</code></pre>


</div>