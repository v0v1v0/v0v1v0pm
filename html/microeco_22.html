<div class="container">

<table style="width: 100%;"><tr>
<td>trans_beta</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create <code>trans_beta</code> object for beta-diversity analysis</h2>

<h3>Description</h3>

<p>This class is a wrapper for a series of beta-diversity related analysis, 
including ordination analysis based on An et al. (2019) &lt;doi:10.1016/j.geoderma.2018.09.035&gt;, group distance comparision, 
clustering, perMANOVA based on Anderson al. (2008) &lt;doi:10.1111/j.1442-9993.2001.01070.pp.x&gt;, ANOSIM and PERMDISP.
Note that the beta diversity analysis methods related with environmental variables are encapsulated within the <code>trans_env</code> class.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_beta-new"><code>trans_beta$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_ordination"><code>trans_beta$cal_ordination()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-plot_ordination"><code>trans_beta$plot_ordination()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_manova"><code>trans_beta$cal_manova()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_anosim"><code>trans_beta$cal_anosim()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_betadisper"><code>trans_beta$cal_betadisper()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_group_distance"><code>trans_beta$cal_group_distance()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_group_distance_diff"><code>trans_beta$cal_group_distance_diff()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-plot_group_distance"><code>trans_beta$plot_group_distance()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-plot_clustering"><code>trans_beta$plot_clustering()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-clone"><code>trans_beta$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-trans_beta-new"></a>



<h4>Method <code>new()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>trans_beta$new(dataset = NULL, measure = NULL, group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt>
<dd>
<p>the object of <code>microtable</code> class.</p>
</dd>
<dt><code>measure</code></dt>
<dd>
<p>default NULL; a matrix name stored in <code>microtable$beta_diversity</code> list, such as "bray" or "jaccard", or a customized matrix; 
used for ordination, manova, group distance comparision, etc.;
Please see <code>cal_betadiv</code> function of <code>microtable</code> class for more details.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>default NULL; sample group used for manova, betadisper or group distance comparision.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>measure, group and dataset stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(dataset)
t1 &lt;- trans_beta$new(dataset = dataset, measure = "bray", group = "Group")
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_ordination"></a>



<h4>Method <code>cal_ordination()</code>
</h4>

<p>Unconstrained ordination.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_ordination(
  method = "PCoA",
  ncomp = 3,
  trans = FALSE,
  scale_species = FALSE,
  scale_species_ratio = 0.8,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt>
<dd>
<p>default "PCoA"; "PCoA", "NMDS", "PCA", "DCA" or "PLS-DA".
PCoA: principal coordinates analysis; NMDS: non-metric multidimensional scaling, PCA: principal component analysis; DCA: detrended correspondence analysis; 
PLS-DA: partial least squares discriminant analysis.
For the methods details, please refer to the papers &lt;doi:10.1111/j.1574-6941.2007.00375.x&gt; (for PCoA, NMDS, PCA and DCA) and 
&lt;doi:10.1186/s12859-019-3310-7&gt; (for PLS-DA).</p>
</dd>
<dt><code>ncomp</code></dt>
<dd>
<p>default 3; dimensions shown in the results (except method "NMDS").</p>
</dd>
<dt><code>trans</code></dt>
<dd>
<p>default FALSE; whether species abundance will be square transformed; only available when <code>method</code> is "PCA" or "DCA".</p>
</dd>
<dt><code>scale_species</code></dt>
<dd>
<p>default FALSE; whether species loading in PCA or DCA is scaled.</p>
</dd>
<dt><code>scale_species_ratio</code></dt>
<dd>
<p>default 0.8; the ratio to scale up the loading; multiply by the maximum distance between samples and origin. 
Only available when <code>scale_species = TURE</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters passed to <code>vegan::rda</code> function when <code>method = "PCA"</code>, 
or <code>vegan::decorana</code> function when <code>method = "DCA"</code>, 
or <code>ape::pcoa</code> function when <code>method = "PCoA"</code>, 
or <code>vegan::metaMDS</code> function when <code>method = "NMDS"</code>,
or <code>ropls::opls</code> function when <code>method = "PLS-DA"</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_ordination</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$cal_ordination(method = "PCoA")
</pre>
</div>


<hr>
<a id="method-trans_beta-plot_ordination"></a>



<h4>Method <code>plot_ordination()</code>
</h4>

<p>Plot the ordination result.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$plot_ordination(
  plot_type = "point",
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  shape_values = c(16, 17, 7, 8, 15, 18, 11, 10, 12, 13, 9, 3, 4, 0, 1, 2, 14),
  plot_color = NULL,
  plot_shape = NULL,
  plot_group_order = NULL,
  add_sample_label = NULL,
  point_size = 3,
  point_alpha = 0.8,
  centroid_segment_alpha = 0.6,
  centroid_segment_size = 1,
  centroid_segment_linetype = 3,
  ellipse_chull_fill = TRUE,
  ellipse_chull_alpha = 0.1,
  ellipse_level = 0.9,
  ellipse_type = "t",
  NMDS_stress_pos = c(1, 1),
  NMDS_stress_text_prefix = "",
  loading_arrow = FALSE,
  loading_taxa_num = 10,
  loading_text_color = "black",
  loading_arrow_color = "grey30",
  loading_text_size = 3,
  loading_text_italic = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_type</code></dt>
<dd>
<p>default "point"; one or more elements of "point", "ellipse", "chull" and "centroid".
</p>

<dl>
<dt><strong>'point'</strong></dt>
<dd>
<p>add sample points</p>
</dd>
<dt><strong>'ellipse'</strong></dt>
<dd>
<p>add confidence ellipse for points of each group</p>
</dd>
<dt><strong>'chull'</strong></dt>
<dd>
<p>add convex hull for points of each group</p>
</dd>
<dt><strong>'centroid'</strong></dt>
<dd>
<p>add centroid line of each group</p>
</dd>
</dl>
</dd>
<dt><code>color_values</code></dt>
<dd>
<p>default <code>RColorBrewer::brewer.pal</code>(8, "Dark2"); colors palette for different groups.</p>
</dd>
<dt><code>shape_values</code></dt>
<dd>
<p>default c(16, 17, 7, 8, 15, 18, 11, 10, 12, 13, 9, 3, 4, 0, 1, 2, 14); a vector for point shape types of groups, see <code>ggplot2</code> tutorial.</p>
</dd>
<dt><code>plot_color</code></dt>
<dd>
<p>default NULL; a colname of <code>sample_table</code> to assign colors to different groups in plot.</p>
</dd>
<dt><code>plot_shape</code></dt>
<dd>
<p>default NULL; a colname of <code>sample_table</code> to assign shapes to different groups in plot.</p>
</dd>
<dt><code>plot_group_order</code></dt>
<dd>
<p>default NULL; a vector used to order the groups in the legend of plot.</p>
</dd>
<dt><code>add_sample_label</code></dt>
<dd>
<p>default NULL; a column name in <code>sample_table</code>; If provided, show the point name in plot.</p>
</dd>
<dt><code>point_size</code></dt>
<dd>
<p>default 3; point size when "point" is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>point_alpha</code></dt>
<dd>
<p>default .8; point transparency in plot when "point" is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>centroid_segment_alpha</code></dt>
<dd>
<p>default 0.6; segment transparency in plot when "centroid" is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>centroid_segment_size</code></dt>
<dd>
<p>default 1; segment size in plot when "centroid" is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>centroid_segment_linetype</code></dt>
<dd>
<p>default 3; the line type related with centroid in plot when "centroid" is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>ellipse_chull_fill</code></dt>
<dd>
<p>default TRUE; whether fill colors to the area of ellipse or chull.</p>
</dd>
<dt><code>ellipse_chull_alpha</code></dt>
<dd>
<p>default 0.1; color transparency in the ellipse or convex hull depending on whether "ellipse" or "centroid" is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>ellipse_level</code></dt>
<dd>
<p>default .9; confidence level of ellipse when "ellipse" is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>ellipse_type</code></dt>
<dd>
<p>default "t"; ellipse type when "ellipse" is in <code>plot_type</code> parameter; see type in <code>stat_ellipse</code>.</p>
</dd>
<dt><code>NMDS_stress_pos</code></dt>
<dd>
<p>default c(1, 1); a numerical vector with two values used to represent the insertion position of the stress text. 
The first one denotes the x-axis, while the second one corresponds to the y-axis. 
The assigned position is determined by multiplying the respective value with the maximum point on the corresponding coordinate axis. 
Thus, the x-axis position is equal to <code>max(points of x axis) * NMDS_stress_pos[1]</code>, 
and the y-axis position is equal to <code>max(points of y axis) * NMDS_stress_pos[2]</code>. Negative values can also be utilized for the negative part of the axis.
<code>NMDS_stress_pos = NULL</code> denotes no stress text to show.</p>
</dd>
<dt><code>NMDS_stress_text_prefix</code></dt>
<dd>
<p>default ""; If NMDS_stress_pos is not NULL, this parameter can be used to add text in front of the stress value.</p>
</dd>
<dt><code>loading_arrow</code></dt>
<dd>
<p>default FALSE; whether show the loading using arrow.</p>
</dd>
<dt><code>loading_taxa_num</code></dt>
<dd>
<p>default 10; the number of taxa used for the loading. Only available when <code>loading_arrow = TRUE</code>.</p>
</dd>
<dt><code>loading_text_color</code></dt>
<dd>
<p>default "black"; the color of taxa text. Only available when <code>loading_arrow = TRUE</code>.</p>
</dd>
<dt><code>loading_arrow_color</code></dt>
<dd>
<p>default "grey30"; the color of taxa arrow. Only available when <code>loading_arrow = TRUE</code>.</p>
</dd>
<dt><code>loading_text_size</code></dt>
<dd>
<p>default 3; the size of taxa text. Only available when <code>loading_arrow = TRUE</code>.</p>
</dd>
<dt><code>loading_text_italic</code></dt>
<dd>
<p>default FALSE; whether using italic for the taxa text. Only available when <code>loading_arrow = TRUE</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>ggplot</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$plot_ordination(plot_type = "point")
t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = "point")
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "ellipse"))
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), 
	  centroid_segment_linetype = 1)
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_manova"></a>



<h4>Method <code>cal_manova()</code>
</h4>

<p>Calculate perMANOVA (Permutational Multivariate Analysis of Variance) based on the <code>adonis2</code> function of vegan package &lt;doi:10.1111/j.1442-9993.2001.01070.pp.x&gt;.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_manova(
  manova_all = TRUE,
  manova_set = NULL,
  group = NULL,
  by_group = NULL,
  p_adjust_method = "fdr",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>manova_all</code></dt>
<dd>
<p>default TRUE; TRUE represents test for all the groups, i.e. the overall test;
FALSE represents test for all the paired groups.</p>
</dd>
<dt><code>manova_set</code></dt>
<dd>
<p>default NULL; other specified group set for manova, such as <code>"Group + Type"</code> and <code>"Group*Type"</code>.
Please also see the <code>formula</code> parameter (only right-hand side) in <code>adonis2</code> function of vegan package.
The parameter manova_set has higher priority than manova_all parameter. If manova_set is provided; manova_all is disabled.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>default NULL; a column name of <code>sample_table</code> used for manova. If NULL, search <code>group</code> variable stored in the object.
Available when <code>manova_set</code> is not provided.</p>
</dd>
<dt><code>by_group</code></dt>
<dd>
<p>default NULL; one column name in <code>sample_table</code>; used to perform paired comparisions within each group. 
Only available when <code>manova_all = FALSE</code> and <code>manova_set</code> is not provided.</p>
</dd>
<dt><code>p_adjust_method</code></dt>
<dd>
<p>default "fdr"; p.adjust method; available when <code>manova_all = FALSE</code>; 
see <code>method</code> parameter of <code>p.adjust</code> function for available options.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters passed to <code>adonis2</code> function of <code>vegan</code> package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_manova</code> stored in object with <code>data.frame</code> class.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$cal_manova(manova_all = TRUE)
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_anosim"></a>



<h4>Method <code>cal_anosim()</code>
</h4>

<p>Analysis of similarities (ANOSIM) based on the <code>anosim</code> function of vegan package.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_anosim(
  paired = FALSE,
  group = NULL,
  by_group = NULL,
  p_adjust_method = "fdr",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>paired</code></dt>
<dd>
<p>default FALSE; whether perform paired test between any two combined groups from all the input groups.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>default NULL; a column name of <code>sample_table</code>. If NULL, search <code>group</code> variable stored in the object.</p>
</dd>
<dt><code>by_group</code></dt>
<dd>
<p>default NULL; one column name in <code>sample_table</code>; used to perform paired comparisions within each group. 
Only available when <code>paired = TRUE</code>.</p>
</dd>
<dt><code>p_adjust_method</code></dt>
<dd>
<p>default "fdr"; p.adjust method; available when <code>paired = TRUE</code>; see method parameter of <code>p.adjust</code> function for available options.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters passed to <code>anosim</code> function of <code>vegan</code> package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_anosim</code> stored in object with <code>data.frame</code> class.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$cal_anosim()
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_betadisper"></a>



<h4>Method <code>cal_betadisper()</code>
</h4>

<p>Multivariate homogeneity test of groups dispersions (PERMDISP) based on <code>betadisper</code> function in vegan package.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_betadisper(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>parameters passed to <code>betadisper</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_betadisper</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$cal_betadisper()
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_group_distance"></a>



<h4>Method <code>cal_group_distance()</code>
</h4>

<p>Convert symmetric distance matrix to distance table of paired samples that are within groups or between groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_group_distance(
  within_group = TRUE,
  by_group = NULL,
  ordered_group = NULL,
  sep = " vs "
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>within_group</code></dt>
<dd>
<p>default TRUE; whether obtain distance table of paired samples within groups; if FALSE, obtain distances of paired samples between any two groups.</p>
</dd>
<dt><code>by_group</code></dt>
<dd>
<p>default NULL; one colname name of <code>sample_table</code> in <code>microtable</code> object.
If provided, transform distances by the provided <code>by_group</code> parameter. This is especially useful for ordering and filtering values further.
When <code>within_group = TRUE</code>, the result of by_group parameter is the format of paired groups.
When <code>within_group = FALSE</code>, the result of by_group parameter is the format same with the group information in <code>sample_table</code>.</p>
</dd>
<dt><code>ordered_group</code></dt>
<dd>
<p>default NULL; a vector representing the ordered elements of <code>group</code> parameter; only useful when within_group = FALSE.</p>
</dd>
<dt><code>sep</code></dt>
<dd>
<p>default TRUE; a character string to separate the group names after merging them into a new name.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_group_distance</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_group_distance(within_group = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_group_distance_diff"></a>



<h4>Method <code>cal_group_distance_diff()</code>
</h4>

<p>Differential test of converted distances across groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_group_distance_diff(
  group = NULL,
  by_group = NULL,
  by_ID = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt>
<dd>
<p>default NULL; a column name of <code>object$res_group_distance</code> used for the statistics; If NULL, use the <code>group</code> inside the object.</p>
</dd>
<dt><code>by_group</code></dt>
<dd>
<p>default NULL; a column of <code>object$res_group_distance</code> used to perform the differential test 
among elements in <code>group</code> parameter for each element in <code>by_group</code> parameter. So <code>by_group</code> has a larger scale than <code>group</code> parameter.
This <code>by_group</code> is very different from the <code>by_group</code> parameter in the <code>cal_group_distance</code> function.</p>
</dd>
<dt><code>by_ID</code></dt>
<dd>
<p>default NULL; a column of <code>object$res_group_distance</code> used to perform paired t test or paired wilcox test for the paired data,
such as the data of plant compartments for different plant species (ID). 
So <code>by_ID</code> should be the smallest unit of sample collection without any repetition in it.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters passed to <code>cal_diff</code> function of <code>trans_alpha</code> class.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_group_distance_diff</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_group_distance_diff()
}
</pre>
</div>


<hr>
<a id="method-trans_beta-plot_group_distance"></a>



<h4>Method <code>plot_group_distance()</code>
</h4>

<p>Plot the distances of paired groups within or between groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$plot_group_distance(plot_group_order = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_group_order</code></dt>
<dd>
<p>default NULL; a vector used to order the groups in the plot.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters (except measure) passed to <code>plot_alpha</code> function of <code>trans_alpha</code> class.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>ggplot</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_group_distance()
}
</pre>
</div>


<hr>
<a id="method-trans_beta-plot_clustering"></a>



<h4>Method <code>plot_clustering()</code>
</h4>

<p>Plot clustering result based on the <code>ggdendro</code> package.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$plot_clustering(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  measure = NULL,
  group = NULL,
  replace_name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt>
<dd>
<p>default RColorBrewer::brewer.pal(8, "Dark2"); color palette for the text.</p>
</dd>
<dt><code>measure</code></dt>
<dd>
<p>default NULL; beta diversity index; If NULL, using the measure when creating object</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p>default NULL; if provided, use this group to assign color.</p>
</dd>
<dt><code>replace_name</code></dt>
<dd>
<p>default NULL; if provided, use this as label.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>ggplot</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$plot_clustering(group = "Group", replace_name = c("Saline", "Type"))
</pre>
</div>


<hr>
<a id="method-trans_beta-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">
## ------------------------------------------------
## Method `trans_beta$new`
## ------------------------------------------------

data(dataset)
t1 &lt;- trans_beta$new(dataset = dataset, measure = "bray", group = "Group")

## ------------------------------------------------
## Method `trans_beta$cal_ordination`
## ------------------------------------------------

t1$cal_ordination(method = "PCoA")

## ------------------------------------------------
## Method `trans_beta$plot_ordination`
## ------------------------------------------------

t1$plot_ordination(plot_type = "point")
t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = "point")
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "ellipse"))
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), 
	  centroid_segment_linetype = 1)

## ------------------------------------------------
## Method `trans_beta$cal_manova`
## ------------------------------------------------

t1$cal_manova(manova_all = TRUE)

## ------------------------------------------------
## Method `trans_beta$cal_anosim`
## ------------------------------------------------

t1$cal_anosim()

## ------------------------------------------------
## Method `trans_beta$cal_betadisper`
## ------------------------------------------------

t1$cal_betadisper()

## ------------------------------------------------
## Method `trans_beta$cal_group_distance`
## ------------------------------------------------


t1$cal_group_distance(within_group = TRUE)


## ------------------------------------------------
## Method `trans_beta$cal_group_distance_diff`
## ------------------------------------------------


t1$cal_group_distance_diff()


## ------------------------------------------------
## Method `trans_beta$plot_group_distance`
## ------------------------------------------------


t1$plot_group_distance()


## ------------------------------------------------
## Method `trans_beta$plot_clustering`
## ------------------------------------------------

t1$plot_clustering(group = "Group", replace_name = c("Saline", "Type"))
</code></pre>


</div>