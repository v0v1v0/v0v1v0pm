<div class="container">

<table style="width: 100%;"><tr>
<td>trans_classifier</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create <code>trans_classifier</code> object for machine-learning-based model prediction.</h2>

<h3>Description</h3>

<p>This class is a wrapper for methods of machine-learning-based classification or regression models, including data pre-processing, feature selection, 
data split, model training, prediction, confusionMatrix and ROC (Receiver Operator Characteristic) or PR (Precision-Recall) curve.
</p>
<p>Author(s): Felipe Mansoldo and Chi Liu
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_classifier-new"><code>trans_classifier$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_preProcess"><code>trans_classifier$cal_preProcess()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_feature_sel"><code>trans_classifier$cal_feature_sel()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_split"><code>trans_classifier$cal_split()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-set_trainControl"><code>trans_classifier$set_trainControl()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_train"><code>trans_classifier$cal_train()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_feature_imp"><code>trans_classifier$cal_feature_imp()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-plot_feature_imp"><code>trans_classifier$plot_feature_imp()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_predict"><code>trans_classifier$cal_predict()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-plot_confusionMatrix"><code>trans_classifier$plot_confusionMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_ROC"><code>trans_classifier$cal_ROC()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-plot_ROC"><code>trans_classifier$plot_ROC()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_caretList"><code>trans_classifier$cal_caretList()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_caretList_resamples"><code>trans_classifier$cal_caretList_resamples()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-plot_caretList_resamples"><code>trans_classifier$plot_caretList_resamples()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-clone"><code>trans_classifier$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-trans_classifier-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a trans_classifier object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$new(
  dataset,
  x.predictors = "Genus",
  y.response = NULL,
  n.cores = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt>
<dd>
<p>an object of <code>microtable</code> class.</p>
</dd>
<dt><code>x.predictors</code></dt>
<dd>
<p>default "Genus"; character string or data.frame; a character string represents selecting the corresponding data from <code>microtable$taxa_abund</code>; 
data.frame denotes other customized input. See the following available options:
</p>

<dl>
<dt><strong>'Genus'</strong></dt>
<dd>
<p>use Genus level table in <code>microtable$taxa_abund</code>, or other specific taxonomic rank, e.g., 'Phylum'.
If an input level (e.g., ASV) is not found in the names of taxa_abund list, the function will use <code>otu_table</code> to calculate relative abundance of features.</p>
</dd>
<dt><strong>'all'</strong></dt>
<dd>
<p>use all the levels stored in <code>microtable$taxa_abund</code>.</p>
</dd>
<dt><strong>other input</strong></dt>
<dd>
<p>must be a data.frame object. It should have the same format with the tables in microtable$taxa_abund, i.e. rows are features; 
columns are samples with same names in sample_table.</p>
</dd>
</dl>
</dd>
<dt><code>y.response</code></dt>
<dd>
<p>default NULL; the response variable in <code>sample_table</code> of input <code>microtable</code> object.</p>
</dd>
<dt><code>n.cores</code></dt>
<dd>
<p>default 1; the CPU thread used.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>data_feature</code> and <code>data_response</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
data(dataset)
t1 &lt;- trans_classifier$new(
		dataset = dataset, 
		x.predictors = "Genus",
		y.response = "Group")
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_preProcess"></a>



<h4>Method <code>cal_preProcess()</code>
</h4>

<p>Pre-process (centering, scaling etc.) of the feature data based on the caret::preProcess function. 
See <a href="https://topepo.github.io/caret/pre-processing.html">https://topepo.github.io/caret/pre-processing.html</a> for more details.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_preProcess(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>preProcess</code> function of caret package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>preprocessed <code>data_feature</code> in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# "nzv" removes near zero variance predictors
t1$cal_preProcess(method = c("center", "scale", "nzv"))
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_feature_sel"></a>



<h4>Method <code>cal_feature_sel()</code>
</h4>

<p>Perform feature selection.
See <a href="https://topepo.github.io/caret/feature-selection-overview.html">https://topepo.github.io/caret/feature-selection-overview.html</a> for more details.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_feature_sel(
  boruta.maxRuns = 300,
  boruta.pValue = 0.01,
  boruta.repetitions = 4,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>boruta.maxRuns</code></dt>
<dd>
<p>default 300; maximal number of importance source runs; passed to the <code>maxRuns</code> parameter in <code>Boruta</code> function of Boruta package.</p>
</dd>
<dt><code>boruta.pValue</code></dt>
<dd>
<p>default 0.01; p value passed to the pValue parameter in <code>Boruta</code> function of Boruta package.</p>
</dd>
<dt><code>boruta.repetitions</code></dt>
<dd>
<p>default 4; repetition runs for the feature selection.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>Boruta</code> function of Boruta package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>optimized <code>data_feature</code> in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_feature_sel(boruta.maxRuns = 300, boruta.pValue = 0.01)
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_split"></a>



<h4>Method <code>cal_split()</code>
</h4>

<p>Split data for training and testing.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_split(prop.train = 3/4)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prop.train</code></dt>
<dd>
<p>default 3/4; the ratio of the data used for the training.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>data_train</code> and <code>data_test</code> in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_split(prop.train = 3/4)
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-set_trainControl"></a>



<h4>Method <code>set_trainControl()</code>
</h4>

<p>Control parameters for the following training. Please see <code>trainControl</code> function of caret package for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$set_trainControl(
  method = "repeatedcv",
  classProbs = TRUE,
  savePredictions = TRUE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt>
<dd>
<p>default 'repeatedcv'; 'repeatedcv': Repeated k-Fold cross validation; 
see method parameter in <code>trainControl</code> function of <code>caret</code> package for available options.</p>
</dd>
<dt><code>classProbs</code></dt>
<dd>
<p>default TRUE; should class probabilities be computed for classification models?;
see classProbs parameter in <code>caret::trainControl</code> function.</p>
</dd>
<dt><code>savePredictions</code></dt>
<dd>
<p>default TRUE; see <code>savePredictions</code> parameter in <code>caret::trainControl</code> function.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>trainControl</code> function of caret package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>trainControl</code> in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$set_trainControl(method = 'repeatedcv')
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_train"></a>



<h4>Method <code>cal_train()</code>
</h4>

<p>Run the model training. Please see <a href="https://topepo.github.io/caret/available-models.html">https://topepo.github.io/caret/available-models.html</a> for available models.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_train(method = "rf", max.mtry = 2, ntree = 500, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt>
<dd>
<p>default "rf"; "rf": random forest; see method in <code>train</code> function of caret package for other options.
For method = "rf", the <code>tuneGrid</code> is set: <code>expand.grid(mtry = seq(from = 1, to = max.mtry))</code></p>
</dd>
<dt><code>max.mtry</code></dt>
<dd>
<p>default 2; for method = "rf"; maximum mtry used in the <code>tuneGrid</code> to do hyperparameter tuning to optimize the model.</p>
</dd>
<dt><code>ntree</code></dt>
<dd>
<p>default 500; for method = "rf"; Number of trees to grow. 
The default 500 is same with the <code>ntree</code> parameter in <code>randomForest</code> function in randomForest package.
When it is a vector with more than one element, the function will try to optimize the model to select a best one, such as <code>c(100, 500, 1000)</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>caret::train</code> function.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_train</code> in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# random forest
t1$cal_train(method = "rf")
# Support Vector Machines with Radial Basis Function Kernel
t1$cal_train(method = "svmRadial", tuneLength = 15)
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_feature_imp"></a>



<h4>Method <code>cal_feature_imp()</code>
</h4>

<p>Get feature importance from the training model.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_feature_imp(rf_feature_sig = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rf_feature_sig</code></dt>
<dd>
<p>default FALSE; whether calculate feature significance in 'rf' model using <code>rfPermute</code> package; 
only available for <code>method = "rf"</code> in <code>cal_train</code> function.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>varImp</code> function of caret package. 
If <code>rf_feature_sig</code> is TURE and <code>train_method</code> is "rf", the parameters will be passed to <code>rfPermute</code> function of rfPermute package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_feature_imp</code> in the object. One row for each predictor variable. The column(s) are different importance measures.
For the method 'rf', it is MeanDecreaseGini (classification) or IncNodePurity (regression) when <code>rf_feature_sig = FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_feature_imp()
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-plot_feature_imp"></a>



<h4>Method <code>plot_feature_imp()</code>
</h4>

<p>Bar plot for feature importance.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$plot_feature_imp(
  rf_sig_show = NULL,
  show_sig_group = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rf_sig_show</code></dt>
<dd>
<p>default NULL; "MeanDecreaseAccuracy" (Default) or "MeanDecreaseGini" for random forest classification;
"%IncMSE" (Default) or "IncNodePurity" for random forest regression;
Only available when <code>rf_feature_sig = TRUE</code> in function <code>cal_feature_imp</code>, 
which generate "MeanDecreaseGini" (and "MeanDecreaseAccuracy") or "%IncMSE" (and "IncNodePurity") in the column names of <code>res_feature_imp</code>;
Function can also generate "Significance" according to the p value.</p>
</dd>
<dt><code>show_sig_group</code></dt>
<dd>
<p>default FALSE; whether show the features with different significant groups;
Only available when "Significance" is found in the data.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>plot_diff_bar</code> function of <code>trans_diff</code> package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>ggplot2</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$plot_feature_imp(use_number = 1:20, coord_flip = FALSE)
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_predict"></a>



<h4>Method <code>cal_predict()</code>
</h4>

<p>Run the prediction.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_predict(positive_class = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>positive_class</code></dt>
<dd>
<p>default NULL; see positive parameter in <code>confusionMatrix</code> function of caret package;
If positive_class is NULL, use the first group in data as the positive class automatically.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_predict</code>, <code>res_confusion_fit</code> and <code>res_confusion_stats</code> stored in the object.
The <code>res_predict</code> is the predicted result for <code>data_test</code>.
Several evaluation metrics in <code>res_confusion_fit</code> are defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">Accuracy = \frac{TP + TN}{TP + TN + FP + FN}</code>
</p>

<p style="text-align: center;"><code class="reqn">Sensitivity = Recall = TPR = \frac{TP}{TP + FN}</code>
</p>

<p style="text-align: center;"><code class="reqn">Specificity = TNR = 1 - FPR = \frac{TN}{TN + FP}</code>
</p>

<p style="text-align: center;"><code class="reqn">Precision = \frac{TP}{TP + FP}</code>
</p>

<p style="text-align: center;"><code class="reqn">Prevalence = \frac{TP + FN}{TP + TN + FP + FN}</code>
</p>

<p style="text-align: center;"><code class="reqn">F1-Score = \frac{2 * Precision * Recall}{Precision + Recall}</code>
</p>

<p style="text-align: center;"><code class="reqn">Kappa = \frac{Accuracy - Pe}{1 - Pe}</code>
</p>

<p>where TP is true positive; TN is ture negative; FP is false positive; and FN is false negative;
FPR is False Positive Rate; TPR is True Positive Rate; TNR is True Negative Rate;
Pe is the hypothetical probability of chance agreement on the classes for reference and prediction in the confusion matrix.
Accuracy represents the ratio of correct predictions.
Precision identifies how the model accurately predicted the positive classes.
Recall (sensitivity) measures the ratio of actual positives that are correctly identified by the model.
F1-score is the weighted average score of recall and precision. The value at 1 is the best performance and at 0 is the worst.
Prevalence represents how often positive events occurred.
Kappa identifies how well the model is predicting.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_predict()
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-plot_confusionMatrix"></a>



<h4>Method <code>plot_confusionMatrix()</code>
</h4>

<p>Plot the cross-tabulation of observed and predicted classes with associated statistics based on the results of function <code>cal_predict</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$plot_confusionMatrix(
  plot_confusion = TRUE,
  plot_statistics = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_confusion</code></dt>
<dd>
<p>default TRUE; whether plot the confusion matrix.</p>
</dd>
<dt><code>plot_statistics</code></dt>
<dd>
<p>default TRUE; whether plot the statistics.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>ggplot</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$plot_confusionMatrix()
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_ROC"></a>



<h4>Method <code>cal_ROC()</code>
</h4>

<p>Get ROC (Receiver Operator Characteristic) curve data and the performance data.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_ROC(input = "pred")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input</code></dt>
<dd>
<p>default "pred"; 'pred' or 'train'; 'pred' represents using prediction results;
'train' represents using training results.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a list <code>res_ROC</code> stored in the object. It has two tables: <code>res_roc</code> and <code>res_pr</code>. AUC: Area Under the ROC Curve.
For the definition of metrics, please refer to the return part of function <code>cal_predict</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_ROC()
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-plot_ROC"></a>



<h4>Method <code>plot_ROC()</code>
</h4>

<p>Plot ROC curve.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$plot_ROC(
  plot_type = c("ROC", "PR")[1],
  plot_group = "all",
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  add_AUC = TRUE,
  plot_method = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_type</code></dt>
<dd>
<p>default c("ROC", "PR")[1]; 'ROC' represents ROC (Receiver Operator Characteristic) curve; 
'PR' represents PR (Precision-Recall) curve.</p>
</dd>
<dt><code>plot_group</code></dt>
<dd>
<p>default "all"; 'all' represents all the classes in the model;
'add' represents all adding micro-average and macro-average results, see 
<a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.html">https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.html</a>;
other options should be one or more class names, same with the names in Group column of res_ROC$res_roc from cal_ROC function.</p>
</dd>
<dt><code>color_values</code></dt>
<dd>
<p>default RColorBrewer::brewer.pal(8, "Dark2"); colors used in the plot.</p>
</dd>
<dt><code>add_AUC</code></dt>
<dd>
<p>default TRUE; whether add AUC in the legend.</p>
</dd>
<dt><code>plot_method</code></dt>
<dd>
<p>default FALSE; If TRUE, show the method in the legend though only one method is found.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>geom_path</code> function of ggplot2 package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>ggplot2</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$plot_ROC(size = 1, alpha = 0.7)
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_caretList"></a>



<h4>Method <code>cal_caretList()</code>
</h4>

<p>Use <code>caretList</code> function of caretEnsemble package to run multiple models. For the available models, please run <code>names(getModelInfo())</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_caretList(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>caretList</code> function of <code>caretEnsemble</code> package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_caretList_models</code> in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_caretList(methodList = c('rf', 'svmRadial'))
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_caretList_resamples"></a>



<h4>Method <code>cal_caretList_resamples()</code>
</h4>

<p>Use <code>resamples</code> function of caret package to collect the metric values based on the <code>res_caretList_models</code> data.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_caretList_resamples(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>resamples</code> function of <code>caret</code> package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_caretList_resamples</code> list and <code>res_caretList_resamples_reshaped</code> table in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_caretList_resamples()
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-plot_caretList_resamples"></a>



<h4>Method <code>plot_caretList_resamples()</code>
</h4>

<p>Visualize the metric values based on the <code>res_caretList_resamples_reshaped</code> data.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$plot_caretList_resamples(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt>
<dd>
<p>default <code>RColorBrewer::brewer.pal</code>(8, "Dark2"); colors palette for the box.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>geom_boxplot</code> function of <code>ggplot2</code> package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>ggplot object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$plot_caretList_resamples()
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">
## ------------------------------------------------
## Method `trans_classifier$new`
## ------------------------------------------------


data(dataset)
t1 &lt;- trans_classifier$new(
		dataset = dataset, 
		x.predictors = "Genus",
		y.response = "Group")


## ------------------------------------------------
## Method `trans_classifier$cal_preProcess`
## ------------------------------------------------

## Not run: 
# "nzv" removes near zero variance predictors
t1$cal_preProcess(method = c("center", "scale", "nzv"))

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_feature_sel`
## ------------------------------------------------

## Not run: 
t1$cal_feature_sel(boruta.maxRuns = 300, boruta.pValue = 0.01)

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_split`
## ------------------------------------------------

## Not run: 
t1$cal_split(prop.train = 3/4)

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$set_trainControl`
## ------------------------------------------------

## Not run: 
t1$set_trainControl(method = 'repeatedcv')

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_train`
## ------------------------------------------------

## Not run: 
# random forest
t1$cal_train(method = "rf")
# Support Vector Machines with Radial Basis Function Kernel
t1$cal_train(method = "svmRadial", tuneLength = 15)

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_feature_imp`
## ------------------------------------------------

## Not run: 
t1$cal_feature_imp()

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$plot_feature_imp`
## ------------------------------------------------

## Not run: 
t1$plot_feature_imp(use_number = 1:20, coord_flip = FALSE)

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_predict`
## ------------------------------------------------

## Not run: 
t1$cal_predict()

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$plot_confusionMatrix`
## ------------------------------------------------

## Not run: 
t1$plot_confusionMatrix()

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_ROC`
## ------------------------------------------------

## Not run: 
t1$cal_ROC()

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$plot_ROC`
## ------------------------------------------------

## Not run: 
t1$plot_ROC(size = 1, alpha = 0.7)

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_caretList`
## ------------------------------------------------

## Not run: 
t1$cal_caretList(methodList = c('rf', 'svmRadial'))

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_caretList_resamples`
## ------------------------------------------------

## Not run: 
t1$cal_caretList_resamples()

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$plot_caretList_resamples`
## ------------------------------------------------

## Not run: 
t1$plot_caretList_resamples()

## End(Not run)
</code></pre>


</div>