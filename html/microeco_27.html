<div class="container">

<table style="width: 100%;"><tr>
<td>trans_network</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create <code>trans_network</code> object for network analysis.</h2>

<h3>Description</h3>

<p>This class is a wrapper for a series of network analysis methods, 
including the network construction, network attributes analysis,
eigengene analysis, network subsetting, node and edge properties, network visualization and other operations.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_network-new"><code>trans_network$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_network"><code>trans_network$cal_network()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_module"><code>trans_network$cal_module()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-save_network"><code>trans_network$save_network()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_network_attr"><code>trans_network$cal_network_attr()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-get_node_table"><code>trans_network$get_node_table()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-get_edge_table"><code>trans_network$get_edge_table()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-get_adjacency_matrix"><code>trans_network$get_adjacency_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-plot_network"><code>trans_network$plot_network()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_eigen"><code>trans_network$cal_eigen()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-plot_taxa_roles"><code>trans_network$plot_taxa_roles()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-subset_network"><code>trans_network$subset_network()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_powerlaw"><code>trans_network$cal_powerlaw()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_sum_links"><code>trans_network$cal_sum_links()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-plot_sum_links"><code>trans_network$plot_sum_links()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-random_network"><code>trans_network$random_network()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-trans_comm"><code>trans_network$trans_comm()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-print"><code>trans_network$print()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-clone"><code>trans_network$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-trans_network-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create the <code>trans_network</code> object, store the important intermediate data 
and calculate correlations if <code>cor_method</code> parameter is not NULL.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$new(
  dataset = NULL,
  cor_method = NULL,
  use_WGCNA_pearson_spearman = FALSE,
  use_NetCoMi_pearson_spearman = FALSE,
  use_sparcc_method = c("NetCoMi", "SpiecEasi")[1],
  taxa_level = "OTU",
  filter_thres = 0,
  nThreads = 1,
  SparCC_simu_num = 100,
  env_cols = NULL,
  add_data = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt>
<dd>
<p>default NULL; the object of <code>microtable</code> class. Default NULL means customized analysis.</p>
</dd>
<dt><code>cor_method</code></dt>
<dd>
<p>default NULL; NULL or one of "bray", "pearson", "spearman", "sparcc", "bicor", "cclasso" and "ccrepe";
All the methods refered to <code>NetCoMi</code> package are performed based on <code>netConstruct</code> function of <code>NetCoMi</code> package and require
<code>NetCoMi</code> to be installed from Github (<a href="https://github.com/stefpeschel/NetCoMi">https://github.com/stefpeschel/NetCoMi</a>);
For the algorithm details, please see Peschel et al. 2020 Brief. Bioinform &lt;doi: 10.1093/bib/bbaa290&gt;;
</p>

<dl>
<dt><strong>NULL</strong></dt>
<dd>
<p>NULL denotes non-correlation network, i.e. do not use correlation-based network. 
If so, the return res_cor_p list will be NULL.</p>
</dd>
<dt><strong>'bray'</strong></dt>
<dd>
<p>1-B, where B is Bray-Curtis dissimilarity; based on <code>vegan::vegdist</code> function</p>
</dd>
<dt><strong>'pearson'</strong></dt>
<dd>
<p>Pearson correlation; If <code>use_WGCNA_pearson_spearman</code> and <code>use_NetCoMi_pearson_spearman</code> are both FALSE, 
use the function <code>cor.test</code> in R; <code>use_WGCNA_pearson_spearman = TRUE</code> invoke <code>corAndPvalue</code> function of <code>WGCNA</code> package; 
<code>use_NetCoMi_pearson_spearman = TRUE</code> invoke <code>netConstruct</code> function of <code>NetCoMi</code> package</p>
</dd>
<dt><strong>'spearman'</strong></dt>
<dd>
<p>Spearman correlation; other details are same with the 'pearson' option</p>
</dd>
<dt><strong>'sparcc'</strong></dt>
<dd>
<p>SparCC algorithm (Friedman &amp; Alm, PLoS Comp Biol, 2012, &lt;doi:10.1371/journal.pcbi.1002687&gt;);
use NetCoMi package when <code>use_sparcc_method = "NetCoMi"</code>; use <code>SpiecEasi</code> package when <code>use_sparcc_method = "SpiecEasi"</code> 
and require <code>SpiecEasi</code> to be installed from Github
(<a href="https://github.com/zdk123/SpiecEasi">https://github.com/zdk123/SpiecEasi</a>)</p>
</dd>
<dt><strong>'bicor'</strong></dt>
<dd>
<p>Calculate biweight midcorrelation efficiently for matrices based on <code>WGCNA::bicor</code> function; 
This option can invoke <code>netConstruct</code> function of <code>NetCoMi</code> package;
Make sure <code>WGCNA</code> and <code>NetCoMi</code> packages are both installed</p>
</dd>
<dt><strong>'cclasso'</strong></dt>
<dd>
<p>Correlation inference of Composition data through Lasso method based on <code>netConstruct</code> function of <code>NetCoMi</code> package; 
for details, see <code>NetCoMi::cclasso</code> function</p>
</dd>
<dt><strong>'ccrepe'</strong></dt>
<dd>
<p>Calculates compositionality-corrected p-values and q-values for compositional data 
using an arbitrary distance metric based on <code>NetCoMi::netConstruct</code> function; also see <code>NetCoMi::ccrepe</code> function</p>
</dd>
</dl>
</dd>
<dt><code>use_WGCNA_pearson_spearman</code></dt>
<dd>
<p>default FALSE; whether use WGCNA package to calculate correlation when <code>cor_method</code> = "pearson" or "spearman".</p>
</dd>
<dt><code>use_NetCoMi_pearson_spearman</code></dt>
<dd>
<p>default FALSE; whether use NetCoMi package to calculate correlation when <code>cor_method</code> = "pearson" or "spearman".
The important difference between NetCoMi and others is the features of zero handling and data normalization; See &lt;doi: 10.1093/bib/bbaa290&gt;.</p>
</dd>
<dt><code>use_sparcc_method</code></dt>
<dd>
<p>default <code>c("NetCoMi", "SpiecEasi")[1]</code>; 
use <code>NetCoMi</code> package or <code>SpiecEasi</code> package to perform SparCC when <code>cor_method = "sparcc"</code>.</p>
</dd>
<dt><code>taxa_level</code></dt>
<dd>
<p>default "OTU"; taxonomic rank; 'OTU' denotes using feature abundance table; 
other available options should be one of the colnames of <code>tax_table</code> of input dataset.</p>
</dd>
<dt><code>filter_thres</code></dt>
<dd>
<p>default 0; the relative abundance threshold.</p>
</dd>
<dt><code>nThreads</code></dt>
<dd>
<p>default 1; the CPU thread number; available when <code>use_WGCNA_pearson_spearman = TRUE</code> or <code>use_sparcc_method = "SpiecEasi"</code>.</p>
</dd>
<dt><code>SparCC_simu_num</code></dt>
<dd>
<p>default 100; SparCC simulation number for bootstrap when <code>use_sparcc_method = "SpiecEasi"</code>.</p>
</dd>
<dt><code>env_cols</code></dt>
<dd>
<p>default NULL; numeric or character vector to select the column names of environmental data in dataset$sample_table;
the environmental data can be used in the correlation network (as the nodes) or <code>FlashWeave</code> network.</p>
</dd>
<dt><code>add_data</code></dt>
<dd>
<p>default NULL; provide environmental variable table additionally instead of <code>env_cols</code> parameter; rownames must be sample names.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>NetCoMi::netConstruct</code> for other operations, such as zero handling and/or data normalization 
when cor_method and other parameters refer to <code>NetCoMi</code> package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_cor_p</code> list with the correlation (association) matrix and p value matrix. Note that when <code>cor_method</code> and other parameters
refer to <code>NetCoMi</code> package, the p value table are all zero as the significant associations have been selected.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
data(dataset)
# for correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.0002)
# for non-correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL)
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_network"></a>



<h4>Method <code>cal_network()</code>
</h4>

<p>Construct network based on the <code>igraph</code> package or <code>SpiecEasi</code> package or <code>julia FlashWeave</code> package or <code>beemStatic</code> package.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_network(
  network_method = c("COR", "SpiecEasi", "gcoda", "FlashWeave", "beemStatic")[1],
  COR_p_thres = 0.01,
  COR_p_adjust = "fdr",
  COR_weight = TRUE,
  COR_cut = 0.6,
  COR_optimization = FALSE,
  COR_optimization_low_high = c(0.01, 0.8),
  COR_optimization_seq = 0.01,
  SpiecEasi_method = "mb",
  FlashWeave_tempdir = NULL,
  FlashWeave_meta_data = FALSE,
  FlashWeave_other_para = "alpha=0.01,sensitive=true,heterogeneous=true",
  beemStatic_t_strength = 0.001,
  beemStatic_t_stab = 0.8,
  add_taxa_name = "Phylum",
  delete_unlinked_nodes = TRUE,
  usename_rawtaxa_notOTU = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>network_method</code></dt>
<dd>
<p>default "COR"; "COR", "SpiecEasi", "gcoda", "FlashWeave" or "beemStatic"; 
<code>network_method = NULL</code> means skipping the network construction for the customized use.
The option details: 
</p>

<dl>
<dt><strong>'COR'</strong></dt>
<dd>
<p>correlation-based network; use the correlation and p value matrices in <code>res_cor_p</code> list stored in the object; 
See Deng et al. (2012) &lt;doi:10.1186/1471-2105-13-113&gt; for other details</p>
</dd>
<dt><strong>'SpiecEasi'</strong></dt>
<dd>
<p><code>SpiecEasi</code> network; relies on algorithms of sparse neighborhood and inverse covariance selection;
belong to the category of conditional dependence and graphical models;
see <a href="https://github.com/zdk123/SpiecEasi">https://github.com/zdk123/SpiecEasi</a> for installing the R package; 
see Kurtz et al. (2015) &lt;doi:10.1371/journal.pcbi.1004226&gt; for the algorithm details</p>
</dd>
<dt><strong>'gcoda'</strong></dt>
<dd>
<p>hypothesize the logistic normal distribution of microbiome data; use penalized maximum likelihood method to estimate
the sparse structure of inverse covariance for latent normal variables to address the high dimensionality of the microbiome data;
belong to the category of conditional dependence and graphical models;
depend on the R <code>NetCoMi</code> package <a href="https://github.com/stefpeschel/NetCoMi">https://github.com/stefpeschel/NetCoMi</a>; 
see FANG et al. (2017) &lt;doi:10.1089/cmb.2017.0054&gt; for the algorithm details</p>
</dd>
<dt><strong>'FlashWeave'</strong></dt>
<dd>
<p><code>FlashWeave</code> network; Local-to-global learning framework; belong to the category of conditional dependence and graphical models;
good performance on heterogenous datasets to find direct associations among taxa;
see <a href="https://github.com/meringlab/FlashWeave.jl">https://github.com/meringlab/FlashWeave.jl</a> for installing <code>julia</code> language and 
<code>FlashWeave</code> package; julia must be in the computer system env path, otherwise the program can not find it;
see Tackmann et al. (2019) &lt;doi:10.1016/j.cels.2019.08.002&gt; for the algorithm details</p>
</dd>
<dt><strong>'beemStatic'</strong></dt>
<dd>
<p><code>beemStatic</code> network;
extend generalized Lotka-Volterra model to cases of cross-sectional datasets to infer interaction among taxa based on expectation-maximization algorithm;
see <a href="https://github.com/CSB5/BEEM-static">https://github.com/CSB5/BEEM-static</a> for installing the R package;
see Li et al. (2021) &lt;doi:10.1371/journal.pcbi.1009343&gt; for the algorithm details</p>
</dd>
</dl>
</dd>
<dt><code>COR_p_thres</code></dt>
<dd>
<p>default 0.01; the p value threshold for the correlation-based network.</p>
</dd>
<dt><code>COR_p_adjust</code></dt>
<dd>
<p>default "fdr"; p value adjustment method, see <code>method</code> parameter of <code>p.adjust</code> function for available options,
in which <code>COR_p_adjust = "none"</code> means giving up the p value adjustment.</p>
</dd>
<dt><code>COR_weight</code></dt>
<dd>
<p>default TRUE; whether use correlation coefficient as the weight of edges; FALSE represents weight = 1 for all edges.</p>
</dd>
<dt><code>COR_cut</code></dt>
<dd>
<p>default 0.6; correlation coefficient threshold for the correlation network.</p>
</dd>
<dt><code>COR_optimization</code></dt>
<dd>
<p>default FALSE; whether use random matrix theory (RMT) based method to determine the correlation coefficient; 
see https://doi.org/10.1186/1471-2105-13-113</p>
</dd>
<dt><code>COR_optimization_low_high</code></dt>
<dd>
<p>default <code>c(0.01, 0.8)</code>; the low and high value threshold used for the RMT optimization; only useful when COR_optimization = TRUE.</p>
</dd>
<dt><code>COR_optimization_seq</code></dt>
<dd>
<p>default 0.01; the interval of correlation coefficient used for RMT optimization; only useful when COR_optimization = TRUE.</p>
</dd>
<dt><code>SpiecEasi_method</code></dt>
<dd>
<p>default "mb"; either 'glasso' or 'mb';see spiec.easi function in package SpiecEasi and https://github.com/zdk123/SpiecEasi.</p>
</dd>
<dt><code>FlashWeave_tempdir</code></dt>
<dd>
<p>default NULL; The temporary directory used to save the temporary files for running FlashWeave; If not assigned, use the system user temp.</p>
</dd>
<dt><code>FlashWeave_meta_data</code></dt>
<dd>
<p>default FALSE; whether use env data for the optimization, If TRUE, the function automatically find the <code>env_data</code> in the object and
generate a file for meta_data_path parameter of FlashWeave package.</p>
</dd>
<dt><code>FlashWeave_other_para</code></dt>
<dd>
<p>default <code>"alpha=0.01,sensitive=true,heterogeneous=true"</code>; the parameters passed to julia FlashWeave package;
user can change the parameters or add more according to FlashWeave help document;
An exception is meta_data_path parameter as it is generated based on the data inside the object, see FlashWeave_meta_data parameter for the description.</p>
</dd>
<dt><code>beemStatic_t_strength</code></dt>
<dd>
<p>default 0.001; for network_method = "beemStatic"; the threshold used to limit the number of interactions (strength);
same with the t.strength parameter in showInteraction function of beemStatic package.</p>
</dd>
<dt><code>beemStatic_t_stab</code></dt>
<dd>
<p>default 0.8; for network_method = "beemStatic"; 
the threshold used to limit the number of interactions (stability); same with the t.stab parameter in showInteraction function of beemStatic package.</p>
</dd>
<dt><code>add_taxa_name</code></dt>
<dd>
<p>default "Phylum"; one or more taxonomic rank name; used to add taxonomic rank name to network node properties.</p>
</dd>
<dt><code>delete_unlinked_nodes</code></dt>
<dd>
<p>default TRUE; whether delete the nodes without any link.</p>
</dd>
<dt><code>usename_rawtaxa_notOTU</code></dt>
<dd>
<p>default FALSE; whether use OTU name as representatives of taxa when <code>taxa_level != "OTU"</code>.
Default <code>FALSE</code> means using taxonomic information of <code>taxa_level</code> instead of OTU name.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>SpiecEasi::spiec.easi</code> when <code>network_method = "SpiecEasi"</code>;
pass to <code>NetCoMi::netConstruct</code> when <code>network_method = "gcoda"</code>; 
pass to <code>beemStatic::func.EM</code> when <code>network_method = "beemStatic"</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_network</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# for correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.001)
t1$cal_network(COR_p_thres = 0.05, COR_cut = 0.6)
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.003)
t1$cal_network(network_method = "SpiecEasi", SpiecEasi_method = "mb")
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.005)
t1$cal_network(network_method = "beemStatic")
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.001)
t1$cal_network(network_method = "FlashWeave")
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_module"></a>



<h4>Method <code>cal_module()</code>
</h4>

<p>Calculate network modules and add module names to the network node properties.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_module(
  method = "cluster_fast_greedy",
  module_name_prefix = "M"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt>
<dd>
<p>default "cluster_fast_greedy"; the method used to find the optimal community structure of a graph;
the following are available functions (options) from igraph package: <br><code>"cluster_fast_greedy"</code>, <code>"cluster_walktrap"</code>, <code>"cluster_edge_betweenness"</code>, <br><code>"cluster_infomap"</code>, <code>"cluster_label_prop"</code>, <code>"cluster_leading_eigen"</code>, <br><code>"cluster_louvain"</code>, <code>"cluster_spinglass"</code>, <code>"cluster_optimal"</code>. <br>
For the details of these functions, please see the help document, such as <code>help(cluster_fast_greedy)</code>;
Note that the default <code>"cluster_fast_greedy"</code> method can not be applied to directed network. 
If directed network is provided, the function can automatically switch the default method from <code>"cluster_fast_greedy"</code> to <code>"cluster_walktrap"</code>.</p>
</dd>
<dt><code>module_name_prefix</code></dt>
<dd>
<p>default "M"; the prefix of module names; module names are made of the module_name_prefix and numbers;
numbers are assigned according to the sorting result of node numbers in modules with decreasing trend.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_network</code> with modules, stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.0002)
t1$cal_network(COR_p_thres = 0.01, COR_cut = 0.6)
t1$cal_module(method = "cluster_fast_greedy")
}
</pre>
</div>


<hr>
<a id="method-trans_network-save_network"></a>



<h4>Method <code>save_network()</code>
</h4>

<p>Save network as gexf style, which can be opened by Gephi (https://gephi.org/).
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$save_network(filepath = "network.gexf")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filepath</code></dt>
<dd>
<p>default "network.gexf"; file path to save the network.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>None
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$save_network(filepath = "network.gexf")
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_network_attr"></a>



<h4>Method <code>cal_network_attr()</code>
</h4>

<p>Calculate network properties.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_network_attr()</pre></div>



<h5>Returns</h5>

<p><code>res_network_attr</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_network_attr()
}
</pre>
</div>


<hr>
<a id="method-trans_network-get_node_table"></a>



<h4>Method <code>get_node_table()</code>
</h4>

<p>Get the node property table. The properties include the node names, modules allocation, degree, betweenness, abundance, 
taxonomy, within-module connectivity (zi) and among-module connectivity (Pi) &lt;doi:10.1186/1471-2105-13-113; 10.1016/j.geoderma.2022.115866&gt;.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$get_node_table(node_roles = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>node_roles</code></dt>
<dd>
<p>default TRUE; whether calculate the node roles &lt;doi:10.1038/nature03288; 10.1186/1471-2105-13-113&gt;.
The role of node i is characterized by its within-module connectivity (zi) and among-module connectivity (Pi) as follows
</p>
<p style="text-align: center;"><code class="reqn">z_i = \dfrac{k_{ib} - \bar{k_b}}{\sigma_{k_b}}</code>
</p>

<p style="text-align: center;"><code class="reqn">P_i = 1 - \displaystyle\sum_{c=1}^{N_M} \biggl(\frac{k_{ic}}{k_i}\biggr)^2</code>
</p>

<p>where <code class="reqn">k_{ib}</code> is the number of links of node <code class="reqn">i</code> to other nodes in its module <code class="reqn">b</code>, 
<code class="reqn">\bar{k_b}</code> and <code class="reqn">\sigma_{k_b}</code> are the average and standard deviation of within-module connectivity, respectively
over all the nodes in module <code class="reqn">b</code>, <code class="reqn">k_i</code> is the number of links of node <code class="reqn">i</code> in the whole network, 
<code class="reqn">k_{ic}</code> is the number of links from node <code class="reqn">i</code> to nodes in module <code class="reqn">c</code>, and <code class="reqn">N_M</code> is the number of modules in the network.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_node_table</code> in object; Abundance expressed as a percentage; 
betweenness_centrality: betweenness centrality; betweenness_centrality: closeness centrality; eigenvector_centrality: eigenvector centrality; 
z: within-module connectivity; p: among-module connectivity.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$get_node_table(node_roles = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_network-get_edge_table"></a>



<h4>Method <code>get_edge_table()</code>
</h4>

<p>Get the edge property table, including connected nodes, label and weight.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$get_edge_table()</pre></div>



<h5>Returns</h5>

<p><code>res_edge_table</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$get_edge_table()
}
</pre>
</div>


<hr>
<a id="method-trans_network-get_adjacency_matrix"></a>



<h4>Method <code>get_adjacency_matrix()</code>
</h4>

<p>Get the adjacency matrix from the network graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$get_adjacency_matrix(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>parameters passed to as_adjacency_matrix function of <code>igraph</code> package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_adjacency_matrix</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$get_adjacency_matrix(attr = "weight")
}
</pre>
</div>


<hr>
<a id="method-trans_network-plot_network"></a>



<h4>Method <code>plot_network()</code>
</h4>

<p>Plot the network based on a series of methods from other packages, such as <code>igraph</code>, <code>ggraph</code> and <code>networkD3</code>. 
The networkD3 package provides dynamic network. It is especially useful for a glimpse of the whole network structure and finding 
the interested nodes and edges in a large network. In contrast, the igraph and ggraph methods are suitable for relatively small network.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$plot_network(
  method = c("igraph", "ggraph", "networkD3")[1],
  node_label = "name",
  node_color = NULL,
  ggraph_layout = "fr",
  ggraph_node_size = 2,
  ggraph_node_text = TRUE,
  ggraph_text_color = NULL,
  ggraph_text_size = 3,
  networkD3_node_legend = TRUE,
  networkD3_zoom = TRUE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt>
<dd>
<p>default "igraph"; The available options:
</p>

<dl>
<dt><strong>'igraph'</strong></dt>
<dd>
<p>call <code>plot.igraph</code> function in <code>igraph</code> package for a static network; see plot.igraph for the parameters</p>
</dd>
<dt><strong>'ggraph'</strong></dt>
<dd>
<p>call <code>ggraph</code> function in <code>ggraph</code> package for a static network</p>
</dd>
<dt><strong>'networkD3'</strong></dt>
<dd>
<p>use forceNetwork function in <code>networkD3</code> package for a dynamic network; see forceNetwork function for the parameters</p>
</dd>
</dl>
</dd>
<dt><code>node_label</code></dt>
<dd>
<p>default "name"; node label shown in the plot for <code>method = "ggraph"</code> or <code>method = "networkD3"</code>; 
Please see the column names of object$res_node_table, which is the returned table of function object$get_node_table;
User can select other column names in res_node_table.</p>
</dd>
<dt><code>node_color</code></dt>
<dd>
<p>default NULL; node color assignment for <code>method = "ggraph"</code> or <code>method = "networkD3"</code>; 
Select a column name of <code>object$res_node_table</code>, such as "module".</p>
</dd>
<dt><code>ggraph_layout</code></dt>
<dd>
<p>default "fr"; for <code>method = "ggraph"</code>; see <code>layout</code> parameter of <code>create_layout</code> function in <code>ggraph</code> package.</p>
</dd>
<dt><code>ggraph_node_size</code></dt>
<dd>
<p>default 2; for <code>method = "ggraph"</code>; the node size.</p>
</dd>
<dt><code>ggraph_node_text</code></dt>
<dd>
<p>default TRUE; for <code>method = "ggraph"</code>; whether show the label text of nodes.</p>
</dd>
<dt><code>ggraph_text_color</code></dt>
<dd>
<p>default NULL; for <code>method = "ggraph"</code>; a column name of object$res_node_table used to assign label text colors.</p>
</dd>
<dt><code>ggraph_text_size</code></dt>
<dd>
<p>default 3; for <code>method = "ggraph"</code>; the node label text size.</p>
</dd>
<dt><code>networkD3_node_legend</code></dt>
<dd>
<p>default TRUE; used for <code>method = "networkD3"</code>; logical value to enable node colour legends;
Please see the legend parameter in networkD3::forceNetwork function.</p>
</dd>
<dt><code>networkD3_zoom</code></dt>
<dd>
<p>default TRUE; used for <code>method = "networkD3"</code>; logical value to enable (TRUE) or disable (FALSE) zooming;
Please see the zoom parameter in networkD3::forceNetwork function.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters passed to <code>plot.igraph</code> function when <code>method = "igraph"</code> or forceNetwork function when <code>method = "networkD3"</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>network plot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_network(method = "igraph", layout = layout_with_kk)
t1$plot_network(method = "ggraph", node_color = "module")
t1$plot_network(method = "networkD3", node_color = "module")
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_eigen"></a>



<h4>Method <code>cal_eigen()</code>
</h4>

<p>Calculate eigengenes of modules, i.e. the first principal component based on PCA analysis, and the percentage of variance &lt;doi:10.1186/1471-2105-13-113&gt;.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_eigen()</pre></div>



<h5>Returns</h5>

<p><code>res_eigen</code> and <code>res_eigen_expla</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_eigen()
}
</pre>
</div>


<hr>
<a id="method-trans_network-plot_taxa_roles"></a>



<h4>Method <code>plot_taxa_roles()</code>
</h4>

<p>Plot the roles or metrics of nodes based on the <code>res_node_table</code> data (coming from function <code>get_node_table</code>) stored in the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$plot_taxa_roles(
  use_type = c(1, 2)[1],
  roles_color_background = FALSE,
  roles_color_values = NULL,
  add_label = FALSE,
  add_label_group = "Network hubs",
  add_label_text = "name",
  label_text_size = 4,
  label_text_color = "grey50",
  label_text_italic = FALSE,
  label_text_parse = FALSE,
  plot_module = FALSE,
  x_lim = c(0, 1),
  use_level = "Phylum",
  show_value = c("z", "p"),
  show_number = 1:10,
  plot_color = "Phylum",
  plot_shape = "taxa_roles",
  plot_size = "Abundance",
  color_values = RColorBrewer::brewer.pal(12, "Paired"),
  shape_values = c(16, 17, 7, 8, 15, 18, 11, 10, 12, 13, 9, 3, 4, 0, 1, 2, 14),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_type</code></dt>
<dd>
<p>default 1; 1 or 2; 1 represents taxa roles plot (node roles include Module hubs, Network hubs, 
Connectors and Peripherals &lt;doi:10.1038/nature03288; 10.1186/1471-2105-13-113&gt;); 
2 represents the layered plot with taxa as x axis and the index (e.g., Zi and Pi) as y axis.
Please refer to <code>res_node_table</code> data stored in the object for the detailed information.</p>
</dd>
<dt><code>roles_color_background</code></dt>
<dd>
<p>default FALSE; for use_type=1; TRUE: use background colors for each area; FALSE: use classic point colors.</p>
</dd>
<dt><code>roles_color_values</code></dt>
<dd>
<p>default NULL; for use_type=1; color palette for background or points.</p>
</dd>
<dt><code>add_label</code></dt>
<dd>
<p>default FALSE; for use_type = 1; whether add labels for the points.</p>
</dd>
<dt><code>add_label_group</code></dt>
<dd>
<p>default "Network hubs"; If add_label = TRUE; which part of tax_roles is used to show labels; character vectors.</p>
</dd>
<dt><code>add_label_text</code></dt>
<dd>
<p>default "name"; If add_label = TRUE; which column of object$res_node_table is used to label the text.</p>
</dd>
<dt><code>label_text_size</code></dt>
<dd>
<p>default 4; The text size of the label.</p>
</dd>
<dt><code>label_text_color</code></dt>
<dd>
<p>default "grey50"; The text color of the label.</p>
</dd>
<dt><code>label_text_italic</code></dt>
<dd>
<p>default FALSE; whether use italic style for the label text.</p>
</dd>
<dt><code>label_text_parse</code></dt>
<dd>
<p>default FALSE; whether parse the label text. See the parse parameter in <code>ggrepel::geom_text_repel</code> function.</p>
</dd>
<dt><code>plot_module</code></dt>
<dd>
<p>default FALSE; for use_type=1; whether plot the modules information.</p>
</dd>
<dt><code>x_lim</code></dt>
<dd>
<p>default c(0, 1); for use_type=1; x axis range when roles_color_background = FALSE.</p>
</dd>
<dt><code>use_level</code></dt>
<dd>
<p>default "Phylum"; for use_type=2; used taxonomic level in x axis.</p>
</dd>
<dt><code>show_value</code></dt>
<dd>
<p>default c("z", "p"); for use_type=2; indexes used in y axis. Please see <code>res_node_table</code> in the object for other available indexes.</p>
</dd>
<dt><code>show_number</code></dt>
<dd>
<p>default 1:10; for use_type=2; showed number in x axis, sorting according to the nodes number.</p>
</dd>
<dt><code>plot_color</code></dt>
<dd>
<p>default "Phylum"; for use_type=2; variable for color.</p>
</dd>
<dt><code>plot_shape</code></dt>
<dd>
<p>default "taxa_roles"; for use_type=2; variable for shape.</p>
</dd>
<dt><code>plot_size</code></dt>
<dd>
<p>default "Abundance"; for use_type=2; used for point size; a fixed number (e.g. 5) is also acceptable.</p>
</dd>
<dt><code>color_values</code></dt>
<dd>
<p>default RColorBrewer::brewer.pal(12, "Paired"); for use_type=2; color vector.</p>
</dd>
<dt><code>shape_values</code></dt>
<dd>
<p>default c(16, 17, 7, 8, 15, 18, 11, 10, 12, 13, 9, 3, 4, 0, 1, 2, 14); for use_type=2; shape vector, see ggplot2 tutorial for the shape meaning.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to <code>geom_point</code> function of ggplot2 package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>ggplot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_taxa_roles(roles_color_background = FALSE)
}
</pre>
</div>


<hr>
<a id="method-trans_network-subset_network"></a>



<h4>Method <code>subset_network()</code>
</h4>

<p>Subset of the network.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$subset_network(node = NULL, edge = NULL, rm_single = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>node</code></dt>
<dd>
<p>default NULL; provide the node names that you want to use in the sub-network.</p>
</dd>
<dt><code>edge</code></dt>
<dd>
<p>default NULL; provide the edge name needed; must be one of "+" or "-".</p>
</dd>
<dt><code>rm_single</code></dt>
<dd>
<p>default TRUE; whether remove the nodes without any edge in the sub-network.
So this function can also be used to remove the nodes withou any edge when node and edge are both NULL.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a new network
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$subset_network(node = t1$res_node_table %&gt;% base::subset(module == "M1") %&gt;% 
  rownames, rm_single = TRUE)
# return a sub network that contains all nodes of module M1
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_powerlaw"></a>



<h4>Method <code>cal_powerlaw()</code>
</h4>

<p>Fit degrees to a power law distribution. First, perform a bootstrapping hypothesis test to determine whether degrees follow a power law distribution.
If the distribution follows power law, then fit degrees to power law distribution and return the parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_powerlaw(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>parameters pass to bootstrap_p function in poweRlaw package.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_powerlaw_p</code> and <code>res_powerlaw_fit</code>; see <code>poweRlaw::bootstrap_p</code> function for the bootstrapping p value details;
see <code>igraph::fit_power_law</code> function for the power law fit return details.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_powerlaw()
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_sum_links"></a>



<h4>Method <code>cal_sum_links()</code>
</h4>

<p>This function is used to sum the links number from one taxa to another or in the same taxa, for example, at Phylum level.
This is very useful to fast see how many nodes are connected between different taxa or within the taxa.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_sum_links(taxa_level = "Phylum")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>taxa_level</code></dt>
<dd>
<p>default "Phylum"; taxonomic rank.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>res_sum_links_pos</code> and <code>res_sum_links_neg</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_sum_links(taxa_level = "Phylum")
}
</pre>
</div>


<hr>
<a id="method-trans_network-plot_sum_links"></a>



<h4>Method <code>plot_sum_links()</code>
</h4>

<p>Plot the summed linkages among taxa.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$plot_sum_links(
  plot_pos = TRUE,
  plot_num = NULL,
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  method = c("chorddiag", "circlize")[1],
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_pos</code></dt>
<dd>
<p>default TRUE; If TRUE, plot the summed positive linkages; If FALSE, plot the summed negative linkages.</p>
</dd>
<dt><code>plot_num</code></dt>
<dd>
<p>default NULL; number of taxa presented in the plot.</p>
</dd>
<dt><code>color_values</code></dt>
<dd>
<p>default RColorBrewer::brewer.pal(8, "Dark2"); colors palette for taxa.</p>
</dd>
<dt><code>method</code></dt>
<dd>
<p>default c("chorddiag", "circlize")[1]; chorddiag package &lt;https://github.com/mattflor/chorddiag&gt; or circlize package.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>pass to <code>chorddiag::chorddiag</code> function when <code>method = "chorddiag"</code> or 
<code>circlize::chordDiagram</code> function when <code>method = "circlize"</code>.
Note that for <code>circlize::chordDiagram</code> function, <code>keep.diagonal</code>, <code>symmetric</code> and <code>self.link</code> parameters have been fixed to fit the input data.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>please see the invoked function.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
test1$plot_sum_links(method = "chorddiag", plot_pos = TRUE, plot_num = 10)
test1$plot_sum_links(method = "circlize", transparency = 0.2, 
	  annotationTrackHeight = circlize::mm_h(c(5, 5)))
}
</pre>
</div>


<hr>
<a id="method-trans_network-random_network"></a>



<h4>Method <code>random_network()</code>
</h4>

<p>Generate random networks, compare them with the empirical network and get the p value of topological properties.
The generation of random graph is based on the <code>erdos.renyi.game</code> function of igraph package.
The numbers of vertices and edges in the random graph are same with the empirical network stored in the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$random_network(runs = 100, output_sim = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>runs</code></dt>
<dd>
<p>default 100; simulation number of random network.</p>
</dd>
<dt><code>output_sim</code></dt>
<dd>
<p>default FALSE; whether output each simulated network result.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a data.frame with the following components:
</p>

<dl>
<dt><code>Observed</code></dt>
<dd>
<p>Topological properties of empirical network</p>
</dd>
<dt><code>Mean_sim</code></dt>
<dd>
<p>Mean of properties of simulated networks</p>
</dd>
<dt><code>SD_sim</code></dt>
<dd>
<p>SD of properties of simulated networks</p>
</dd>
<dt><code>p_value</code></dt>
<dd>
<p>Significance, i.e. p values</p>
</dd>
</dl>
<p>When <code>output_sim = TRUE</code>, the columns from the five to the last are each simulated result.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$random_network(runs = 100)
}
</pre>
</div>


<hr>
<a id="method-trans_network-trans_comm"></a>



<h4>Method <code>trans_comm()</code>
</h4>

<p>Transform classifed features to community-like microtable object for further analysis, such as module-taxa table.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$trans_comm(use_col = "module", abundance = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_col</code></dt>
<dd>
<p>default "module"; which column to use as the 'community'; must be one of the name of res_node_table from function <code>get_node_table</code>.</p>
</dd>
<dt><code>abundance</code></dt>
<dd>
<p>default TRUE; whether sum abundance of taxa. TRUE: sum the abundance for a taxon across all samples; 
FALSE: sum the frequency for a taxon across all samples.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a new <code>microtable</code> class.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t2 &lt;- t1$trans_comm(use_col = "module")
}
</pre>
</div>


<hr>
<a id="method-trans_network-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Print the trans_network object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$print()</pre></div>


<hr>
<a id="method-trans_network-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">
## ------------------------------------------------
## Method `trans_network$new`
## ------------------------------------------------


data(dataset)
# for correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.0002)
# for non-correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL)


## ------------------------------------------------
## Method `trans_network$cal_network`
## ------------------------------------------------

## Not run: 
# for correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.001)
t1$cal_network(COR_p_thres = 0.05, COR_cut = 0.6)
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.003)
t1$cal_network(network_method = "SpiecEasi", SpiecEasi_method = "mb")
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.005)
t1$cal_network(network_method = "beemStatic")
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.001)
t1$cal_network(network_method = "FlashWeave")

## End(Not run)

## ------------------------------------------------
## Method `trans_network$cal_module`
## ------------------------------------------------


t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.0002)
t1$cal_network(COR_p_thres = 0.01, COR_cut = 0.6)
t1$cal_module(method = "cluster_fast_greedy")


## ------------------------------------------------
## Method `trans_network$save_network`
## ------------------------------------------------

## Not run: 
t1$save_network(filepath = "network.gexf")

## End(Not run)

## ------------------------------------------------
## Method `trans_network$cal_network_attr`
## ------------------------------------------------


t1$cal_network_attr()


## ------------------------------------------------
## Method `trans_network$get_node_table`
## ------------------------------------------------


t1$get_node_table(node_roles = TRUE)


## ------------------------------------------------
## Method `trans_network$get_edge_table`
## ------------------------------------------------


t1$get_edge_table()


## ------------------------------------------------
## Method `trans_network$get_adjacency_matrix`
## ------------------------------------------------


t1$get_adjacency_matrix(attr = "weight")


## ------------------------------------------------
## Method `trans_network$plot_network`
## ------------------------------------------------


t1$plot_network(method = "igraph", layout = layout_with_kk)
t1$plot_network(method = "ggraph", node_color = "module")
t1$plot_network(method = "networkD3", node_color = "module")


## ------------------------------------------------
## Method `trans_network$cal_eigen`
## ------------------------------------------------


t1$cal_eigen()


## ------------------------------------------------
## Method `trans_network$plot_taxa_roles`
## ------------------------------------------------


t1$plot_taxa_roles(roles_color_background = FALSE)


## ------------------------------------------------
## Method `trans_network$subset_network`
## ------------------------------------------------


t1$subset_network(node = t1$res_node_table %&gt;% base::subset(module == "M1") %&gt;% 
  rownames, rm_single = TRUE)
# return a sub network that contains all nodes of module M1


## ------------------------------------------------
## Method `trans_network$cal_powerlaw`
## ------------------------------------------------


t1$cal_powerlaw()


## ------------------------------------------------
## Method `trans_network$cal_sum_links`
## ------------------------------------------------


t1$cal_sum_links(taxa_level = "Phylum")


## ------------------------------------------------
## Method `trans_network$plot_sum_links`
## ------------------------------------------------

## Not run: 
test1$plot_sum_links(method = "chorddiag", plot_pos = TRUE, plot_num = 10)
test1$plot_sum_links(method = "circlize", transparency = 0.2, 
	  annotationTrackHeight = circlize::mm_h(c(5, 5)))

## End(Not run)

## ------------------------------------------------
## Method `trans_network$random_network`
## ------------------------------------------------

## Not run: 
t1$random_network(runs = 100)

## End(Not run)

## ------------------------------------------------
## Method `trans_network$trans_comm`
## ------------------------------------------------


t2 &lt;- t1$trans_comm(use_col = "module")

</code></pre>


</div>