<div class="container">

<table style="width: 100%;"><tr>
<td>RecombinatorPair</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pair Recombinator Base Class</h2>

<h3>Description</h3>

<p>Base class for recombination that covers the common case of combining two individuals, where two (typically complementary) child individuals
could be taken as the result, such as bitwise crossover or SBX crossover.
</p>
<p>This is a relatively lightweight class, it adds the <code>keep_complement</code> active binding and sets <code style="white-space: pre;">⁠$n_indivs_in⁠</code> and <code style="white-space: pre;">⁠$n_indivs_out⁠</code> appropriately.
</p>


<h3>Inheriting</h3>

<p><code>RecombinatorPair</code> is an abstract base class and should be inherited from. Inheriting classes should implement the private
<code style="white-space: pre;">⁠$.recombine_pair()⁠</code> function. During <code style="white-space: pre;">⁠$operate()⁠</code>, the <code style="white-space: pre;">⁠$.recombine_pair()⁠</code> function is called with the same input as the <code style="white-space: pre;">⁠$.recombine()⁠</code> function
of the <code>Recombinator</code> class. It should return a <code>data.table</code> of two individuals.
</p>
<p>Constructors of inheriting  classes should have a <code>keep_complement</code> argument.
</p>


<h3>Super classes</h3>

<p><code>miesmuschel::MiesOperator</code> -&gt; <code>miesmuschel::Recombinator</code> -&gt; <code>RecombinatorPair</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>keep_complement</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Whether the operation keeps both resulting individuals of the operation or discards the complement.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorPair-new"><code>RecombinatorPair$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorPair-clone"><code>RecombinatorPair$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href="../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help"><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href="../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate"><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href="../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime"><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href="../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print"><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href="../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr"><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul></details><hr>
<a id="method-RecombinatorPair-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initialize base class components of the <code>RecombinatorPair</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorPair$new(
  keep_complement = TRUE,
  param_classes = c("ParamLgl", "ParamInt", "ParamDbl", "ParamFct"),
  param_set = ps(),
  packages = character(0),
  dict_entry = NULL,
  own_param_set = quote(self$param_set)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keep_complement</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Whether the operation should keep both resulting individuals (<code>TRUE</code>), or only the first and discard
the complement (<code>FALSE</code>). Default <code>TRUE</code>.
The <code style="white-space: pre;">⁠$keep_complement⁠</code> field will reflect this value.</p>
</dd>
<dt><code>param_classes</code></dt>
<dd>
<p>(<code>character</code>)<br>
Classes of parameters that the operator can handle. May contain any of <code>"ParamLgl"</code>, <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>.
Default is all of them.<br>
The <code style="white-space: pre;">⁠$param_classes⁠</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt>
<dd>
<p>(<code>ParamSet</code> | <code>list</code> of <code>expression</code>)<br>
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code>ParamSet</code>, it is used as the <code>MiesOperator</code>'s <code>ParamSet</code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code>ParamSet</code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code>ParamSet</code> are then combined using a <code>ParamSetCollection</code>.
Default is the empty <code>ParamSet</code>.<br>
The <code style="white-space: pre;">⁠$param_set⁠</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt>
<dd>
<p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br>
The <code style="white-space: pre;">⁠$packages⁠</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt>
<dd>
<p>(<code>character(1)</code> | <code>NULL</code>)<br>
Key of the class inside the <code>Dictionary</code> (usually one of
<code>dict_mutators</code>, <code>dict_recombinators</code>, <code>dict_selectors</code>), where it can
be retrieved using a short access function. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br>
The <code style="white-space: pre;">⁠$dict_entry⁠</code> field will reflect this value.</p>
</dd>
<dt><code>own_param_set</code></dt>
<dd>
<p>(<code>language</code>)<br>
An expression that evaluates to a <code>ParamSet</code> indicating the configuration parameters that are entirely owned by
this operator class (and not proxied from a construction argument object). This should be <code>quote(self$param_set)</code> (the default) when
the <code>param_set</code> argument is not a list of expressions.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-RecombinatorPair-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorPair$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>Other base classes: 
<code>Filtor</code>,
<code>FiltorSurrogate</code>,
<code>MiesOperator</code>,
<code>Mutator</code>,
<code>MutatorDiscrete</code>,
<code>MutatorNumeric</code>,
<code>OperatorCombination</code>,
<code>Recombinator</code>,
<code>Scalor</code>,
<code>Selector</code>,
<code>SelectorScalar</code>
</p>
<p>Other recombinators: 
<code>OperatorCombination</code>,
<code>Recombinator</code>,
<code>dict_recombinators_cmpmaybe</code>,
<code>dict_recombinators_convex</code>,
<code>dict_recombinators_cvxpair</code>,
<code>dict_recombinators_maybe</code>,
<code>dict_recombinators_null</code>,
<code>dict_recombinators_proxy</code>,
<code>dict_recombinators_sbx</code>,
<code>dict_recombinators_sequential</code>,
<code>dict_recombinators_swap</code>,
<code>dict_recombinators_xonary</code>,
<code>dict_recombinators_xounif</code>
</p>


</div>