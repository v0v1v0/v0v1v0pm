<div class="container">

<table style="width: 100%;"><tr>
<td>dict_recombinators_cvxpair</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convex Combination Recombinator for Pairs</h2>

<h3>Description</h3>

<p>Numeric Values between various individuals are recombined via component-wise convex combination (or weighted mean). Exactly two
individuals are being recombined, and the <code>lambda</code> configuration parameter determines the relative weight of the first
individual in each pair for the first result, and the relative weight of the second indivudual for the complement, if
initialized with <code>keep_complement</code> set to <code>TRUE</code>.
</p>


<h3>Configuration Parameters</h3>


<ul><li> <p><code>lambda</code> :: <code>numeric</code><br>
Combination weight. If <code>keep_complement</code> is <code>TRUE</code>, then two individuals are returned for each pair of input individuals:
one corresponding to <code style="white-space: pre;">⁠lambda * &lt;1st individual&gt; + (1-lambda) * &lt;2nd individual&gt;⁠</code>, and one corresponding to
<code style="white-space: pre;">⁠(1-lambda) * &lt;1st individual&gt; + lambda * &lt;2nd individual&gt;⁠</code> (i.e. the complement). Otherwise, only the first of these two
is generated.
Must either be a scalar, or a vector with length equal to the number of
components in the values being operated on. Must be between 0 and 1.<br>
Initialized to 0.5.
</p>
</li></ul>
<h3>Supported Operand Types</h3>

<p>Supported <code>Domain</code> classes are: <code>p_dbl</code> ('ParamDbl')
</p>


<h3>Dictionary</h3>

<p>This <code>Recombinator</code> can be created with the short access form <code>rec()</code>
(<code>recs()</code> to get a list), or through the the dictionary
<code>dict_recombinators</code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("convex")
recs("convex")  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("convex")
</pre></div>


<h3>Super classes</h3>

<p><code>miesmuschel::MiesOperator</code> -&gt; <code>miesmuschel::Recombinator</code> -&gt; <code>miesmuschel::RecombinatorPair</code> -&gt; <code>RecombinatorConvexPair</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorConvexPair-new"><code>RecombinatorConvexPair$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorConvexPair-clone"><code>RecombinatorConvexPair$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href="../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help"><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href="../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate"><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href="../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime"><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href="../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print"><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href="../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr"><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul></details><hr>
<a id="method-RecombinatorConvexPair-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initialize the <code>RecombinatorConvexPair</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorConvexPair$new(keep_complement = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keep_complement</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Whether the operation should keep both resulting individuals (<code>TRUE</code>), or only the first and discard
the complement (<code>FALSE</code>). Default <code>TRUE</code>.
The <code style="white-space: pre;">⁠$keep_complement⁠</code> field will reflect this value.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-RecombinatorConvexPair-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorConvexPair$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>Other recombinators: 
<code>OperatorCombination</code>,
<code>Recombinator</code>,
<code>RecombinatorPair</code>,
<code>dict_recombinators_cmpmaybe</code>,
<code>dict_recombinators_convex</code>,
<code>dict_recombinators_maybe</code>,
<code>dict_recombinators_null</code>,
<code>dict_recombinators_proxy</code>,
<code>dict_recombinators_sbx</code>,
<code>dict_recombinators_sequential</code>,
<code>dict_recombinators_swap</code>,
<code>dict_recombinators_xonary</code>,
<code>dict_recombinators_xounif</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
rcvx = rec("cvxpair")
p = ps(x = p_dbl(-5, 5), y = p_dbl(-5, 5), z = p_dbl(-5, 5))
data = data.frame(x = 0:5, y = 0:5, z = 0:5)

rcvx$prime(p)
rcvx$operate(data)  # mean of groups of 2
# with the default value of lambda = 0.5, the default of
# keep_complement = TRUE means that pairs of equal values are generated;
# consider setting keep_complement = FALSE int that case.

rcvx$param_set$values$lambda = 0.1
rcvx$operate(data)

</code></pre>


</div>