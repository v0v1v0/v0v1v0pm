<div class="container">

<table style="width: 100%;"><tr>
<td>mies_aggregate_generations</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get Aggregated Performance Values by Generation</h2>

<h3>Description</h3>

<p>Get evaluated performance values from an <code>OptimInstance</code> aggregated for each generation.
This may either concern all individuals that were alive at the end of a given generation (<code>survivors_only</code> <code>TRUE</code>)
or at any point during a generation (<code>survivors_only</code> <code>FALSE</code>).
</p>
<p>The result is a single <code>data.table</code> object with a <code>dob</code> column indicating the
generation, as well as one column for each <code>aggregations</code> entry crossed with each objective of <code>inst</code>.
</p>
<p>See <code>mies_generation_apply()</code> on how to apply functions to entire fitness-matrices, not only individual objectives.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mies_aggregate_generations(
  inst,
  objectives = inst$archive$codomain$ids(),
  aggregations = list(min = min, mean = mean, max = max, median = stats::median, size =
    length),
  as_fitnesses = TRUE,
  survivors_only = TRUE,
  condition_on_budget_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>inst</code></td>
<td>
<p>(<code>OptimInstance</code>)<br>
Optimization instance to evaluate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objectives</code></td>
<td>
<p>(<code>character</code>)<br>
Objectives for which to calculate aggregates. Must be a subset of the codomain elements of <code>inst</code>, but when <code>as_fitnesses</code> is <code>TRUE</code>, elements
that are neither being minimized nor maximized are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregations</code></td>
<td>
<p>(named <code>list</code> of <code>function</code>)<br>
List containing aggregation functions to be evaluated on a vector of objective falues for each generation. These functions should take
a single argument and return a scalar value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_fitnesses</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Whether to transform performance values into "fitness" values that are always to be maximized.
This means that values that objectives that should originally be minimized are multiplied with -1,
and that parts of the objective codomain that are neither being minimized nor maximized are dropped.
Default <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>survivors_only</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Whether to ignore configurations that have <code>"eol"</code> set to the given generation, i.e. individuals that were killed during that generation.
When this is <code>TRUE</code> (default), then only individuals that are alive at the <em>end</em> of a generation are considered; otherwise all individuals
alive at any point of a generation are considered. If it is <code>TRUE</code>, this leads to individuals that have <code>"dob"</code> == <code>"eol"</code> being ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition_on_budget_id</code></td>
<td>
<p>(<code>character(1)</code> | <code>NULL</code>)<br>
Budget component when doing multi-fidelity optimization. When this is given, then for each generation, only individuals with the highest value for this
component are considered. If <code>survivors_only</code> is <code>TRUE</code>, this means the highest value of all survivors of a given generation, if it is <code>FALSE</code>, then it
is the highest value of all individuals alive at any point of a generation. To ignore possible budget-parameters, set this to <code>NULL</code> (default).
This is inparticular necessary when fidelity is not monotonically increasing (e.g. if it is categorical).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a <code>data.table</code> with the column <code>"dob"</code>, indicating the generation, as well as further
columns named by the items in <code>aggregations</code>. There is more on element in <code>objectives</code>
(or more than one element not being minimized/maximized when <code>as_fitnesses</code> is <code>TRUE</code>), then columns are named <code style="white-space: pre;">⁠&lt;aggregations element name&gt;.&lt;objective name&gt;⁠</code>.
Otherwise, they are named by <code style="white-space: pre;">⁠&lt;aggregations element name&gt;⁠</code> only. To get a guarantee that elements are only named after elements in <code>aggregations</code>, set <code>objectives</code>
to a length 1 <code>character</code>.
</p>


<h3>See Also</h3>

<p>Other aggregation methods: 
<code>mies_aggregate_single_generation()</code>,
<code>mies_get_generation_results()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- 10 - exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "minimize"))
)

oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 6)
)

op &lt;- opt("mies",
  lambda = 2, mu = 2,
  mutator = mut("gauss", sdev = 0.1),
  recombinator = rec("xounif"),
  parent_selector = sel("best")
)
set.seed(1)
op$optimize(oi)

# negates objectives that are minimized:
mies_aggregate_generations(oi)

# silly aggregation: first element
mies_aggregate_generations(oi, aggregations = list(first = function(x) x[1]))

# real objective values:
mies_aggregate_generations(oi, as_fitnesses = FALSE)

# Individuals that died are included:
mies_aggregate_generations(oi, survivors_only = FALSE)
</code></pre>


</div>