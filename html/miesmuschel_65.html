<div class="container">

<table style="width: 100%;"><tr>
<td>mies_aggregate_single_generation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate a Value for a given Generation</h2>

<h3>Description</h3>

<p>Applies a <code>fitness_aggregator</code> function to the values that were alive in the archive at a given generation.
The function is supplied with the fitness values, and optionally other data, of all individuals that are alive at that point.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mies_aggregate_single_generation(
  archive,
  fitness_aggregator,
  generation = NA,
  include_previous_generations = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>archive</code></td>
<td>
<p>(<code>Archive</code>)<br>
The archive over which to aggregate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitness_aggregator</code></td>
<td>
<p>(<code>function</code>)<br>
Aggregation function, called with information about alive individuals of each generation. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>generation</code></td>
<td>
<p>(<code>numeric(1)</code>)<br>
Generation for which to aggregate the value.
If <code>include_previous_generations</code> is <code>FALSE</code>, then an individual is considered to be alive at generation <code>i</code> if its <code>dob</code> is smaller or equal to <code>i</code>, and
if its <code>eol</code> is either <code>NA</code> or greater than <code>i</code>. If <code>include_previous_generations</code> is <code>TRUE</code>, then all individuals with <code>dob</code> smaller or equal to <code>i</code> are
considered.
If this is <code>NA</code>, the currently alive (<code>include_previous_generations</code> <code>FALSE</code>) or all (<code>include_previous_generations</code> <code>TRUE</code>) individuals are aggregated.
If multiple individuals considered "alive" with the same <code>x_id</code> are found, then only the last individual is used.
This excludes previous individuals that were re-evaluated with a different fidelity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_previous_generations</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Aggregate all individuals that were alive at <code>generation</code> or at any point before that.
Duplicates with the same <code>x_id</code> are removed, meaning that if an individual was re-evaluated with different fidelity, only the last
re-evaluation is counted.
However, note that individuals from different generations may still have been evaluated with different fidelity, so if
Default <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>fitness_aggregator</code> function may have any of the following arguments, which will be given the following information when
<code>fitness_aggregator</code> is called:
</p>

<ul>
<li> <p><code>fitnesses</code> :: <code>matrix</code><br>
Will contain fitnesses for each alive individual. This value has one column when doing single-crit optimization and one column for
each "criterion" when doing multi-crit optimization.
Fitnesses are always being maximized, so if an objective is being minimized, the <code>fitness_aggregator</code> function is given the objective values * -1.
</p>
</li>
<li> <p><code>objectives_unscaled</code> :: <code>matrix</code><br>
The objective values as given to <code>fitnesses</code>, but not multiplied by -1 if they are being minimized. It is recommended that
the <code>codomain</code> argument is queried for <code>"maximize"</code> or <code>"minimize"</code> tags when <code>objectives_unscaled</code> is used.
</p>
</li>
<li> <p><code>budget</code> :: <code>scalar</code><br>
If multi-fidelity evaluation is being performed, then this is the "budget" value of each individual. Otherwise it is a vector containing the value
1 for each individual.
</p>
</li>
<li> <p><code>xdt</code> :: <code>data.table</code><br>
The configurations that were evaluated for the alive individuals. Rows are in the same order as the values given to <code>fitnesses</code>
or <code>objectives_unscaled</code>.
</p>
</li>
<li> <p><code>search_space</code> :: <code>ParamSet</code><br>
The search space of the <code>Archive</code> under evaluation.
</p>
</li>
<li> <p><code>codomain</code> :: <code>ParamSet</code><br>
The codomain of the <code>Archive</code> under evaluation.
This is particularly useful when using <code>objectives_unscaled</code> to determine minimization or maximization.
</p>
</li>
</ul>
<p>Not all of these arguments need to present, but at least one of <code>fitnesses</code>, <code>objectives_unscaled</code>, or <code>xdt</code> must be.
</p>
<p><code>fitness_aggregator</code> will never be called for an empty generation.
</p>


<h3>Value</h3>

<p>The value returned by <code>fitness_aggregator</code> when applied to individuals alive at generation <code>generation</code>. If no
individuals of the requested generation are present, <code>fitness_aggregator</code> is not called
and <code>mies_aggregate_single_generation()</code> returns <code>NULL</code> instead.
</p>


<h3>See Also</h3>

<p>Other aggregation methods: 
<code>mies_aggregate_generations()</code>,
<code>mies_get_generation_results()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("bbotk")
lgr::threshold("warn")

objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    list(y1 = xs$x1, y2 = xs$x2)
  },
  domain = ps(x1 = p_dbl(0, 1), x2 = p_dbl(-1, 0)),
  codomain = ps(y1 = p_dbl(0, 1, tags = "maximize"),
    y2 = p_dbl(-1, 0, tags = "minimize"))
)

oi &lt;- OptimInstanceMultiCrit$new(objective, terminator = trm("none"))

try(mies_aggregate_single_generation(oi$archive, identity), silent = TRUE)

mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses)


mies_init_population(oi, 2, budget_id = "x1", fidelity = .5)

oi$archive$data

mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses)

# Notice how fitnesses are positive, since x2 is scaled with -1.
# To get the original objective-values, use objectives_unscaled:
mies_aggregate_single_generation(oi$archive,
  function(objectives_unscaled) objectives_unscaled)

# When `...` is used, all information is passed:
mies_aggregate_single_generation(oi$archive, function(...) names(list(...)))

# Generation 10 is not present, but individuals with eol `NA` are still
# considered alive:
mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses,
  generation = 10)

# Re-evaluating points with higher "fidelity" (x1)
mies_step_fidelity(oi, budget_id = "x1", fidelity = 0.7)

oi$archive$data
# Lower-fidelity values are considered dead now, even for generation 1:
mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses,
  generation = 1)

# This adds two new alive individuals at generation 2.
# Also the individuals from gen 1 are reevaluated with fidelity 0.8
mies_evaluate_offspring(oi, offspring = data.frame(x2 = c(-0.1, -0.2)),
  budget_id = "x1", fidelity = 0.9, reevaluate_fidelity = 0.8)

oi$archive$data

mies_aggregate_single_generation(oi$archive, function(budget, ...) budget)

mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses,
  generation = 1)

mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses,
  generation = 2)

# No individuals were killed, but some were fidelity-reevaluated.
# These are not present with include_previous_generations:
mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses,
  generation = 2, include_previous_generations = TRUE)

# Typical use-case: get dominated hypervolume
mies_aggregate_single_generation(oi$archive, function(fitnesses) domhv(fitnesses))

# Get generation-wise mean fitness values
mies_aggregate_single_generation(oi$archive, function(fitnesses) {
  apply(fitnesses, 2, mean)
})
</code></pre>


</div>