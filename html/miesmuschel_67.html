<div class="container">

<table style="width: 100%;"><tr>
<td>mies_filter_offspring</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter Offspring</h2>

<h3>Description</h3>

<p>Uses a <code>Filtor</code> to extract a subset of individuals from a given set. The individuals are either returned directly (when <code>get_indivs</code> is <code>TRUE</code>)
or in form of an index into the given individuals (when <code>get_indivs</code> is <code>FALSE</code>).
</p>
<p><code>Filtor</code>s must always select individuals without replacement, so selected individual indices are unique.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mies_filter_offspring(
  inst,
  individuals,
  lambda,
  filtor = NULL,
  budget_id = NULL,
  fidelity = NULL,
  get_indivs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>inst</code></td>
<td>
<p>(<code>OptimInstance</code>)<br>
Optimization instance to evaluate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>individuals</code></td>
<td>
<p>(<code>data.frame</code> | <code>data.table</code>)<br>
Individuals to filter. Must have columns according to <code>filtor$primed_ps</code>, and must have at least <code>filtor$needed_input(lambda)</code> rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>(<code>integer(1)</code>)<br>
Number of individuals to filter down to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filtor</code></td>
<td>
<p>(<code>Filtor</code> | <code>NULL</code>)<br><code>Filtor</code> operator that filters. When <code>NULL</code> is given, then the <code>FiltorNull</code> operation is performed and the first <code>lambda</code> individuals are
taken from <code>individuals</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>budget_id</code></td>
<td>
<p>(<code>character(1)</code> | <code>NULL</code>)<br>
Budget component when doing multi-fidelity optimization. This component of the search space is added
to <code>individuals</code> according to <code>fidelity</code>. Should be <code>NULL</code> when no multi-fidelity optimization is performed (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fidelity</code></td>
<td>
<p>(<code>atomic</code> | <code>NULL</code>)<br>
scalar indicating the value of the <code>budget_id</code> component with which to evaluate individuals to be filtered.<br>
This value must be <code>NULL</code> when no multi-fidelity optimization is performed, but it may <strong>also</strong> be <code>NULL</code> when the
maximum value of the <code>budget_id</code> found in <code>inst$archive</code> should be used (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>get_indivs</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Whether to return the <code>data.frame</code> or <code>data.table</code> of selected individuals, or an index into <code>individuals</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>get_indivs</code> is <code>TRUE</code>: a <code>data.frame</code> or <code>data.table</code> (depending on the input type of <code>individuals</code>) of filtered configurations.
If <code>get_indivs</code> is <code>FALSE</code>: an <code>integer</code> vector indexing the filtered individuals.
</p>


</div>