<div class="container">

<table style="width: 100%;"><tr>
<td>mies_generation_apply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate Values for All Generations Present</h2>

<h3>Description</h3>

<p>Applies a <code>fitness_aggregator</code> function to the values that were alive in the archive at at any generation.
<code>mies_aggregate_single_generation()</code> is used, see there for more information about <code>fitness_aggregator</code>.
</p>
<p>Generations for which <code>fitness_aggregator</code> returns <code>NULL</code>, or which are not present in any <code>dob</code> in the archive,
or which contain no alive individuals (e.g. because <code>eol</code> is smaller or equal <code>dob</code> for all of them) are ignored.
</p>
<p><code>as.list()</code> is applied to the values returned by <code>fitness_aggregator</code>, and <code>data.table::rbindlist()</code> is called on
the list of resulting values. If the first non-<code>NULL</code>-value returned by <code>fitness_aggregator</code>, then <code>data.table::rbindlist()</code>
is called with <code>fill = TRUE</code> and <code>use.names = TRUE</code>.
</p>
<p>If no non-empty generations are present, or <code>fitness_aggregator</code> returns <code>NULL</code> on every call, then the return value
is <code>data.table(dob = numeric(0))</code>.
</p>
<p>In contrast with <code>mies_aggregate_generations()</code>, <code>mies_generate_apply()</code> can construct aggregated values for
entire fitness matrices, not only individual objectives (see examples). However, <code>mies_aggregate_generations()</code> is simpler
if per-objective aggregates are desired.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mies_generation_apply(
  archive,
  fitness_aggregator,
  include_previous_generations = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>archive</code></td>
<td>
<p>(<code>Archive</code>)<br>
The archive over which to aggregate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitness_aggregator</code></td>
<td>
<p>(<code>function</code>)<br>
Aggregation function, called with information about alive individuals of each generation. See <code>mies_aggregate_single_generation()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_previous_generations</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Aggregate all individuals that were alive at <code>generation</code> or at any point before that.
Duplicates with the same <code>x_id</code> are removed, meaning that if an individual was re-evaluated with different fidelity, only the last
re-evaluation is counted.
However, note that individuals from different generations may still have been evaluated with different fidelity, so if
Default <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>data.table</code> with columns <code>dob</code>, next to the columns constructed from the return values of <code>fitness_aggregator</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
library("bbotk")
lgr::threshold("warn")

objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    list(y1 = xs$x1, y2 = xs$x2)
  },
  domain = ps(x1 = p_dbl(0, 1), x2 = p_dbl(-1, 0)),
  codomain = ps(y1 = p_dbl(0, 1, tags = "maximize"),
    y2 = p_dbl(-1, 0, tags = "minimize"))
)
oi &lt;- OptimInstanceMultiCrit$new(objective,
  terminator = trm("evals", n_evals = 40))

op &lt;- opt("mies",
  lambda = 4, mu = 4,
  mutator = mut("gauss", sdev = 0.1),
  recombinator = rec("xounif"),
  parent_selector = sel("random"),
  survival_selector = sel("best", scl("hypervolume"))
)

op$optimize(oi)

# Aggregated hypervolume of individuals alive in each gen:
mies_generation_apply(oi$archive, function(fitnesses) {
  domhv(fitnesses)
})

# Aggregated hypervolume of all points evaluated up to each gen
# (may be slightly more, since the domhv of more points is evaluated).
# This would be the dominated hypervolume of the result set at each
# generation:
mies_generation_apply(oi$archive, function(fitnesses) {
  domhv(fitnesses)
}, include_previous_generations = TRUE)

# The following are simpler with mies_aggregate_single_generations():
mies_generation_apply(oi$archive, function(fitnesses) {
  apply(fitnesses, 2, mean)
})
# Compare:
mies_aggregate_generations(oi, aggregations = list(mean = mean))

mies_generation_apply(oi$archive, function(objectives_unscaled) {
  apply(objectives_unscaled, 2, mean)
})
# Compare:
mies_aggregate_generations(oi, aggregations = list(mean = mean),
  as_fitnesses = FALSE)
</code></pre>


</div>