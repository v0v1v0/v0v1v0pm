<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_terminators_genstag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Terminator That Stops When a Generation-Wise Aggregated Value Stagnates</h2>

<h3>Description</h3>

<p><code>Terminator</code> that terminates when a value, aggregated over generations, stagnates.
</p>
<p>The user-supplied <code>fitness_aggregator</code> function is called whenever the archive of evaluated configurations contains a new generation.
The function is supplied with the fitness values, and optionally other data, of all individuals that are alive at that point
(<code>include_previous_generations = FALSE</code>) or at any point (<code>include_previous_generations = TRUE</code>).
Its result is saved inside the <code style="white-space: pre;">⁠$data_extra⁠</code> field of the <code>Archive</code> object.
Termination is then signaled when the aggregated value has stagnated, or not improved enough, for a given number of generations.
</p>
<p>The <code>mies_aggregate_single_generation()</code> function is used, see the documentation there for the functioning of <code>fitness_aggregator</code>.
The <code>fitness_aggregator</code> functions used for termination must return a scalar value or <code>NULL</code>, if a generation should be ignored.
The value returned by <code>fitness_aggregator</code> should be increasing for better performance, even if the underlying objective is being minimized.
</p>
<p>Termination is triggered in generation <code>i</code> when the aggregated value, returned by <code>fitness_aggregator</code>, of generation <code>i - patience</code>
is not greater than the maximum of all later generations (<code>i - patience + 1</code> .. <code>i</code>) by at least <code>min_delta</code>.
</p>
<p>If the aggregated value for generation <code>i - patience</code> is not known, for example because fewer than <code>patience + 1</code> generations
have been evaluated so far, because <code>fitness_aggregator</code> returned <code>NULL</code>, or because previous generations were evaluated
when <code>TerminatorGenerationStagnation</code> was not used, then termination is not triggered, regardless of whether values are known
for generations <em>before</em> generation <code>i - patience</code>.
</p>


<h3>Multi-Fidelity Optimization</h3>

<p>Multi-fidelity optimization can introduce a few edge-cases, for one because the individuals inside the generation(s) being aggregated may have
been evaluated with different fidelity values, which can give biased results. Besides that, it may also be problematic that increase of
fidelity could lead to "worse" aggregated results (e.g. because of reduced noise making max-aggregation worse), triggering an undesired termination.
</p>


<h4>Termination from fidelity changes</h4>

<p>Higher fidelity values can sometimes lead to worse aggregated fitness values, which can trigger undesired termination.
However, in many multi-fidelity-setups, terminating before the last fidelity increase, controlled e.g. by the <code>fidelity</code>
configuration parameter of <code>OptimizerMies</code>, may be undesirable to begin with.
</p>
<p>If the fidelity increase follows a fixed schedule based on evaluations or generations, one solution may be to use a
<code>TerminatorCombo</code> together with a <code>TerminatorEvals</code> or <code>TerminatorGenerations</code>
that prevents premature termination. Termination should happen at least <code>patience</code> generations after the last switch to the
highest fidelity if termination from biased values because of fidelity changes should be avoided.
</p>
<p>Otherwise it may be necessary to check whether the <code>budget</code> value given to <code>fitness_aggregator</code> reached the desired level,
and to prevent comparisons by letting <code>fitness_aggregator</code> return <code>NULL</code> if not.
</p>
<p>In both cases one may still have a problem with biased aggregations within an aggregated set of individuals if <code>include_previous_generations</code>
is <code>TRUE</code>.
</p>



<h4>Biases within aggregated generation(s)</h4>

<p>When <code>OptimizerMies</code> is constructed with <code>multi_fidelity</code> set to <code>TRUE</code>, it typically evaluates some configurations multiple times,
at first with a lower fidelity, followed by an evaluation at "full" fidelity.
<code>fitness_aggregator</code> will only be called for generations containing entirely full-fidelity-evaluations will be aggregated.
</p>
<p>This is achieved by caching aggregated fitness values in the <code style="white-space: pre;">⁠$data_extra⁠</code> field of the <code>Archive</code> and only ever calling
<code>fitness_aggregator</code> for a generation that does not have a cached value. Since <code>mies_step_fidelity()</code> will
count low-fidelity evaluations as part of the "previous" generation, <code>fitness_aggregator</code> will not see them.
Note, however that if <code>fitness_aggregator</code> returns <code>NULL</code>, it will be called again should a second evaluation occur in the same generation,
since <code>NULL</code> is not cached and instead treated as absent.
</p>
<p>It is possible for <code>fitness_aggregator</code> to see fitness values that were evaluated with different fidelities when using <code>OptimizerMies</code>,
and
</p>

<ol>
<li> <p><code>fidelity_monotonic</code> is set to <code>TRUE</code> and fidelity decreases (unlikely setup), or
</p>
</li>
<li>
<p> if <code>fidelity_current_gen_only</code> is set to <code>FALSE</code> (advanced usage), or
</p>
</li>
<li>
<p> The value returned by the <code>fidelity</code> configuration parameter (not <code>fidelity_offspring</code>) changes over the course of optimization and
<code>include_previous_generations</code> of <code>TerminatorGenerationStagnation</code> is set to <code>TRUE</code>.
</p>
</li>
</ol>
<p>(1) and (2) only need consideration in advanced scenarios, but (3) may be a common, e.g. when doing multi-fidelity optimization
and stopping on overall dominated hypervolume stagnation. In this case, it may be necessary to inspect the <code>budget</code> value given to <code>fitness_aggregator</code>
and to remove all individuals evaluated with a different than the current fidelity.
</p>
<p>When using a custom-written optimization loop, case (1) relates to <code>fidelity_monotonic</code> argument of <code>mies_step_fidelity()</code> and <code>mies_init_population()</code>,
and case (2) relates to the <code>current_gen_only</code> argument of <code>mies_step_fidelity()</code> and the <code>fidelity_new_individuals_only</code> argument of <code>mies_init_population()</code>.
Case (3) relates to changing the fidelity given to <code>mies_step_fidelity()</code> if that function is used, or to changing the fidelity given to <code>mies_evaluate_offspring()</code> if
<code>mies_step_fidelity()</code> is not used.
</p>



<h3>Dictionary</h3>

<p>This <code>Terminator</code> can be created with the short access form <code>trm()</code> (<code>trms()</code> to get a list),
or through the dictionary <code>mlr_terminators</code> in the following way:
</p>
<div class="sourceCode"><pre># preferred
trm("genstag")
trms("genstag")  # takes vector IDs, returns list of Terminators

# long form
mlr_terminators$get("genstag")
</pre></div>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>fitness_aggregator</code> :: <code>function</code><br>
Aggregation function, called with information about alive individuals of each generation.
This argument is passed to <code>mies_aggregate_single_generation()</code>, see there for more details.
The aggregated values returned by <code>fitness_aggregator</code> should be maximized, so a larger value must be returned to indicate improvement in a generation,
even if an underlying objective is being minimized. The return value must be a scalar <code>numeric(1)</code>.
</p>
</li>
<li> <p><code>include_previous_generations</code> :: <code>logical(1)</code><br>
Whether to aggregate over all individuals that were evaluated (<code>TRUE</code>), or only the individuals alive in the current generation (<code>FALSE</code>).
If multi-fidelity optimization is being performed and individuals were re-evaluated with a different fidelity, their <code>x_id</code> will be the same and only
the last fidelity-reevaluation will be given to <code>fitness_aggregator</code>. However, individuals from different generations may still have been evaluated
with different fidelity and it may be necessary to inspect the <code>budget</code> value given to <code>fitness_aggregator</code> if <code>include_previous_generations</code> is <code>TRUE</code> in a
multi-fidelity-setting. See the "Multi-Fidelity Optimization" section for more.
</p>
</li>
<li> <p><code>min_delta</code> :: <code>numeric(1)</code><br>
Minimum positive change of aggregated value to count as improvement.
This value may also be negative, resulting in termination only when aggregated value <em>decreases</em> by at least the given amount.
However, depending on the survival setup, or on <code>include_previous_generations</code>, it is possible that aggregate values never decrease; in this
case, setting <code>min_delta</code> to a negative value may never trigger termination.
Initialized to 0.
</p>
</li>
<li> <p><code>patience</code> :: <code>integer(1)</code><br>
Number of generations with no improvement better than <code>min_delta</code> after which to terminate.
Initialized to 1.
</p>
</li>
</ul>
<h3>Super class</h3>

<p><code>bbotk::Terminator</code> -&gt; <code>TerminatorGenerationStagnation</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorGenerationStagnation-new"><code>TerminatorGenerationStagnation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorGenerationStagnation-is_terminated"><code>TerminatorGenerationStagnation$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorGenerationStagnation-clone"><code>TerminatorGenerationStagnation$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href="../../bbotk/html/Terminator.html#method-Terminator-format"><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href="../../bbotk/html/Terminator.html#method-Terminator-print"><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href="../../bbotk/html/Terminator.html#method-Terminator-remaining_time"><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href="../../bbotk/html/Terminator.html#method-Terminator-status"><code>bbotk::Terminator$status()</code></a></span></li>
</ul></details><hr>
<a id="method-TerminatorGenerationStagnation-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initialize the <code>TerminatorGenerationStagnation</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerationStagnation$new()</pre></div>


<hr>
<a id="method-TerminatorGenerationStagnation-is_terminated"></a>



<h4>Method <code>is_terminated()</code>
</h4>

<p>Is <code>TRUE</code> if when the termination criterion is matched, <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerationStagnation$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt>
<dd>
<p><code>Archive</code>
Archive to check.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>logical(1)</code>: Whether to terminate.
</p>


<hr>
<a id="method-TerminatorGenerationStagnation-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerationStagnation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
library("bbotk")
lgr::threshold("warn")

# Terminate when hypervolume with nadir `c(0, 0, ...)`
# does not improve for 3 generations by at least 0.1:
tg &lt;- trm("genstag",
  fitness_aggregator = function(fitnesses) domhv(fitnesses),
  include_previous_generations = TRUE,
  min_delta = 0.1,
  patience = 3
)

set.seed(1)
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    list(y1 = xs$x1, y2 = xs$x2)
  },
  domain = ps(x1 = p_dbl(0, 1), x2 = p_dbl(-1, 0)),
  codomain = ps(y1 = p_dbl(0, 1, tags = "maximize"),
    y2 = p_dbl(-1, 0, tags = "minimize"))
)

oi &lt;- OptimInstanceMultiCrit$new(objective, terminator = tg)

op &lt;- opt("mies",
  lambda = 4, mu = 4,
  mutator = mut("gauss", sdev = 0.1),
  recombinator = rec("xounif"),
  parent_selector = sel("random"),
  survival_selector = sel("best", scl("hypervolume"))
)

op$optimize(oi)

# the observed aggregated values:
oi$archive$data_extra$TerminatorGenerationStagnation

# ... or as calculated by mies_generation_apply
mies_generation_apply(oi$archive, function(fitnesses) {
  domhv(fitnesses)
}, include_previous_generations = TRUE)
#' @export
</code></pre>


</div>