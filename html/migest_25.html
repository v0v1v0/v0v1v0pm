<div class="container">

<table style="width: 100%;"><tr>
<td>ipf2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Iterative proportional fitting routine for the indirect estimation of origin-destination migration flow table with known margins.</h2>

<h3>Description</h3>

<p>The <code>ipf2</code> function finds the maximum likelihood estimates for fitted values in the log-linear model:
</p>
<p style="text-align: center;"><code class="reqn">\log y_{ij} = \log \alpha_{i} + \log \beta_{j} + \log m_{ij} </code>
</p>

<p>where <code class="reqn">m_{ij}</code> is a set of prior estimates for <code class="reqn">y_{ij}</code> and itself is no more complex than the one being fitted.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ipf2(
  row_tot = NULL,
  col_tot = NULL,
  m = matrix(1, length(row_tot), length(col_tot)),
  tol = 1e-05,
  maxit = 500,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>row_tot</code></td>
<td>
<p>Vector of origin totals to constrain the sum of the imputed cell rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_tot</code></td>
<td>
<p>Vector of destination totals to constrain the sum of the imputed cell columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Matrix of auxiliary data. By default set to 1 for all origin-destination combinations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Numeric value for the tolerance level used in the parameter estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Numeric value for the maximum number of iterations used in the parameter estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Iterative Proportional Fitting routine set up in a similar manner to Agresti (2002, p.343). This is equivalent to a conditional maximization of the likelihood, as discussed by Willekens (1999), and hence provides identical indirect estimates to those obtained from the <code>cm2</code> routine. 
</p>
<p>The user must ensure that the row and column totals are equal in sum. Care must also be taken to allow the dimension of the auxiliary matrix (<code>m</code>) to equal those provided in the row and column totals.
</p>
<p>If only one of the margins is known, the function can still be run. The indirect estimates will correspond to the log-linear model without the <code class="reqn">\alpha_{i}</code> term if (<code>row_tot = NULL</code>) or without the <code class="reqn">\beta_{j}</code> term if (<code>col_tot = NULL</code>)
</p>
<p>Returns a <code>list</code> object with
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mu </code></td>
<td>
<p>Origin-Destination matrix of indirect estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>it </code></td>
<td>
<p>Iteration count</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol </code></td>
<td>
<p>Tolerance level at final iteration</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Agresti, A. (2002). <em>Categorical Data Analysis</em> 2nd edition. Wiley. 
</p>
<p>Willekens, F. (1999). Modelling Approaches to the Indirect Estimation of Migration Flows: From Entropy to EM. <em>Mathematical Population Studies</em> 7 (3), 239â€“78.
</p>


<h3>See Also</h3>

<p><code>cm2</code>, <code>ipf3</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## with Willekens (1999) data
dn &lt;- LETTERS[1:2]
y &lt;- ipf2(row_tot = c(18, 20), col_tot = c(16, 22), 
          m = matrix(c(5, 1, 2, 7), ncol = 2, 
                     dimnames = list(orig = dn, dest = dn)))
round(addmargins(y$mu),2)

## with all elements of offset equal
y &lt;- ipf2(row_tot = c(18, 20), col_tot = c(16, 22))
round(addmargins(y$mu),2)

## with bigger matrix
dn &lt;- LETTERS[1:3]
y &lt;- ipf2(row_tot = c(170, 120, 410), col_tot = c(500, 140, 60), 
          m = matrix(c(50, 10, 220, 120, 120, 30, 545, 0, 10), ncol = 3, 
                     dimnames = list(orig = dn, dest = dn)))
# display with row and col totals
round(addmargins(y$mu))

## only one margin known
dn &lt;- LETTERS[1:2]
y &lt;- ipf2(row_tot = c(18, 20), col_tot = NULL, 
          m = matrix(c(5, 1, 2, 7), ncol = 2, 
                     dimnames = list(orig = dn, dest = dn)))
round(addmargins(y$mu))
</code></pre>


</div>