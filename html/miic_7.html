<div class="container">

<table style="width: 100%;"><tr>
<td>discretizeMutual</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Iterative dynamic programming for (conditional) mutual information through
optimized discretization.</h2>

<h3>Description</h3>

<p>This function chooses cutpoints in the input distributions by
maximizing the mutual information minus a complexity cost
(computed as BIC or with the Normalized Maximum Likelihood).
The (conditional) mutual information computed on the optimized discretized
distributions effectively estimates the mutual information of the original
continuous variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">discretizeMutual(
  x,
  y,
  matrix_u = NULL,
  maxbins = NULL,
  cplx = "nml",
  n_eff = NULL,
  sample_weights = NULL,
  is_continuous = NULL,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>[a vector]
The <code class="reqn">X</code> vector that contains the observational data of the first variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>[a vector]
The <code class="reqn">Y</code> vector that contains the observational data of the second variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrix_u</code></td>
<td>
<p>[a numeric matrix]
The matrix with the observations of as many columns as conditioning variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxbins</code></td>
<td>
<p>[an int]
The maximum number of bins desired in the discretization. A lower number makes the computation faster, a higher
number allows finer discretization (by default : 5 * cubic root of N).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cplx</code></td>
<td>
<p>[a string]
The complexity used in the dynamic programming:
</p>

<ul>
<li>
<p>["bic"] Bayesian Information Criterion
</p>
</li>
<li>
<p>["nml"] Normalized Maximum Likelihood, more accurate complexity cost
compared to BIC, especially on small sample size.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_eff</code></td>
<td>
<p>[an integer]
The effective number of samples. When there is significant autocorrelation
between successive samples, you may want to specify an effective number of
samples that is lower than the total number of samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample_weights</code></td>
<td>
<p>[a vector of floats]
Individual weights for each sample, used for the same reason as the effective
number of samples but with individual weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_continuous</code></td>
<td>
<p>[a vector of booleans]
Specify if each variable is to be treated as continuous (TRUE)
or discrete (FALSE) in a logical vector of length ncol(matrix_u) + 2,
in the order [X, Y, U1, U2...]. By default, factors and character vectors
are treated as discrete, and numerical vectors as continuous.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>[a boolean]
Specify whether the resulting XY optimum discretization is to be plotted
(requires 'ggplot2' and 'gridExtra').</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a pair of continuous variables <code class="reqn">X</code> and <code class="reqn">Y</code>,
the algorithm will iteratively choose cutpoints on <code class="reqn">X</code> then on <code class="reqn">Y</code>,
maximizing <code class="reqn">I(X_{d};Y_{d}) - cplx(X_{d};Y_{d})</code> where
<code class="reqn">cplx(X_{d};Y_{d})</code> is the complexity cost of the considered
discretizations of <code class="reqn">X</code> and <code class="reqn">Y</code> (see Cabeli 2020).
Upon convergence, the discretization scheme of <code class="reqn">X_{d}</code> and <code class="reqn">Y_{d}</code>
is returned as well as <code class="reqn">I(X_{d};Y_{d})</code>
and <code class="reqn">I(X_{d};Y_{d})-cplx(X_{d};Y_{d})</code>.
</p>
<p>With a set of conditioning variables <code class="reqn">U</code>, the discretization scheme
maximizes each term of the sum
<code class="reqn">I(X;Y|U) \sim 0.5*(I(X_{d};Y_{d}, U_{d}) - I(X_{d};U_{d}) + I(Y_{d};X_{d}, U_{d}) - I(Y_{d};U_{d}))</code>.
</p>
<p>Discrete variables can be passed as factors and will be used "as is" to maximize each term.
</p>


<h3>Value</h3>

<p>A list that contains :
</p>

<ul>
<li>
<p>two vectors containing the cutpoints for each variable :
<em>cutpoints1</em> corresponds to <em>x</em>,
<em>cutpoints2</em> corresponds to <em>y</em>.
</p>
</li>
<li>
<p><em>n_iterations</em> is the number of iterations performed before
convergence of the (C)MI estimation.
</p>
</li>
<li>
<p><em>iteration1, iteration2, ...</em>, lists containing
the cutpoint vectors for each iteration.
</p>
</li>
<li>
<p><em>info</em> and <em>infok</em>, the estimated (C)MI value
and (C)MI minus the complexity cost.
</p>
</li>
<li>
<p>if <em>plot</em> == TRUE, a plot object (requires ggplot2 and gridExtra).
</p>
</li>
</ul>
<h3>References</h3>


<ul><li>
<p> Cabeli <em>et al.</em>, PLoS Comput. Biol. 2020, <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1007866">Learning clinical networks from medical records based on information estimates in mixed-type data</a>
</p>
</li></ul>
<h3>Examples</h3>

<pre><code class="language-R">library(miic)
N &lt;- 1000
# Dependence, conditional independence : X &lt;- Z -&gt; Y
Z &lt;- runif(N)
X &lt;- Z * 2 + rnorm(N, sd = 0.2)
Y &lt;- Z * 2 + rnorm(N, sd = 0.2)
res &lt;- discretizeMutual(X, Y, plot = FALSE)
message("I(X;Y) = ", res$info)
res &lt;- discretizeMutual(X, Y, matrix_u = matrix(Z, ncol = 1), plot = FALSE)
message("I(X;Y|Z) = ", res$info)


# Conditional independence with categorical conditioning variable : X &lt;- Z -&gt; Y
Z &lt;- sample(1:3, N, replace = TRUE)
X &lt;- -as.numeric(Z == 1) + as.numeric(Z == 2) + 0.2 * rnorm(N)
Y &lt;- as.numeric(Z == 1) + as.numeric(Z == 2) + 0.2 * rnorm(N)
res &lt;- miic::discretizeMutual(X, Y, cplx = "nml")
message("I(X;Y) = ", res$info)
res &lt;- miic::discretizeMutual(X, Y, matrix(Z, ncol = 1), is_continuous = c(TRUE, TRUE, FALSE))
message("I(X;Y|Z) = ", res$info)


# Independence, conditional dependence : X -&gt; Z &lt;- Y
X &lt;- runif(N)
Y &lt;- runif(N)
Z &lt;- X + Y + rnorm(N, sd = 0.1)
res &lt;- discretizeMutual(X, Y, plot = TRUE)
message("I(X;Y) = ", res$info)
res &lt;- discretizeMutual(X, Y, matrix_u = matrix(Z, ncol = 1), plot = TRUE)
message("I(X;Y|Z) = ", res$info)

</code></pre>


</div>