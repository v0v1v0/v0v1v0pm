<div class="container">

<table style="width: 100%;"><tr>
<td>cv_misvm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit MI-SVM model to the data using cross-validation</h2>

<h3>Description</h3>

<p>Cross-validation wrapper on the <code>misvm()</code> function to fit the MI-SVM model
over a variety of specified cost parameters.  The optimal cost parameter
is chosen by the best AUC of the cross-fit models.  See <code>?misvm</code> for
more details on the fitting function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
cv_misvm(
  x,
  y,
  bags,
  cost_seq,
  n_fold,
  fold_id,
  method = c("heuristic", "mip", "qp-heuristic"),
  weights = TRUE,
  control = list(kernel = "linear", sigma = 1, nystrom_args = list(m = nrow(x), r =
    nrow(x), sampling = "random"), max_step = 500, type = "C-classification", scale =
    TRUE, verbose = FALSE, time_limit = 60, start = FALSE),
  ...
)

## S3 method for class 'formula'
cv_misvm(formula, data, cost_seq, n_fold, fold_id, ...)

## S3 method for class 'mi_df'
cv_misvm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A data.frame, matrix, or similar object of covariates, where each
row represents a sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A numeric, character, or factor vector of bag labels for each
instance.  Must satisfy <code>length(y) == nrow(x)</code>. Suggest that one of the
levels is 1, '1', or TRUE, which becomes the positive class; otherwise, a
positive class is chosen and a message will be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bags</code></td>
<td>
<p>A vector specifying which instance belongs to each bag.  Can be a
string, numeric, of factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost_seq</code></td>
<td>
<p>A sequence of <code>cost</code> arguments (default <code>2^(-2:2)</code>) in
<code>misvm()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_fold</code></td>
<td>
<p>The number of folds (default 5). If this is specified,
<code>fold_id</code> need not be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fold_id</code></td>
<td>
<p>The ids for the specific the fold for each instance. Care must
be taken to ensure that ids respect the bag structure to avoid information
leakage.  If <code>n_fold</code> is specified, <code>fold_id</code> will be computed
automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The algorithm to use in fitting (default  <code>'heuristic'</code>).  When
<code>method = 'heuristic'</code>, which employs an algorithm similar to Andrews et
al. (2003). When <code>method = 'mip'</code>, the novel MIP method will be used.  When
<code style="white-space: pre;">⁠method = 'qp-heuristic⁠</code>, the heuristic algorithm is computed using the
dual SVM.  See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>named vector, or <code>TRUE</code>, to control the weight of the cost
parameter for each possible y value.  Weights multiply against the cost
vector. If <code>TRUE</code>, weights are calculated based on inverse counts of
instances with given label, where we only count one positive instance per
bag. Otherwise, names must match the levels of <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list of additional parameters passed to the method that
control computation with the following components:
</p>

<ul>
<li> <p><code>kernel</code> either a character the describes the kernel ('linear' or
'radial') or a kernel matrix at the instance level.
</p>
</li>
<li> <p><code>sigma</code> argument needed for radial basis kernel.
</p>
</li>
<li> <p><code>nystrom_args</code> a list of parameters to pass to <code>kfm_nystrom()</code>. This is
used when <code>method = 'mip'</code> and <code>kernel = 'radial'</code> to generate a Nystrom
approximation of the kernel features.
</p>
</li>
<li> <p><code>max_step</code> argument used when <code>method = 'heuristic'</code>. Maximum steps of
iteration for the heuristic algorithm.
</p>
</li>
<li> <p><code>type</code>: argument used when <code>method = 'heuristic'</code>. The <code>type</code> argument is
passed to <code>e1071::svm()</code>.
</p>
</li>
<li> <p><code>scale</code> argument used for all methods. A logical for whether to rescale
the input before fitting.
</p>
</li>
<li> <p><code>verbose</code> argument used when <code>method = 'mip'</code>. Whether to message output
to the console.
</p>
</li>
<li> <p><code>time_limit</code> argument used when <code>method = 'mip'</code>. <code>FALSE</code>, or a time
limit (in seconds) passed to <code>gurobi()</code> parameters.  If <code>FALSE</code>, no time
limit is given.
</p>
</li>
<li> <p><code>start</code> argument used when <code>method = 'mip'</code>.  If <code>TRUE</code>, the mip program
will be warm_started with the solution from <code>method = 'qp-heuristic'</code> to
potentially improve speed.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula with specification <code>mi(y, bags) ~ x</code> which uses the
<code>mi</code> function to create the bag-instance structure. This argument is an
alternative to the <code style="white-space: pre;">⁠x, y, bags⁠</code> arguments, but requires the <code>data</code>
argument. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>If <code>formula</code> is provided, a data.frame or similar from which
formula elements will be extracted.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>cv_misvm</code>.  The object contains the following
components:
</p>

<ul>
<li> <p><code>misvm_fit</code>: A fit object of class <code>misvm</code> trained on the full data with
the cross-validated choice of cost parameter. See <code>misvm()</code> for details.
</p>
</li>
<li> <p><code>cost_seq</code>: the input sequence of cost arguments
</p>
</li>
<li> <p><code>cost_aucs</code>: estimated AUC for the models trained for each <code>cost_seq</code>
parameter.  These are the average of the fold models for that cost, excluding
any folds that don't have both levels of <code>y</code> in the validation set.
</p>
</li>
<li> <p><code>best_cost</code>: The optimal choice of cost parameter, chosen as that which has
the maximum AUC.  If there are ties, this will pick the smallest cost with
maximum AUC.
</p>
</li>
</ul>
<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Method for data.frame-like objects
</p>
</li>
<li> <p><code>formula</code>: Method for passing formula
</p>
</li>
<li> <p><code>mi_df</code>: Method for <code>mi_df</code> objects, automatically handling bag
names, labels, and all covariates.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Sean Kent, Yifei Liu
</p>


<h3>See Also</h3>

<p><code>misvm()</code> for fitting without cross-validation.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(8)
mil_data &lt;- generate_mild_df(nbag = 20,
                             positive_prob = 0.15,
                             dist = rep("mvnormal", 3),
                             mean = list(rep(1, 10), rep(2, 10)),
                             sd_of_mean = rep(0.1, 3))
df &lt;- build_instance_feature(mil_data, seq(0.05, 0.95, length.out = 10))
cost_seq &lt;- 2^seq(-5, 7, length.out = 3)

# Heuristic method
mdl1 &lt;- cv_misvm(x = df[, 4:123], y = df$bag_label,
                 bags = df$bag_name, cost_seq = cost_seq,
                 n_fold = 3, method = "heuristic")
mdl2 &lt;- cv_misvm(mi(bag_label, bag_name) ~ X1_mean + X2_mean + X3_mean, data = df,
                 cost_seq = cost_seq, n_fold = 3)

if (require(gurobi)) {
  # solve using the MIP method
  mdl3 &lt;- cv_misvm(x = df[, 4:123], y = df$bag_label,
                   bags = df$bag_name, cost_seq = cost_seq,
                   n_fold = 3, method = "mip")
}

predict(mdl1, new_data = df, type = "raw", layer = "bag")

# summarize predictions at the bag layer
suppressWarnings(library(dplyr))
df %&gt;%
  bind_cols(predict(mdl2, df, type = "class")) %&gt;%
  bind_cols(predict(mdl2, df, type = "raw")) %&gt;%
  distinct(bag_name, bag_label, .pred_class, .pred)

</code></pre>


</div>