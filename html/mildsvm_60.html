<div class="container">

<table style="width: 100%;"><tr>
<td>smm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit SMM model to the data</h2>

<h3>Description</h3>

<p>Function to carry out support measure machines algorithm which is appropriate
for multiple instance learning. The algorithm calculates the kernel matrix of
different empirical measures using kernel mean embedding. The data set should
be passed in with rows corresponding to samples from a set of instances.  SMM
will compute a kernel on the instances and pass that to <code>kernlab::ksvm()</code> to
train the appropriate SVM model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
smm(
  x,
  y,
  instances,
  cost = 1,
  weights = TRUE,
  control = list(kernel = "radial", sigma = if (is.vector(x)) 1 else 1/ncol(x), scale =
    TRUE),
  ...
)

## S3 method for class 'formula'
smm(formula, data, instances = "instance_name", ...)

## S3 method for class 'mild_df'
smm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A data.frame, matrix, or similar object of covariates, where each
row represents a sample. If a <code>mild_df</code> object is passed, <code style="white-space: pre;">⁠y, instances⁠</code>
are automatically extracted, <code>bags</code> is ignored, and all other columns will
be used as predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A numeric, character, or factor vector of bag labels for each
instance.  Must satisfy <code>length(y) == nrow(x)</code>. Suggest that one of the
levels is 1, '1', or TRUE, which becomes the positive class; otherwise, a
positive class is chosen and a message will be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>instances</code></td>
<td>
<p>A vector specifying which samples belong to each instance.
Can be a string, numeric, of factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>The cost parameter in SVM, fed to the <code>C</code> argument in
<code>kernlab::ksvm()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>named vector, or <code>TRUE</code>, to control the weight of the cost
parameter for each possible y value.  Weights multiply against the cost
vector. If <code>TRUE</code>, weights are calculated based on inverse counts of
instances with given label, where we only count one positive instance per
bag. Otherwise, names must match the levels of <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of additional parameters passed to the method that
control computation with the following components:
</p>

<ul>
<li> <p><code>kernel</code> either a character the describes the kernel ('linear' or
'radial') or a kernel matrix at the instance level.
</p>
</li>
<li> <p><code>sigma</code> argument needed for radial basis kernel.
</p>
</li>
<li> <p><code>scale</code> argument used for all methods. A logical for whether to rescale
the input before fitting.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula with specification <code>y ~ x</code>. This argument is an
alternative to the <code>x</code>, <code>y</code> arguments, but requires the <code>data</code> and
<code>instances</code> argument. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>If <code>formula</code> is provided, a data.frame or similar from which
formula elements will be extracted.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>smm</code>  The object contains at least the
following components:
</p>

<ul>
<li> <p><code>ksvm_fit</code>: A fit of class <code>ksvm</code> from the kernlab package.
</p>
</li>
<li> <p><code>call_type</code>: A character indicating which method <code>smm()</code> was called with.
</p>
</li>
<li> <p><code>x</code>: The training data needed for computing the kernel matrix in
prediction.
</p>
</li>
<li> <p><code>features</code>: The names of features used in training.
</p>
</li>
<li> <p><code>levels</code>: The levels of <code>y</code> that are recorded for future prediction.
</p>
</li>
<li> <p><code>cost</code>: The cost parameter from function inputs.
</p>
</li>
<li> <p><code>sigma</code>: The radial basis function kernel parameter.
</p>
</li>
<li> <p><code>weights</code>: The calculated weights on the <code>cost</code> parameter, if applicable.
</p>
</li>
<li> <p><code>x_scale</code>: If <code>scale = TRUE</code>, the scaling parameters for new predictions.
</p>
</li>
</ul>
<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Method for data.frame-like objects
</p>
</li>
<li> <p><code>formula</code>: Method for passing formula
</p>
</li>
<li> <p><code>mild_df</code>: Method for <code>mild_df</code> objects. Use the <code>bag_label</code> as <code>y</code> at
the instance level, then perform <code>smm()</code> ignoring the MIL structure.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Sean Kent, Yifei Liu
</p>


<h3>References</h3>

<p>Muandet, K., Fukumizu, K., Dinuzzo, F., &amp; Schölkopf, B. (2012).
Learning from distributions via support measure machines. <em>Advances in
neural information processing systems</em>, <em>25</em>.
</p>


<h3>See Also</h3>

<p><code>predict.smm()</code> for prediction on new data.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(8)
n_instances &lt;- 10
n_samples &lt;- 20
y &lt;- rep(c(1, -1), each = n_samples * n_instances / 2)
instances &lt;- as.character(rep(1:n_instances, each = n_samples))
x &lt;- data.frame(x1 = rnorm(length(y), mean = 1*(y==1)),
                x2 = rnorm(length(y), mean = 2*(y==1)),
                x3 = rnorm(length(y), mean = 3*(y==1)))

df &lt;- data.frame(instance_name = instances, y = y, x)

mdl &lt;- smm(x, y, instances)
mdl2 &lt;- smm(y ~ ., data = df)

# instance level predictions
suppressWarnings(library(dplyr))
df %&gt;%
  dplyr::bind_cols(predict(mdl, type = "raw", new_data = x, new_instances = instances)) %&gt;%
  dplyr::bind_cols(predict(mdl, type = "class", new_data = x, new_instances = instances)) %&gt;%
  dplyr::distinct(instance_name, y, .pred, .pred_class)

</code></pre>


</div>