<div class="container">

<table style="width: 100%;"><tr>
<td>assign_treatment</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Min MSE Treatment Assignment
</h2>

<h3>Description</h3>

<p>Computes the treatment assignment vector according to available data (observable characteristics, covariate vectors) given about the units (individuals or clusters, such as schools, hospitals, ...).
Consider using the user-friendly wrapper function assign_minMSE_treatment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">assign_treatment(current_data,
                 prev_treatment = NULL,
                 evaluation_function = evaluate_solution,
                 swap_treatment_function = swap_treatment,
                 n_treatments = 1,
                 n_per_group = NULL,
                 mse_weights = NULL,
                 iterations = 50,
                 change = 3,
                 cooling = 1,
                 t0 = 10,
                 tmax = 10,
                 built_in = 0,
                 plot = 0,
                 create_plot_file = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>current_data</code></td>
<td>
<p>a matrix containing the covariate vectors for each attribute. If the values are missing or on different scales, please use assign_minMSE_treatment, which automatically scales the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prev_treatment</code></td>
<td>
<p>takes a numerical vector of partial treatment assignment as argument, and assigns the missing units (where the value is NA) to a treatment group while minimizing the objective function. Non-missing values are copied to the new vector, i.e., treatment group assignment of these observations is unaffected, but taken into consideration for achieving balanced treatment groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaluation_function</code></td>
<td>
<p>the function used to evaluate the MSE treatment. Default is evaluate_solution, which does not take into account outcome or treatment weights. Other options are evaluate_solution_vector and evaluate_solution_matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swap_treatment_function</code></td>
<td>
<p>the function used to create new treatments. Default is swap_treatment. Other options are swap_treatment_prev which, given a previous treatment, creates a new treatment assignment that takes the previous one into account.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_treatments</code></td>
<td>
<p>specifies the number of treatment groups desired (in addition to the control group); minimum and default value is n_treatments = 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_per_group</code></td>
<td>
<p>specifies a vector containing uneven sizes for the treatment groups. Default value is NULL, which yields even sized groups. The sum of the elements in the vector should be equal to the total number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mse_weights</code></td>
<td>
<p>a vector containing the mse_weights for each treatment, or a matrix containing the mse_weights for treatments and outcomes and scaling factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>specifies the number of iterations the algorithm performs; the default value is iterations = 50. Depending on the number of units and the number of covariates to consider for group assignment, a high value could result in a long run-time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>change</code></td>
<td>
<p>sets the number of units to exchange treatment in each iteration; the default value is change = 3. In case of big datasets (e.g., with more than 100 units), one might consider increasing the default value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cooling</code></td>
<td>
<p>specifies the cooling scheme for the simulated annealing algorithm to use. cooling = 1, which is the default scheme, sets the temperature to
</p>
<p style="text-align: center;"><code class="reqn">t0/log(floor((k - 1)/tmax ) * tmax + exp(1)),</code>
</p>
<p> whereas cooling = 2 sets the temperature to the faster decreasing sequence </p>
<p style="text-align: center;"><code class="reqn">t0 /(floor((k - 1)/tmax) * tmax + 1).</code>
</p>
<p> In praxis, cooling schemes are mostly of one of these forms. One might want to change the cooling scheme if the plot indicates a too slow decrease of objective values. For a theoretical discussion of cooling schemes, see Belisle (see 1992, p. 890).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t0</code></td>
<td>
<p>sets the starting temperature for the simulated annealing algorithm, see Belisle (1992) for theoretical convergence considerations. In praxis, a lower starting temperature t0 decreases the acceptance rate of a worse solution more rapidly. Specifying a negative number allows values proportional to the objective function, i.e. t0 = -5 sets the starting temperature to 1/5 of the objective function for the starting point, and thus - for the first tmax iterations of the algorithm - the difference of the old and the proposed solution is scaled by 1/5. When changing the default value, it should be considered that also worse solutions have to be accepted in order for the algorithm to escape a local minimum, so it should be chosen high enough. The default value is t0 = 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tmax</code></td>
<td>
<p>specifies the number of function evaluations at each temperature: For instance, tmax = 10 makes the algorithm evaluate 10 treatment assignments that are found based on the current solution, before the temperature is decreased and thus the probability of accepting a worse solution is decreased. The default value is tmax = 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>built_in</code></td>
<td>
<p>if built_in = 1 the R built-in function optim with method 'SANN' (Simulated ANNealing) will be used to optimize the function. Otherwise, if built_in = 0, our implementation of the simulated annealing will be used. The function built_in = 0 uses our first cooling function and this cannot be changed. To use the second cooling function, set built_in = 0. All the other parameters, such as iterations, change, t0, tmax are taken into account.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>can be used to draw a plot showing the value of the objective function for the a percentage of the iterations by setting plot = 1. The default setting is plot = 0, which suppresses the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>create_plot_file</code></td>
<td>
<p>Used to overwrite the plot file, in case there already exists one. It should only be 1 (true) when this method is called without the wrapper assign_minMSE_treatment. This method alone is not capable of plotting, but it will create an auxiliary file that contains the information for plotting. To include plotting, use assign_minMSE_treatment with desired_test_vectors = 1.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns the current assignment and the mean squared error value for that assignment.
</p>


<h3>Note</h3>

<p>With the default setting of plotting and using the trace output, the program writes to different files. To avoid this, set plot = 0 and trace_output = 0. For the built-in function optim, the trace output is necessary for printing, because we pipe the output of the program to a file to obtain the intermediate values of the optimization function.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>References</h3>

<p><a href="https://www.econstor.eu/handle/10419/161931">Schneider and Schlather (2017)</a>,
<a href="https://www.jstor.org/stable/3214721">Belisle (1992)</a>
</p>


<h3>See Also</h3>

<p><code>ginv</code>, <code>optim</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">input &lt;- matrix(1:30, nrow = 10, ncol = 3)

assign_treatment(input,
                 evaluation_function = evaluate_solution_vector,
                 swap_treatment_function = swap_treatment_prev,
                 prev_treatment = c(0, NA, NA, NA, 1, NA, NA, NA, NA, NA),
                 n_treatments = 2,
                 mse_weights = c(1, 2),
                 iterations = 100,
                 built_in = 0,
                 plot = 0)
</code></pre>


</div>