<div class="container">

<table style="width: 100%;"><tr>
<td>mined</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Minimum Energy Design

</h2>

<h3>Description</h3>

<p>Generate MinED samples from an unnormalized density function.

</p>


<h3>Usage</h3>

<pre><code class="language-R">mined(initial, logf, K_iter = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>

<p>An n-by-p matrix containing the initial uniform samples from <code>[0,1]^p</code>. 

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logf</code></td>
<td>

<p>An R function to compute the logarithm of unnormalized density function. The input region should be scaled in <code>[0,1]^p</code>.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_iter</code></td>
<td>

<p>The number of iteration steps for annealed version of the unnormalized posterior density. Optional, default is <code>0</code>. If <code>0</code>, <code>K_iter = ceiling(4 * sqrt(p))</code> is used.

</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p>This is the main function of the package, which is used for generating the MinED samples. The MinED sample can be viewed as a deterministic sample from the probability density specified in the mined function. Since only the unnormalized density is needed to generate the MinED samples, this method could be used in Bayesian computation to approximate the posterior. The method uses few evaluations of the unnormalized posterior compared to random sampling-based methods and therefore, it will be useful when the evaluations are expensive or time consuming.
</p>
<p>There are many parameters that control the performance of the algorithm, which are fixed at some reasonable values as specified in Joseph et al. (2019). The only thing user need to choose is the region for scaling the variables in [0,1]^p. Ideally it should be the highercube containing the highest posterior density region with good coverage. However, the algorithm is robust to this choice to some extend as it can shrink or expand from the intial region. Therefore, it can be chosen based on user's guessed range of each variable.
</p>


<h3>Value</h3>






<p>The value returned from the function is a list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>
<p>A matrix containing <code>n</code> MinED samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logf</code></td>
<td>
<p>Log-unnormalized density function values of MinED samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cand</code></td>
<td>
<p>Full set of samples used in the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>candlf</code></td>
<td>
<p>Log-unormalized density function values of the samples in <code>cand</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>


<p>Dianpeng Wang &lt;wdp@bit.edu.cn&gt; and V. Roshan Joseph &lt;roshan@gatech.edu&gt;
</p>


<h3>References</h3>

<p>Joseph, V. R., Wang, D., Gu, L., Lv, S., and Tuo, R. (2019). "Deterministic Sampling of Expensive Posteriors Using Minimum Energy Designs", <em>Technometrics</em>, 61, 297-308, arXiv:1712.08929, DOI:10.1080/00401706.2018.1552203.

</p>


<h3>Examples</h3>

<pre><code class="language-R">require(mined)
p &lt;- 2
n &lt;- 109 # largest prime number less than 100+5p
initial &lt;- Lattice(n, p)

# suppose x1 is in [-40,40] and x2 in [-25,10]
logf &lt;- function(para)
{
  l1 &lt;- -40
  u1 &lt;- 40
  l2 &lt;- -25
  u2 &lt;- 10
  x1 &lt;- l1 + (u1 - l1) * para[1]
  x2 &lt;- l2 + (u2 - l2) * para[2]
  val &lt;- -.5 * (x1 ^2 / 100 + (x2+ .03 * x1^2 -3)^2)
  return(val)
}

res &lt;- mined::mined(initial, logf, K_iter = 8)
dim(res$points)
dim(res$cand)

x1 &lt;- seq(0, 1, length.out = 200)
x2 &lt;- seq(0, 1, length.out = 200)
y &lt;- matrix(0.0, 200, 200)
for(i in 1:200)
{
  for(j in 1:200)
  {
    y[i, j] = logf(c(x1[i], x2[j]))
  }
}
image(x1, x2, exp(y), col = cm.colors(5), xlab = expression(x[1]), ylab = expression(x[2]))
points(res$cand[, 1], res$cand[, 2], pch = 11, col = rgb(red = 0, green = 0, blue = 1, 
       alpha = 0.35), cex = .25)
points(res$points[, 1], res$points[, 2], pch = 17, col = 'black', cex = .75)
legend("bottom", c('Candidates points', 'MinED samples'), pch = c(11, 17), 
        col = c(rgb(red = 0, green = 0, blue = 1, alpha = 0.35), 'black'), 
        inset = .02, bg = 'transparent', bty = 'n')
</code></pre>


</div>