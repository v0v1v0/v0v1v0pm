<div class="container">

<table style="width: 100%;"><tr>
<td>rnewton</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regularized quasi-Newton optimization</h2>

<h3>Description</h3>

<p>Performs regularized (quasi-)Newton optimisation with limited-memory BFGS, SR1, or PSB updates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rnewton(x0, fn, gr,
  he = NULL,
  quasi = TRUE,
  method = "LBFGS",
  verbose = FALSE,
  return.hess = FALSE,
  control = list(maxit = 1000, m = 5, sigma1 = 0.5, sigma2 = 4, c1 = 0.001,
    c2 = 0.9, pmin = 0.001, tol.g = 1e-08, tol.gamma = 1e-05, tol.obj = 1e-08, 
    tol.step = 1e-14, tol.mu = 1e-04, tol.mu2 = 1e+15, tol.c = 1e-08, report.iter = 10, 
    grad.reject = FALSE, max.reject = 50, mu0 = 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x0</code></td>
<td>
<p>Initial values for the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>A function to be minimized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr</code></td>
<td>
<p>A function that returns the gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>he</code></td>
<td>
<p>A function that returns the hessian (only used when quasi = FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quasi</code></td>
<td>
<p>logical. Defaults to TRUE. If FALSE implements regularised Newton optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method to be used when <code>quasi = TRUE</code>. Defaults to "LBFGS", alternatives are "LPSB", "LSR1" and ther full-memory alternatives "BFGS", "SR1", "PSB". The latter three options should probably not be used in practice (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical. Defaults to FALSE. If TRUE prints reports on each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.hess</code></td>
<td>
<p>logical. Defaults to FALSE. If TRUE returns (approximation of) the hessian at the final iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a <code>"list"</code> of control options.
</p>

<ul>
<li> <p><em>maxit</em>: The maximum number of iterations. Defaults to 1000.
</p>
</li>
<li> <p><em>m</em>: The number of gradients to remember from previous optimisation steps. Defaults to 5.
</p>
</li>
<li> <p><em>sigma1</em>: Step decrement factor. Defaults to 0.5. Must be smaller than 1 but larger than 0.
</p>
</li>
<li> <p><em>sigma2</em>: Step increment factor. Defaults to 4. Must be larger than 1.
</p>
</li>
<li> <p><em>c1</em>: First constant for determining step success. Defaults to 1e-3. See details.
</p>
</li>
<li> <p><em>c2</em>: Second constant for determining step success. Defaults to 0.9. See details.
</p>
</li>
<li> <p><em>pmin</em>: Third constant for determining (lack of) step success. Defaults to 1e-3.
</p>
</li>
<li> <p><em>tol.g</em>: Convergence tolerance for gradient. Defaults to 1e-8.
</p>
</li>
<li> <p><em>tol.gamma</em>: Threshold for gamma paramter. Defaults to 1e-5.
</p>
</li>
<li> <p><em>tol.obj</em>: Convergence tolerance for reduction in the objective. Defaults to 1e-8.
</p>
</li>
<li> <p><em>tol.step</em>: Convergence tolerance for squared norm of the step. Defaults to 1e-14.
</p>
</li>
<li> <p><em>tol.mu</em>: Minimum threshold for the regularisation parameter. Defaults to 1e-4.
</p>
</li>
<li> <p><em>tol.mu2</em>: Maximum threshold for the regularisation parameter. Defaults to 1e15.
</p>
</li>
<li> <p><em>tol.c</em>: Tolerance for cautious updating. Defaults to 1e-8.
</p>
</li>
<li> <p><em>report.iter</em>: If 'verbose = TRUE', how often should a report be printed? Defaults to every 10 iterations.
</p>
</li>
<li> <p><em>max.reject</em>: Maximum number of consecutive rejections before algorithm terminates.
</p>
</li>
<li> <p><em>grad.reject</em>: Logical. If TRUE the gradient is evaluated at every iteration and information of rejected steps is incorporated in limited-memory methods. Defaults to FALSE.
</p>
</li>
<li> <p><em>mu0.reject</em>: Initial value of the regularisation parameter. Defaults to 5.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function implements some of the regularised (quasi-)Newton optimisation methods presented in Kanzow and Steck (2023) with one modification; gradient information of rejected steps is incorporated by default. The full-memory options that are implemented rely on explicitly inverting the approximated Hessian and regularisation penalty, are thus slow, and should probably not be used in practice. 
</p>
<p>The function start with a single More-Thuente line search along the normalized negative gradient direction. 
The code for this was originally written in matlab by Burdakov et al. (2017), translated to python by Kanzow and Steck (2023), and separately translated to R code for this package. 
</p>
<p>A step is considered somewhat successful for <code class="reqn">c_1&lt;\rho\leq c_2</code>, where <code class="reqn">\rho</code> is the proportion of achieved and predicted reduction in the objective function. Note the requirement <code class="reqn">c_1 \in (0,1)</code> and <code class="reqn">c_2 \in (c_1,1)</code>.
A step is considered highly successful for <code class="reqn">c_2 &lt; \rho</code>, where rho is the proportion of achieved and predicted reduction in the objective function.
</p>
<p>The <code class="reqn">\sigma_1</code> constant controls the decrement of the regularisation parameter <code class="reqn">\mu</code> on a highly succesful step.
The <code class="reqn">\sigma_2</code> constant controls the increment of the regularisation parameter <code class="reqn">\mu</code> on a unsuccesful step. A step is defned as unsuccesful if 1) the predicted reduction less than pmin times the product of the l2 norm for step direction and gradient, or 2) if <code class="reqn">\rho \leq c_1</code>.
</p>


<h3>Value</h3>

<p>An object of class "rnewton" including the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>objective: </code></td>
<td>
<p> The value of fn corresponding to par.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations: </code></td>
<td>
<p> Number of completed iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evalg: </code></td>
<td>
<p> Number of calls to gr.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par: </code></td>
<td>
<p> The best set of parameters found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info: </code></td>
<td>
<p> Convergence code.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxgr: </code></td>
<td>
<p> Maximum absolute gradient component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence: </code></td>
<td>
<p> logical, TRUE indicating succesful convergence (reached tol.obj, tol.g, or tol.step).</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Bert van der Veen
</p>


<h3>References</h3>

<p>Burdakov, O., Gong, L., Zikrin, S., &amp; Yuan, Y. X. (2017). On efficiently combining limited-memory and trust-region techniques. Mathematical Programming Computation, 9, 101-134.
</p>
<p>Kanzow, C., &amp; Steck, D. (2023). Regularization of limited memory quasi-Newton methods for large-scale nonconvex minimization. Mathematical Programming Computation, 15(3), 417-444.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Powell's quartic function
fn &lt;- function(x) {
  (x[1] + 10*x[2])^2 + 5 * (x[3] - x[4])^2 + 
  (x[2] - 2*x[3])^4 + 10 * (x[1] - x[4])^4
}

# Gradient
gr &lt;- function(x) {
  c(2 * (x[1] + 10*x[2]) + 40 * (x[1] - x[4])^3,    # dfdx1
    20 * (x[1] + 10*x[2]) + 4 * (x[2] - 2 * x[3])^3,# dfdx2
    10 * (x[3] - x[4]) - 8 * (x[2] - 2*x[3])^3,     # dfdx3
    -(10 * (x[3] - x[4]) + 40 * (x[1] - x[4])^3))   # dfdx4
}

# Lower tolerances from default
rnewton(c(1, 1, 1, 1), fn, gr, control = list(mu0 = 1, tol.g = 1e-10, tol.obj = 0))
</code></pre>


</div>