<div class="container">

<table style="width: 100%;"><tr>
<td>nlsLM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Standard 'nls' framework that uses 'nls.lm' for fitting</h2>

<h3>Description</h3>

<p><code>nlsLM</code> is a modified version of <code>nls</code> that uses <code>nls.lm</code> for fitting. 
Since an object of class 'nls' is returned, all generic functions such as <code>anova</code>, 
<code>coef</code>, <code>confint</code>, <code>deviance</code>, <code>df.residual</code>, 
<code>fitted</code>, <code>formula</code>, <code>logLik</code>, <code>predict</code>,
<code>print</code>, <code>profile</code>, <code>residuals</code>, <code>summary</code>,
<code>update</code>, <code>vcov</code> and <code>weights</code> are applicable.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">nlsLM(formula, data = parent.frame(), start, jac = NULL, 
      algorithm = "LM", control = nls.lm.control(), 
      lower = NULL, upper = NULL, trace = FALSE, subset, 
      weights, na.action, model = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a nonlinear model <code>formula</code> including variables and parameters. Will be coerced to a formula if necessary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables in<code>formula</code> and <code>weights</code>.  
Can also be a list or an environment, but not a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>a named list or named numeric vector of starting estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jac</code></td>
<td>
<p>A function to return the Jacobian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>only method <code>"LM"</code> (Levenberg-Marquardt) is implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>an optional list of control settings.  See <code>nls.lm.control</code> for 
the names of the settable control values and their effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>A numeric vector of lower bounds on each parameter. If not given, the default lower bound for each parameter is set to <code>-Inf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>A numeric vector of upper bounds on each parameter. If not given, the default upper bound for each parameter is set to <code>Inf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>logical value indicating if a trace of the iteration progress should be printed. Default is <code>FALSE</code>. If <code>TRUE</code>, the residual (weighted) sum-of-squares and the parameter values are printed at the conclusion of each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional numeric vector of (fixed) weights.  When
present, the objective function is weighted least squares.  See the
<code>wfct</code> function for options for easy specification of weighting
schemes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s. The default is set by the <code>na.action</code> setting of <code>options</code>, and is <code>na.fail</code> if that is unset. The ‘factory-fresh’ default is <code>na.omit</code>. Value <code>na.exclude</code> can be useful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>logical. If true, the model frame is returned as part of the object. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional optional arguments. None are used at present.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The standard <code>nls</code> function was modified in several ways to incorporate the Levenberg-Marquardt type <code>nls.lm</code> fitting algorithm. The <code>formula</code> is transformed into a function that returns a vector of (weighted) residuals whose sum square is minimized by <code>nls.lm</code>. The optimized parameters are then transferred
to <code>nlsModel</code> in order to obtain an object of class 'nlsModel'. The internal C function <code>C_nls_iter</code> and <code>nls_port_fit</code> were removed to avoid subsequent "Gauss-Newton", "port" or "plinear" types of optimization of <code>nlsModel</code>. Several other small modifications were made in order to make all generic functions work on the output.
</p>


<h3>Value</h3>

<p>A list of
</p>
<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>an <code>nlsModel</code> object incorporating the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the expression that was passed to <code>nls</code> as the data argument.  The actual data values are present in the environment of the <code>m</code> component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convInfo</code></td>
<td>
<p>a list with convergence information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>the control <code>list</code> used, see the <code>control</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>the <code>"na.action"</code> attribute (if any) of the model frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataClasses</code></td>
<td>
<p>the <code>"dataClasses"</code> attribute (if any) of the <code>"terms"</code> attribute of the model frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>if <code>model = TRUE</code>, the model frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>if <code>weights</code> is supplied, the weights.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Andrej-Nikolai Spiess and Katharine M. Mullen</p>


<h3>References</h3>

<p>Bates, D. M. and Watts, D. G. (1988)
<em>Nonlinear Regression Analysis and Its Applications</em>, Wiley
</p>
<p>Bates, D. M. and Chambers, J. M. (1992)
<em>Nonlinear models.</em>
Chapter 10 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>
<p>J.J. More, "The Levenberg-Marquardt algorithm: implementation and theory," 
in <em>Lecture Notes in Mathematics</em>
<b>630</b>: Numerical Analysis, G.A. Watson (Ed.), Springer-Verlag: Berlin, 1978, pp. 105-116.
</p>


<h3>See Also</h3>

<p><code>nls.lm</code>, <code>nls</code>, <code>nls.lm.control</code>, <code>optim</code></p>


<h3>Examples</h3>

<pre><code class="language-R">### Examples from 'nls' doc ###
DNase1 &lt;- subset(DNase, Run == 1)
## using a selfStart model
fm1DNase1 &lt;- nlsLM(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1)
## using logistic formula
fm2DNase1 &lt;- nlsLM(density ~ Asym/(1 + exp((xmid - log(conc))/scal)),
                 data = DNase1, 
                 start = list(Asym = 3, xmid = 0, scal = 1))

## all generics are applicable
coef(fm1DNase1)
confint(fm1DNase1)
deviance(fm1DNase1)
df.residual(fm1DNase1)
fitted(fm1DNase1)
formula(fm1DNase1)
logLik(fm1DNase1)
predict(fm1DNase1)
print(fm1DNase1)
profile(fm1DNase1)
residuals(fm1DNase1)
summary(fm1DNase1)
update(fm1DNase1)
vcov(fm1DNase1)
weights(fm1DNase1)

## weighted nonlinear regression using 
## inverse squared variance of the response
## gives same results as original 'nls' function
Treated &lt;- Puromycin[Puromycin$state == "treated", ]
var.Treated &lt;- tapply(Treated$rate, Treated$conc, var)
var.Treated &lt;- rep(var.Treated, each = 2)
Pur.wt1 &lt;- nls(rate ~ (Vm * conc)/(K + conc), data = Treated, 
               start = list(Vm = 200, K = 0.1), weights = 1/var.Treated^2)
Pur.wt2 &lt;- nlsLM(rate ~ (Vm * conc)/(K + conc), data = Treated, 
               start = list(Vm = 200, K = 0.1), weights = 1/var.Treated^2)
all.equal(coef(Pur.wt1), coef(Pur.wt2))

## 'nlsLM' can fit zero-noise data
## in contrast to 'nls'
x &lt;- 1:10
y &lt;- 2*x + 3                           
## Not run: 
nls(y ~ a + b * x, start = list(a = 0.12345, b = 0.54321))

## End(Not run)
nlsLM(y ~ a + b * x, start = list(a = 0.12345, b = 0.54321))

### Examples from 'nls.lm' doc
## values over which to simulate data 
x &lt;- seq(0,5, length = 100)
## model based on a list of parameters 
getPred &lt;- function(parS, xx) parS$a * exp(xx * parS$b) + parS$c 
## parameter values used to simulate data
pp &lt;- list(a = 9,b = -1, c = 6) 
## simulated data with noise  
simDNoisy &lt;- getPred(pp, x) + rnorm(length(x), sd = .1)
## make model
mod &lt;- nlsLM(simDNoisy ~ a * exp(b * x) + c, 
             start = c(a = 3, b = -0.001, c = 1), 
             trace = TRUE)     
## plot data
plot(x, simDNoisy, main = "data")
## plot fitted values
lines(x, fitted(mod), col = 2, lwd = 2)

## create declining cosine
## with noise
TT &lt;- seq(0, 8, length = 501)
tau &lt;- 2.2
N0 &lt;- 1000
a &lt;- 0.25
f0 &lt;- 8
Ndet &lt;- N0 * exp(-TT/tau) * (1 + a * cos(f0 * TT))
N &lt;- Ndet +  rnorm(length(Ndet), mean = Ndet, sd = .01 * max(Ndet))
## make model
mod &lt;- nlsLM(N ~ N0 * exp(-TT/tau) * (1 + a * cos(f0 * TT)), 
             start = c(tau = 2.2, N0 = 1500, a = 0.25, f0 = 10), 
             trace = TRUE)  

## plot data
plot(TT, N, main = "data")
## plot fitted values
lines(TT, fitted(mod), col = 2, lwd = 2)
</code></pre>


</div>