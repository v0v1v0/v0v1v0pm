<div class="container">

<table style="width: 100%;"><tr>
<td>Ipfp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Multidimensional Iterative Proportional Fitting
</h2>

<h3>Description</h3>

<p>This function implements the iterative proportional fitting (IPFP) procedure. 
This procedure updates an initial N-dimensional array (referred as the seed) 
with respect to given target marginal distributions. Those targets can also 
be multi-dimensional. This procedure is also able to 
estimate a (multi-dimensional) contingency table (encoded as an array) matching 
a given set of (multi-dimensional) margins. In that case, each cell of the seed 
must simply be set to 1.
</p>
<p>The IPFP is also known as the RAS algorithm in economics and matrix raking or 
matrix scaling in computer science.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Ipfp(seed, target.list, target.data, print = FALSE, iter = 1000, tol = 1e-10,
     tol.margins = 1e-10, na.target = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>The initial multi-dimensional array to be updated. Each cell must
be non-negative.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.list</code></td>
<td>

<p>A list of dimensions of the marginal target constrains in
<code>target.data</code>. Each component of the list is an array whose cells 
indicate which dimension the corresponding margin relates to.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.data</code></td>
<td>

<p>A list containing the data of the target marginal tables. Each
component of the list is an array storing a margin.
The list order must follow the ordering defined in <code>target.list</code>.
Note that the cells of the arrays must be non-negative.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print</code></td>
<td>

<p>Verbose parameter: if TRUE prints the current iteration number
and the associated value of the stopping criterion. Default is FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>

<p>Stopping criterion. The maximum number of iteration allowed; 
must be greater than 0. Default is 1000.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>Stopping criterion. If the maximum absolute difference between two iteration
is lower than the value specified by <code>tol</code>, then ipfp has reached 
convergence; must be greater than 0. Default is <code class="reqn">1e^{-10}</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol.margins</code></td>
<td>

<p>Tolerance for the margins consistency. Default is <code class="reqn">1e^{-10}</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.target</code></td>
<td>

<p>If set to TRUE, allows the targets to have NA cells. Note that in that 
particular case the margins consistency is not checked.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the final updated array as well as other convergence
informations.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x.hat</code></td>
<td>

<p>An array with the same dimension of <code>seed</code> whose margins match those
specified in <code>target.list</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.hat</code></td>
<td>

<p>An array with the same dimension of <code>x.hat</code> containing the updated
cell probabilities, i.e. <code>x.hat / sum(x.hat)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evol.stp.crit</code></td>
<td>

<p>The evolution of the stopping criterion over the iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>

<p>A boolean indicating whether the algorithm converged to a solution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error.margins</code></td>
<td>

<p>A list returning, for each margin, the absolute maximum deviation between 
the desired and generated margin.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>The selected method for estimation (here it will always be <code>ipfpf</code>).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>The matched call.  
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>It is important to note that if the margins given in <code>target.list</code> are
not consistent (i.e. the sums of their cells are not equals), the input data
is then normalised by considering probabilities instead of frequencies:
</p>

<ul>
<li>
<p> the cells of the seed are divided by <code>sum(seed)</code>;
</p>
</li>
<li>
<p> the cells of each margin <code>i</code> of the list <code>target.data</code> are 
divided by <code>sum(target.data[[i]])</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Bacharach, M. (1965).
Estimating Nonnegative Matrices from Marginal Data.
<em>International Economic Review</em> (Blackwell Publishing) 6 (3): 294-310.
</p>
<p>Bishop, Y. M. M., Fienberg, S. E., Holland, P. W. (1975).
<em>Discrete Multivariate Analysis: Theory and Practice.</em>
MIT Press. ISBN 978-0-262-02113-5.
</p>
<p>Deming, W. E., Stephan, F. F. (1940).
On a Least Squares Adjustment of a Sampled Frequency Table When the Expected
Marginal Totals are Known.
<em>Annals of Mathematical Statistics</em> 11 (4): 427-444.
</p>
<p>Fienberg, S. E. (1970).
An Iterative Procedure for Estimation in Contingency Tables.
<em>Annals of Mathematical Statistics</em> 41 (3): 907-917.
</p>
<p>Stephan, F. F. (1942).
Iterative method of adjusting frequency tables when expected margins are known.
<em>Annals of Mathematical Statistics</em> 13 (2): 166-178.
</p>


<h3>See Also</h3>

<p>The documentation of <code>IpfpCov</code> provide details on the
the covariance matrices determination.
</p>
<p><code>ObtainModelEstimates</code> for alternatives 
to the IPFP.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1: 2-way table (V1,V2) of dim=(2,2)
# generating an intial 2-way table to be updated
seed.2d &lt;- array(1,dim=c(2,2))
# desired targets (margins) : V1 and V2
target.row &lt;- c(50,50)
target.col &lt;- c(30,70)
# storing the margins in a list
tgt.data.2d &lt;- list(target.col, target.row)
# list of dimensions of each marginal constrain
tgt.list.2d &lt;- list(1,2)
# calling the Ipfp function
res.2d &lt;- Ipfp(seed.2d, tgt.list.2d, tgt.data.2d)

# Example 2: 3-way table (V1,V2,V3) of dim=(2,4,2)
# seed
seed.3d &lt;- array(1,c(2,4,2))
seed.3d[1,1,1] &lt;- 4
seed.3d[1,3,1] &lt;- 10
seed.3d[1,4,2] &lt;- 6
# desired targets (margins) : V1 and (V2,V3)
target.V1 &lt;- c(50, 16)
target.V2.V3 &lt;- array(4, dim=c(4,2))
target.V2.V3[1,1] &lt;- 10
target.V2.V3[3,1] &lt;- 22
target.V2.V3[4,2] &lt;- 14
# list of dimensions of each marginal constrain
tgt.data.3d &lt;- list(target.V1, target.V2.V3)
# storing the description of target data in a list
tgt.list.3d &lt;- list( 1, c(2,3) )
# calling the Ipfp function
res.3d &lt;- Ipfp(seed.3d, tgt.list.3d, tgt.data.3d, iter=50, print=TRUE, tol=1e-5)

# Example 3: 2-way table (V1,V2) of dim=(2,3) with missing values in the targets
# generating an intial 2-way table to be updated
seed.2d.na &lt;- array(1,dim=c(2,3))
# desired targets (margins) : V1 and V2
target.row.na &lt;- c(40,60)
target.col.na &lt;- c(NA,10,NA)
# storing the margins in a list
tgt.data.2d.na &lt;- list(target.row.na, target.col.na)
# storing the description of target data in a list
tgt.list.2d.na &lt;- list(1,2)
# calling the Ipfp function
res.2d.na &lt;- Ipfp(seed.2d.na, tgt.list.2d.na, tgt.data.2d.na, na.target=TRUE)
</code></pre>


</div>