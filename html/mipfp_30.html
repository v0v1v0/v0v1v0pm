<div class="container">

<table style="width: 100%;"><tr>
<td>ObtainModelEstimates</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimating a contingency table using model-based approaches
</h2>

<h3>Description</h3>

<p>This function provides several alternative estimating methods to 
the IPFP when estimating a multiway table subject to known constrains/totals: 
maximum likelihood method (ML), minimum chi-squared (CHI2) and weighted least 
squares (WLSQ). Note that the resulting estimators are probabilities.
</p>
<p>The covariance matrix of the estimated proportions (as defined by Little and Wu, 
1991) are also provided. Also in the case of the ML method, the covariance 
matrix defined by Lang (2004) is also returned.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ObtainModelEstimates(seed, target.list, target.data, method="ml", 
                     tol.margins = 1e-10, replace.zeros = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>The initial multi-dimensional array to be updated. Each cell must
be non-negative.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.list</code></td>
<td>

<p>A list of the target margins provided in <code>target.data</code>. Each component
of the list is an array whose cells indicates which dimension the
corresponding margin relates to.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.data</code></td>
<td>

<p>A list containing the data of the target margins. Each
component of the list is an array storing a margin.
The list order must follow the one defined in <code>target.list</code>.
Note that the cells of the arrays must be non-negative.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Determine the model to be used for estimating the contingency
table. By default the method is <code>ml</code> (maximum likelihood); other 
options available are <code>chi2</code> (minimum chi-squared) and <code>lsq</code> 
(least squares).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol.margins</code></td>
<td>

<p>Tolerance for the margins consistency. Default is <code class="reqn">1e^{-10}</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace.zeros</code></td>
<td>

<p>Constant that is added to zero cell found in the seed,
as procedures require strictly positive cells. Default value is 
<code class="reqn">1e^{-10}</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters that can be passed to control the 
optimisation process (see solnp from the package 
Rsolnp).
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the final estimated table as well as the covariance matrix of
the estimated proportion and other convergence informations.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x.hat</code></td>
<td>

<p>Array of the estimated table frequencies.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.hat</code></td>
<td>

<p>Array of the estimated table probabilities.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error.margins</code></td>
<td>

<p>For each list element of <code>target.data</code>, <code>check.margins</code> shows the 
maximum absolute deviation between the element and the corresponding 
estimated margin. Note that the deviations should approximate zero, 
otherwise the target margins are not met.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solnp.res</code></td>
<td>

<p>The estimation process uses the <code>solnp</code> optimisation function from 
the R package Rsolnp and <code>solnp.res</code> is the corresponding object 
returned by the solver.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>

<p>A boolean indicating whether the algorithm converged to a solution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>The selected method for estimation.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>The matched call.  
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>It is important to note that if the margins given in <code>target.list</code> are
not consistent (i.e. the sums of their cells are not equals), the input data
is then normalised by considering probabilities instead of frequencies:
</p>

<ul>
<li>
<p> the cells of the seed are divided by <code>sum(seed)</code>;
</p>
</li>
<li>
<p> the cells of each margin <code>i</code> of the list <code>target.data</code> are 
divided by <code>sum(target.data[[i]])</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Thomas Suesse 
</p>
<p>Maintainer: Johan Barthelemy &lt;johan@uow.edu.au&gt;.
</p>


<h3>References</h3>

<p>Lang, J.B. (2004) 
Multinomial-Poisson homogeneous models for contingency tables. 
<em>Annals of Statistics</em> 32(1): 340-383.
</p>
<p>Little, R. J., Wu, M. M. (1991)
Models for contingency tables with known margins when target and sampled 
populations differ.
<em>Journal of the American Statistical Association</em> 86 (413): 87-95.
</p>


<h3>See Also</h3>

<p><code>solnp</code> function documentation of the package
<code>Rsolnp</code> for the details of the <code>solnp.res</code> object 
returned by the function.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># set-up an initial 3-way table of dimension (2 x 2 x 2)
seed &lt;- Vector2Array(c(80, 60, 20, 20, 40, 35, 35, 30), dim = c(c(2, 2, 2)))

# building target margins
margins12 &lt;- c(2000, 1000, 1500, 1800)
margins12.array &lt;- Vector2Array(margins12, dim=c(2, 2))
margins3 &lt;- c(4000,2300)
margins3.array &lt;- Vector2Array(margins3, dim = 2) 
target.list &lt;- list(c(1, 2), 3)
target.data &lt;- list(margins12.array, margins3.array)

# estimating the new contingency table using the ml method
results.ml &lt;- ObtainModelEstimates(seed, target.list, target.data, 
                                   compute.cov = TRUE)
print(results.ml)

# estimating the new contingency table using the chi2 method
results.chi2 &lt;- ObtainModelEstimates(seed, target.list, target.data, 
                                     method = "chi2", compute.cov = TRUE)
print(results.chi2)

# estimating the new contingency table using the lsq method
results.lsq &lt;- ObtainModelEstimates(seed, target.list, target.data,
                                    method = "lsq", compute.cov = TRUE)
print(results.lsq)
</code></pre>


</div>