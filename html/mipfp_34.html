<div class="container">

<table style="width: 100%;"><tr>
<td>Estimate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Update an N-way table given target margins
</h2>

<h3>Description</h3>

<p>This function provides several estimating methods to up multiway table 
(referred as the seed) subject to known constrains/totals: Iterative 
proportional fitting procedure (ipfp), maximum likelihood method (ml), minimum 
chi-squared (chi2) and weighted least squares (lsq). Note that the targets can 
also be multi-dimensional.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Estimate(seed, target.list, target.data, method = "ipfp", keep.input = FALSE,
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>

<p>The initial multi-dimensional array to be updated. Each cell must
be non-negative if <code>method</code> is <code>ipfp</code> or strictly positive
when <code>method</code> is <code>ml</code>, <code>lsq</code> or <code>chi2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.list</code></td>
<td>

<p>A list of dimensions of the marginal target constrains in
<code>target.data</code>. Each component of the list is an array whose cells 
indicate which dimension the corresponding margin relates to.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.data</code></td>
<td>

<p>A list containing the data of the target marginal tables. Each
component of the list is an array storing a margin.
The list order must follow the ordering defined in <code>target.list</code>.
Note that the cells of the arrays must be non-negative.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>An optional character string indicating which method is to be used to
update the <code>seed</code>. This must be on of the strings "ipfp", "ml",
"chi2", or "lsq". Default is "ipfp".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.input</code></td>
<td>

<p>A Boolean indicating if <code>seed</code>, <code>target.data</code> and 
<code>target.list</code> when set to <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additionals argument that can be passed to the functions 
Ipfp and 
ObtainModelEstimates. See their 
respective documentation for more details.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>mipfp</code> is a list containing at least the 
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x.hat</code></td>
<td>

<p>An array with the same dimension of <code>seed</code> whose margins match those
specified in <code>target.list</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.hat</code></td>
<td>

<p>An array with the same dimension of <code>x.hat</code> containing the updated
cell probabilities, i.e. <code>x.hat / sum(x.hat)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error.margins</code></td>
<td>

<p>A list returning, for each margin, the absolute maximum deviation between 
the desired and generated margin.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>

<p>A boolean indicating whether the algorithm converged to a solution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evol.stp.crit</code></td>
<td>

<p>The evolution of the stopping criterion over the iterations (if selected
<code>method</code> is <code>"ipfp"</code>)).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solnp.res</code></td>
<td>

<p>The estimation process uses the <code>solnp</code> optimisation function from 
the R package Rsolnp and <code>solnp.res</code> is the corresponding object 
returned by the solver (if selected <code>method</code> is not <code>"ipfp"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>The selected method for estimation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>The matched call.  
</p>
</td>
</tr>
</table>
<p>The will be also added if <code>keep.input</code> has been set to <code>TRUE</code>: 
<code>seed</code>, <code>target.data</code>, <code>target.list</code>.
</p>


<h3>Note</h3>

<p>It is important to note that if the margins given in <code>target.list</code> are
not consistent (i.e. the sums of their cells are not equals), the input data
is then normalised by considering probabilities instead of frequencies:
</p>

<ul>
<li>
<p> the cells of the seed are divided by <code>sum(seed)</code>;
</p>
</li>
<li>
<p> the cells of each margin <code>i</code> of the list <code>target.data</code> are 
divided by <code>sum(target.data[[i]])</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Johan Barthelemy.
</p>
<p>Maintainer: Johan Barthelemy <a href="mailto:johan@uow.edu.au">johan@uow.edu.au</a>.
</p>


<h3>References</h3>

<p>Bacharach, M. (1965).
Estimating Nonnegative Matrices from Marginal Data.
<em>International Economic Review</em> (Blackwell Publishing) 6 (3): 294-310.
</p>
<p>Bishop, Y. M. M., Fienberg, S. E., Holland, P. W. (1975).
<em>Discrete Multivariate Analysis: Theory and Practice.</em>
MIT Press. ISBN 978-0-262-02113-5.
</p>
<p>Deming, W. E., Stephan, F. F. (1940).
On a Least Squares Adjustment of a Sampled Frequency Table When the Expected
Marginal Totals are Known.
<em>Annals of Mathematical Statistics</em> 11 (4): 427-444.
</p>
<p>Fienberg, S. E. (1970).
An Iterative Procedure for Estimation in Contingency Tables.
<em>Annals of Mathematical Statistics</em> 41 (3): 907-917.
</p>
<p>Little, R. J., Wu, M. M. (1991)
Models for contingency tables with known margins when target and sampled 
populations differ.
<em>Journal of the American Statistical Association</em> 86 (413): 87-95.
</p>
<p>Lang, J.B. (2004) 
Multinomial-Poisson homogeneous models for contingency tables. 
<em>Annals of Statistics</em> 32(1): 340-383.
</p>
<p>Stephan, F. F. (1942).
Iterative method of adjusting frequency tables when expected margins are known.
<em>Annals of Mathematical Statistics</em> 13 (2): 166-178.
</p>


<h3>See Also</h3>

<p>See the functions <code>Ipfp</code> and 
<code>ObtainModelEstimates</code>
for more details about the estimation process.
</p>
<p><code>summary.mipfp</code> for summaries,  
<code>vcov.mipfp</code> for the (asymptotic) covariance of 
the estimates and <code>gof.estimates.mipfp</code>
for testing if the seed agrees with the targets.
</p>
<p>The genereric functions <code>print</code> and
<code>coef</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># loading the data
data(spnamur, package = "mipfp")
# subsetting the data frame, keeping only the first 3 variables
spnamur.sub &lt;- subset(spnamur, select = Household.type:Prof.status)
# true table
true.table &lt;- table(spnamur.sub)
# extracting the margins
tgt.v1        &lt;- apply(true.table, 1, sum)
tgt.v1.v2     &lt;- apply(true.table, c(1,2), sum)
tgt.v2.v3     &lt;- apply(true.table, c(2,3), sum)
tgt.list.dims &lt;- list(1, c(1,2), c(2,3))
tgt.data      &lt;- list(tgt.v1, tgt.v1.v2, tgt.v2.v3)
# creating the seed, a 10 pct sample of spnamur
seed.df &lt;- spnamur.sub[sample(nrow(spnamur), round(0.10*nrow(spnamur))), ]
seed.table &lt;- table(seed.df)
# applying one fitting method (ipfp)
r.ipfp &lt;- Estimate(seed=seed.table, target.list=tgt.list.dims, 
                   target.data = tgt.data)
print(r.ipfp)
</code></pre>


</div>