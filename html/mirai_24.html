<div class="container">

<table style="width: 100%;"><tr>
<td>mirai</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>mirai (Evaluate Async)</h2>

<h3>Description</h3>

<p>Evaluate an expression asynchronously in a new background R process or
persistent daemon (local or remote). This function will return
immediately with a ‘mirai’, which will resolve to the evaluated
result once complete.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mirai(.expr, ..., .args = list(), .timeout = NULL, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.expr</code></td>
<td>
<p>an expression to evaluate asynchronously (of arbitrary length,
wrapped in { } where necessary), <strong>or else</strong> a pre-constructed
language object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(optional) <strong>either</strong> named arguments (name = value pairs)
specifying objects referenced, but not defined, in ‘.expr’,
<strong>or</strong> an environment containing such objects. See
‘evaluation’ section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.args</code></td>
<td>
<p>(optional) <strong>either</strong> a named list specifying objects
referenced, but not defined, in ‘.expr’, <strong>or</strong> an
environment containing such objects. These objects will remain local to
the evaluation environment as opposed to those supplied in ‘...’
above - see ‘evaluation’ section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.timeout</code></td>
<td>
<p>[default NULL] for no timeout, or an integer value in
milliseconds. A mirai will resolve to an ‘errorValue’ 5 (timed
out) if evaluation exceeds this limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function will return a ‘mirai’ object immediately.
</p>
<p>The value of a mirai may be accessed at any time at <code>$data</code>, and
if yet to resolve, an ‘unresolved’ logical NA will be returned
instead.
</p>
<p><code>unresolved</code> may be used on a mirai, returning TRUE if a
‘mirai’ has yet to resolve and FALSE otherwise. This is suitable
for use in control flow statements such as <code>while</code> or <code>if</code>.
</p>
<p>Alternatively, to call (and wait for) the result, use
<code>call_mirai</code> on the returned ‘mirai’. This will block
until the result is returned.
</p>
<p>Specify ‘.compute’ to send the mirai using a specific compute
profile (if previously created by <code>daemons</code>), otherwise leave
as ‘default’.
</p>


<h3>Value</h3>

<p>A ‘mirai’ object.
</p>


<h3>Evaluation</h3>

<p>The expression ‘.expr’ will be evaluated in a separate R process
in a clean environment (not the global environment), consisting only of
the objects in the list or environment supplied to ‘.args’, with
the named objects passed as ‘...’ (from the environment if one was
supplied) assigned to the global environment of that process.
</p>
<p>For evaluation to occur <em>as if</em> in your global environment, supply
objects to ‘...’ rather than ‘.args’. For stricter scoping,
use ‘.args’, which limits, for example, where variables not
explicitly passed as arguments to functions are found.
</p>
<p>As evaluation occurs in a clean environment, all undefined objects must
be supplied though ‘...’ and/or ‘.args’, including
self-defined functions. Functions from a package should use namespaced
calls such as <code>mirai::mirai()</code>, or else the package should be loaded
beforehand as part of ‘.expr’.
</p>


<h3>Errors</h3>

<p>If an error occurs in evaluation, the error message is returned as a
character string of class ‘miraiError’ and ‘errorValue’
(the stack trace is available at <code>$stack.trace</code> on the error
object). <code>is_mirai_error</code> may be used to test for this.
</p>
<p>If a daemon crashes or terminates unexpectedly during evaluation, an
‘errorValue’ 19 (Connection reset) is returned (when not using
dispatcher or using dispatcher with <code>retry = FALSE</code>). Otherwise,
using dispatcher with <code>retry = TRUE</code>, the mirai will remain
unresolved and is automatically re-tried on the next daemon to connect to
the particular instance. To cancel the task instead, use
<code>saisei(force = TRUE)</code> (see <code>saisei</code>).
</p>
<p><code>is_error_value</code> tests for all error conditions including
‘mirai’ errors, interrupts, and timeouts.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (interactive()) {
# Only run examples in interactive R sessions

# specifying objects via '...'
n &lt;- 3
m &lt;- mirai(x + y + 2, x = 2, y = n)
m
m$data
Sys.sleep(0.2)
m$data

# passing the calling environment to '...'
df1 &lt;- data.frame(a = 1, b = 2)
df2 &lt;- data.frame(a = 3, b = 1)
m &lt;- mirai(as.matrix(rbind(df1, df2)), environment(), .timeout = 1000)
call_mirai(m)$data

# using unresolved()
m &lt;- mirai(
  {
    res &lt;- rnorm(n)
    res / rev(res)
  },
  n = 1e6
)
while (unresolved(m)) {
  cat("unresolved\n")
  Sys.sleep(0.1)
}
str(m$data)

# evaluating scripts using source() in '.expr'
n &lt;- 10L
file &lt;- tempfile()
cat("r &lt;- rnorm(n)", file = file)
m &lt;- mirai({source(file); r}, file = file, n = n)
call_mirai(m)[["data"]]
unlink(file)

# use source(local = TRUE) when passing in local variables via '.args'
n &lt;- 10L
file &lt;- tempfile()
cat("r &lt;- rnorm(n)", file = file)
m &lt;- mirai({source(file, local = TRUE); r}, .args = list(file = file, n = n))
call_mirai(m)[["data"]]
unlink(file)

# passing a language object to '.expr' and a named list to '.args'
expr &lt;- quote(a + b + 2)
args &lt;- list(a = 2, b = 3)
m &lt;- mirai(.expr = expr, .args = args)
call_mirai(m)$data

}

</code></pre>


</div>