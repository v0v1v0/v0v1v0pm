<div class="container">

<table style="width: 100%;"><tr>
<td>mirai_map</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>mirai Map</h2>

<h3>Description</h3>

<p>Asynchronous parallel map of a function over a list or vector using
<span class="pkg">mirai</span>, with optional <span class="pkg">promises</span> integration. Performs multiple
map over the rows of a dataframe or matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mirai_map(.x, .f, ..., .args = list(), .promise = NULL, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.x</code></td>
<td>
<p>a list or atomic vector. Also accepts a matrix or dataframe, in
which case multiple map is performed over its rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p>a function to be applied to each element of <code>.x</code>, or row of
<code>.x</code> as the case may be.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(optional) named arguments (name = value pairs) specifying objects
referenced, but not defined, in <code>.f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.args</code></td>
<td>
<p>(optional) further constant arguments to <code>.f</code>, provided as
a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.promise</code></td>
<td>
<p>(optional) if supplied, registers a promise against each
mirai. Either a function, supplied to the ‘onFulfilled’ argument
of <code>promises::then()</code> or a list of 2 functions, supplied
respectively to ‘onFulfilled’ and ‘onRejected’ for
<code>promises::then()</code>. Using this argument requires the
<a href="https://CRAN.R-project.org/package=promises"><span class="pkg">promises</span></a> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Sends each application of function <code>.f</code> on an element of
<code>.x</code> (or row of <code>.x</code>) for computation in a separate
<code>mirai</code> call.
</p>
<p>This simple and transparent behaviour is designed to make full use of
<span class="pkg">mirai</span> scheduling to minimise overall execution time.
</p>
<p>Facilitates recovery from partial failure by returning all
‘miraiError’ / ‘errorValue’ as the case may be, thus
allowing only the failures to be re-run.
</p>
<p>Note: requires daemons to have previously been set. If not, then one
local daemon is set before the function proceeds.
</p>


<h3>Value</h3>

<p>A ‘mirai_map’ (list of ‘mirai’ objects).
</p>


<h3>Results</h3>

<p><code>x[]</code> collects the results of a ‘mirai_map’ <code>x</code> and
returns a list. This will wait for all asynchronous operations to
complete if still in progress, blocking but user-interruptible.
</p>
<p><code>x[.flat]</code> collects and flattens map results to a vector, checking
that they are of the same type to avoid coercion. Note: errors if an
‘errorValue’ has been returned or results are of differing type.
</p>
<p><code>x[.progress]</code> collects map results whilst showing a simple text
progress indicator of parts completed of the total.
</p>
<p><code>x[.progress_cli]</code> collects map results whilst showing a progress bar
from the <a href="https://CRAN.R-project.org/package=cli"><span class="pkg">cli</span></a> package, if available, with completion percentage
and ETA.
</p>
<p><code>x[.stop]</code> collects map results applying early stopping, which stops
at the first failure and cancels remaining operations. Note: operations
already in progress continue to completion, although their results are
not collected.
</p>
<p>The options above may be combined in the manner of: <br><code>x[.stop, .progress]</code> which applies early stopping together with a
progress indicator.
</p>


<h3>Multiple Map</h3>

<p>Multiple map is performed automatically over the <strong>rows</strong> of an
object with ‘dim’ attributes such as a matrix or dataframe. This is
most often the desired behaviour.
</p>
<p>To map over <strong>columns</strong> instead, first wrap a dataframe in
<code>as.list</code>, or transpose a matrix using <code>t</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (interactive()) {
# Only run examples in interactive R sessions

daemons(4, dispatcher = "none")

# map with constant args specified via '.args'
mirai_map(1:3, rnorm, .args = list(mean = 20, sd = 2))[]

# flatmap with function definition passed via '...'
mirai_map(1:3, function(x) func(1L, x, x + 1L), func = stats::runif)[.flat]

# sum rows of a dataframe
(df &lt;- data.frame(a = 1:3, b = c(4, 3, 2)))
mirai_map(df, sum)[.flat]

# sum rows of a matrix
(mat &lt;- matrix(1:4, nrow = 2L))
mirai_map(mat, sum)[.flat]

# map over rows of a dataframe
df &lt;- data.frame(a = c("Aa", "Bb"), b = c(1L, 4L))
mirai_map(df, function(...) sprintf("%s: %d", ...))[.flat]

# indexed map over a vector
v &lt;- c("egg", "got", "ten", "nap", "pie")
mirai_map(
  data.frame(1:length(v), v),
  sprintf,
  .args = list(fmt = "%d_%s")
)[.flat]

# return a 'mirai_map' object, check for resolution, collect later
mp &lt;- mirai_map(
  c(a = 2, b = 3, c = 4),
  function(x, y) do(x, as.logical(x %% y)),
  do = nanonext::random,
  .args = list(y = 2)
)
unresolved(mp)
mp
mp[]
unresolved(mp)

# progress indicator counts up from 0 to 4 seconds
res &lt;- mirai_map(1:4, Sys.sleep)[.progress]

daemons(0)

# generates warning as daemons not set
# stops early when second element returns an error
tryCatch(
  mirai_map(list(1, "a", 3), sum)[.stop],
  error = identity
)

# promises example that outputs the results, including errors, to the console
if (requireNamespace("promises", quietly = TRUE)) {
daemons(1, dispatcher = "none")
ml &lt;- mirai_map(
  1:30,
  function(x) {Sys.sleep(0.1); if (x == 30) stop(x) else x},
  .promise = list(
    function(x) cat(paste(x, "")),
    function(x) { cat(conditionMessage(x), "\n"); daemons(0) }
  )
)
}

}

</code></pre>


</div>