<div class="container">

<table style="width: 100%;"><tr>
<td>extract.mirtCAT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract elements from the internal person, test, and design objects</h2>

<h3>Description</h3>

<p>This function extracts elements, as well as builds a few convenient elements, 
from the three internal <code>person</code>, <code>design</code>, or <code>test</code>
objects that are accessible through a <code>customNextItem</code> function 
definition (see <code>mirtCAT</code> for details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">extract.mirtCAT(x, what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>either the <code>person</code>, <code>design</code>, or <code>test</code> object defined through a 
<code>customNextItem</code> definition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>a character vector extracting the desired element (see the Details section)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Depending on which object is supplied, the following elements can be extracted.
</p>


<h3>The 'person' argument</h3>


<dl>
<dt><code>ID</code></dt>
<dd>
<p>a scalar value indicating the ID of the participant 
(generally only needed in Monte Carlo simulations)</p>
</dd>
<dt><code>responses</code></dt>
<dd>
<p>an integer vector indicating how items that have been responded to. 
Each element pertains to the associated item location (e.g., <code>responses[100]</code> is associated with the 
100th item), and is <code>NA</code> if the item has not been responded to</p>
</dd>
<dt><code>raw_responses</code></dt>
<dd>
<p>of the same form as <code>responses</code>, pertaining to the observed responses
in a character vector</p>
</dd>
<dt><code>items_in_bank</code></dt>
<dd>
<p>an integer vector indicating items which have not been administered yet and 
are also valid candidates for administration</p>
</dd>
<dt><code>items_answered</code></dt>
<dd>
<p>an integer vector indicating the order in which items have been responded to</p>
</dd>
<dt><code>thetas</code></dt>
<dd>
<p>the current ability/latent trait estimates given the previously administered items</p>
</dd>
<dt><code>thetas_SE</code></dt>
<dd>
<p>the current ability/latent trait standard error estimates given the 
previously administered items</p>
</dd>
<dt><code>thetas_history</code></dt>
<dd>
<p>history of the  ability/latent trait estimates</p>
</dd>
<dt><code>thetas_SE_history</code></dt>
<dd>
<p>history of the latent trait standard error estimates</p>
</dd>
<dt><code>item_time</code></dt>
<dd>
<p>of the same form as <code>items_answered</code>, pertaining to the amount of time it took the 
participant to response to the item</p>
</dd>
<dt><code>demographics</code></dt>
<dd>
<p>a data.frame containing the (optional) prior survey information from the GUI interface</p>
</dd>
<dt><code>clientData</code></dt>
<dd>
<p>a list of useful information from shiny's <code>session$clientData</code></p>
</dd>
</dl>
<h3>The 'design' argument</h3>


<dl>
<dt><code>items_not_scored</code></dt>
<dd>
<p>an integer vector indicating items which should be included but not 
scored in the test (these are experimental items)</p>
</dd>
<dt><code>min_items</code></dt>
<dd>
<p>minimum number of items to administer</p>
</dd>
<dt><code>max_items</code></dt>
<dd>
<p>maximum number of items to administer</p>
</dd>
<dt><code>max_time</code></dt>
<dd>
<p>maximum amount of time alloted to the GUI</p>
</dd>
<dt><code>met_SEM</code></dt>
<dd>
<p>logical vector indicating whether the SEM criteria has been met</p>
</dd>
<dt><code>met_delta_thetas</code></dt>
<dd>
<p>logical vector indicating whether the delta_thetas criteria has been met</p>
</dd>
<dt><code>met_classify</code></dt>
<dd>
<p>logical vector indicating whether the classify criteria has been met</p>
</dd>
<dt><code>exposure</code></dt>
<dd>
<p>exposure control elements of the same form as <code>responses</code></p>
</dd>
<dt><code>content</code></dt>
<dd>
<p>content constraint information</p>
</dd>
<dt><code>content_prop</code></dt>
<dd>
<p>content proportions</p>
</dd>
<dt><code>test_properties</code></dt>
<dd>
<p>user-defined <code>data.frame</code> of test-based properties</p>
</dd>
<dt><code>person_properties</code></dt>
<dd>
<p>user-defined <code>data.frame</code> of person-based properties</p>
</dd>
</dl>
<h3>The 'test' argument</h3>


<dl>
<dt><code>mo</code></dt>
<dd>
<p>extract the defined model from the <code>mirt</code> package. Afterward, users can use the 
<code>extract.mirt</code> function to pull out a large number of internal elements for easy use</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>


<h3>See Also</h3>

<p><code>mirt</code>, <code>mirtCAT</code>, <code>extract.mirt</code>, 
<code>findNextItem</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
 #example test
set.seed(1234)
nitems &lt;- 25
itemnames &lt;- paste0('Item.', 1:nitems)
a &lt;- matrix(rlnorm(nitems, .2, .3))
d &lt;- matrix(rnorm(nitems))
dat &lt;- simdata(a, d, 500, itemtype = 'dich')
colnames(dat) &lt;- itemnames
mod &lt;- mirt(dat, 1, verbose = FALSE, TOL = .01)

# simple math items
questions &lt;- answers &lt;- character(nitems)
choices &lt;- matrix(NA, nitems, 5)
spacing &lt;- floor(d - min(d)) + 1 #easier items have more variation in the options

for(i in 1:nitems){
  n1 &lt;- sample(1:50, 1)
  n2 &lt;- sample(51:100, 1)
  ans &lt;- n1 + n2
  questions[i] &lt;- paste0(n1, ' + ', n2, ' = ?')
  answers[i] &lt;- as.character(ans)
  ch &lt;- ans + sample(c(-5:-1, 1:5) * spacing[i,], 5)
  ch[sample(1:5, 1)] &lt;- ans
  choices[i, ] &lt;- as.character(ch)
}

df &lt;- data.frame(Question=questions, Option=choices, 
  Type = 'radio', stringsAsFactors = FALSE)
df$Answer &lt;- answers

pat &lt;- generate_pattern(mod, Theta = 0, df)

#------------------------------------------------
# administer items in sequence
customNextItem &lt;- function(person, design, test){
   # browser()
   items_left_2_choose_from &lt;- extract.mirtCAT(person, 'items_in_bank')
   min(items_left_2_choose_from)
}

res &lt;- mirtCAT(df, local_pattern=pat, 
  design = list(customNextItem=customNextItem))
summary(res)

#------------------------------------------------
# administer items in order, but stop after 10 items
customNextItem &lt;- function(person, design, test){
   items_left_2_choose_from &lt;- extract.mirtCAT(person, 'items_in_bank')
   items_answered &lt;- extract.mirtCAT(person, 'items_answered')
   total &lt;- sum(!is.na(items_answered))
   ret &lt;- if(total &lt; 10) min(items_left_2_choose_from)
     else return(NA)
   ret
}

res &lt;- mirtCAT(df, local_pattern=pat, 
  design = list(customNextItem=customNextItem))
summary(res)

#------------------------------------------------
# using findNextItem() and stopping after 10 items

customNextItem &lt;- function(person, design, test){
   items_answered &lt;- extract.mirtCAT(person, 'items_answered')
   total &lt;- sum(!is.na(items_answered))
   ret &lt;- NA
   if(total &lt; 10) 
     ret &lt;- findNextItem(person=person, test=test, design=design, criteria = 'MI')
   ret
}

res &lt;- mirtCAT(df, mod, local_pattern=pat, start_item = 'MI',
  design = list(customNextItem=customNextItem))
summary(res)

# equivalent to the following
res2 &lt;- mirtCAT(df, mod, local_pattern=pat, start_item = 'MI', 
  criteria = 'MI', design = list(max_items = 10))
summary(res2)


## End(Not run)
</code></pre>


</div>