<div class="container">

<table style="width: 100%;"><tr>
<td>findNextItem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find next CAT item</h2>

<h3>Description</h3>

<p>A function that returns the next item in the computerized adaptive, optimal assembly, or shadow test.
For direction manipulation of the internal objects this function should be used in conjunction
with the <code>updateDesign</code> and <code>customNextItem</code>.
Finally, the raw input forms can be used when a <code>customNextItem</code> function has been
defined in <code>mirtCAT</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">findNextItem(
  x,
  person = NULL,
  test = NULL,
  design = NULL,
  criteria = NULL,
  objective = NULL,
  subset = NULL,
  all_index = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class 'mirtCAT_design' returned from the <code>mirtCAT</code> function
when passing <code>design_elements = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>person</code></td>
<td>
<p>(required when <code>x</code> is missing) internal person object. To be
used when <code>customNextItem</code> function has been defined</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>(required when <code>x</code> is missing) internal test object. To be
used when <code>customNextItem</code> function has been defined</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>(required when <code>x</code> is missing) internal design object. To be
used when <code>customNextItem</code> function has been defined</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteria</code></td>
<td>
<p>item selection criteria (see <code>mirtCAT</code>'s <code>criteria</code> input).
If not specified the value from <code>extract.mirtCAT(design, 'criteria')</code> will be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objective</code></td>
<td>
<p>a vector of values used as the optimization criteria to be passed to
<code>lp(objective.in)</code>. This is typically the vector of criteria values returned from
<code>computeCriteria</code>, however supplying other
criteria are possible (e.g., to minimize the number of items administered simply pass a vector
of -1's)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an integer vector indicating which items should be included in the optimal search;
the default <code>NULL</code> includes all possible items. To allow only the first 10 items to be
selected from this can be modified to <code>subset = 1:10</code>. This is useful when administering
a multi-unidimensional CAT session where unidimensional blocks should be clustered together
for smoother presentation. Useful when using the <code>customNextItem</code> function in
<code>mirtCAT</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_index</code></td>
<td>
<p>logical; return all items instead of just the most optimal?
When <code>TRUE</code> a vector of items is returned instead of the most optimal,
where the items are sorted according to how
well they fit the criteria (e.g., the first element is the most optimal, followed by the second
most optimal, and so on). Note that this does not work for some selection criteria (e.g.,
'seq' or 'random')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to <code>lp</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When a numeric <code>objective</code> is supplied the next item in the computerized adaptive test is found via
an integer solver through searching for a maximum. The raw input forms can be used
when a <code>customNextItem</code> function has been defined in <code>mirtCAT</code>, and requires
the definition of a <code>constr_fun</code> (see the associated element in <code>mirtCAT</code> for details,
as well as the examples below). Can be used to for 'Optimal Test Assembly',
as well as 'Shadow Testing' designs (van der Linden, 2005),
by using the <code>lp</code> function. When <code>objective</code> is not supplied the result follows the
typical maximum criteria of more standard adaptive tests.
</p>


<h3>Value</h3>

<p>typically returns an integer value indicating the index of the next item to be selected or a
value of <code>NA</code> to indicate that the test should be terminated. However, see the arguments for
further returned object descriptions
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>
<p>van der Linden, W. J. (2005). Linear models for optimal test design. Springer.
</p>


<h3>See Also</h3>

<p><code>mirtCAT</code>, <code>updateDesign</code>, <code>extract.mirtCAT</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# test defined in mirtCAT help file, first example 
# equivalent to criteria = 'MI'
customNextItem &lt;- function(design, person, test){
   item &lt;- findNextItem(person=person, design=design, test=test,
                        criteria = 'MI')
   item
 }
 
set.seed(1)
nitems &lt;- 100
itemnames &lt;- paste0('Item.', 1:nitems)
a &lt;- matrix(rlnorm(nitems, .2, .3))
d &lt;- matrix(rnorm(nitems))
dat &lt;- simdata(a, d, 500, itemtype = 'dich')
colnames(dat) &lt;- itemnames
mod &lt;- mirt(dat, 1, verbose = FALSE)

# simple math items
questions &lt;- answers &lt;- character(nitems)
choices &lt;- matrix(NA, nitems, 5)
spacing &lt;- floor(d - min(d)) + 1 #easier items have more variation in the options

for(i in 1:nitems){
 n1 &lt;- sample(1:50, 1)
 n2 &lt;- sample(51:100, 1)
 ans &lt;- n1 + n2
 questions[i] &lt;- paste0(n1, ' + ', n2, ' = ?')
 answers[i] &lt;- as.character(ans)
 ch &lt;- ans + sample(c(-5:-1, 1:5) * spacing[i,], 5)
 ch[sample(1:5, 1)] &lt;- ans
 choices[i, ] &lt;- as.character(ch)
}

df &lt;- data.frame(Question=questions, Option=choices, 
              Type = 'radio', stringsAsFactors = FALSE)
   
response &lt;- generate_pattern(mod, 1)
result &lt;- mirtCAT(mo=mod, local_pattern = response, 
                  design = list(customNextItem=customNextItem))
                
-----------------------------------------------------------
# direct manipulation of internal objects
CATdesign &lt;- mirtCAT(df=df, mo=mod, criteria = 'MI', design_elements = TRUE)

# returns number 1 in this case, since that's the starting item
findNextItem(CATdesign)

# determine next item if item 1 and item 10 were answered correctly
CATdesign &lt;- updateDesign(CATdesign, new_item = 1, new_response = 1)
extract.mirtCAT(CATdesign$person, 'thetas') # updated thetas
CATdesign &lt;- updateDesign(CATdesign, new_item = 10, new_response = 1)
extract.mirtCAT(CATdesign$person, 'thetas') # updated thetas again
findNextItem(CATdesign)
findNextItem(CATdesign, all_index = TRUE) # all items rank in terms of most optimal

#-------------------------------------------------------------
## Integer programming example (e.g., shadow testing)

# find maximum information subject to constraints
#  sum(xi) &lt;= 5               ### 5 or fewer items
#  x1 + x2 &lt;= 1               ### items 1 and 2 can't be together
#  x4 == 0                    ### item 4 not included
#  x5 + x6 == 1               ### item 5 or 6 must be included, but not both

# constraint function
constr_fun &lt;- function(design, person, test){

  # left hand side constrains
  #    - 1 row per constraint, and ncol must equal number of items
  mo &lt;- extract.mirtCAT(test, 'mo')
  nitems &lt;- extract.mirt(mo, 'nitems')
  lhs &lt;- matrix(0, 4, nitems)
  lhs[1,] &lt;- 1
  lhs[2,c(1,2)] &lt;- 1
  lhs[3, 4] &lt;- 1
  lhs[4, c(5,6)] &lt;- 1

  # relationship direction
  dirs &lt;- c("&lt;=", "&lt;=", '==', '==')

  #right hand side
  rhs &lt;- c(5, 1, 0, 1)

  #all together
  constraints &lt;- data.frame(lhs, dirs, rhs)
  constraints
}

CATdesign &lt;- mirtCAT(df=df, mo=mod, design_elements = TRUE,
                     design = list(constr_fun=constr_fun))

# MI criteria value associated with each respective item
objective &lt;- computeCriteria(CATdesign, criteria = 'MI')

# most optimal item, given constraints
findNextItem(CATdesign, objective=objective)

# all the items which solve the problem
findNextItem(CATdesign, objective=objective, all_index = TRUE)

## within a customNextItem() definition the above code would look like
# customNextItem &lt;- function(design, person, test){
#   objective &lt;- computeCriteria(person=person, design=design, test=test,
#                                criteria = 'MI')
#   item &lt;- findNextItem(person=person, design=design, test=test,
#                        objective=objective)
#   item
# }


## End(Not run)
</code></pre>


</div>