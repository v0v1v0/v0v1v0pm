<div class="container">

<table style="width: 100%;"><tr>
<td>multipleGroup</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiple Group Estimation</h2>

<h3>Description</h3>

<p><code>multipleGroup</code> performs a full-information
maximum-likelihood multiple group analysis for any combination of dichotomous and polytomous
data under the item response theory paradigm using either Cai's (2010)
Metropolis-Hastings Robbins-Monro (MHRM) algorithm or with an EM algorithm approach. This
function may be used for detecting differential item functioning (DIF), thought the
<code>DIF</code> function may provide a more convenient approach. If the grouping
variable is not specified then the <code>dentype</code> input can be modified to fit
mixture models to estimate any latent group components.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multipleGroup(
  data,
  model = 1,
  group,
  itemtype = NULL,
  invariance = "",
  method = "EM",
  dentype = "Gaussian",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a <code>matrix</code> or <code>data.frame</code> that consists of
numerically ordered data, with missing data coded as <code>NA</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>string to be passed to, or a model object returned from, <code>mirt.model</code>
declaring how the global model is to be estimated (useful to apply constraints here)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>a <code>character</code> or <code>factor</code> vector indicating group membership. If a <code>character</code>
vector is supplied this will be automatically transformed into a <code>factor</code> variable.
As well, the first level of the (factorized) grouping variable will be treated as the "reference" group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itemtype</code></td>
<td>
<p>can be same type of input as is documented in <code>mirt</code>, however may also be a
<code>ngroups</code> by <code>nitems</code> matrix specifying the type of IRT models for each group, respectively.
Rows of this input correspond to the levels of the <code>group</code> input. For mixture models the rows correspond
to the respective mixture grouping variables to be constructed, and the IRT models should be within these
mixtures</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invariance</code></td>
<td>
<p>a character vector containing the following possible options:
</p>

<dl>
<dt>
<code>'free_mean'</code> or <code>'free_means'</code>
</dt>
<dd>
<p>freely estimate all latent means in all focal groups
(reference group constrained to a vector of 0's)</p>
</dd>
<dt>
<code>'free_var'</code>, <code>'free_vars'</code>, <code>'free_variance'</code>, or <code>'free_variances'</code>
</dt>
<dd>
<p>freely estimate all latent variances in focal groups
(reference group variances all constrained to 1)</p>
</dd>
<dt><code>'slopes'</code></dt>
<dd>
<p>to constrain all the slopes to be equal across all groups</p>
</dd>
<dt><code>'intercepts'</code></dt>
<dd>
<p>to constrain all the intercepts to be equal across all
groups, note for nominal models this also includes the category specific slope parameters</p>
</dd>
</dl>
<p>Additionally, specifying specific item name bundles (from <code>colnames(data)</code>) will
constrain all freely estimated parameters in each item to be equal across groups. This is
useful for selecting 'anchor' items for vertical and horizontal scaling, and for detecting
differential item functioning (DIF) across groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character object that is either <code>'EM'</code>, <code>'QMCEM'</code>, or <code>'MHRM'</code>
(default is <code>'EM'</code>). See <code>mirt</code> for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dentype</code></td>
<td>
<p>type of density form to use for the latent trait parameters. Current options include
all of the methods described in <code>mirt</code>, as well as
</p>

<ul><li> <p><code>'mixture-#'</code> estimates mixtures of Gaussian distributions,
where the <code>#</code> placeholder represents the number of potential grouping variables
(e.g., <code>'mixture-3'</code> will estimate 3 underlying classes). Each class is
assigned the group name <code>MIXTURE_#</code>, where <code>#</code> is the class number.
Note that internally the mixture coefficients are stored as log values where
the first mixture group coefficient is fixed at 0
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to the estimation engine. See <code>mirt</code>
for details and examples</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default the estimation in <code>multipleGroup</code> assumes that the models are maximally
independent, and therefore could initially be performed by sub-setting the data and running
identical models with <code>mirt</code> and aggregating the results (e.g., log-likelihood).
However, constrains may be automatically imposed across groups by invoking various
<code>invariance</code> keywords. Users may also supply a list of parameter equality constraints
to by <code>constrain</code> argument, of define equality constraints using the
<code>mirt.model</code> syntax (recommended).
</p>


<h3>Value</h3>

<p>function returns an object of class <code>MultipleGroupClass</code>
(MultipleGroupClass-class).
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>


<h3>See Also</h3>

<p><code>mirt</code>, <code>DIF</code>, <code>extract.group</code>, <code>DRF</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# single factor
set.seed(12345)
a &lt;- matrix(abs(rnorm(15,1,.3)), ncol=1)
d &lt;- matrix(rnorm(15,0,.7),ncol=1)
itemtype &lt;- rep('2PL', nrow(a))
N &lt;- 1000
dataset1 &lt;- simdata(a, d, N, itemtype)
dataset2 &lt;- simdata(a, d, N, itemtype, mu = .1, sigma = matrix(1.5))
dat &lt;- rbind(dataset1, dataset2)
group &lt;- c(rep('D1', N), rep('D2', N))

# marginal information
itemstats(dat)

# conditional information
itemstats(dat, group=group)

mod_configural &lt;- multipleGroup(dat, 1, group = group) #completely separate analyses
# limited information fit statistics
M2(mod_configural)

mod_metric &lt;- multipleGroup(dat, 1, group = group, invariance=c('slopes')) #equal slopes
# equal intercepts, free variance and means
mod_scalar2 &lt;- multipleGroup(dat, 1, group = group,
                             invariance=c('slopes', 'intercepts', 'free_var','free_means'))
mod_scalar1 &lt;- multipleGroup(dat, 1, group = group,  #fixed means
                             invariance=c('slopes', 'intercepts', 'free_var'))
mod_fullconstrain &lt;- multipleGroup(dat, 1, group = group,
                             invariance=c('slopes', 'intercepts'))
extract.mirt(mod_fullconstrain, 'time') #time of estimation components

# optionally use Newton-Raphson for (generally) faster convergence in the M-step's
mod_fullconstrain &lt;- multipleGroup(dat, 1, group = group, optimizer = 'NR',
                             invariance=c('slopes', 'intercepts'))
extract.mirt(mod_fullconstrain, 'time') #time of estimation components

summary(mod_scalar2)
coef(mod_scalar2, simplify=TRUE)
residuals(mod_scalar2)
plot(mod_configural)
plot(mod_configural, type = 'info')
plot(mod_configural, type = 'trace')
plot(mod_configural, type = 'trace', which.items = 1:4)
itemplot(mod_configural, 2)
itemplot(mod_configural, 2, type = 'RE')

anova(mod_metric, mod_configural) #equal slopes only
anova(mod_scalar2, mod_metric) #equal intercepts, free variance and mean
anova(mod_scalar1, mod_scalar2) #fix mean
anova(mod_fullconstrain, mod_scalar1) #fix variance

# compared all at once (in order of most constrained to least)
anova(mod_fullconstrain, mod_scalar2, mod_configural)


# test whether first 6 slopes should be equal across groups
values &lt;- multipleGroup(dat, 1, group = group, pars = 'values')
values
constrain &lt;- list(c(1, 63), c(5,67), c(9,71), c(13,75), c(17,79), c(21,83))
equalslopes &lt;- multipleGroup(dat, 1, group = group, constrain = constrain)
anova(equalslopes, mod_configural)

# same as above, but using mirt.model syntax
newmodel &lt;- '
    F = 1-15
    CONSTRAINB = (1-6, a1)'
equalslopes &lt;- multipleGroup(dat, newmodel, group = group)
coef(equalslopes, simplify=TRUE)

############
# vertical scaling (i.e., equating when groups answer items others do not)
dat2 &lt;- dat
dat2[group == 'D1', 1:2] &lt;- dat2[group != 'D1', 14:15] &lt;- NA
head(dat2)
tail(dat2)

# items with missing responses need to be constrained across groups for identification
nms &lt;- colnames(dat2)
mod &lt;- multipleGroup(dat2, 1, group, invariance = nms[c(1:2, 14:15)])

# this will throw an error without proper constraints (SEs cannot be computed either)
# mod &lt;- multipleGroup(dat2, 1, group)

# model still does not have anchors, therefore need to add a few (here use items 3-5)
mod_anchor &lt;- multipleGroup(dat2, 1, group,
                            invariance = c(nms[c(1:5, 14:15)], 'free_means', 'free_var'))
coef(mod_anchor, simplify=TRUE)

# check if identified by computing information matrix
mod_anchor &lt;- multipleGroup(dat2, 1, group, pars = mod2values(mod_anchor), TOL=NaN, SE=TRUE,
                            invariance = c(nms[c(1:5, 14:15)], 'free_means', 'free_var'))
mod_anchor
coef(mod_anchor)
coef(mod_anchor, printSE=TRUE)


#############
# DIF test for each item (using all other items as anchors)
itemnames &lt;- colnames(dat)
refmodel &lt;- multipleGroup(dat, 1, group = group, SE=TRUE,
                          invariance=c('free_means', 'free_var', itemnames))

# loop over items (in practice, run in parallel to increase speed). May be better to use ?DIF
estmodels &lt;- vector('list', ncol(dat))
for(i in 1:ncol(dat))
    estmodels[[i]] &lt;- multipleGroup(dat, 1, group = group, verbose = FALSE,
                             invariance=c('free_means', 'free_var', itemnames[-i]))
anova(refmodel, estmodels[[1]])
(anovas &lt;- lapply(estmodels, function(x, refmodel) anova(refmodel, x),
   refmodel=refmodel))

# family-wise error control
p &lt;- do.call(rbind, lapply(anovas, function(x) x[2, 'p']))
p.adjust(p, method = 'BH')

# same as above, except only test if slopes vary (1 df)
# constrain all intercepts
estmodels &lt;- vector('list', ncol(dat))
for(i in 1:ncol(dat))
    estmodels[[i]] &lt;- multipleGroup(dat, 1, group = group, verbose = FALSE,
                             invariance=c('free_means', 'free_var', 'intercepts',
                             itemnames[-i]))

(anovas &lt;- lapply(estmodels, function(x, refmodel) anova(refmodel, x),
   refmodel=refmodel))

# quickly test with Wald test using DIF()
mod_configural2 &lt;- multipleGroup(dat, 1, group = group, SE=TRUE)
DIF(mod_configural2, which.par = c('a1', 'd'), Wald=TRUE, p.adjust = 'fdr')



#############
# Three group model where the latent variable parameters are constrained to
# be equal in the focal groups

set.seed(12345)
a &lt;- matrix(abs(rnorm(15,1,.3)), ncol=1)
d &lt;- matrix(rnorm(15,0,.7),ncol=1)
itemtype &lt;- rep('2PL', nrow(a))
N &lt;- 1000
dataset1 &lt;- simdata(a, d, N, itemtype)
dataset2 &lt;- simdata(a, d, N, itemtype, mu = .1, sigma = matrix(1.5))
dataset3 &lt;- simdata(a, d, N, itemtype, mu = .1, sigma = matrix(1.5))
dat &lt;- rbind(dataset1, dataset2, dataset3)
group &lt;- rep(c('D1', 'D2', 'D3'), each=N)

# marginal information
itemstats(dat)

# conditional information
itemstats(dat, group=group)

model &lt;- 'F1 = 1-15
          FREE[D2, D3] = (GROUP, MEAN_1), (GROUP, COV_11)
          CONSTRAINB[D2,D3] = (GROUP, MEAN_1), (GROUP, COV_11)'

mod &lt;- multipleGroup(dat, model, group = group, invariance = colnames(dat))
coef(mod, simplify=TRUE)



#############
# multiple factors

a &lt;- matrix(c(abs(rnorm(5,1,.3)), rep(0,15),abs(rnorm(5,1,.3)),
     rep(0,15),abs(rnorm(5,1,.3))), 15, 3)
d &lt;- matrix(rnorm(15,0,.7),ncol=1)
mu &lt;- c(-.4, -.7, .1)
sigma &lt;- matrix(c(1.21,.297,1.232,.297,.81,.252,1.232,.252,1.96),3,3)
itemtype &lt;- rep('2PL', nrow(a))
N &lt;- 1000
dataset1 &lt;- simdata(a, d, N, itemtype)
dataset2 &lt;- simdata(a, d, N, itemtype, mu = mu, sigma = sigma)
dat &lt;- rbind(dataset1, dataset2)
group &lt;- c(rep('D1', N), rep('D2', N))

# group models
model &lt;- '
   F1 = 1-5
   F2 = 6-10
   F3 = 11-15'

# define mirt cluster to use parallel architecture
if(interactive()) mirtCluster()

# EM approach (not as accurate with 3 factors, but generally good for quick model comparisons)
mod_configural &lt;- multipleGroup(dat, model, group = group) #completely separate analyses
mod_metric &lt;- multipleGroup(dat, model, group = group, invariance=c('slopes')) #equal slopes
mod_fullconstrain &lt;- multipleGroup(dat, model, group = group, #equal means, slopes, intercepts
                             invariance=c('slopes', 'intercepts'))

anova(mod_metric, mod_configural)
anova(mod_fullconstrain, mod_metric)

# same as above, but with MHRM (generally  more accurate with 3+ factors, but slower)
mod_configural &lt;- multipleGroup(dat, model, group = group, method = 'MHRM')
mod_metric &lt;- multipleGroup(dat, model, group = group, invariance=c('slopes'), method = 'MHRM')
mod_fullconstrain &lt;- multipleGroup(dat, model, group = group, method = 'MHRM',
                             invariance=c('slopes', 'intercepts'))

anova(mod_metric, mod_configural)
anova(mod_fullconstrain, mod_metric)

############
# polytomous item example
set.seed(12345)
a &lt;- matrix(abs(rnorm(15,1,.3)), ncol=1)
d &lt;- matrix(rnorm(15,0,.7),ncol=1)
d &lt;- cbind(d, d-1, d-2)
itemtype &lt;- rep('graded', nrow(a))
N &lt;- 1000
dataset1 &lt;- simdata(a, d, N, itemtype)
dataset2 &lt;- simdata(a, d, N, itemtype, mu = .1, sigma = matrix(1.5))
dat &lt;- rbind(dataset1, dataset2)
group &lt;- c(rep('D1', N), rep('D2', N))
model &lt;- 'F1 = 1-15'

mod_configural &lt;- multipleGroup(dat, model, group = group)
plot(mod_configural)
plot(mod_configural, type = 'SE')
itemplot(mod_configural, 1)
itemplot(mod_configural, 1, type = 'info')
plot(mod_configural, type = 'trace') # messy, score function typically better
plot(mod_configural, type = 'itemscore')

fs &lt;- fscores(mod_configural, full.scores = FALSE)
head(fs[["D1"]])
fscores(mod_configural, method = 'EAPsum', full.scores = FALSE)

# constrain slopes within each group to be equal (but not across groups)
model2 &lt;- 'F1 = 1-15
           CONSTRAIN = (1-15, a1)'
mod_configural2 &lt;- multipleGroup(dat, model2, group = group)
plot(mod_configural2, type = 'SE')
plot(mod_configural2, type = 'RE')
itemplot(mod_configural2, 10)

############
## empirical histogram example (normal and bimodal groups)
set.seed(1234)
a &lt;- matrix(rlnorm(50, .2, .2))
d &lt;- matrix(rnorm(50))
ThetaNormal &lt;- matrix(rnorm(2000))
ThetaBimodal &lt;- scale(matrix(c(rnorm(1000, -2), rnorm(1000,2)))) #bimodal
Theta &lt;- rbind(ThetaNormal, ThetaBimodal)
dat &lt;- simdata(a, d, 4000, itemtype = '2PL', Theta=Theta)
group &lt;- rep(c('G1', 'G2'), each=2000)

EH &lt;- multipleGroup(dat, 1, group=group, dentype="empiricalhist", invariance = colnames(dat))
coef(EH, simplify=TRUE)
plot(EH, type = 'empiricalhist', npts = 60)

# DIF test for item 1
EH1 &lt;- multipleGroup(dat, 1, group=group, dentype="empiricalhist", invariance = colnames(dat)[-1])
anova(EH, EH1)

#--------------------------------
# Mixture model (no prior group variable specified)

set.seed(12345)
nitems &lt;- 20
a1 &lt;- matrix(.75, ncol=1, nrow=nitems)
a2 &lt;- matrix(1.25, ncol=1, nrow=nitems)
d1 &lt;- matrix(rnorm(nitems,0,1),ncol=1)
d2 &lt;- matrix(rnorm(nitems,0,1),ncol=1)
itemtype &lt;- rep('2PL', nrow(a1))
N1 &lt;- 500
N2 &lt;- N1*2 # second class twice as large

dataset1 &lt;- simdata(a1, d1, N1, itemtype)
dataset2 &lt;- simdata(a2, d2, N2, itemtype)
dat &lt;- rbind(dataset1, dataset2)
# group &lt;- c(rep('D1', N1), rep('D2', N2))

# Mixture Rasch model (Rost, 1990)
models &lt;- 'F1 = 1-20
           CONSTRAIN = (1-20, a1)'
mod_mix &lt;- multipleGroup(dat, models, dentype = 'mixture-2', GenRandomPars = TRUE)
coef(mod_mix, simplify=TRUE)
summary(mod_mix)
plot(mod_mix)
plot(mod_mix, type = 'trace')
itemplot(mod_mix, 1, type = 'info')

head(fscores(mod_mix)) # theta estimates
head(fscores(mod_mix, method = 'classify')) # classification probability
itemfit(mod_mix)

# Mixture 2PL model
mod_mix2 &lt;- multipleGroup(dat, 1, dentype = 'mixture-2', GenRandomPars = TRUE)
anova(mod_mix, mod_mix2)
coef(mod_mix2, simplify=TRUE)
itemfit(mod_mix2)

# Compare to single group
mod &lt;- mirt(dat)
anova(mod, mod_mix2)

########################################
# Zero-inflated 2PL IRT model

n &lt;- 1000
nitems &lt;- 20

a &lt;- rep(2, nitems)
d &lt;- rep(c(-2,-1,0,1,2), each=nitems/5)
zi_p &lt;- 0.2 # Proportion of people in zero class

theta &lt;- rnorm(n, 0, 1)
zeros &lt;- matrix(0, n*zi_p, nitems)
nonzeros &lt;- simdata(a, d, n*(1-zi_p), itemtype = '2PL',
                   Theta = as.matrix(theta[1:(n*(1-zi_p))]))
data &lt;- rbind(nonzeros, zeros)

# define class with extreme theta but fixed item parameters
zi2PL &lt;- "F = 1-20
          START [MIXTURE_1] = (GROUP, MEAN_1, -100), (GROUP, COV_11, .00001),
                              (1-20, a1, 1.0), (1-20, d, 0)
          FIXED [MIXTURE_1] = (GROUP, MEAN_1), (GROUP, COV_11),
                              (1-20, a1), (1-20, d)"

# define custom Theta integration grid that contains extreme theta + normal grid
technical &lt;- list(customTheta = matrix(c(-100, seq(-6,6,length.out=61))))

# fit ZIM-IRT
zi2PL.fit &lt;- multipleGroup(data, zi2PL, dentype = 'mixture-2', technical=technical)
coef(zi2PL.fit, simplify=TRUE)


## End(Not run)
</code></pre>


</div>