<div class="container">

<table style="width: 100%;"><tr>
<td>missSBM_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>An R6 class to represent an SBM fit with missing data</h2>

<h3>Description</h3>

<p>The function <code>estimateMissSBM()</code> fits a collection of SBM for varying number of block.
Each fitted SBM is an instance of an R6 object with class <code>missSBM_fit</code>, described here.
</p>
<p>Fields are accessed via active binding and cannot be changed by the user.
</p>
<p>This class comes with a set of R6 methods, some of them being useful for the user and exported
as S3 methods. See the documentation for  <code>show()</code>, <code>print()</code>, <code>fitted()</code>, <code>predict()</code>, <code>plot()</code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>fittedSBM</code></dt>
<dd>
<p>the fitted SBM with class <code>SimpleSBM_fit_noCov</code>, <code>SimpleSBM_fit_withCov</code> or
<code>SimpleSBM_fit_MNAR</code> inheriting from class <code>sbm::SimpleSBM_fit</code></p>
</dd>
<dt><code>fittedSampling</code></dt>
<dd>
<p>the fitted sampling, inheriting from class <code>networkSampling</code> and corresponding fits</p>
</dd>
<dt><code>imputedNetwork</code></dt>
<dd>
<p>The network data as a matrix with NAs values imputed with the current model</p>
</dd>
<dt><code>monitoring</code></dt>
<dd>
<p>a list carrying information about the optimization process</p>
</dd>
<dt><code>entropyImputed</code></dt>
<dd>
<p>the entropy of the distribution of the imputed dyads</p>
</dd>
<dt><code>entropy</code></dt>
<dd>
<p>the entropy due to the distribution of the imputed dyads and of the clustering</p>
</dd>
<dt><code>vExpec</code></dt>
<dd>
<p>double: variational expectation of the complete log-likelihood</p>
</dd>
<dt><code>penalty</code></dt>
<dd>
<p>double, value of the penalty term in ICL</p>
</dd>
<dt><code>loglik</code></dt>
<dd>
<p>double: approximation of the log-likelihood (variational lower bound) reached</p>
</dd>
<dt><code>ICL</code></dt>
<dd>
<p>double: value of the integrated classification log-likelihood</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-missSBM_fit-new"><code>missSBM_fit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-missSBM_fit-doVEM"><code>missSBM_fit$doVEM()</code></a>
</p>
</li>
<li> <p><a href="#method-missSBM_fit-show"><code>missSBM_fit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-missSBM_fit-print"><code>missSBM_fit$print()</code></a>
</p>
</li>
<li> <p><a href="#method-missSBM_fit-clone"><code>missSBM_fit$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-missSBM_fit-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>constructor for networkSampling
</p>


<h5>Usage</h5>

<div class="r"><pre>missSBM_fit$new(partlyObservedNet, netSampling, clusterInit, useCov = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>partlyObservedNet</code></dt>
<dd>
<p>An object with class <code>partlyObservedNetwork</code>.</p>
</dd>
<dt><code>netSampling</code></dt>
<dd>
<p>The sampling design for the modelling of missing data: MAR designs ("dyad", "node") and MNAR designs ("double-standard", "block-dyad", "block-node" ,"degree")</p>
</dd>
<dt><code>clusterInit</code></dt>
<dd>
<p>Initial clustering: a vector with size <code>ncol(adjacencyMatrix)</code>, providing a user-defined clustering. The number of blocks is deduced from the number of levels in with <code>clusterInit</code>.</p>
</dd>
<dt><code>useCov</code></dt>
<dd>
<p>logical. If covariates are present in partlyObservedNet, should they be used for the inference or of the network sampling design, or just for the SBM inference? default is TRUE.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-missSBM_fit-doVEM"></a>



<h4>Method <code>doVEM()</code>
</h4>

<p>a method to perform inference of the current missSBM fit with variational EM
</p>


<h5>Usage</h5>

<div class="r"><pre>missSBM_fit$doVEM(
  control = list(threshold = 0.01, maxIter = 100, fixPointIter = 3, trace = TRUE)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>control</code></dt>
<dd>
<p>a list of parameters controlling the variational EM algorithm. See details of function <code>estimateMissSBM()</code></p>
</dd>
</dl>
</div>


<hr>
<a id="method-missSBM_fit-show"></a>



<h4>Method <code>show()</code>
</h4>

<p>show method for missSBM_fit
</p>


<h5>Usage</h5>

<div class="r"><pre>missSBM_fit$show()</pre></div>


<hr>
<a id="method-missSBM_fit-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>User friendly print method
</p>


<h5>Usage</h5>

<div class="r"><pre>missSBM_fit$print()</pre></div>


<hr>
<a id="method-missSBM_fit-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>missSBM_fit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">## Sample 75% of dyads in  French political Blogosphere's network data
adjMatrix &lt;- missSBM::frenchblog2007 %&gt;%
  igraph::as_adj (sparse = FALSE) %&gt;%
  missSBM::observeNetwork(sampling = "dyad", parameters = 0.75)
collection &lt;- estimateMissSBM(adjMatrix, 3:5, sampling = "dyad")
my_missSBM_fit &lt;- collection$bestModel
class(my_missSBM_fit)
plot(my_missSBM_fit, "imputed")

</code></pre>


</div>