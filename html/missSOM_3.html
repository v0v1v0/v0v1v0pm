<div class="container">

<table style="width: 100%;"><tr>
<td>imputeSOM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Self-Organizing Maps with Built-in Missing Data Imputation.</h2>

<h3>Description</h3>

<p><code>imputeSOM</code> is an extension of the online algorithm of the 'kohonen' package where missing data are imputed during the algorithm. 
All missing values are first imputed with initial values such as the mean of the observed variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">imputeSOM(
  data,
  grid = somgrid(),
  rlen = 100,
  alpha = c(0.05, 0.01),
  radius = quantile(nhbrdist, 2/3),
  maxNA.fraction = 1,
  keep.data = TRUE,
  dist.fcts = NULL,
  init
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a <code>matrix</code> or <code>data.frame</code> with continuous variables containing the observations to be mapped on the grid by the kohonen algorithm, even if there are incomplete.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>a grid for the codebook vectors: see <code>somgrid</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rlen</code></td>
<td>
<p>the number of times the complete data set will be presented to the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>learning rate, a vector of two numbers indicating the amount of change. Default is to decline linearly from 0.05 to 0.01 over <code>rlen</code> updates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>the radius of the neighbourhood, either given as a single number or a vector (start, stop). If it is given as a single 
number the radius will change linearly from <code>radius</code> to zero; as soon as the neighbourhood gets smaller than one only the winning unit 
will be updated. Note that the default before version 3.0 was to run from <code>radius</code> to <code>-radius</code>. If nothing is supplied, the 
default is to start with a value that covers 2/3 of all unit-to-unit distances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxNA.fraction</code></td>
<td>
<p>the maximal fraction of values that may be NA to prevent the column to be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.data</code></td>
<td>
<p>if TRUE, return original data and mapping information. If FALSE, only return the trained map (in essence the 
codebook vectors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.fcts</code></td>
<td>
<p>distance function to be used for the data. Admissable values 
currently are "sumofsquares", "euclidean" and "manhattan. Default is to use "sumofsquares".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>a <code>matrix</code> or <code>data.frame</code> corresponding to the initial values for the codebook vectors. 
It should have the same number of variables (columns) as the data. 
The number of rows corresponding to the number of units in the map.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class "missSOM" with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data matrix, only returned if <code>keep.data == TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ximp</code></td>
<td>
<p>Imputed data matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit.classif</code></td>
<td>
<p>Winning units for data objects, only returned if <code>keep.data == TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distances</code></td>
<td>
<p>Distances of objects to their corresponding winning unit, only returned if <code>keep.data == TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>The grid, an object of class <code>somgrid</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>codes</code></td>
<td>
<p>A list of matrices containing codebook vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha, radius</code></td>
<td>
<p>Input arguments presented to the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxNA.fraction</code></td>
<td>
<p>The maximal fraction of values that may be NA to prevent the column to be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.fcts</code></td>
<td>
<p>The distance function used for the data.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p>somgrid, <code>plot.missSOM</code>, <code>map.missSOM</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(wines)

## Data with no missing values 
som.wines &lt;- imputeSOM(scale(wines), grid = somgrid(5, 5, "hexagonal"))
summary(som.wines)
print(dim(som.wines$data))

## Data with missing values 
X &lt;- scale(wines)
missing_obs &lt;- sample(1:nrow(wines), 10, replace = FALSE)
X[missing_obs, 1:2] &lt;- NaN
som.wines &lt;- imputeSOM(X, grid = somgrid(5, 5, "hexagonal"))
summary(som.wines)
print(dim(som.wines$ximp))
print(sum(is.na(som.wines$ximp)))

</code></pre>


</div>