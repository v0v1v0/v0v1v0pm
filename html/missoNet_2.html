<div class="container">

<table style="width: 100%;"><tr>
<td>cv.missoNet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation for missoNet</h2>

<h3>Description</h3>

<p>This function performs k-fold cross-validation for ‘<code>missoNet</code>’. The regularization path is computed 
for all possible combinations of values given in the two regularization parameter sequences, namely <code class="reqn">\lambda_B</code> and <code class="reqn">\lambda_\Theta</code>. 
‘<code>cv.missoNet</code>’ will select the most suitable model among all cross-validated fits along the path.
See the details of ‘<code>missoNet</code>’ for the model definition. 
To help users, the ‘<code>cv.missoNet</code>’ function is designed to automatically determine the likely ranges 
of the regularization parameters over which the cross-validation searches.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.missoNet(
  X,
  Y,
  kfold = 5,
  rho = NULL,
  lambda.Beta = NULL,
  lambda.Theta = NULL,
  lamBeta.min.ratio = NULL,
  lamTheta.min.ratio = NULL,
  n.lamBeta = NULL,
  n.lamTheta = NULL,
  lamBeta.scale.factor = 1,
  lamTheta.scale.factor = 1,
  Beta.maxit = 1000,
  Beta.thr = 1e-04,
  eta = 0.8,
  Theta.maxit = 1000,
  Theta.thr = 1e-04,
  eps = 1e-08,
  penalize.diagonal = TRUE,
  diag.penalty.factor = NULL,
  standardize = TRUE,
  standardize.response = TRUE,
  fit.1se = FALSE,
  fit.relax = FALSE,
  permute = TRUE,
  with.seed = NULL,
  parallel = FALSE,
  cl = NULL,
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Numeric predictor matrix (<code class="reqn">n\times p</code>): columns correspond to predictor variables and rows correspond to samples. Missing values are not allowed. There is no need for centering or scaling of the variables. <code>'X'</code> should not include a column of ones for an intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Numeric response matrix (<code class="reqn">n\times q</code>): columns correspond to response variables and rows correspond to samples. Missing values should be coded as either <code>'NA'</code>s or <code>'NaN'</code>s. There is no need for centering or scaling of the variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kfold</code></td>
<td>
<p>Number of folds for cross-validation – the default is <code>'5'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>(Optional) A scalar or a numeric vector of length <code class="reqn">q</code>: the elements are user-supplied probabilities of missingness for the response variables. The default is <code>'rho = NULL'</code> and the program will compute the empirical missing rates for each of the columns of <code>'Y'</code> and use them as the working missing probabilities. The default setting should suffice in most cases; misspecified missing probabilities would introduce biases into the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.Beta</code></td>
<td>
<p>(Optional) Numeric vector: a user-supplied sequence of non-negative values for {<code class="reqn">\lambda_B</code>} penalizing the elements of the coefficient matrix <code class="reqn">\mathbf{B}</code> among which the cross-validation procedure searches. The default is <code>'lambda.Beta = NULL'</code>, in which case the program computes an appropriate range of <code class="reqn">\lambda_B</code> values using <code>'n.lamBeta'</code> and <code>'lamBeta.min.ratio'</code>. Supplying a vector overrides this default. Note that the supplied sequence will be automatically arranged, internally, in a descending order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.Theta</code></td>
<td>
<p>(Optional) Numeric vector: a user-supplied sequence of non-negative values for {<code class="reqn">\lambda_\Theta</code>} penalizing the (off-diagonal) elements of the precision matrix <code class="reqn">\mathbf{\Theta}</code> among which the cross-validation procedure searches. The default is <code>'lambda.Theta = NULL'</code>, in which case the program computes an appropriate range of <code class="reqn">\lambda_\Theta</code> values using <code>'n.lamTheta'</code> and <code>'lamTheta.min.ratio'</code>. Supplying a vector overrides this default. Note that the supplied sequence will be automatically arranged, internally, in a descending order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lamBeta.min.ratio</code></td>
<td>
<p>The smallest value of <code class="reqn">\lambda_B</code> is calculated as the data-derived <code class="reqn">\mathrm{max}(\lambda_B)</code> multiplied by <code>'lamBeta.min.ratio'</code>. The default depends on the sample size, <code class="reqn">n</code>, relative to the number of predictors, <code class="reqn">p</code>. If <code class="reqn">n &gt; p</code>, the default is <code>'1.0E-4'</code>, otherwise it is <code>'1.0E-3'</code>. A very small value of <code>'lamBeta.min.ratio'</code> may significantly increase runtime and lead to a saturated fit in the <code class="reqn">n \leq p</code> case. This is only needed when <code>'lambda.Beta = NULL'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lamTheta.min.ratio</code></td>
<td>
<p>The smallest value of <code class="reqn">\lambda_\Theta</code> is calculated as the data-derived <code class="reqn">\mathrm{max}(\lambda_\Theta)</code> multiplied by <code>'lamTheta.min.ratio'</code>. The default depends on the sample size, <code class="reqn">n</code>, relative to the number of responses, <code class="reqn">q</code>. If <code class="reqn">n &gt; q</code>, the default is <code>'1.0E-4'</code>, otherwise it is <code>'1.0E-3'</code>. A very small value of <code>'lamTheta.min.ratio'</code> may significantly increase runtime and lead to a saturated fit in the <code class="reqn">n \leq q</code> case. This is only needed when <code>'lambda.Theta = NULL'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.lamBeta</code></td>
<td>
<p>The number of <code class="reqn">\lambda_B</code> values. If <code class="reqn">n &gt; p</code>, the default is <code>'40'</code>, otherwise it is <code>'30'</code>. Avoid supplying an excessively large number since the program will fit (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) models in total for each fold of the cross-validation. Typically we suggest <code>'n.lamBeta' = -log10('lamBeta.min.ratio') * c</code>, where <code>c</code> <code class="reqn">\in</code> [<code>10</code>, <code>20</code>]. This is only needed when <code>'lambda.Beta = NULL'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.lamTheta</code></td>
<td>
<p>The number of <code class="reqn">\lambda_\Theta</code> values. If <code class="reqn">n &gt; q</code>, the default is <code>'40'</code>, otherwise it is <code>'30'</code>. Avoid supplying an excessively large number since the program will fit (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) models in total for each fold of the cross-validation. Typically we suggest <code>'n.lamTheta' = -log10('lamTheta.min.ratio') * c</code>, where <code>c</code> <code class="reqn">\in</code> [<code>10</code>, <code>20</code>]. This is only needed when <code>'lambda.Theta = NULL'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lamBeta.scale.factor</code></td>
<td>
<p>A positive multiplication factor for scaling the entire <code class="reqn">\lambda_B</code> sequence; the default is <code>'1'</code>. A typical usage is when the magnitudes of the auto-computed <code class="reqn">\lambda_B</code> values are inappropriate. For example, this factor would be needed if the optimal value of <code class="reqn">\lambda_B</code> selected by the cross-validation (i.e. <code class="reqn">{\lambda_B}_\mathrm{min}</code> with the minimum cross-validated error) approaches either boundary of the search range. This is only needed when <code>'lambda.Beta = NULL'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lamTheta.scale.factor</code></td>
<td>
<p>A positive multiplication factor for scaling the entire <code class="reqn">\lambda_\Theta</code> sequence; the default is <code>'1'</code>. A typical usage is when the magnitudes of the auto-computed <code class="reqn">\lambda_\Theta</code> values are inappropriate. For example, this factor would be needed if the optimal value of <code class="reqn">\lambda_\Theta</code> selected by the cross-validation (i.e. <code class="reqn">{\lambda_\Theta}_\mathrm{min}</code> with the minimum cross-validated error) approaches either boundary of the search range. This is only needed when <code>'lambda.Theta = NULL'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Beta.maxit</code></td>
<td>
<p>The maximum number of iterations of the fast iterative shrinkage-thresholding algorithm (FISTA) for updating <code class="reqn">\hat{\mathbf{B}}</code>. The default is <code>'Beta.maxit = 1000'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Beta.thr</code></td>
<td>
<p>The convergence threshold of the FISTA algorithm for updating <code class="reqn">\hat{\mathbf{B}}</code>; the default is <code>'Beta.thr = 1.0E-4'</code>. Iterations stop when the absolute parameter change is less than (<code>'Beta.thr'</code> <code>*</code> <code>sum(abs(</code><code class="reqn">\hat{\mathbf{B}}</code><code>))</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>The backtracking line search shrinkage factor; the default is <code>'eta = 0.8'</code>. Most users will be able to use the default value, some experienced users may want to tune <code>'eta'</code> according to the properties of a specific dataset for a faster convergence of the FISTA algorithm. Note that <code>'eta'</code> must be in (0, 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Theta.maxit</code></td>
<td>
<p>The maximum number of iterations of the ‘<code>glasso</code>’ algorithm for updating <code class="reqn">\hat{\mathbf{\Theta}}</code>. The default is <code>'Theta.maxit = 1000'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Theta.thr</code></td>
<td>
<p>The convergence threshold of the ‘<code>glasso</code>’ algorithm for updating <code class="reqn">\hat{\mathbf{\Theta}}</code>; the default is <code>'Theta.thr = 1.0E-4'</code>. Iterations stop when the average absolute parameter change is less than (<code>'Theta.thr'</code> <code>*</code> <code>ave(abs(offdiag(</code><code class="reqn">\hat{\mathbf{\Sigma}}</code><code>)))</code>), where <code class="reqn">\hat{\mathbf{\Sigma}}</code> denotes the empirical working covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>A numeric tolerance level for the L1 projection of the empirical covariance matrix; the default is <code>'eps = 1.0E-8'</code>. The empirical covariance matrix will be projected onto a L1 ball to have <code>min(eigen(</code><code class="reqn">\hat{\mathbf{\Sigma}}</code><code>)$value)</code> == <code>'eps'</code>, if any of the eigenvalues is less than the specified tolerance. Most users will be able to use the default value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalize.diagonal</code></td>
<td>
<p>Logical: should the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> be penalized? The default is <code>'TRUE'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag.penalty.factor</code></td>
<td>
<p>Numeric: a separate penalty multiplication factor for the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> when <code>'penalize.diagonal = TRUE'</code>. <code class="reqn">\lambda_\Theta</code> is multiplied by this number to allow a differential shrinkage of the diagonal elements. The default is <code>'NULL'</code> and the program will guess a value based on an initial estimate of <code class="reqn">\mathbf{\Theta}</code>. This factor could be <code>'0'</code> for no shrinkage (equivalent to <code>'penalize.diagonal = FALSE'</code>) or <code>'1'</code> for an equal shrinkage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical: should the columns of <code>'X'</code> be standardized so each has unit variance? The default is <code>'TRUE'</code>. The estimated results will always be returned on the original scale. ‘<code>cv.missoNet</code>’ computes appropriate <code class="reqn">\lambda</code> sequences relying on standardization, if <code>'X'</code> has been standardized prior to fitting the model, you might not wish to standardize it inside the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize.response</code></td>
<td>
<p>Logical: should the columns of <code>'Y'</code> be standardized so each has unit variance? The default is <code>'TRUE'</code>. The estimated results will always be returned on the original scale. ‘<code>cv.missoNet</code>’ computes appropriate <code class="reqn">\lambda</code> sequences relying on standardization, if <code>'Y'</code> has been standardized prior to fitting the model, you might not wish to standardize it inside the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.1se</code></td>
<td>
<p>Logical: the default is <code>'FALSE'</code>. If <code>'TRUE'</code>, two additional models will be fitted with the largest values of <code class="reqn">\lambda_B</code> and <code class="reqn">\lambda_\Theta</code> respectively at which the cross-validated error is within one standard error of the minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.relax</code></td>
<td>
<p>Logical: the default is <code>'FALSE'</code>. If <code>'TRUE'</code>, the program will re-estimate the edges in the active set (i.e. nonzero off-diagonal elements) of the network structure <code class="reqn">\hat{\mathbf{\Theta}}</code> without penalization (<code class="reqn">\lambda_\Theta=0</code>). This debiased estimate of <code class="reqn">\mathbf{\Theta}</code> could be useful for some interdependency analyses. WARNING: there may be convergence issues if the empirical covariance matrix is not of full rank (e.g. <code class="reqn">n &lt; q)</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permute</code></td>
<td>
<p>Logical: should the subject indices for the cross-validation be permuted? The default is <code>'TRUE'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.seed</code></td>
<td>
<p>A random number seed for the permutation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Logical: the default is <code>'FALSE'</code>. If <code>'TRUE'</code>, the program uses clusters to compute the cross-validation folds in parallel. Must register parallel clusters beforehand, see examples below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>A cluster object created by ‘<code>parallel::makeCluster</code>’ for parallel evaluations. This is only needed when <code>'parallel = TRUE'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Value of <code>'0'</code>, <code>'1'</code> or <code>'2'</code>. <code>'verbose = 0'</code> – silent; <code>'verbose = 1'</code> (the default) – limited tracing with progress bars; <code>'verbose = 2'</code> – detailed tracing. Note that displaying the progress bars slightly increases the computation overhead compared to the silent mode. The detailed tracing should be used for monitoring progress only when the program runs extremely slowly, and it is not supported under <code>'parallel = TRUE'</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The ‘<code>cv.missoNet</code>’ function fits ‘<code>missoNet</code>’ models (<code>'kfold'</code> <code>*</code> <code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) 
times in the whole cross-validation process. That is, for the <code class="reqn">k</code>th-fold (<code class="reqn">k=1,...,K</code>) computation, the models are fitted at each of 
the all (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) possible combinations of the regularization parameters (<code class="reqn">\lambda_B</code>, <code class="reqn">\lambda_\Theta</code>), with the <code class="reqn">k</code>th 
fold of the training data omitted. The errors are accumulated, and the averaged errors as well as the standard deviations are computed over all folds. 
Note that the results of ‘<code>cv.missoNet</code>’ are random, since the samples are randomly split into k-folds. Users can eliminate this randomness 
by setting <code>'permute = FALSE'</code>, or by explicitly assigning a seed to the permutation of samples.
</p>
<p>A user-supplied sequence for {<code class="reqn">\lambda_B</code>} and/or {<code class="reqn">\lambda_\Theta</code>} is permitted, 
otherwise the program computes an appropriate range of values for the regularization parameters using other control arguments.
Note that ‘<code>cv.missoNet</code>’ standardizes <code>'X'</code> and <code>'Y'</code> to have unit variances before computing its <code class="reqn">\lambda</code> 
sequences (and then unstandardizes the resulting coefficients); if you wish to reproduce/compare results with those of other softwares, 
it is best to supply pre-standardized <code>'X'</code> and <code>'Y'</code>. If the algorithm is running slowly, track its progress with <code>'verbose = 2'</code>. 
In most cases, choosing a sparser grid for the regularization parameters (e.g. smaller <code>'n.lamBeta'</code> and/or <code>'n.lamTheta'</code>) or setting <code>'Beta.thr = 1.0E-3'</code> (or even bigger) 
allows the algorithm to make faster progress.
</p>
<p>After cross-validation, the regression coefficient matrix <code class="reqn">\mathbf{B}</code> and the precision matrix <code class="reqn">\mathbf{\Theta}</code> can be 
estimated at three special <code class="reqn">\lambda</code> pairs, by reapplying ‘<code>missoNet</code>’ to the entire training dataset:
</p>

<ol>
<li>
<p> "<code>lambda.min</code>" := (<code class="reqn">{\lambda_B}_\mathrm{min}, {\lambda_\Theta}_\mathrm{min}</code>), at which the minimum mean cross-validated error is achieved;
</p>
</li>
<li>
<p> "<code>lambda.1se.Beta</code>" := (<code class="reqn">{\lambda_B}_\mathrm{1se}, {\lambda_\Theta}_\mathrm{min}</code>), where <code class="reqn">{\lambda_B}_\mathrm{1se}</code> is the largest <code class="reqn">\lambda_B</code> at which the mean cross-validated error is within one standard error of the minimum;
</p>
</li>
<li>
<p> "<code>lambda.1se.Theta</code>" := (<code class="reqn">{\lambda_B}_\mathrm{min}, {\lambda_\Theta}_\mathrm{1se}</code>), where <code class="reqn">{\lambda_\Theta}_\mathrm{1se}</code> is the largest <code class="reqn">\lambda_\Theta</code> at which the mean cross-validated error is within one standard error of the minimum.
</p>
</li>
</ol>
<p>The corresponding estimates, along with the <code class="reqn">\lambda</code> values, are stored in three separate lists inside the returned object: 
<code>'est.min'</code>, <code>'est.1se.B'</code> and <code>'est.1se.Tht'</code> (<code>'est.1se.B'</code> and <code>'est.1se.Tht'</code> are <code>'NULL'</code> 
unless the argument <code>'fit.1se = TRUE'</code> when calling ‘<code>cv.missoNet</code>’).
</p>
<p>The ‘<code>cv.missoNet</code>’ function returns an R object of S3 class <code>'cv.missoNet'</code> for which there are a set of accessory functions available.
The plotting function ‘<code>plot.cv.missoNet</code>’ can be used to graphically identify the optimal pair of the regularization parameters, 
and the prediction function ‘<code>predict.cv.missoNet</code>’ can be used to make predictions of response values given new input <code>'X'</code>. 
See the vignette for examples.
</p>


<h3>Value</h3>

<p>This function returns a <code>'cv.missoNet'</code> object containing a named <code>'list'</code> with all the ingredients of the cross-validated fit:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>est.min</code></td>
<td>
<p>A <code>'list'</code> of results estimated at "<code>lambda.min</code>" := (<code class="reqn">{\lambda_B}_\mathrm{min}, {\lambda_\Theta}_\mathrm{min}</code>) that gives the minimum mean cross-validated error. It consists of the following components:
</p>

<ul>
<li> <p><code>Beta</code>: the penalized estimate of the regression coefficient matrix <code class="reqn">\hat{\mathbf{B}}</code> (<code class="reqn">p\times q</code>).
</p>
</li>
<li> <p><code>Theta</code>: the penalized estimate of the precision matrix <code class="reqn">\hat{\mathbf{\Theta}}</code> (<code class="reqn">q\times q</code>).
</p>
</li>
<li> <p><code>mu</code>: a vector of length <code class="reqn">q</code> storing the model intercept <code class="reqn">\hat{\mu}</code>.
</p>
</li>
<li> <p><code>lambda.Beta</code>: the value of <code class="reqn">\lambda_B</code> (i.e. <code class="reqn">{\lambda_B}_\mathrm{min}</code>) used to fit the model.
</p>
</li>
<li> <p><code>lambda.Theta</code>: the value of <code class="reqn">\lambda_\Theta</code> (i.e. <code class="reqn">{\lambda_\Theta}_\mathrm{min}</code>) used to fit the model.
</p>
</li>
<li> <p><code>relax.net</code>: the relaxed (debiased) estimate of the conditional network structure <code class="reqn">\hat{\mathbf{\Theta}}_\mathrm{rlx}</code> (<code class="reqn">q\times q</code>) if <code>'fit.relax = TRUE'</code> when calling ‘<code>cv.missoNet</code>’.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.1se.B</code></td>
<td>
<p>A <code>'list'</code> of results estimated at "<code>lambda.1se.Beta</code>" := (<code class="reqn">{\lambda_B}_\mathrm{1se}, {\lambda_\Theta}_\mathrm{min}</code>) if <code>'fit.1se = TRUE'</code> when calling ‘<code>cv.missoNet</code>’. "<code>lambda.1se.Beta</code>" refers to the largest <code class="reqn">\lambda_B</code> at which the mean cross-validated error is within one standard error of the minimum, by fixing <code class="reqn">\lambda_\Theta</code> at <code class="reqn">{\lambda_\Theta}_\mathrm{min}</code>. This <code>'list'</code> consists of the same components as <code>'est.min'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.1se.Tht</code></td>
<td>
<p>A <code>'list'</code> of results estimated at "<code>lambda.1se.Theta</code>" := (<code class="reqn">{\lambda_B}_\mathrm{min}, {\lambda_\Theta}_\mathrm{1se}</code>) if <code>'fit.1se = TRUE'</code> when calling ‘<code>cv.missoNet</code>’. "<code>lambda.1se.Theta</code>" refers to the largest <code class="reqn">\lambda_\Theta</code> at which the mean cross-validated error is within one standard error of the minimum, by fixing <code class="reqn">\lambda_B</code> at <code class="reqn">{\lambda_B}_\mathrm{min}</code>. This <code>'list'</code> consists of the same components as <code>'est.min'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>A vector of length <code class="reqn">q</code> storing the working missing probabilities for the <code class="reqn">q</code> response variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fold.index</code></td>
<td>
<p>The subject indices identifying which fold each observation is in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.Beta.vec</code></td>
<td>
<p>A flattened vector of length (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) storing the <code class="reqn">\lambda_B</code> values along the regularization path. More specifically, <code>'lambda.Beta.vec' = rep('lambda.Beta', each = 'n.lamTheta')</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.Theta.vec</code></td>
<td>
<p>A flattened vector of length (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) storing the <code class="reqn">\lambda_\Theta</code> values along the regularization path. More specifically, <code>'lambda.Theta.vec' = rep('lambda.Theta', times = 'n.lamBeta')</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvm</code></td>
<td>
<p>A flattened vector of length (<code>'n.lamBeta'</code> <code>*</code> <code>'n.lamTheta'</code>) storing the (standardized) mean cross-validated errors along the regularization path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvup</code></td>
<td>
<p>Upper cross-validated errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvlo</code></td>
<td>
<p>Lower cross-validated errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalize.diagonal</code></td>
<td>
<p>Logical: whether the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> were penalized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag.penalty.factor</code></td>
<td>
<p>The additional penalty multiplication factor for the diagonal elements of <code class="reqn">\mathbf{\Theta}</code> when <code>'penalize.diagonal'</code> was returned as <code>'TRUE'</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Yixiao Zeng <a href="mailto:yixiao.zeng@mail.mcgill.ca">yixiao.zeng@mail.mcgill.ca</a>, Celia M.T. Greenwood and Archer Yi Yang.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simulate a dataset with response values missing completely at random (MCAR), 
## the overall missing rate is around 10%.
set.seed(123)  # reproducibility
sim.dat &lt;- generateData(n = 300, p = 50, q = 20, rho = 0.1, missing.type = "MCAR")
tr &lt;- 1:240  # training set indices
tst &lt;- 241:300  # test set indices
X.tr &lt;- sim.dat$X[tr, ]  # predictor matrix
Y.tr &lt;- sim.dat$Z[tr, ]  # corrupted response matrix


## Perform a five-fold cross-validation WITH specified 'lambda.Beta' and 'lambda.Theta'.
## 'standardize' and 'standardize.response' are 'TRUE' by default.
lamB.vec &lt;- 10^(seq(from = 0, to = -1, length.out = 5))
lamTht.vec &lt;- 10^(seq(from = 0, to = -1, length.out = 5))
cvfit &lt;- cv.missoNet(X = X.tr, Y = Y.tr, kfold = 5,
                     lambda.Beta = lamB.vec, lambda.Theta = lamTht.vec)


## Perform a five-fold cross-validation WITHOUT specified 'lambda.Beta' and 'lambda.Theta'.
## In this case, a grid of 'lambda.Beta' and 'lambda.Theta' values in a (hopefully) reasonable 
## range will be computed and used by the program.
## 
## &lt; This simplest command should be a good start for most analyses. &gt;
cvfit &lt;- cv.missoNet(X = X.tr, Y = Y.tr, kfold = 5)


## Alternatively, compute the cross-validation folds in parallel on a cluster with 2 cores.
## 
## 'fit.1se = TRUE' tells the program to make additional estimations of the parameters at the 
## largest value of 'lambda.Beta' / 'lambda.Theta' that gives the most regularized model such 
## that the cross-validated error is within one standard error of the minimum.
cl &lt;- parallel::makeCluster(min(parallel::detectCores()-1, 2))
cvfit &lt;- cv.missoNet(X = X.tr, Y = Y.tr, kfold = 5, fit.1se = TRUE,
                     parallel = TRUE, cl = cl,
                     permute = TRUE, with.seed = 486)  # permute with seed for reproducibility
parallel::stopCluster(cl)


## Use PRE-STANDARDIZED training data if you wish to compare the results with other softwares. 
X.tr.std &lt;- scale(X.tr, center = TRUE, scale = TRUE)
Y.tr.std &lt;- scale(Y.tr, center = TRUE, scale = TRUE)
cvfit.std &lt;- cv.missoNet(X = X.tr.std, Y = Y.tr.std, kfold = 5,
                         standardize = FALSE, standardize.response = FALSE)


## Plot the (standardized) mean cross-validated errors in a heatmap.
plot(cvfit, type = "cv.heatmap")

## Plot the (standardized) mean cross-validated errors in a 3D scatterplot.
plot(cvfit, type = "cv.scatter", plt.surf = TRUE)


## Extract the estimates at "lambda.min".
Beta.hat1 &lt;- cvfit$est.min$Beta
Theta.hat1 &lt;- cvfit$est.min$Theta

## Extract the estimates at "lambda.1se.Beta" (if 'fit.1se' = TRUE).
Beta.hat2 &lt;- cvfit$est.1se.B$Beta
Theta.hat2 &lt;- cvfit$est.1se.B$Theta

## Extract the estimates at "lambda.1se.Theta" (if 'fit.1se' = TRUE).
Beta.hat3 &lt;- cvfit$est.1se.Tht$Beta
Theta.hat3 &lt;- cvfit$est.1se.Tht$Theta


## Make predictions of response values on the test set.
newy1 &lt;- predict(cvfit, newx = sim.dat$X[tst, ], s = "lambda.min")
newy2 &lt;- predict(cvfit, newx = sim.dat$X[tst, ], s = "lambda.1se.Beta")  # 'fit.1se' = TRUE
newy3 &lt;- predict(cvfit, newx = sim.dat$X[tst, ], s = "lambda.1se.Theta")  # 'fit.1se' = TRUE

</code></pre>


</div>