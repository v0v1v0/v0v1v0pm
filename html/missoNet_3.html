<div class="container">

<table style="width: 100%;"><tr>
<td>generateData</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Quickly generate synthetic data for simulation studies</h2>

<h3>Description</h3>

<p>The ‘<code>generateData</code>’ function is used to readily produce synthetic data with randomly/systematically-missing values from a conditional Gaussian graphical model. 
This function supports three types of missing mechanisms that can be specified by users – missing completely at random (MCAR), missing at random (MAR) and 
missing not at random (MNAR).
</p>


<h3>Usage</h3>

<pre><code class="language-R">generateData(
  X = NULL,
  Beta = NULL,
  E = NULL,
  Theta = NULL,
  Sigma.X = NULL,
  n,
  p,
  q,
  rho,
  missing.type = "MCAR",
  Beta.row.sparsity = 0.2,
  Beta.elm.sparsity = 0.2,
  with.seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>(Optional) a user-supplied predictor matrix (<code class="reqn">n\times p</code>). The default is <code>'NULL'</code> and the program simulates the rows of <code>'X'</code> independently from <code class="reqn">\mathcal{MVN}</code>(<code class="reqn">0_p</code>, <code class="reqn">\mathbf{\Sigma}_X</code>). A user-supplied matrix overrides this default, and the argument <code>'Sigma.X'</code> for <code class="reqn">\mathbf{\Sigma}_X</code> will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Beta</code></td>
<td>
<p>(Optional) a user-supplied regression coefficient matrix <code class="reqn">\mathbf{B}</code> (<code class="reqn">p\times q</code>). The default is <code>'NULL'</code> and the program will generate a sparse <code class="reqn">\mathbf{B}</code> in which the nonzero elements are independently drawn from <code class="reqn">\mathcal{N}(0, 1)</code>; the row sparsity and element sparsity of <code class="reqn">\mathbf{B}</code> are controlled by the arguments <code>'Beta.row.sparsity'</code> and <code>'Beta.elm.sparsity'</code>, respectively. A user-supplied matrix overrides this default, and <code>'Beta.row.sparsity'</code> and <code>'Beta.elm.sparsity'</code> will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>(Optional) a user-supplied error matrix (<code class="reqn">n\times q</code>). The default is <code>'NULL'</code> and the program simulates the rows of <code>'E'</code> independently from <code class="reqn">\mathcal{MVN}</code>(<code class="reqn">0_q</code>, <code class="reqn">\mathbf{\Theta}^{-1}</code>). A response matrix <code>'Y'</code> without missing values is given by <code>'Y = X %*% Beta + E'</code>. A user-supplied matrix overrides this default, and the argument <code>'Theta'</code> for <code class="reqn">\mathbf{\Theta}</code> will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Theta</code></td>
<td>
<p>(Optional) a user-supplied positive definite precision (inverse covariance) matrix <code class="reqn">\mathbf{\Theta}</code> (<code class="reqn">q\times q</code>) for the response variables. The default is <code>'NULL'</code> and the program will generate a block-structured matrix having four blocks corresponding to four types of network structures: independent, weak graph, strong graph and chain. This is only needed when <code>'E = NULL'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma.X</code></td>
<td>
<p>(Optional) A user-supplied positive definite covariance matrix <code class="reqn">\mathbf{\Sigma}_X</code> (<code class="reqn">p\times p</code>) for the predictor variables. The samples of <code>'X'</code> are independently drawn from a multivariate Gaussian distribution <code class="reqn">\mathcal{MVN}</code>(<code class="reqn">0_p</code>, <code class="reqn">\mathbf{\Sigma}_X</code>). If <code>'Sigma.X = NULL'</code> (default), the program uses an AR(1) covariance with 0.7 autocorrelation (i.e., <code class="reqn">[\mathbf{\Sigma}_X]_{jk} = 0.7^{|j-k|}</code>). This is only needed when <code>'X = NULL'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>The dimensionality of the predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>The dimensionality of the responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>A scalar or a numeric vector of length <code class="reqn">q</code> specifying the approximate proportion of missing values in each column of the response matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing.type</code></td>
<td>
<p>Character string: can be "<code>MCAR</code>" (default), "<code>MAR</code>" or "<code>MNAR</code>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Beta.row.sparsity</code></td>
<td>
<p>A Bernoulli parameter between 0 and 1 controlling the approximate proportion of rows where at least one element could be nonzero in <code class="reqn">\mathbf{B}</code>; the default is <code>'Beta.row.sparsity = 0.2'</code>. This is only needed when <code>'Beta = NULL'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Beta.elm.sparsity</code></td>
<td>
<p>A Bernoulli parameter between 0 and 1 controlling the approximate proportion of nonzero elements among the rows of <code class="reqn">\mathbf{B}</code> where not all elements are zeros; the default is <code>'Beta.elm.sparsity = 0.2'</code>. This is only needed when <code>'Beta = NULL'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.seed</code></td>
<td>
<p>A random number seed for the generative process.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The dataset is simulated through the following steps:
</p>

<ol>
<li>
<p> If <code>'X = NULL'</code> (default), the function ‘<code>MASS::mvrnorm(n, mean = rep(0, p), sigma = Sigma.X)</code>’ is used to simulate <code>'n'</code> samples from a <code>'p'</code>-variate Gaussian distribution for generating a predictor matrix <code>'X'</code>;
</p>
</li>
<li>
<p> If <code>'Beta = NULL'</code> (default), the function ‘<code>stats::rnorm(p*q, 0, 1)</code>’ is used to fill an empty (<code class="reqn">p \times q</code>) dimensional matrix <code>'Beta'</code>, of which the row sparsity and element sparsity are later controlled by the auxiliary arguments <code>'Beta.row.sparsity'</code> and <code>'Beta.elm.sparsity'</code>, respectively;
</p>
</li>
<li>
<p> If <code>'E = NULL'</code> (default), the function ‘<code>MASS::mvrnorm(n, mean = rep(0, q), sigma = solve(Theta))</code>’ is used to simulate <code>'n'</code> samples from a <code>'q'</code>-variate Gaussian distribution for generating an error matrix <code>'E'</code>;
</p>
</li>
<li>
<p> A complete response matrix <code>'Y'</code> without missing values is then generated by the command <code>'Y = X %*% Beta + E'</code>;
</p>
</li>
<li>
<p> To get a response matrix <code>'Z'</code> := <code class="reqn">f</code>(<code>'Y'</code>) corrupted by missing data, the values in <code>'Y'</code> are partially replaced with <code>'NA'</code>s following the strategy specified by the arguments <code>'missing.type'</code> and <code>'rho'</code>.
</p>
</li>
</ol>
<p>To better illustrate the step 5 above, suppose for all <code>i = 1,...,n</code> and <code>j = 1,...,q</code>: <code>'Y[i, j]'</code> is replaced with <code>'NA'</code> 
if <code>'M[i, j] == 1'</code>, where <code>'M'</code> is an indicator matrix of missingness having the same dimension as <code>'Y'</code>.
The value of <code>'M[i, j]'</code> is partially controlled by the arguments <code>'missing.type'</code> and <code>'rho'</code>. 
Below we sum up the three built-in missing mechanisms supported by the ‘<code>generateData</code>’ function:
</p>

<ul>
<li> <p><code>'missing.type'</code> == "<code>MCAR</code>": <code>'Y[i, j] &lt;- NA'</code> if <code>'M[i, j] == 1'</code>, where <code>'M[i, j] = rbinom(0, rho[j])'</code>;
</p>
</li>
<li> <p><code>'missing.type'</code> == "<code>MAR</code>": <code>'Y[i, j] &lt;- NA'</code> if <code>'M[i, j] == 1'</code>, where <code>'M[i, j]  = rbinom(0, (rho[j] * c / (1 + exp(-(X %*% Beta)[i, j]))))'</code>, in which <code>c</code> is a constant correcting the missing rate of the <code>j</code>th column of <code>'Y'</code> to <code>'rho[j]'</code>;
</p>
</li>
<li> <p><code>'missing.type'</code> == "<code>MNAR</code>": <code>'Y[i, j] &lt;- NA'</code> if <code>'M[i, j] == 1'</code>, where <code>'M[i, j] = 1 * (Y[i, j] &lt; Tj)'</code>, in which <code>'Tj = quantile(Y[ , j], rho[j])'</code>.
</p>
</li>
</ul>
<p>Of the aforementioned missing mechanisms, "<code>MCAR</code>" is random, and the other two are systematic. 
under "<code>MCAR</code>", <code>'M[i, j]'</code> is not related to <code>'Y'</code> or to <code>'X'</code>; 
under "<code>MAR</code>", <code>'M[i, j]'</code> is related to <code>'X'</code>, but not related to <code>'Y'</code> after <code>'X'</code> is controlled; 
under "<code>MNAR</code>", <code>'M[i, j]'</code> is related to <code>'Y'</code> itself, even after <code>'X'</code> is controlled.
</p>


<h3>Value</h3>

<p>This function returns a <code>'list'</code> consisting of the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A simulated (or the user-supplied) predictor matrix (<code class="reqn">n\times p</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>A simulated response matrix without missing values (<code class="reqn">n\times q</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>A simulated response matrix with missing values coded as <code>'NA'</code>s (<code class="reqn">n\times q</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Beta</code></td>
<td>
<p>The regression coefficient matrix <code class="reqn">\mathbf{B}</code> for the generative model (<code class="reqn">p\times q</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Theta</code></td>
<td>
<p>The precision matrix <code class="reqn">\mathbf{\Theta}</code> for the generative model (<code class="reqn">q\times q</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>A vector of length <code class="reqn">q</code> storing the specified missing rate for each column of the response matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing.type</code></td>
<td>
<p>Character string: the type of missing mechanism used to generate missing values in the response matrix.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Yixiao Zeng <a href="mailto:yixiao.zeng@mail.mcgill.ca">yixiao.zeng@mail.mcgill.ca</a>, Celia M.T. Greenwood and Archer Yi Yang.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simulate a dataset with response values missing completely at random (MCAR), 
## the overall missing rate is around 10%.
sim.dat &lt;- generateData(n = 300, p = 50, q = 20, rho = 0.1, missing.type = "MCAR")
## -------------------------------------------------------------------------------
## Fit a missoNet model using the simulated dataset.
X &lt;- sim.dat$X  # predictor matrix
Y &lt;- sim.dat$Z  # corrupted response matrix
fit &lt;- missoNet(X = X, Y = Y, lambda.Beta = 0.1, lambda.Theta = 0.1)


## Simulate a dataset with response values missing at random (MAR), the approximate 
## missing rate for each column of the response matrix is specified through a vector 'rho'.
## 
## The row sparsity and element sparsity of the auto-generated 'Beta' could be 
## adjusted correspondingly by using 'Beta.row.sparsity' and 'Beta.elm.sparsity'.
n &lt;- 300; p &lt;- 50; q &lt;- 20
rho &lt;- runif(q, min = 0, max = 0.2)
sim.dat &lt;- generateData(n = n, p = p, q = q, rho = rho, missing.type = "MAR",
                        Beta.row.sparsity = 0.3, Beta.elm.sparsity = 0.2)


## Simulate a dataset with response values missing not at random (MNAR), 
## using the user-supplied 'Beta' and 'Theta'.
n &lt;- 300; p &lt;- 50; q &lt;- 20
Beta &lt;- matrix(rnorm(p*q, 0, 1), p, q)  # a nonsparse 'Beta' (p x q)
Theta &lt;- diag(q)  # a diagonal 'Theta' (q x q)
sim.dat &lt;- generateData(Beta = Beta, Theta = Theta, n = n, p = p, q = q,
                        rho = 0.1, missing.type = "MNAR")
## ---------------------------------------------------------------------          
## Specifying just one of 'Beta' and 'Theta' is also allowed.
sim.dat &lt;- generateData(Theta = Theta, n = n, p = p, q = q,
                        rho = 0.1, missing.type = "MNAR")


## User-supplied 'X', 'Beta' and 'E', in which case 'Y' is deterministic.
n &lt;- 300; p &lt;- 50; q &lt;- 20
X &lt;- matrix(rnorm(n*p, 0, 1), n, p)
Beta &lt;- matrix(rnorm(p*q, 0, 1), p, q)
E &lt;- mvtnorm::rmvnorm(n, rep(0, q), sigma = diag(q))
sim.dat &lt;- generateData(X = X, Beta = Beta, E = E, n = n, p = p, q = q,
                        rho = 0.1, missing.type = "MCAR")
</code></pre>


</div>