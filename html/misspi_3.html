<div class="container">

<table style="width: 100%;"><tr>
<td>misspi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Missing Value Imputation in Parallel</h2>

<h3>Description</h3>

<p>Enables embarrassingly parallel computing for imputation. Some of the advantages include
</p>

<ul>
<li>
<p> Provides fast implementation especially for high dimensional datasets.
</p>
</li>
<li>
<p> Accepts a variety of machine learning models as methods with friendly user portal.
</p>
</li>
<li>
<p> Supports multiple initializations.
</p>
</li>
<li>
<p> Supports early stopping that prohibits unnecessary iterations.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">misspi(
  x,
  ncore = NULL,
  init.method = "rf",
  method = "rf",
  earlystopping = TRUE,
  ntree = 100,
  init.ntree = 100,
  viselect = NULL,
  lgb.params = NULL,
  lgb.params0 = NULL,
  model.train = NULL,
  pmm = TRUE,
  nn = 3,
  intcol = NULL,
  maxiter = 10,
  rdiff.thre = 0.01,
  verbose = TRUE,
  progress = TRUE,
  nlassofold = 5,
  isis = FALSE,
  char = " * ",
  iteration = TRUE,
  ndecimal = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix of numerical values for imputation, missing value should all be "NA".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore</code></td>
<td>
<p>number of cores to use, will be set to the cores detected as default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.method</code></td>
<td>
<p>initializing method to fill in the missing value before imputation. Support "rf" for random forest imputation as default, "mean" for mean imputation, "median" for median imputation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method name for the imputation, support "rf" for random forest, "lgb" for lightgbm, "lasso" for LASSO, or "customize" if you want to use your own method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>earlystopping</code></td>
<td>
<p>a Boolean which indicates whether to stop the algorithm if the relative difference stop decreasing, with TRUE as default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntree</code></td>
<td>
<p>number of trees to use for imputation when method is "rf" or "gbm".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.ntree</code></td>
<td>
<p>number of trees to use for initialization when method is "rf"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>viselect</code></td>
<td>
<p>the number of variables with highest variable importance calculated from random forest initialization to work on if the value is not NULL. This would only work when init.method is "rf", and method is "rf" or "gbm".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lgb.params</code></td>
<td>
<p>parameters to customize for lightgbm models, could be invoked when method is "rf" or "gbm".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lgb.params0</code></td>
<td>
<p>parameters to customize for initialization using random forest, could be invoked when init.method is "rf".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.train</code></td>
<td>
<p>machine learning model to be invoked for customizing the imputation. Only invoked when parameter method = "customize". The input model should be able to take y~x for fitting process where y, and x are matrices, also make sure that it could be called using method "predict" for model prediction. You could pass the parameters for the model through the additional arguments ...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmm</code></td>
<td>
<p>a Boolean which indicated whether to use predictive mean matching.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn</code></td>
<td>
<p>number of neighbors to use for prediction if predictive mean matching is invoked (pmm is "TRUE").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intcol</code></td>
<td>
<p>a vector of indices of columns that are know to be integer, and will be round to integer in every iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum number of iterations for imputation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rdiff.thre</code></td>
<td>
<p>relative difference threshold for determining the imputation convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a Boolean that indicates whether to print out the intermediate steps verbally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>a Boolean that indicates whether to show the progress bar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlassofold</code></td>
<td>
<p>number of folds for cross validation when the method is "lasso".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isis</code></td>
<td>
<p>a Boolean that indicates whether to use isis if the method is "lasso", recommended to use for ultra high dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>char</code></td>
<td>
<p>a character to use which also accept unicode for progress bar. For example, u03c, u213c for pi, u2694 for swords, u2605 for star, u2654 for king, u26a1 for thunder, u2708 for plane.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iteration</code></td>
<td>
<p>a Boolean that indicates whether use iterative algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndecimal</code></td>
<td>
<p>number of decimals to round for the result, with NULL meaning no intervention.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments to be passed to the method.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list that contains the imputed values, time consumed and number of iterations.
</p>
<p>x.imputed the imputed matrix.
</p>
<p>time.elapsed time consumed for the algorithm.
</p>
<p>niter number of iterations used in the algorithm.
</p>


<h3>Author(s)</h3>

<p>Zhongli Jiang <a href="mailto:jiang548@purdue.edu">jiang548@purdue.edu</a>
</p>


<h3>References</h3>

<p>Azur, M. J., Stuart, E. A., Frangakis, C., &amp; Leaf, P. J. (2011). Multiple imputation by chained equations: what is it and how does it work?. International journal of methods in psychiatric research, 20(1), 40-49.
</p>
<p>Ke, G., Meng, Q., Finley, T., Wang, T., Chen, W., Ma, W., ... &amp; Liu, T. Y. (2017). Lightgbm: A highly efficient gradient boosting decision tree. Advances in neural information processing systems, 30.
</p>
<p>Stekhoven, D. J., &amp; Bühlmann, P. (2012). MissForest—non-parametric missing value imputation for mixed-type data. Bioinformatics, 28(1), 112-118.
</p>
<p>Fan, J., &amp; Lv, J. (2008). Sure independence screening for ultrahigh dimensional feature space. Journal of the Royal Statistical Society Series B: Statistical Methodology, 70(5), 849-911.
</p>
<p>Tibshirani, R. (1996). Regression shrinkage and selection via the lasso. Journal of the Royal Statistical Society Series B: Statistical Methodology, 58(1), 267-288.
</p>
<p>Breiman, L. (2001). Random forests. Machine learning, 45, 5-32.
</p>


<h3>See Also</h3>

<p><code>missar</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

# Quick example 1
# Load a small data
data(iris)
# Keep numerical columns
num.col &lt;- which(sapply(iris, is.numeric))
iris.numeric &lt;- as.matrix(iris[, num.col])
set.seed(0)
iris.miss &lt;- missar(iris.numeric, 0.3, 1)
iris.impute &lt;- misspi(iris.miss)
iris.impute

# Quick example 2
# Load a high dimensional data
data(toxicity, package = "misspi")
set.seed(0)
toxicity.miss &lt;- missar(toxicity, 0.4, 0.2)
toxicity.impute &lt;- misspi(toxicity.miss)
toxicity.impute

# Change cores
iris.impute.5core &lt;- misspi(iris.miss, ncore = 5)

# Change initialization and maximum iterations (no iteration in the example)
iris.impute.mean.5iter &lt;- misspi(iris.miss, init.method = "mean", maxiter = 0)

# Change fun shapes for progress bar
iris.impute.king &lt;- misspi(iris.miss, char = " \u2654")


# Use variable selection
toxicity.impute.vi &lt;- misspi(toxicity.miss, viselect = 128)


# Use different machine learning algorithms as method
# linear model
iris.impute.lm &lt;- misspi(iris.miss, model.train = lm)

# From external packages
# Support Vector Machine (SVM)

library(e1071)
iris.impute.svm.radial &lt;- misspi(iris.miss, model.train = svm)


# Neural Networks

library(neuralnet)
iris.impute.nn &lt;- misspi(iris.miss, model.train = neuralnet)


</code></pre>


</div>