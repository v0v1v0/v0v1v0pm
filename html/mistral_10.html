<div class="container">

<table style="width: 100%;"><tr>
<td>IRW</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Increasing Randow Walk</h2>

<h3>Description</h3>

<p>Simulate the increasing random walk associated with a real-valued continuous
random variable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">IRW(
  dimension,
  lsf,
  N = 10,
  q = Inf,
  Nevent = Inf,
  X,
  y = lsf(X),
  K,
  burnin = 20,
  sigma = 0.3,
  last.return = TRUE,
  use.potential = TRUE,
  plot = FALSE,
  plot.lsf = FALSE,
  print_plot = FALSE,
  output_dir = NULL,
  plot.lab = c("x_1", "x_2")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dimension</code></td>
<td>
<p>dimension of the input space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lsf</code></td>
<td>
<p>limit state function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of particules.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>level until which the randow walk is to be generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nevent</code></td>
<td>
<p>the number of desired events.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>to start with some given particles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>value of the <code>lsf</code> on X.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>kernel transition for conditional generations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>burnin parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>radius parameter for <code>K</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>last.return</code></td>
<td>
<p>if the last event should be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.potential</code></td>
<td>
<p>tu use a ‘potential’ matrix to select starting point not
directly related to the sample to be moved with the MH algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>if <code>TRUE</code>, the algorithm plots the evolution of the particles. This
requieres to evaluate the <code>lsf</code> on a grid and is only for visual purpose.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.lsf</code></td>
<td>
<p>a boolean indicating if the <code>lsf</code> should be added to the
plot. This requires the evaluation of the <code>lsf</code> over a grid and
consequently should be used only for illustation purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_plot</code></td>
<td>
<p>if TRUE, print the updated plot after each iteration. This might
be slow; use with a small <code>N</code>. Otherwise it only prints the final plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_dir</code></td>
<td>
<p>if plots are to be saved in pdf in a given directory. This will
be pasted with ‘_IRW.pdf’. Together with <code>print_plot==TRUE</code> this will
produce a pdf with a plot at each iteration, enabling ‘video’ reconstitution
of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.lab</code></td>
<td>
<p>the x and y labels for the plot</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function lets generate the increasing random walk associated with a continous
real-valued random variable of the form <code>Y = lsf(X)</code> where <code>X</code> is
vectorial random variable.
</p>
<p>This random walk can be associated with a Poisson process with parameter
<code>N</code> and hence the number of iterations before a given threshold <code>q</code>
is directly related to P[ lsf(X) &gt; q]. It is the core tool of algorithms
such as nested sampling, Last Particle Algorithm or Tootsie Pop Algorithm.
</p>
<p>Bascially for <code>N = 1</code>, it generates a sample <code class="reqn">Y = lsf(X)</code> and iteratively
regenerates greater than the found value: <code class="reqn">Y_{n+1} \sim \mu^Y( \cdot \mid Y &gt; Y_n</code>. This
regeneration step is done with a Metropolis-Hastings algorithm and that is why it is usefull
to consider generating several chains all together (<code>N &gt; 1</code>).
</p>
<p>The algorithm stops when it has simulated the required number of events <code>Nevent</code> or when
it has reached the sought threshold <code>q</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>list</code> containing the following data:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>the events of the random walk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>the total number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ncall</code></td>
<td>
<p>the total number of calls to the <code>lsf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a matrix containing the final particles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the value of <code>lsf</code> on <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>the threshold considered when generating the random walk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nevent</code></td>
<td>
<p>the target number of events when generating the random walk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nwmoves</code></td>
<td>
<p>the number of rejected transitions, ie when the proposed point was not stricly
greater/lower than the current state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance</code></td>
<td>
<p>a vector containing the acceptance rate for each use of the MH algorithm.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Problem is supposed to be defined in the standard space. If not,
use <code>UtoX</code> to do so. Furthermore, each time a set of vector
is defined as a matrix, ‘nrow’ = <code>dimension</code> and
‘ncol’ = number of vector to be consistent with <code>as.matrix</code>
transformation of a vector.
</p>
<p>Algorithm calls lsf(X) (where X is a matrix as defined previously) and
expects a vector in return. This allows the user to optimise the computation
of a batch of points, either by vectorial computation, or by the use of
external codes (optimised C or C++ codes for example) and/or parallel
computation; see examples in MonteCarlo.
</p>


<h3>Author(s)</h3>

<p>Clement WALTER <a href="mailto:clementwalter@icloud.com">clementwalter@icloud.com</a>
</p>


<h3>References</h3>


<ul>
<li>
<p> C. Walter:<br><em>Moving Particles: a parallel optimal Multilevel Splitting method
with application in quantiles estimation and meta-model based algorithms</em><br>
Structural Safety, 55, 10-25.<br></p>
</li>
<li>
<p> C. Walter:<br><em>Point Process-based Monte Carlo estimation</em><br>
Statistics and Computing, in press, 1-18.<br>
arXiv preprint arXiv:1412.6368.<br></p>
</li>
<li>
<p> J. Skilling:<br><em>Nested sampling for general Bayesian computation</em><br>
Bayesian Analysis, 1(4), 833-859.<br></p>
</li>
<li>
<p> M. Huber and S. Schott:<br><em>Using TPA for Bayesian inference</em><br>
Bayesian Statistics 9, 9, 257.<br></p>
</li>
<li>
<p> A. Guyader, N. Hengartner and E. Matzner-Lober:<br><em>Simulation and estimation of extreme quantiles and extreme
probabilities</em><br>
Applied Mathematics and Optimization, 64(2), 171-196.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>MP</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Get faililng samples for the kiureghian limit state function
# Failure is defined as lsf(X) &lt; 0 so we have to invert the lsf
lsf &lt;- function(x) -1*kiureghian(x)
## Not run: 
fail.samp &lt;- IRW(2, lsf, q = 0, N = 10, plot = TRUE)

## End(Not run)
</code></pre>


</div>