<div class="container">

<table style="width: 100%;"><tr>
<td>MetaIS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Metamodel based Impotance Sampling</h2>

<h3>Description</h3>

<p>Estimate failure probability by MetaIS method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MetaIS(
  dimension,
  lsf,
  N = 5e+05,
  N_alpha = 100,
  N_DOE = 10 * dimension,
  N1 = N_DOE * 30,
  Ru = 8,
  Nmin = 30,
  Nmax = 200,
  Ncall_max = 1000,
  precision = 0.05,
  N_seeds = 2 * dimension,
  Niter_seed = Inf,
  N_alphaLOO = 5000,
  K_alphaLOO = 1,
  alpha_int = c(0.1, 10),
  k_margin = 1.96,
  lower.tail = TRUE,
  X = NULL,
  y = NULL,
  failure = 0,
  meta_model = NULL,
  kernel = "matern5_2",
  learn_each_train = TRUE,
  limit_fun_MH = NULL,
  failure_MH = 0,
  sampling_strategy = "MH",
  seeds = NULL,
  seeds_eval = limit_fun_MH(seeds),
  burnin = 20,
  compute.PPP = FALSE,
  plot = FALSE,
  limited_plot = FALSE,
  add = FALSE,
  output_dir = NULL,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dimension</code></td>
<td>
<p>of the input space</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lsf</code></td>
<td>
<p>the failure defining the failure/safety domain</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>size of the Monte-Carlo population for P_epsilon estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_alpha</code></td>
<td>
<p>initial size of the Monte-Carlo population for alpha estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_DOE</code></td>
<td>
<p>size of the initial DOE got by clustering of the N1 samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N1</code></td>
<td>
<p>size of the initial uniform population sampled in a hypersphere of radius Ru</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ru</code></td>
<td>
<p>radius of the hypersphere for the initial sampling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nmin</code></td>
<td>
<p>minimum number of call for the construction step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nmax</code></td>
<td>
<p>maximum number of call for the construction step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ncall_max</code></td>
<td>
<p>maximum number of call for the whole algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision</code></td>
<td>
<p>desired maximal value of cov</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_seeds</code></td>
<td>
<p>number of seeds for MH algoritm while generating into the margin (
according to MP*gauss)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Niter_seed</code></td>
<td>
<p>maximum number of iteration for the research of a seed for alphaLOO
refinement sampling</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_alphaLOO</code></td>
<td>
<p>number of points to sample at each refinement step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_alphaLOO</code></td>
<td>
<p>number of clusters at each refinement step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_int</code></td>
<td>
<p>range for alpha to stop construction step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_margin</code></td>
<td>
<p>margin width; default value means that points are classified with more
than 97,5%</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>specify if one wants to estimate P[lsf(X)&lt;failure] or P[lsf(X)&gt;failure].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Coordinates of alredy known points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Value of the LSF on these points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>failure</code></td>
<td>
<p>Failure threshold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meta_model</code></td>
<td>
<p>Provide here a kriging metamodel from km if wanted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>Specify the kernel to use for km</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learn_each_train</code></td>
<td>
<p>Specify if kernel parameters are re-estimated at each train</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limit_fun_MH</code></td>
<td>
<p>Define an area of exclusion with a limit function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>failure_MH</code></td>
<td>
<p>Threshold for the limit_MH function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling_strategy</code></td>
<td>
<p>Either MH for Metropolis-Hastings of AR for accept-reject</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>If some points are already known to be in the appropriate subdomain</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds_eval</code></td>
<td>
<p>Value of the metamodel on these points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Burnin parameter for MH</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.PPP</code></td>
<td>
<p>to simulate a Poisson process at each iteration to estimate
the conditional expectation and the SUR criteria based on the conditional
variance: h (average probability of misclassification at level <code>failure</code>)
and I (integral of h over the whole interval [failure, infty))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>Set to TRUE for a full plot, ie refresh at each iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limited_plot</code></td>
<td>
<p>Set to TRUE for a final plot with final DOE, metamodel and LSF</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>If plots are to be added to a current device</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_dir</code></td>
<td>
<p>If plots are to be saved in jpeg in a given directory</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Either 0 for almost no output, or 1 for medium size or 2 for all outputs</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>MetaIS is an Important Sampling based probability estimator. It makes use of
a kriging surogate to approximate the optimal density function, replacing the
indicatrice by its kriging pendant, the probability of being in the failure
domain. In this context, the normallizing constant of this quasi-optimal PDF
is called the ‘augmented failure probability’ and the modified
probability ‘alpha’.
</p>
<p>After a first uniform Design of Experiments, MetaIS uses an alpha
Leave-One-Out criterion combined with a margin sampling strategy to refine
a kriging-based metamodel. Samples are generated according to the weighted
margin probability with Metropolis-Hastings algorithm and some are selected
by clustering; the <code>N_seeds</code> are got from an accept-reject strategy on
a standard population.
</p>
<p>Once criterion is reached or maximum number of call done, the augmented
failure probability is estimated with a crude Monte-Carlo. Then, a new
population is generated according to the quasi-optimal instrumenal PDF;
<code>burnin</code> and <code>thinning</code> are used here and alpha is evaluated.
While the coefficient of variation of alpha estimate is greater than a
given threshold and some computation spots still available (defined by
<code>Ncall_max</code>) the estimate is refined with extra calculus.
</p>
<p>The final probability is the product of p_epsilon and alpha, and final
squared coefficient of variation is the sum of p_epsilon and alpha one's.
</p>


<h3>Value</h3>

<p>An object of class <code>list</code> containing the failure probability
and some more outputs as described below:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>The estimated failure probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>The coefficient of variation of the Monte-Carlo probability
estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ncall</code></td>
<td>
<p>The total number of calls to the <code>lsf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The final learning database, ie. all points where <code>lsf</code>
has been calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The value of the <code>lsf</code> on the learning database.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meta_fun</code></td>
<td>
<p>The metamodel approximation of the <code>lsf</code>. A call output
is a list containing the value and the standard deviation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meta_model</code></td>
<td>
<p>The final metamodel. An S4 object from <span class="pkg">DiceKriging</span>.
Note that the algorithm enforces the problem to be the estimation of
P[lsf(X)&lt;failure] and so using ‘predict’ with this object will
return inverse values if <code>lower.tail==FALSE</code>; in this scope prefer
using directly <code>meta_fun</code> which handle this possible issue.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>
<p>Points in the failure domain according to the metamodel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>the sequence of the estimated relative SUR criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I</code></td>
<td>
<p>the sequence of the estimated integrated SUR criteria.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Problem is supposed to be defined in the standard space. If not,
use <code>UtoX</code> to do so. Furthermore, each time a set of vector
is defined as a matrix, ‘nrow’ = <code>dimension</code> and
‘ncol’ = number of vector to be consistent with <code>as.matrix</code>
transformation of a vector.
</p>
<p>Algorithm calls lsf(X) (where X is a matrix as defined previously) and
expects a vector in return. This allows the user to optimise the computation
of a batch of points, either by vectorial computation, or by the use of
external codes (optimised C or C++ codes for example) and/or parallel
computation; see examples in MonteCarlo.
</p>


<h3>Author(s)</h3>

<p>Clement WALTER <a href="mailto:clementwalter@icloud.com">clementwalter@icloud.com</a>
</p>


<h3>References</h3>


<ul>
<li>
<p>V. Dubourg:<br>
Meta-modeles adaptatifs pour l'analyse de fiabilite et l'optimisation sous
containte fiabiliste<br>
PhD Thesis, Universite Blaise Pascal - Clermont II,2011<br></p>
</li>
<li>
<p>V. Dubourg, B. Sudret, F. Deheeger:<br>
Metamodel-based importance sampling for structural reliability analysis
Original Research Article<br>
Probabilistic Engineering Mechanics, Volume 33, July 2013, Pages 47-57<br></p>
</li>
<li>
<p>V. Dubourg, B. Sudret:<br>
Metamodel-based importance sampling for reliability sensitivity analysis.<br>
Accepted for publication in Structural Safety, special issue in the honor
of Prof. Wilson Tang.(2013)<br></p>
</li>
<li>
<p>V. Dubourg, B. Sudret and J.-M. Bourinet:<br>
Reliability-based design optimization using kriging surrogates and subset
simulation.<br>
Struct. Multidisc. Optim.(2011)<br></p>
</li>
</ul>
<h3>See Also</h3>

<p><code>SubsetSimulation</code>
<code>MonteCarlo</code>
<code>km</code> (in package <span class="pkg">DiceKriging</span>)
</p>


<h3>Examples</h3>

<pre><code class="language-R">kiureghian = function(x, b=5, kappa=0.5, e=0.1) {
x = as.matrix(x)
b - x[2,] - kappa*(x[1,]-e)^2
}

## Not run: 
res = MetaIS(dimension=2,lsf=kiureghian,plot=TRUE)

#Compare with crude Monte-Carlo reference value
N = 500000
dimension = 2
U = matrix(rnorm(dimension*N),dimension,N)
G = kiureghian(U)
P = mean(G&lt;0)
cov = sqrt((1-P)/(N*P))

## End(Not run)

#See impact of kernel choice with Waarts function :
waarts = function(u) {
  u = as.matrix(u)
  b1 = 3+(u[1,]-u[2,])^2/10 - sign(u[1,] + u[2,])*(u[1,]+u[2,])/sqrt(2)
  b2 = sign(u[2,]-u[1,])*(u[1,]-u[2,])+7/sqrt(2)
  val = apply(cbind(b1, b2), 1, min)
}

## Not run: 
res = list()
res$matern5_2 = MetaIS(2,waarts,plot=TRUE)
res$matern3_2 = MetaIS(2,waarts,kernel="matern3_2",plot=TRUE)
res$gaussian = MetaIS(2,waarts,kernel="gauss",plot=TRUE)
res$exp = MetaIS(2,waarts,kernel="exp",plot=TRUE)

#Compare with crude Monte-Carlo reference value
N = 500000
dimension = 2
U = matrix(rnorm(dimension*N),dimension,N)
G = waarts(U)
P = mean(G&lt;0)
cov = sqrt((1-P)/(N*P))

## End(Not run)

</code></pre>


</div>