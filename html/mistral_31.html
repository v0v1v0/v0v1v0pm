<div class="container">

<table style="width: 100%;"><tr>
<td>SMART</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Support-vector Margin Algoritm for Reliability esTimation</h2>

<h3>Description</h3>

<p>Calculate a failure probability with SMART method. This
should not be used by itself but only through S2MART.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SMART(
  dimension,
  lsf,
  N1 = 10000,
  N2 = 50000,
  N3 = 2e+05,
  Nu = 50,
  lambda1 = 7,
  lambda2 = 3.5,
  lambda3 = 1,
  tune_cost = c(1, 10, 100, 1000),
  tune_gamma = c(0.5, 0.2, 0.1, 0.05, 0.02, 0.01),
  clusterInMargin = TRUE,
  alpha_margin = 1,
  k1 = round(6 * (dimension/2)^(0.2)),
  k2 = round(12 * (dimension/2)^(0.2)),
  k3 = k2 + 16,
  X = NULL,
  y = NULL,
  failure = 0,
  limit_fun_MH = NULL,
  sampling_strategy = "MH",
  seeds = NULL,
  seeds_eval = NULL,
  burnin = 20,
  thinning = 4,
  plot = FALSE,
  limited_plot = FALSE,
  add = FALSE,
  output_dir = NULL,
  z_MH = NULL,
  z_lsf = NULL,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dimension</code></td>
<td>
<p>the dimension of the input space</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lsf</code></td>
<td>
<p>the limit-state function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N1</code></td>
<td>
<p>Number of samples for the (L)ocalisation step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N2</code></td>
<td>
<p>Number of samples for the (S)tabilisation step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N3</code></td>
<td>
<p>Number of samples for the (C)onvergence step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nu</code></td>
<td>
<p>Size of the first Design of Experiments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p>Relaxing parameter for MH algorithm at step L</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>
<p>Relaxing parameter for MH algorithm at step S</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda3</code></td>
<td>
<p>Relaxing parameter for MH algorithm at step C</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune_cost</code></td>
<td>
<p>Input for tuning cost paramter of the SVM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune_gamma</code></td>
<td>
<p>Input for tuning gamma parameter of the SVM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterInMargin</code></td>
<td>
<p>Enforce selected clusterised points to be in margin</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_margin</code></td>
<td>
<p>a real value defining the margin. While
1 is the ‘real’ margin for a SVM, one can decide here to
stretch it a bit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k1</code></td>
<td>
<p>Rank of the first iteration of step S</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k2</code></td>
<td>
<p>Rank of the first iteration of step C</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k3</code></td>
<td>
<p>Rank of the last iteration of step C</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Coordinates of alredy known points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Value of the LSF on these points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>failure</code></td>
<td>
<p>Failure threshold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limit_fun_MH</code></td>
<td>
<p>Define an area of exclusion with a limit function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling_strategy</code></td>
<td>
<p>Either MH for Metropolis-Hastings of AR for accept-reject</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>If some points are already known to be in the subdomain defined
by <code>limit_fun_MH</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds_eval</code></td>
<td>
<p>Value of the metamodel on these points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Burnin parameter for MH</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thinning</code></td>
<td>
<p>Thinning parameter for MH</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>Set to TRUE for a full plot, ie. refresh at each iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limited_plot</code></td>
<td>
<p>Set to TRUE for a final plot with final DOE, metamodel and LSF</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>If plots are to be added to the current device</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_dir</code></td>
<td>
<p>If plots are to be saved in jpeg in a given directory</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z_MH</code></td>
<td>
<p>For plots, if the limit_fun_MH has already been evaluated on the grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z_lsf</code></td>
<td>
<p>For plots, if LSF has already been evaluated on the grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Either 0 for almost no output, 1 for medium size output and 2
for all outputs</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>SMART</code> is a reliability method proposed by J.-M. Bourinet et al. It makes
uses of a SVM-based metamodel to approximate the limit state function and calculates
the failure probability with a crude Monte-Carlo method using the metamodel-based
limit state function. As SVM is a classification method, it makes use of limit state
function values to create two classes : greater and lower than the failure threshold.
Then the border is taken as a surogate of the limit state function.
</p>
<p>Concerning the refinement strategy, it distinguishes 3 stages, known as Localisation,
Stalibilsation and Convergence stages. The first one is proposed to reduce the margin
as much as possible, the second one focuses on switching points while the last one works
on the final Monte-Carlo population and is designed to insure a strong margin;
see F. Deheeger PhD thesis for more information.
</p>


<h3>Value</h3>

<p>An object of class <code>list</code> containing the failure probability and some more outputs as described below:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>proba</code></td>
<td>
<p>The estimated failure probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>The coefficient of variation of the Monte-Carlo probability estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ncall</code></td>
<td>
<p>The total number of calls to the <code>limit_state_function</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The final learning database, ie. all points where <code>lsf</code> has been calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The value of the <code>limit_state_function</code> on the learning database.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meta_fun</code></td>
<td>
<p>The metamodel approximation of the <code>limit_state_function</code>.
A call output is a list containing the value and the standard deviation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meta_model</code></td>
<td>
<p>The final metamodel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>
<p>Points in the failure domain according to the metamodel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meta_eval</code></td>
<td>
<p>Evaluation of the metamodel on these points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z_meta</code></td>
<td>
<p>If <code>plot</code>==TRUE, the evaluation of the metamodel on the plot grid.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Problem is supposed to be defined in the standard space. If not, use <code>UtoX</code>
to do so.
</p>
<p>Furthermore, each time a set of vector is defined as a matrix,
‘nrow’ = <code>dimension</code> and ‘ncol’ = number of vector.
</p>


<h3>Author(s)</h3>

<p>Clement WALTER <a href="mailto:clementwalter@icloud.com">clementwalter@icloud.com</a>
</p>


<h3>References</h3>


<ul>
<li>
<p>J.-M. Bourinet, F. Deheeger, M. Lemaire:<br><em>Assessing small failure probabilities by combined Subset Simulation and Support Vector Machines</em><br>
Structural Safety (2011)
</p>
</li>
<li>
<p>F. Deheeger:<br><em>Couplage mecano-fiabiliste : 2SMART - methodologie d'apprentissage stochastique en fiabilite</em><br>
PhD. Thesis, Universite Blaise Pascal - Clermont II, 2008
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>SubsetSimulation</code>
<code>MonteCarlo</code>
<code>svm</code> (in package <span class="pkg">e1071</span>)
<code>S2MART</code>
</p>


</div>