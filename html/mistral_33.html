<div class="container">

<table style="width: 100%;"><tr>
<td>SubsetSimulation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Subset Simulation Monte Carlo</h2>

<h3>Description</h3>

<p>Estimate a probability of failure with the Subset Simulation algorithm (also known as
Multilevel Splitting or Sequential Monte Carlo for rare events).
</p>


<h3>Usage</h3>

<pre><code class="language-R">SubsetSimulation(
  dimension,
  lsf,
  p_0 = 0.1,
  N = 10000,
  q = 0,
  lower.tail = TRUE,
  K,
  thinning = 20,
  save.all = FALSE,
  plot = FALSE,
  plot.level = 5,
  plot.lsf = TRUE,
  output_dir = NULL,
  plot.lab = c("x", "y"),
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dimension</code></td>
<td>
<p>the dimension of the input space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lsf</code></td>
<td>
<p>the function defining failure/safety domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_0</code></td>
<td>
<p>a cutoff probability for defining the subsets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>the number of samples per subset, ie the population size for the Monte
Carlo estimation of each conditional probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>the quantile defining the failure domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>as for pxxxx functions, TRUE for estimating P(lsf(X) &lt; q), FALSE
for P(lsf(X) &gt; q)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>a transition Kernel for Markov chain drawing in the regeneration step.
K(X) should propose a matrix of candidate sample (same dimension as X) on which
<code>lsf</code> will be then evaluated and transition accepted of rejected. Default
kernel is the one defined K(X) = (X + sigma*W)/sqrt(1 + sigma^2) with W ~ N(0, 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thinning</code></td>
<td>
<p>a thinning parameter for the the regeneration step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.all</code></td>
<td>
<p>if TRUE, all the samples generated during the algorithms are saved
and return at the end. Otherwise only the working population is kept at each
iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>to plot the generated samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.level</code></td>
<td>
<p>maximum number of expected levels for color consistency. If number of
levels exceeds this value, the color scale will change according to
<code>ggplot2</code> default policy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.lsf</code></td>
<td>
<p>a boolean indicating if the <code>lsf</code> should be added to the
plot. This requires the evaluation of the <code>lsf</code> over a grid and
consequently should be used only for illustation purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_dir</code></td>
<td>
<p>to save the plot into a pdf file. This variable will
be paster with
"_Subset_Simulation.pdf"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.lab</code></td>
<td>
<p>the x and y labels for the plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Either 0 for almost no output, 1 for medium size output and 2 for all outputs</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This algorithm uses the property of conditional probabilities on nested subsets
to calculate a given probability defined by a limit state function.
</p>
<p>It operates iteratively on ‘populations’ to estimate the quantile
corresponding to a probability of <code>p_0</code>. Then, it generates
samples conditionnaly to this threshold, until found threshold be lower
than 0.
</p>
<p>Finally, the estimate is the product of the conditional probabilities.
</p>


<h3>Value</h3>

<p>An object of class <code>list</code> containing the failure probability and
some more outputs as described below:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>the estimated failure probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv</code></td>
<td>
<p>the estimated coefficient of variation of the estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ncall</code></td>
<td>
<p>the total number of calls to the <code>lsf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>the working population.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>the value lsf(X).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xtot</code></td>
<td>
<p>if <code>save.list==TRUE</code>, all the <code>Ncall</code> samples generated by
the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ytot</code></td>
<td>
<p>the value lsf(Xtot).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.hist</code></td>
<td>
<p>if default kernel is used, sigma is initialized with 0.3 and
then further adaptively updated to have an average acceptance rate of 0.3</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Problem is supposed to be defined in the standard space. If not, use <code>UtoX</code>
to do so. Furthermore, each time a set of vector is defined as a matrix, ‘nrow’
= <code>dimension</code> and ‘ncol’ = number of vector to be consistent with
<code>as.matrix</code> transformation of a vector.
</p>
<p>Algorithm calls lsf(X) (where X is a matrix as defined previously) and expects a vector
in return. This allows the user to optimise the computation of a batch of points,
either by vectorial computation, or by the use of external codes (optimised C or
C++ codes for example) and/or parallel computation; see examples in MonteCarlo.
</p>


<h3>Author(s)</h3>

<p>Clement WALTER <a href="mailto:clementwalter@icloud.com">clementwalter@icloud.com</a>
</p>


<h3>References</h3>


<ul>
<li>
<p>S.-K. Au, J. L. Beck:<br><em>Estimation of small failure probabilities in high dimensions by Subset Simulation</em> <br>
Probabilistic Engineering Mechanics (2001)<br></p>
</li>
<li>
<p> A. Guyader, N. Hengartner and E. Matzner-Lober:<br><em>Simulation and estimation of extreme quantiles and extreme
probabilities</em><br>
Applied Mathematics and Optimization, 64(2), 171-196.<br></p>
</li>
<li>
<p> F. Cerou, P. Del Moral, T. Furon and A. Guyader:<br><em>Sequential Monte Carlo for rare event estimation</em><br>
Statistics and Computing, 22(3), 795-808.<br></p>
</li>
</ul>
<h3>See Also</h3>

<p><code>IRW</code>
<code>MP</code>
<code>MonteCarlo</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Try Subset Simulation Monte Carlo on a given function and change number of points.
 
## Not run: 
 res = list()
 res[[1]] = SubsetSimulation(2,kiureghian,N=10000)
 res[[2]] = SubsetSimulation(2,kiureghian,N=100000)
 res[[3]] = SubsetSimulation(2,kiureghian,N=500000)

## End(Not run)

# Compare SubsetSimulation with MP
## Not run: 
p &lt;- res[[3]]$p # get a reference value for p
p_0 &lt;- 0.1 # the default value recommended by Au and Beck
N_mp &lt;- 100
# to get approxumately the same number of calls to the lsf
N_ss &lt;- ceiling(N_mp*log(p)/log(p_0))
comp &lt;- replicate(50, {
ss &lt;- SubsetSimulation(2, kiureghian, N = N_ss)
mp &lt;- MP(2, kiureghian, N = N_mp, q = 0)
comp &lt;- c(ss$p, mp$p, ss$Ncall, mp$Ncall)
names(comp) = rep(c("SS", "MP"), 2)
comp
})
boxplot(t(comp[1:2,])) # check accuracy
sd.comp &lt;- apply(comp,1,sd)
print(sd.comp[1]/sd.comp[2]) # variance increase in SubsetSimulation compared to MP

colMeans(t(comp[3:4,])) # check similar number of calls

## End(Not run)

</code></pre>


</div>