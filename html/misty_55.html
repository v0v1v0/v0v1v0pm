<div class="container">

<table style="width: 100%;"><tr>
<td>item.cfa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Confirmatory Factor Analysis</h2>

<h3>Description</h3>

<p>This function is a wrapper function for conducting confirmatory factor analysis
with continuous and/or ordered-categorical indicators by calling the <code>cfa</code>
function in the R package <span class="pkg">lavaan</span>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">item.cfa(..., data = NULL, model = NULL, rescov = NULL, hierarch = FALSE,
         meanstructure = TRUE, ident = c("marker", "var", "effect"),
         parameterization = c("delta", "theta"), ordered = NULL, cluster = NULL,
         estimator = c("ML", "MLM", "MLMV", "MLMVS", "MLF", "MLR",
                       "GLS", "WLS", "DWLS", "WLSM", "WLSMV",
                       "ULS", "ULSM", "ULSMV", "DLS", "PML"),
         missing = c("listwise", "pairwise", "fiml",
                     "two.stage", "robust.two.stage", "doubly.robust"),
         print = c("all", "summary", "coverage", "descript", "fit", "est",
                   "modind", "resid"),
         mod.minval = 6.63, resid.minval = 0.1, digits = 3, p.digits = 3,
         as.na = NULL, write = NULL, append = TRUE, check = TRUE, output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>a matrix or data frame. If <code>model = NULL</code>,
confirmatory factor analysis based on a measurement
model with one factor labeled <code>f</code> comprising all
variables in the matrix or data frame is conducted.
Note that the cluster variable is excluded from <code>x</code>
when specifying <code>cluster</code>. If <code>model</code> is
specified, the matrix or data frame needs to contain
all variables used in the argument <code>model</code> and
the cluster variable when specifying <code>cluster</code>.
Alternatively, an expression indicating the variable names in
<code>data</code> e.g., <code>item.cfa(x1, x2, x3, data = dat)</code>.
Note that the operators <code>.</code>, <code>+</code>, <code>-</code>, <code>~</code>, <code>:</code>,
<code>::</code>, and <code>!</code> can also be used to select variables,
see 'Details' in the <code>df.subset</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame when specifying one or more variables in the
argument <code>...</code>. Note that the argument is <code>NULL</code>
when specifying a vector, factor, matrix, array, data frame,
or list for the argument <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a character vector specifying a measurement model with
one factor, or a list of character vectors for specifying
a measurement model with more than one factor, e.g.,
<code>model = c("x1", "x2", "x3", "x4")</code> for specifying
a measurement model with one factor labeled <code>f</code>
comprising four indicators, or
<code>model = list(factor1 = c("x1", "x2", "x3", "x4"),
factor2 = c("x5", "x6", "x7", "x8"))</code> for specifying a
measurement model with two latent factors labeled
<code>factor1</code> and <code>factor2</code> each comprising four
indicators. Note that the name of each list element is
used to label factors, i.e., all list elements need to
be named, otherwise factors are labeled with
<code>"f1", "f2", "f3"</code> and so on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescov</code></td>
<td>
<p>a character vector or a list of character vectors for
specifying residual covariances, e.g.
<code>rescov = c("x1", "x2")</code> for specifying a residual
covariance between items <code>x1</code> and <code>x2</code>, or
<code>rescov = list(c("x1", "x2"), c("x3", "x4"))</code> for
specifying residual covariances between items <code>x1</code>
and <code>x2</code>, and items <code>x3</code> and <code>x4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hierarch</code></td>
<td>
<p>logical: if <code>TRUE</code>, a second-order factor model
is specified given at least three first-order factors
were specified in <code>model</code>. Note that it is not
possible to specify more than one second-order factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanstructure</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), intercept/means of
observed variables means of latent variables will be
added to the model. Note that <code>meanstructure = FALSE</code>
is only applicable when the <code>missing</code> is
<code>listwise</code>, <code>pairwise</code>, or <code>doubly-robust</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ident</code></td>
<td>
<p>a character string indicating the method used for
identifying and scaling latent variables, i.e.,
<code>"marker"</code> for the marker variable method fixing
the first factor loading of each latent variable to 1,
<code>"var"</code> for the fixed variance method fixing the
variance of each latent variable to 1, or <code>"effect"</code>
for the effects-coding method using equality constraints
so that the average of the factor loading for each
latent variable equals 1. By default, fixed variance
method is used when <code>hierarch = FALSE</code>, whereas
marker variable method is used when
<code>hierarch = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameterization</code></td>
<td>
<p>a character string indicating the method used for
identifying and scaling latent variables when indicators
are ordered, i.e., <code>"delta"</code> (default) for delta
parameterization and <code>"theta"</code> for theta
parameterization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>if <code>NULL</code> (default), all indicators of the
measurement model are treated as continuous. If
<code>TRUE</code>, all indicators of the measurement model
are treated as ordered (ordinal). Alternatively, a
character vector indicating which variables to treat
as ordered (ordinal) variables can be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>either a character string indicating the variable name
of the cluster variable in <code>...</code> or <code>data</code>,
or a vector representing the nested grouping structure
(i.e., group or cluster variable) for computing
cluster-robust standard errors. Note that cluster-robust
standard errors are not available when treating indicators
of the measurement model as ordered (ordinal).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>
<p>a character string indicating the estimator to be used
(see 'Details'). By default, <code>"MLR"</code> is used for
CFA models with continuous indicators (i.e.,
<code>ordered = FALSE</code>) and <code>"WLSMV"</code> is used for
CFA model with ordered-categorical indicators (i.e.,
ordered = TRUE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>
<p>a character string indicating how to deal with missing
data, i.e., <code>"listwise"</code> for listwise deletion,
<code>"pairwise"</code> for pairwise deletion, <code>"fiml"</code>
for full information maximum likelihood method,
<code>two.stage</code> for two-stage maximum likelihood
method, <code>robust.two.stage</code> for robust two-stage
maximum likelihood method, and <code>doubly-robust</code>
for doubly-robust method (see 'Details'). By default,
<code>"fiml"</code> is used for CFA models with continuous
indicators which are estimated by using
<code>estimator = "MLR"</code>, and <code>"pairwise"</code> for
CFA models with ordered-categorical indicators which
are estimated by using <code>estimator = "pairwise"</code>
by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print</code></td>
<td>
<p>a character string or character vector indicating which
results to show on the console, i.e. <code>"all"</code> for
all results, <code>"summary"</code> for a summary of the
specification of the estimation method and missing
data handling in lavaan, <code>"coverage"</code> for the
variance-covariance coverage of the data,
<code>"descript"</code> for descriptive statistics,
<code>"fit"</code> for model fit, <code>"est"</code> for parameter
estimates, <code>"modind"</code> for modification
indices and <code>"resid"</code> for the residual correlation
matrix and standardized residual means By default, a
summary of the specification, model fit, and parameter
estimates are printed.. By default, a summary of the specification,
model fit, and parameter estimates are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.minval</code></td>
<td>
<p>numeric value to filter modification indices and only
show modifications with a modification index value equal
or higher than this minimum value. By default, modification
indices equal or higher 6.63 are printed. Note that a
modification index value of 6.63 is equivalent to a
significance level of <code class="reqn">\alpha = .01</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid.minval</code></td>
<td>
<p>numeric value indicating the minimum absolute residual
correlation coefficients and standardized means to
highlight in boldface. By default, absolute residual
correlation coefficients and standardized means equal
or higher 0.1 are highlighted. Note that highlighting
can be disabled by setting the minimum value to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>an integer value indicating the number of decimal places
to be used for displaying results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.digits</code></td>
<td>
<p>an integer value indicating the number of decimal places
to be used for displaying the <em>p</em>-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.na</code></td>
<td>
<p>a numeric vector indicating user-defined missing values,
i.e. these values are converted to <code>NA</code> before
conducting the analysis. Note that <code>as.na()</code>
function is only applied to <code>x</code> but not to
<code>cluster</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write</code></td>
<td>
<p>a character string naming a file for writing the output into
either a text file with file extension <code>".txt"</code> (e.g.,
<code>"Output.txt"</code>) or Excel file with file extension
<code>".xlsx"</code>  (e.g., <code>"Output.xlsx"</code>). If the file
name does not contain any file extension, an Excel file will
be written.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>append</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), output will be appended
to an existing text file with extension <code>.txt</code> specified
in <code>write</code>, if <code>FALSE</code> existing text file will be
overwritten.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), argument specification is checked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), output is shown.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<dl>
<dt><strong>Estimator</strong></dt>
<dd>
<p>The R package <span class="pkg">lavaan</span> provides seven estimators
that affect the estimation, namely <code>"ML"</code>, <code>"GLS"</code>, <code>"WLS"</code>,
<code>"DWLS"</code>, <code>"ULS"</code>, <code>"DLS"</code>, and <code>"PML"</code>. All other options
for the argument <code>estimator</code> combine these estimators with various standard
error and chi-square test statistic computation. Note that the estimators also
differ in how missing values can be dealt with (e.g., listwise deletion,
pairwise deletion, or full information maximum likelihood, FIML).
</p>

<ul>
<li>
<p><code>"ML"</code>: Maximum likelihood parameter estimates with conventional standard errors
and conventional test statistic. For both complete and incomplete data
using pairwise deletion or FIML.
</p>
</li>
<li>
<p><code>"MLM"</code>: Maximum likelihood parameter estimates with conventional
robust standard errors and a Satorra-Bentler scaled test statistic that
are robust to non-normality. For complete data only.
</p>
</li>
<li>
<p><code>"MLMV"</code>: Maximum likelihood parameter estimates with conventional
robust standard errors and a mean and a variance adjusted test statistic
using a scale-shifted approach that are robust to non-normality. For complete
data only.
</p>
</li>
<li>
<p><code>"MLMVS"</code>: Maximum likelihood parameter estimates with conventional
robust standard errors and a mean and a variance adjusted test statistic
using the Satterthwaite approach that are robust to non-normality. For complete
data only.
</p>
</li>
<li>
<p><code>"MLF"</code>: Maximum likelihood parameter estimates with standard
errors approximated by first-order derivatives and conventional test statistic.
For both complete and incomplete data using pairwise deletion or FIML.
</p>
</li>
<li>
<p><code>"MLR"</code>: Maximum likelihood parameter estimates with Huber-White
robust standard errors a test statistic which is asymptotically equivalent
to the Yuan-Bentler T2* test statistic that are robust to non-normality
and non-independence of observed when specifying a cluster variable using
the argument <code>cluster</code>. For both complete and incomplete data using
pairwise deletion or FIML.
</p>
</li>
<li>
<p><code>"GLS"</code>: Generalized least squares parameter estimates with
conventional standard errors and conventional test statistic that uses a
normal-theory based weight matrix. For complete data only.
and conventional chi-square test. For both complete and incomplete data.
</p>
</li>
<li>
<p><code>"WLS"</code>: Weighted least squares parameter estimates (sometimes
called ADF estimation) with conventional standard errors and conventional
test statistic that uses a full weight matrix. For complete data only.
</p>
</li>
<li>
<p><code>"DWLS"</code>: Diagonally weighted least squares parameter estimates
which uses the diagonal of the weight matrix for estimation with conventional
standard errors and conventional test statistic. For both complete and
incomplete data using pairwise deletion.
</p>
</li>
<li>
<p><code>"WLSM"</code>: Diagonally weighted least squares parameter estimates
which uses the diagonal of the weight matrix for estimation, but uses the
full weight matrix for computing the conventional robust standard errors
and a Satorra-Bentler scaled test statistic. For both complete and incomplete
data using pairwise deletion.
</p>
</li>
<li>
<p><code>"WLSMV"</code>: Diagonally weighted least squares parameter estimates
which uses the diagonal of the weight matrix for estimation, but uses the
full weight matrix for computing the conventional robust standard errors
and a mean and a variance adjusted test statistic using a scale-shifted
approach. For both complete and incomplete data using pairwise deletion.
</p>
</li>
<li>
<p><code>"ULS"</code>: Unweighted least squares parameter estimates with
conventional standard errors and conventional test statistic. For both
complete and incomplete data using pairwise deletion.
</p>
</li>
<li>
<p><code>"ULSM"</code>: Unweighted least squares parameter estimates with
conventional robust standard errors and a Satorra-Bentler scaled test
statistic. For both complete and incomplete data using pairwise deletion.
</p>
</li>
<li>
<p><code>"ULSMV"</code>: Unweighted least squares parameter estimates with
conventional robust standard errors and a mean and a variance adjusted
test statistic using a scale-shifted approach. For both complete and
incomplete data using pairwise deletion.
</p>
</li>
<li>
<p><code>"DLS"</code>: Distributionally-weighted least squares parameter
estimates with conventional robust standard errors and a Satorra-Bentler
scaled test statistic. For complete data only.
</p>
</li>
<li>
<p><code>"PML"</code>: Pairwise maximum likelihood parameter estimates
with Huber-White robust standard errors and a mean and a variance adjusted
test statistic using the Satterthwaite approach. For both complete and
incomplete data using pairwise deletion.
</p>
</li>
</ul>
</dd>
<dt><strong>Missing Data</strong></dt>
<dd>
<p>The R package <span class="pkg">lavaan</span> provides six methods
for dealing with missing data:
</p>

<ul>
<li>
<p><code>"listwise"</code>: Listwise deletion, i.e., all cases with missing
values are removed from the data before conducting the analysis. This is
only valid if the data are missing completely at random (MCAR).
</p>
</li>
<li>
<p><code>"pairwise"</code>: Pairwise deletion, i.e., each element of a
variance-covariance matrix is computed using cases that have data needed
for estimating that element. This is only valid if the data are missing
completely at random (MCAR).
</p>
</li>
<li>
<p><code>"fiml"</code>: Full information maximum likelihood (FIML) method,
i.e., likelihood is computed case by case using all available data from
that case. FIML method is only applicable for following estimators:
<code>"ML"</code>, <code>"MLF"</code>, and <code>"MLR"</code>.
</p>
</li>
<li>
<p><code>"two.stage"</code>: Two-stage maximum likelihood estimation, i.e.,
sample statistics is estimated using EM algorithm in the first step. Then,
these estimated sample statistics are used as input for a regular analysis.
Standard errors and test statistics are adjusted correctly to reflect the
two-step procedure. Two-stage method is only applicable for following
estimators: <code>"ML"</code>, <code>"MLF"</code>, and <code>"MLR"</code>.
</p>
</li>
<li>
<p><code>"robust.two.stage"</code>: Robust two-stage maximum likelihood
estimation, i.e., two-stage maximum likelihood estimation with standard
errors and a test statistic that are robust against non-normality. Robust
two-stage method is only applicable for following estimators: <code>"ML"</code>,
<code>"MLF"</code>, and <code>"MLR"</code>.
</p>
</li>
<li>
<p><code>"doubly.robust"</code>: Doubly-robust method only applicable for
pairwise maximum likelihood estimation (i.e., <code>estimator = "PML"</code>.
</p>
</li>
</ul>
</dd>
<dt><strong>Convergence and model idenfitification checks</strong></dt>
<dd>
<p>In line with the
R package <span class="pkg">lavaan</span>, this functions provides several checks for model
convergence and model identification:
</p>

<ul>
<li>
<p><code>Degrees of freedom</code>: An error message is printed if the number
of degrees of freedom is negative, i.e., the model is not identified.
</p>
</li>
<li>
<p><code>Model convergence</code>: An error message is printed if the
optimizer has not converged, i.e., results are most likely unreliable.
</p>
</li>
<li>
<p><code>Standard errors</code>: An error message is printed if the standard
errors could not be computed, i.e., the model might not be identified.
</p>
</li>
<li>
<p><code>Variance-covariance matrix of the estimated parameters</code>: A
warning message is printed if the variance-covariance matrix of the
estimated parameters is not positive definite, i.e., the smallest eigenvalue
of the matrix is smaller than zero or very close to zero.
</p>
</li>
<li>
<p><code>Negative variances of observed variables</code>: A warning message
is printed if the estimated variances of the observed variables are
negative.
</p>
</li>
<li>
<p><code>Variance-covariance matrix of observed variables</code>: A warning
message is printed if the estimated variance-covariance matrix of the
observed variables is not positive definite, i.e., the smallest eigenvalue
of the matrix is smaller than zero or very close to zero.
</p>
</li>
<li>
<p><code>Negative variances of latent variables</code>: A warning message
is printed if the estimated variances of the latent variables are
negative.
</p>
</li>
<li>
<p><code>Variance-covariance matrix of latent variables</code>: A warning
message is printed if the estimated variance-covariance matrix of the
latent variables is not positive definite, i.e., the smallest eigenvalue
of the matrix is smaller than zero or very close to zero.
</p>
</li>
</ul>
<p>Note that unlike the R package <span class="pkg">lavaan</span>, the <code>item.cfa</code> function does
not provide any results when the degrees of freedom is negative, the model
has not converged, or standard errors could not be computed.
</p>
</dd>
<dt><strong>Model Fit</strong></dt>
<dd>
<p>The <code>item.cfa</code> function provides the chi-square
test, incremental fit indices (i.e., CFI and TLI), and absolute fit indices
(i.e., RMSEA, and SRMR) to evaluate overall model fit. However, different
versions of the CFI, TLI, and RMSEA are provided depending on the estimator.
Unlike the R package <span class="pkg">lavaan</span>, the different versions are labeled with
<code>Standard</code>, <code>Scaled</code>, and <code>Robust</code> in the output:
</p>

<ul>
<li>
<p><code>"Standard"</code>: CFI, TLI, and RMSEA without any non-normality
corrections. These fit measures based on the normal theory maximum
likelihood test statistic are sensitive to deviations from multivariate
normality of endogenous variables. Simulation studies by Brosseau-Liard
et al. (2012), and Brosseau-Liard and Savalei (2014) showed that the
uncorrected fit indices are affected by non-normality, especially at small
and medium sample sizes (e.g., n &lt; 500).
</p>
</li>
<li>
<p><code>"Scaled"</code>: Population-corrected robust CFI, TLI, and RMSEA
with ad hoc non-normality corrections that simply replace the maximum
likelihood test statistic with a robust test statistic (e.g., mean-adjusted
chi-square). These fit indices change the population value being estimated
depending on the degree of non-normality present in the data. Brosseau-Liard
et al. (2012) demonstrated that the ad hoc corrected RMSEA increasingly
accepts poorly fitting models as non-normality in the data increases, while
the effect of the ad hoc correction on the CFI and TLI is less predictable
with non-normality making fit appear worse, better, or nearly unchanged
(Brosseau-Liard &amp; Savalei, 2014).
</p>
</li>
<li>
<p><code>"Robust"</code>: Sample-corrected robust CFI, TLI, and RMSEA
with non-normality corrections based on formula provided by Li and Bentler
(2006) and Brosseau-Liard and Savalei (2014). These fit indices do not
change the population value being estimated and can be interpreted the
same way as the uncorrected fit indices when the data would have been
normal.
</p>
</li>
</ul>
<p>In conclusion, the use of sample-corrected fit indices (<code>Robust</code>)
instead of population-corrected fit indices (<code>Scaled</code>) is recommended.
Note that when sample size is very small (e.g., n &lt; 200), non-normality
correction does not appear to adjust fit indices sufficiently to counteract
the effect of non-normality (Brosseau-Liard &amp; Savalei, 2014).
</p>
</dd>
<dt><strong>Modification Indices and Residual Correlation Matrix</strong></dt>
<dd>
<p>The <code>item.cfa</code>
function provides modification indices and the residual correlation matrix when
requested by using the <code>print</code> argument. Modification indices (aka score
tests) are univariate Lagrange Multipliers (LM) representing a chi-square
statistic with a single degree of freedom. LM approximates the amount by which
the chi-square test statistic would decrease if a fixed or constrained parameter
is freely estimated (Kline, 2023). However, (standardized) expected parameter
change (EPC) values should also be inspected since modification indices are
sensitive to sample size. EPC values are an estimate of how much the parameter
would be expected to change if it were freely estimated (Brown, 2023). The residual
correlation matrix is computed by separately converting the sample covariance
and model-implied covariance matrices to correlation matrices before calculation
differences between observed and predicted covariances (i.e., <code>type = "cor.bollen"</code>).
As a rule of thumb, absolute correlation residuals greater than .10 indicate
possible evidence for poor local fit, whereas smaller correlation residuals
than 0.05 indicate negligible degree of model misfit (Maydeu-Olivares, 2017).
There is no reliable connection between the size of diagnostic statistics
(i.e., modification indices and residuals) and the type or amount of model
misspecification since (1) diagnostic statistics are themselves affected by
misspecification, (2) misspecification in one part of the model distorts estimates
in other parts of the model (i.e., error propagation), and (3) equivalent models
have identical residuals but contradict the pattern of causal effects (Kline, 2023).
Note that according to Kline' (2023) "any report of the results without information
about the residuals is deficient" (p. 172).</p>
</dd>
</dl>
<h3>Value</h3>

<p>Returns an object of class <code>misty.object</code>, which is a list with following
entries:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>function call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>matrix or data frame specified in <code>x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args</code></td>
<td>
<p>specification of function arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>specified model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.fit</code></td>
<td>
<p>fitted lavaan object (<code>mod.fit</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>results of the convergence and model identification check</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result</code></td>
<td>
<p>list with result tables, i.e., <code>summary</code> for the
specification of the estimation method and missing data
handling in lavaan, <code>"coverage"</code> for the
variance-covariance coverage of the data, <code>"descript"</code>
for descriptive statistics, <code>itemfreq</code> for absolute
frequencies (<code>freq</code>), percentages (<code>perc</code>),
and  (<code>v.perc</code>) valid percentages, <code>"fit"</code> for
model fit, <code>"param"</code> for parameter estimates, and
<code>"modind"</code> for modification indices.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The function uses the functions <code>cfa</code>, <code>lavInspect</code>, <code>lavTech</code>,
<code>modindices</code>, <code>parameterEstimates</code>, and <code>standardizedsolution</code>
provided in the R package <span class="pkg">lavaan</span> by Yves Rosseel (2012).
</p>


<h3>Author(s)</h3>

<p>Takuya Yanagida <a href="mailto:takuya.yanagida@univie.ac.at">takuya.yanagida@univie.ac.at</a>
</p>


<h3>References</h3>

<p>Brosseau-Liard, P. E., Savalei, V., &amp; Li. L. (2012). An investigation of the
sample performance of two nonnormality corrections for RMSEA,
<em>Multivariate Behavioral Research, 47</em>, 904-930.
https://doi.org/10.1080/00273171.2014.933697
</p>
<p>Brosseau-Liard, P. E., &amp; Savalei, V. (2014) Adjusting incremental fit indices
for nonnormality. <em>Multivariate Behavioral Research, 49</em>, 460-470.
https://doi.org/10.1080/00273171.2014.933697
</p>
<p>Brown, T. A. (2023). Confirmatory factor analysis. In R. H. Hoyle (Ed.),
<em>Handbook of structural equation modeling</em> (2nd ed.) (pp. 361–379). The
Guilford Press.
</p>
<p>Kline, R. B. (2023). <em>Principles and practice of structural equation modeling</em> (5th ed.).
Guilford Press.
</p>
<p>Li, L., &amp; Bentler, P. M. (2006). Robust statistical tests for evaluating the
hypothesis of close fit of misspecified mean and covariance structural models.
<em>UCLA Statistics Preprint #506</em>. University of California.
</p>
<p>Maydeu-Olivares, A. (2017). Assessing the size of model misfit in structural
equation models. <em>Psychometrika, 82</em>(3), 533–558. https://doi.org/10.1007/s11336-016-9552-7
</p>
<p>Rosseel, Y. (2012). lavaan: An R Package for Structural Equation Modeling.
<em>Journal of Statistical Software, 48</em>, 1-36. https://doi.org/10.18637/jss.v048.i02
</p>


<h3>See Also</h3>

<p><code>item.alpha</code>, <code>item.omega</code>, <code>item.scores</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Load data set "HolzingerSwineford1939" in the lavaan package
data("HolzingerSwineford1939", package = "lavaan")

#----------------------------------------------------------------------------
# Measurement model with one factor

# Example 1a: Specification using the argument 'x'
item.cfa(HolzingerSwineford1939[, c("x1", "x2", "x3")])

# Example 1b: Alternative specification using the 'data' argument
item.cfa(x1:x3, data = HolzingerSwineford1939)

# Example 1c: Alternative specification using the argument 'model'
item.cfa(HolzingerSwineford1939, model = c("x1", "x2", "x3"))

# Example 1d: Alternative specification using the 'data' and 'model' argument
item.cfa(., data = HolzingerSwineford1939, model = c("x1", "x2", "x3"))

# Example 1e: Alternative specification using the argument 'model'
item.cfa(HolzingerSwineford1939, model = list(visual = c("x1", "x2", "x3")))

# Example 1f: Alternative specification using the  'data' and 'model' argument
item.cfa(., data = HolzingerSwineford1939, model = list(visual = c("x1", "x2", "x3")))

#----------------------------------------------------------------------------
# Measurement model with three factors

# Example 2: Specification using the argument 'model'
item.cfa(HolzingerSwineford1939,
         model = list(visual = c("x1", "x2", "x3"),
                      textual = c("x4", "x5", "x6"),
                      speed = c("x7", "x8", "x9")))

#----------------------------------------------------------------------------
# Residual covariances

# Example 3a: One residual covariance
item.cfa(HolzingerSwineford1939,
         model = list(visual = c("x1", "x2", "x3"),
                      textual = c("x4", "x5", "x6"),
                      speed = c("x7", "x8", "x9")),
         rescov = c("x1", "x2"))

# Example 3b: Two residual covariances
item.cfa(HolzingerSwineford1939,
         model = list(visual = c("x1", "x2", "x3"),
                      textual = c("x4", "x5", "x6"),
                      speed = c("x7", "x8", "x9")),
         rescov = list(c("x1", "x2"), c("x4", "x5")))

#----------------------------------------------------------------------------
# Second-order factor model based on three first-order factors

# Example 4
item.cfa(HolzingerSwineford1939,
         model = list(visual = c("x1", "x2", "x3"),
                      textual = c("x4", "x5", "x6"),
                      speed = c("x7", "x8", "x9")),
         hierarch = TRUE)

#----------------------------------------------------------------------------
# Measurement model with ordered-categorical indicators

# Example 5
item.cfa(round(HolzingerSwineford1939[, c("x4", "x5", "x6")]), ordered = TRUE)

#----------------------------------------------------------------------------
# Cluster-robust standard errors

# Load data set "Demo.twolevel" in the lavaan package
data("Demo.twolevel", package = "lavaan")

# Example 6a: Specification using a variable in 'x'
item.cfa(Demo.twolevel[, c("y4", "y5", "y6", "cluster")], cluster = "cluster")

# Example 6b: Specification of the cluster variable in 'cluster'
item.cfa(Demo.twolevel[, c("y4", "y5", "y6")], cluster = Demo.twolevel$cluster)

# Example 6c: Alternative specification using the 'data' argument
item.cfa(y4:y6, data = Demo.twolevel, cluster = "cluster")

#----------------------------------------------------------------------------
# Print argument

# Example 7a: Request all results
item.cfa(HolzingerSwineford1939[, c("x1", "x2", "x3")], print = "all")

# Example 7b: Request modification indices with value equal or higher than 5
item.cfa(HolzingerSwineford1939[, c("x1", "x2", "x3", "x4")],
         print = "modind", mod.minval = 5)

#----------------------------------------------------------------------------
# lavaan summary of the estimated model

# Example 8
mod &lt;- item.cfa(HolzingerSwineford1939[, c("x1", "x2", "x3")], output = FALSE)

lavaan::summary(mod$model.fit, standardized = TRUE, fit.measures = TRUE)

#----------------------------------------------------------------------------
# Write Results

# Example 9a: Write results into a text file
item.cfa(HolzingerSwineford1939[, c("x1", "x2", "x3")], write = "CFA.txt")

# Example 9b: Write results into an Excel file
item.cfa(HolzingerSwineford1939[, c("x1", "x2", "x3")], write = "CFA.xlsx")

result &lt;- item.cfa(HolzingerSwineford1939[, c("x1", "x2", "x3")], output = FALSE)
write.result(result, "CFA.xlsx")

## End(Not run)
</code></pre>


</div>