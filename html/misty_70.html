<div class="container">

<table style="width: 100%;"><tr>
<td>multilevel.cfa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multilevel Confirmatory Factor Analysis</h2>

<h3>Description</h3>

<p>This function is a wrapper function for conducting multilevel confirmatory factor
analysis to investigate four types of constructs, i.e., within-cluster constructs,
shared cluster-level constructs, configural cluster constructs, and simultaneous
shared and configural cluster constructs by calling the <code>cfa</code> function in
the R package <span class="pkg">lavaan</span>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multilevel.cfa(..., data = NULL, cluster, model = NULL, rescov = NULL,
               model.w = NULL, model.b = NULL, rescov.w = NULL, rescov.b = NULL,
               const = c("within", "shared", "config", "shareconf"),
               fix.resid = NULL, ident = c("marker", "var", "effect"),
               ls.fit = FALSE, estimator = c("ML", "MLR"),
               optim.method = c("nlminb", "em"), missing = c("listwise", "fiml"),
               print = c("all", "summary", "coverage", "descript", "fit", "est",
                         "modind", "resid"),
               mod.minval = 6.63, resid.minval = 0.1, digits = 3, p.digits = 3,
               as.na = NULL, write = NULL, append = TRUE, check = TRUE, output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>a matrix or data frame. If <code>model</code>, <code>model.w</code>,
and <code>model.b</code> are <code>NULL</code>, multilevel confirmatory
factor analysis based on a measurement model with one factor
labeled <code>wf</code> at the Within level and one factor labeled
<code>bf</code> at the Between level comprising all variables in
the matrix or data frame is conducted. Note that the cluster
variable specified in <code>cluster</code> is excluded from <code>...</code>
when specifying the argument <code>cluster</code> using the variable
name of the cluster variable. If <code>model</code> or <code>mode.w</code>
and <code>model.b</code> is specified, the matrix or data frame
needs to contain all variables used in the <code>model</code>
argument(s). Alternatively, an expression indicating
the variable names in <code>data</code>.
Note that the operators <code>.</code>, <code>+</code>, <code>-</code>,
<code>~</code>, <code>:</code>, <code>::</code>, and <code>!</code> can also be
used to select variables, see 'Details' in the
<code>df.subset</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame when specifying one or more variables in the
argument <code>...</code>. Note that the argument is <code>NULL</code>
when specifying a matrix or data frame for the argument <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>either a character string indicating the variable name of
the cluster variable in <code>...</code> or <code>data</code>, or a
vector representing the nested grouping structure (i.e.,
group or cluster variable).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a character vector for specifying the same factor structure
with one factor at the Within and Between Level, or a list
of character vectors for specifying the same measurement
model with more than one factor at the Within and Between
Level, e.g.,<code>model = c("x1", "x2", "x3", "x4")</code> for
specifying a measurement model with one factor labeled <code>wf</code>
at the Within level and a measurement model with one factor
labeled <code>bf</code> at the Between level each comprising four
indicators, or <code>model = list(factor1 = c("x1", "x2", "x3", "x4"),
factor2 = c("x5", "x6", "x7", "x8"))</code> for specifying a
measurement model with two latent factors labeled <code>wfactor1</code>
and <code>wfactor2</code> at the Within level and a measurement
model with two latent factors labeled <code>bfactor1</code> and
<code>bfactor2</code> at the Between level each comprising four
indicators. Note that the name of each list element is used
to label factors, where prefixes <code>w</code> and <code>b</code> are
added the labels to distinguish factor labels at the Within
and Between level, i.e., all list elements need to be named,
otherwise factors are labeled with <code>"wf1", "wf2", "wf3"</code>
for labels at the Within level and <code>"bf1", "bf2", "bf3"</code>
for labels at the Between level and so on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescov</code></td>
<td>
<p>a character vector or a list of character vectors for specifying
residual covariances at the Within level, e.g. <code>rescov = c("x1", "x2")</code>
for specifying a residual covariance between indicators <code>x1</code>
and <code>x2</code> at the Within level or <code>rescov = list(c("x1", "x2"), c("x3", "x4"))</code>
for specifying residual covariances between indicators <code>x1</code>
and <code>x2</code>, and indicators <code>x3</code> and <code>x4</code> at
the Within level. Note that residual covariances at the
Between level can only be specified by using the arguments
<code>model.w</code>, <code>model.b</code>, and <code>model.b</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.w</code></td>
<td>
<p>a character vector specifying a measurement model with one
factor at the Within level, or a list of character vectors
for specifying a measurement model with more than one factor
at the Within level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.b</code></td>
<td>
<p>a character vector specifying a measurement model with one
factor at the Between level, or a list of character vectors
for specifying a measurement model with more than one factor
at the Between level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescov.w</code></td>
<td>
<p>a character vector or a list of character vectors for
specifying residual covariances at the Within level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescov.b</code></td>
<td>
<p>a character vector or a list of character vectors for
specifying residual covariances at the Between level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>
<p>a character string indicating the type of construct(s), i.e.,
<code>"within"</code> for within-cluster constructs, <code>"shared"</code>
for shared cluster-level constructs, <code>"config"</code> (default)
for configural cluster constructs, and <code>"shareconf"</code>
for simultaneous shared and configural cluster constructs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix.resid</code></td>
<td>
<p>a character vector for specifying residual variances to be
fixed at 0 at the Between level, e.g., <code>fix.resid = c("x1", "x3")</code>
to fix residual variances of indicators <code>x1</code> and <code>x2</code>
at the Between level at 0. Note that it is also possible
to specify <code>fix.resid = "all"</code> which fixes all residual
variances at the Between level at 0 in line with the strong
factorial measurement invariance assumption across cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ident</code></td>
<td>
<p>a character string indicating the method used for identifying
and scaling latent variables, i.e., <code>"marker"</code> for the
marker variable method fixing the first factor loading of
each latent variable to 1, <code>"var"</code> for the fixed variance
method fixing the variance of each latent variable to 1,
or <code>"effect"</code> for the effects-coding method using equality
constraints so that the average of the factor loading for
each latent variable equals 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ls.fit</code></td>
<td>
<p>logical: if <code>TRUE</code> (default) level-specific fit indices
are computed when specifying a model using the arguments
<code>model.w</code> and <code>model.b</code> given the model does not
contain any cross-level equality constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>
<p>a character string indicating the estimator to be used:
<code>"ML"</code> for maximum likelihood with conventional standard
errors and <code>"MLR"</code> (default) for maximum likelihood
with Huber-White robust standard errors and a scaled test
statistic that is asymptotically equal to the Yuan-Bentler
test statistic. Note that by default, full information maximum
likelihood (FIML) method is used to deal with missing data
when using <code>"ML"</code> (<code>missing = "fiml"</code>), whereas
incomplete cases are removed listwise (i.e., <code>missing = "listwise"</code>)
when using <code>"MLR"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.method</code></td>
<td>
<p>a character string indicating the optimizer, i.e., <code>"nlminb"</code>
(default) for the unconstrained and bounds-constrained
quasi-Newton method optimizer and <code>"em"</code> for the
Expectation Maximization (EM) algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>
<p>a character string indicating how to deal with missing data,
i.e., <code>"listwise"</code> (default) for listwise deletion or
<code>"fiml"</code> for full information maximum likelihood (FIML)
method. Note that FIML method is only available when <code>estimator = "ML"</code>,
that it takes longer to estimate the model  using FIML, and
that FIML is prone to convergence issues which might be
resolved by switching to listwise deletion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print</code></td>
<td>
<p>a character string or character vector indicating which
results to show on the console, i.e. <code>"all"</code> for all
results, <code>"summary"</code> for a summary of the specification
of the estimation method and missing data handling in lavaan,
<code>"coverage"</code> for the variance-covariance coverage of
the data, <code>"descript"</code> for descriptive statistics,
<code>"fit"</code> for model fit,  <code>"est"</code> for parameter
estimates, and <code>"modind"</code> for modification indices.
By default, a summary of the specification, descriptive
statistics, model fit, and parameter estimates are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.minval</code></td>
<td>
<p>numeric value to filter modification indices and only
show modifications with a modification index value equal
or higher than this minimum value. By default, modification
indices equal or higher 6.63 are printed. Note that a
modification index value of 6.63 is equivalent to a
significance level of <code class="reqn">\alpha = .01</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid.minval</code></td>
<td>
<p>numeric value indicating the minimum absolute residual
correlation coefficients and standardized means to
highlight in boldface. By default, absolute residual
correlation coefficients and standardized means equal
or higher 0.1 are highlighted. Note that highlighting
can be disabled by setting the minimum value to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>an integer value indicating the number of decimal places
to be used for displaying results. Note that loglikelihood,
information criteria and chi-square test statistic is
printed with <code>digits</code> minus 1 decimal places.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.digits</code></td>
<td>
<p>an integer value indicating the number of decimal places
to be used for displaying the <em>p</em>-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.na</code></td>
<td>
<p>a numeric vector indicating user-defined missing values,
i.e. these values are converted to <code>NA</code> before conducting
the analysis. Note that <code>as.na()</code> function is only
applied to <code>x</code> but not to <code>cluster</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>write</code></td>
<td>
<p>a character string naming a file for writing the output into
either a text file with file extension <code>".txt"</code> (e.g.,
<code>"Output.txt"</code>) or Excel file with file extension
<code>".xlsx"</code>  (e.g., <code>"Output.xlsx"</code>). If the file
name does not contain any file extension, an Excel file will
be written.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>append</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), output will be appended
to an existing text file with extension <code>.txt</code> specified
in <code>write</code>, if <code>FALSE</code> existing text file will be
overwritten.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), argument specification, convergence
and model identification is checked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), output is shown.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns an object of class <code>misty.object</code>, which is a list with following
entries:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>function call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data frame used for the current analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args</code></td>
<td>
<p>specification of function arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>specified model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.fit</code></td>
<td>
<p>fitted lavaan object (<code>mod.fit</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>results of the convergence and model identification check</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result</code></td>
<td>
<p>list with result tables, i.e., <code>summary</code> for the
summary of the specification of the estimation method
and missing data handling in lavaan, <code>coverage</code> for
the variance-covariance coverage of the data, <code>descript</code>
for descriptive statistics, <code>fit</code> for model fit,
<code>est</code> for parameter estimates, and <code>modind</code>
for modification indices.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The function uses the functions <code>cfa</code>, <code>lavInspect</code>, <code>lavTech</code>,
<code>modindices</code>, <code>parameterEstimates</code>, and <code>standardizedsolution</code>
provided in the R package <span class="pkg">lavaan</span> by Yves Rosseel (2012).
</p>


<h3>Author(s)</h3>

<p>Takuya Yanagida <a href="mailto:takuya.yanagida@univie.ac.at">takuya.yanagida@univie.ac.at</a>
</p>


<h3>References</h3>

<p>Rosseel, Y. (2012). lavaan: An R Package for Structural Equation Modeling.
<em>Journal of Statistical Software, 48</em>, 1-36. https://doi.org/10.18637/jss.v048.i02
</p>


<h3>See Also</h3>

<p><code>item.cfa</code>, <code>multilevel.fit</code>, <code>multilevel.invar</code>,
<code>multilevel.omega</code>, <code>multilevel.cor</code>, <code>multilevel.descript</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Load data set "Demo.twolevel" in the lavaan package
data("Demo.twolevel", package = "lavaan")

#----------------------------------------------------------------------------
# Model specification using 'x' for a one-factor model
# with the same factor structure with one factor at the Within and Between Level

#..........
# Cluster variable specification

# Example 1a: Cluster variable 'cluster' in 'x'
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4", "cluster")], cluster = "cluster")

# Example 1b: Cluster variable 'cluster' not in 'x'
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster)

# Example 1c: Alternative specification using the 'data' argument
multilevel.cfa(y1:y4, data = Demo.twolevel, cluster = "cluster")

#..........
# Type of construct

# Example 2a: Within-cluster constructs
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
               const = "within")

# Example 2b: Shared cluster-level construct
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
               const = "shared")

# Example 2c: Configural cluster construct (default)
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
               const = "config")

# Example 2d: Simultaneous shared and configural cluster construct
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
               const = "shareconf")

#..........
# Residual covariances at the Within level

# Example 3a: Residual covariance between 'y1' and 'y3'
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
               rescov = c("y1", "y3"))

# Example 3b: Residual covariance between 'y1' and 'y3', and 'y2' and 'y4'
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
               rescov = list(c("y1", "y3"), c("y2", "y4")))

#..........
# Residual variances at the Between level fixed at 0

# Example 4a: All residual variances fixed at 0
# i.e., strong factorial invariance across clusters
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
               fix.resid = "all")

# Example 4b: Fesidual variances of 'y1', 'y2', and 'y4' fixed at 0
# i.e., partial strong factorial invariance across clusters
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
               fix.resid = c("y1", "y2", "y4"))

#..........
# Print all results

# Example 5: Set minimum value for modification indices to 1
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
               print = "all", mod.minval = 1)

#..........
# Example 6: lavaan model and summary of the estimated model

mod &lt;- multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
                      output = FALSE)

# lavaan model syntax
cat(mod$model)

# Fitted lavaan object
lavaan::summary(mod$model.fit, standardized = TRUE, fit.measures = TRUE)

#..........
# Write results

# Example 7a: Assign results into an object and write results into an Excel file
mod &lt;- multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
                      print = "all", write = "Multilevel_CFA.txt", output = FALSE)

# Example 7b: Assign results into an object and write results into an Excel file
mod &lt;- multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
                      print = "all", output = FALSE)

# Write results into an Excel file
write.result(mod, "Multilevel_CFA.xlsx")

# Estimate model and write results into an Excel file
multilevel.cfa(Demo.twolevel[, c("y1", "y2", "y3", "y4")], cluster = Demo.twolevel$cluster,
               print = "all", write = "Multilevel_CFA.xlsx")

#----------------------------------------------------------------------------
# Model specification using 'model' for one or multiple factor model
# with the same factor structure at the Within and Between Level

# Example 8a: One-factor model
multilevel.cfa(Demo.twolevel, cluster = "cluster", model = c("y1", "y2", "y3", "y4"))

# Example 8b: Two-factor model
multilevel.cfa(Demo.twolevel, cluster = "cluster",
               model = list(c("y1", "y2", "y3"), c("y4", "y5", "y6")))

# Example 8c: Two-factor model with user-specified labels for the factors
multilevel.cfa(Demo.twolevel, cluster = "cluster",
               model = list(factor1 = c("y1", "y2", "y3"), factor2 = c("y4", "y5", "y6")))

#..........
# Type of construct

# Example 9a: Within-cluster constructs
multilevel.cfa(Demo.twolevel, cluster = "cluster", const = "within",
               model = list(c("y1", "y2", "y3"), c("y4", "y5", "y6")))

# Example 9b: Shared cluster-level construct
multilevel.cfa(Demo.twolevel, cluster = "cluster", const = "shared",
               model = list(c("y1", "y2", "y3"), c("y4", "y5", "y6")))

# Example 9c: Configural cluster construct (default)
multilevel.cfa(Demo.twolevel, cluster = "cluster", const = "config",
               model = list(c("y1", "y2", "y3"), c("y4", "y5", "y6")))

# Example 9d: Simultaneous shared and configural cluster construct
multilevel.cfa(Demo.twolevel, cluster = "cluster", const = "shareconf",
               model = list(c("y1", "y2", "y3"), c("y4", "y5", "y6")))

#..........
# Residual covariances at the Within level

# Example 10a: Residual covariance between 'y1' and 'y4' at the Within level
multilevel.cfa(Demo.twolevel, cluster = "cluster",
               model = list(c("y1", "y2", "y3"), c("y4", "y5", "y6")),
               rescov = c("y1", "y4"))

# Example 10b: Fix all residual variances at 0
# i.e., strong factorial invariance across clusters
multilevel.cfa(Demo.twolevel, cluster = "cluster",
               model = list(c("y1", "y2", "y3"), c("y4", "y5", "y6")),
               fix.resid = "all")

#----------------------------------------------------------------------------
# Model specification using 'model.w' and 'model.b' for one or multiple factor model
# with different factor structure at the Within and Between Level

# Example 11a: Two-factor model at the Within level and one-factor model at the Between level
multilevel.cfa(Demo.twolevel, cluster = "cluster",
               model.w = list(c("y1", "y2", "y3"), c("y4", "y5", "y6")),
               model.b = c("y1", "y2", "y3", "y4", "y5", "y6"))

# Example 11b: Residual covariance between 'y1' and 'y4' at the Within level
# Residual covariance between 'y5' and 'y6' at the Between level
multilevel.cfa(Demo.twolevel, cluster = "cluster",
               model.w = list(c("y1", "y2", "y3"), c("y4", "y5", "y6")),
               model.b = c("y1", "y2", "y3", "y4", "y5", "y6"),
               rescov.w = c("y1", "y4"),
               rescov.b = c("y5", "y6"))

## End(Not run)
</code></pre>


</div>