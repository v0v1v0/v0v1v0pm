<div class="container">

<table style="width: 100%;"><tr>
<td>rwg.lindell</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Lindell, Brandt and Whitney (1999) r*wg(j) Within-Group Agreement Index for
Multi-Item Scales</h2>

<h3>Description</h3>

<p>This function computes r*wg(j) within-group agreement index for multi-item scales
as described in Lindell, Brandt and Whitney (1999).
</p>


<h3>Usage</h3>

<pre><code class="language-R">rwg.lindell(..., data = NULL, cluster, A = NULL, ranvar = NULL, z = TRUE,
            expand = TRUE, na.omit = FALSE, append = TRUE, name = "rwg",
            as.na = NULL, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>a numeric vector or data frame. Alternatively, an expression
indicating the variable names in <code>data</code> e.g.,
<code>rwg.lindell(x1, x2, x3, data = dat)</code>. Note that the operators
<code>.</code>, <code>+</code>, <code>-</code>, <code>~</code>, <code>:</code>, <code>::</code>,
and <code>!</code> can also be used to select variables, see 'Details'
in the <code>df.subset</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame when specifying one or more variables in the
argument <code>...</code>. Note that the argument is <code>NULL</code>
when specifying a numeric vector or data frame for the argument
<code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>either a character string indicating the variable name of
the cluster variable in <code>...</code> or <code>data</code>, or a
vector representing the nested grouping structure (i.e.,
group or cluster variable).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a numeric value indicating the number of discrete response
options of the items from which the random variance is computed
based on <code class="reqn">(A^2 - 1) / 12</code>. Note that either the argument
<code>j</code> or the argument<code>ranvar</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranvar</code></td>
<td>
<p>a numeric value indicating the random variance to which the
mean of the item variance is divided. Note that either the
argument <code>j</code> or the argument<code>ranvar</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), Fisher z-transformation based on the
formula <code class="reqn">z = 0.5*log((1 + r) / (1 - r))</code> is applied to
the vector of r*wg(j) estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), vector of r*wg(j) estimates is expanded
to match the input vector <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.omit</code></td>
<td>
<p>logical: if <code>TRUE</code>, incomplete cases are removed before
conducting the analysis (i.e., listwise deletion).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>append</code></td>
<td>
<p>logical: if <code>TRUE</code> (default),  a variable with the r*wg(j)
within-group agreement index are appended to the data frame
specified in the argument <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>a character string indicating the name of the variable appended
to the data frame specified in the argument <code>data</code> when
<code>append = TRUE</code>. By default, the variable is named <code>rwg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.na</code></td>
<td>
<p>a numeric vector indicating user-defined missing values,
i.e. these values are converted to <code>NA</code> before conducting
the analysis. Note that <code>as.na()</code> function is only applied to
<code>x</code>, but not to <code>cluster</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), argument specification is checked.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The r*wg(j) index is calculated by dividing the mean of the item variance by
the expected random variance (i.e., null distribution). The default null distribution
in most research is the rectangular or uniform distribution calculated with
<code class="reqn">\sigma^2_eu = (A^2 - 1) / 12</code>, where <code class="reqn">A</code> is the number of discrete response
options of the items. However, what constitutes a reasonable standard for random
variance is highly debated. Note that the r*wg(j) allows that the mean of the
item variances to be larger than the expected random variances, i.e., r*wg(j)
values can be negative.
</p>
<p>Note that the <code>rwg.j.lindell()</code> function in the <span class="pkg">multilevel</span> package
uses listwise deletion by default, while the <code>rwg.lindell()</code> function uses
all available information to compute the r*wg(j) agreement index by default. In
order to obtain equivalent results in the presence of missing values, listwise
deletion (<code>na.omit = TRUE</code>) needs to be applied.
</p>
<p>Examples for the application of r*wg(j) within-group agreement index for multi-item
scales can be found in Bardach, Yanagida, Schober and Lueftenegger (2018),
Bardach, Lueftenegger, Yanagida, Schober and Spiel (2018), and Bardach, Lueftenegger,
Yanagida, Spiel and Schober (2019).
</p>


<h3>Value</h3>

<p>Returns a numeric vector containing r*wg(j) agreement index for multi-item scales
with the same length as <code>group</code> if <code>expand = TRUE</code> or a data frame with
following entries if <code>expand = FALSE</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>cluster identifier</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>cluster size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rwg.lindell</code></td>
<td>
<p>r*wg(j) estimate for each group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.rwg.lindell</code></td>
<td>
<p>Fisher z-transformed r*wg(j) estimate for each cluster</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Takuya Yanagida <a href="mailto:takuya.yanagida@univie.ac.at">takuya.yanagida@univie.ac.at</a>
</p>


<h3>References</h3>

<p>Bardach, L., Lueftenegger, M., Yanagida, T., &amp; Schober, B. (2019). Achievement
or agreement - Which comes first? Clarifying the temporal ordering of achievement
and within-class consensus on classroom goal structures. <em>Learning and Instruction,
61</em>, 72-83. https://doi.org/10.1016/j.learninstruc.2019.01.003
</p>
<p>Bardach, L., Lueftenegger, M., Yanagida, T., Schober, B. &amp; Spiel, C. (2019).
The role of within-class consensus on mastery goal structures in predicting
socio-emotional outcomes. <em>British Journal of Educational Psychology, 89</em>,
239-258. https://doi.org/10.1111/bjep.12237
</p>
<p>Bardach, L., Yanagida, T., Schober, B. &amp; Lueftenegger, M. (2018). Within-class
consensus on classroom goal structures: Relations to achievement and achievement
goals in mathematics and language classes. <em>Learning and Individual Differences,
67</em>, 78-90. https://doi.org/10.1016/j.lindif.2018.07.002
</p>
<p>Lindell, M. K., Brandt, C. J., &amp; Whitney, D. J. (1999). A revised index of interrater
agreement for multi-item ratings of a single target. <em>Applied Psychological
Measurement</em>, <em>23</em>, 127-135. https://doi.org/10.1177/01466219922031257
</p>
<p>O'Neill, T. A. (2017). An overview of interrater agreement on Likert scales for
researchers and practitioners. <em>Frontiers in Psychology</em>, <em>8</em>, Article
777. https://doi.org/10.3389/fpsyg.2017.00777
</p>


<h3>See Also</h3>

<p><code>cluster.scores</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">dat &lt;- data.frame(id = c(1, 2, 3, 4, 5, 6, 7, 8, 9),
                  cluster = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
                  x1 = c(2, 3, 2, 1, 1, 2, 4, 3, 5),
                  x2 = c(3, 2, 2, 1, 2, 1, 3, 2, 5),
                  x3 = c(3, 1, 1, 2, 3, 3, 5, 5, 4))

# Example 1a: Compute Fisher z-transformed r*wg(j) for a multi-item scale
# with A = 5 response options
rwg.lindell(dat[, c("x1", "x2", "x3")], cluster = dat$cluster, A = 5)

# Example 1b: Alternative specification using the 'data' argument,
rwg.lindell(x1:x3, data = dat, cluster = "cluster", A = 5)
# Example 2: Compute Fisher z-transformed r*wg(j) for a multi-item scale with a random variance of 2
rwg.lindell(dat[, c("x1", "x2", "x3")], cluster = dat$cluster, ranvar = 2)

# Example 3: Compute r*wg(j) for a multi-item scale with A = 5 response options
rwg.lindell(dat[, c("x1", "x2", "x3")], cluster = dat$cluster, A = 5, z = FALSE)

# Example 4: Compute Fisher z-transformed r*wg(j) for a multi-item scale
# with A = 5 response options, do not expand the vector
rwg.lindell(dat[, c("x1", "x2", "x3")], cluster = dat$cluster, A = 5, expand = FALSE)
</code></pre>


</div>