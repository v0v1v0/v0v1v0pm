<div class="container">

<table style="width: 100%;"><tr>
<td>raggedCoef-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Class <code>"raggedCoef"</code> — ragged list objects
</h2>

<h3>Description</h3>

<p>Some models have several several vectors of parameters, possibly of
different lengths, such that in some circumstances they are thought of
as lists, in others as matrices after suitable padding with zeroes.
Class <code>"raggedCoef"</code> represents such ragged lists.  In package
<code>"MixAR"</code> it is used to hold the autoregressive coefficients of
MixAR models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">raggedCoef(p, value = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>orders, vector of integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>typically, a list, but see Details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Class <code>"raggedCoef"</code> is for objects that can be considered as
both, lists and matrices. The elements of the list are vectors,
possibly of different lengths.  When the object is viewed as a matrix,
each element of the list (suitably padded with zeroes or <code>NA</code>s)
represents a row of a matrix.
</p>
<p>The recommended way to create objects from class <code>"raggedCoef"</code>
is with the function <code>raggedCoef</code>. 
</p>
<p>If <code>value</code> is a "raggedCoef" object it is returned.
If value is a list, it is converted to "raggedCoef" using
<code>new()</code>.
If argument <code>p</code> is missing, it is inferred from the
lengths of the elements of the list.  
If argument <code>p</code> is not missing, a consistency check
is made to ensure that the order of the object is as specified by
<code>p</code>.
</p>
<p>Otherwise, if <code>value</code> is of length one, it is replicated to form
a ragged list with i-th element a vector of length
<code>p[i]</code>. Although not checked, the intention here is that
<code>value</code> is from some atomic class.  The default for <code>value</code>
is <code>NA_real_</code> to give a convenient way to create a ragged list.
</p>
<p>Finally, if none of the above applies, <code>value</code> is effectively assumed to
be a vector of length <code>sum(p)</code>, although other cases are
admissible (but I don't remember if this was intended). In this case,
<code>value</code> is reshaped into a ragged list to match <code>p</code>. This is
convenient when, for example, the elements of a ragged array are
obtained from an optimisation routine which expects plain vector.


</p>


<h3>Objects from the Class</h3>

<p>Below we describe the <code>"initialize"</code> method that underlies
<code>new("raggedCoef", ...)</code>.  The recommended way to create
<code>"raggedCoef"</code> objects is with the function <code>raggedCoef</code>,
see section Details.
</p>
<p>Objects can also be created by calls of the form
<code>new("raggedCoef", v)</code>, where <code>v</code> is a list whose elements
are numeric vectors, or <code>new("raggedCoef", v1, v2, ...)</code>, where
<code>v1, v2, ...</code> are numeric vectors.  The two forms are equivalent
if <code>v = list(v1, v2, ...)</code>.
</p>
<p>The elements of the list <code>v</code> may be named.
Similarly, named arguments can be used in the second form, say
<code>new("raggedCoef", name1 = v1, name2 = v2, ...)</code>.
In both cases the names are preserved in the internal representaion,
but not used.
</p>
<p>If the arguments are not as specified above the result should be
considered undefined. 
Currently, if there are other arguments after the list <code>v</code>, they
are ignored with a warning. If the first argument is not a list then
all arguments must be <code>numeric</code> and an error is raised if this is
not the case. For completeness, we mention that exactly two arguments named
<code>a</code>, and <code>p</code> are also accepted by <code>new()</code>, eg
<code>new("raggedCoef", p = c(1, 2), a =  list(3, 4:5))</code>, but these
are assigned to the slots without any checking. so it is
most flexible (and recommended) to use <code>raggedCoef()</code> instead.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>a</code>:</dt>
<dd>
<p>Object of class <code>"list"</code> containing the values. </p>
</dd>
<dt>
<code>p</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code> containing the
lengths of the components of <code>a</code>.</p>
</dd>
</dl>
<h3>Methods</h3>

<p>Indexing with "[" treats a <code>raggedCoef</code> object as a matrix, while
"[[" treats the object as list (it works on slot <code>a</code>).
</p>
<p>Note that there is a difference between <code>x[2,]</code> (or the
equivalent <code>x[2]</code>) and <code>x[[2]]</code>—the former gives a vector
of length <code>max(p)</code>, so potentially padded with zeroes, while the
latter gives the component with its “natural” length.
</p>
<p>The replacement variants of "[" and "[[" do not change the structure
of the object and issue errors if the replacement value would result
in that. In situations where the checks are deemed redundant, direct
assignments to the corresponding slots may be used.
</p>

<dl>
<dt>[</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "missing", j = "missing", drop = "ANY")</code>: </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "missing", j = "numeric", drop = "ANY")</code>: </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "numeric", j = "missing", drop = "ANY")</code>: </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "numeric", j = "numeric", drop = "ANY")</code>:
Indexing with "[" treats a <code>raggedCoef</code> object as a matrix
with one row for each component and number of columns equal to
<code>max(p)</code>. However, <code>x[2]</code> is equivalent to <code>x[2,]</code>
which is different from the treatment of <code>matrix</code> objects in
base <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.
</p>
</dd>
<dt>[[</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "ANY", j = "missing")</code>:</p>
</dd>
<dt>[[</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "ANY", j = "ANY")</code>:
<code>"[["</code> extracts the corresponding element of slot <code>a</code>.</p>
</dd>
<dt>[[&lt;-</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "ANY", j = "ANY", value = "numeric")</code>:
Replace the j-th element of i-th row with <code>value</code>.
All arguments must be scalars.
</p>
</dd>
<dt>[[&lt;-</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "ANY", j = "missing", value = "numeric")</code>:
</p>
</dd>
<dt>[&lt;-</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "ANY", j = "missing", value = "numeric")</code>:
Replace the i-th row with <code>value</code>. Argument <code>i</code> must be
a scalar while the length of <code>value</code> must be the same as that
of <code>x@a[[i]]</code>. The methods for "[" and "[[" with this
signature coinside.
</p>
</dd>
<dt>[&lt;-</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "ANY", j = "missing", value = "list")</code>:
The elements of <code>value</code> must have the same lengths as the
elements they are replacing.
</p>
</dd>
<dt>[&lt;-</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "ANY", j = "missing", value = "matrix")</code>:
This is essentially the reverse od the corresponding
non-replacement operator. <code>value</code> must have at least as many
columns as the longest element of <code>x</code> that is replaced.
</p>
</dd>
<dt>[&lt;-</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "ANY", j = "ANY", value = "numeric")</code>: ... </p>
</dd>
<dt>[&lt;-</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "missing", j = "missing", value = "list")</code>: ... </p>
</dd>
<dt>[&lt;-</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "missing", j = "missing", value = "matrix")</code>: ... </p>
</dd>
<dt>[&lt;-</dt>
<dd>
<p><code>signature(x = "raggedCoef", i = "missing", j = "missing", value = "numeric")</code>: ... </p>
</dd>
<dt>initialize</dt>
<dd>
<p><code>signature(.Object = "raggedCoef")</code>:
Creates objects of class <code>raggedCoef</code>. This method is used
internally by <code>new()</code>. Users should use <code>new()</code> for
creation of objects from this class, see the examples.
</p>
</dd>
<dt>show</dt>
<dd>
<p><code>signature(object = "raggedCoef")</code>: ... </p>
</dd>
<dt>mixFilter</dt>
<dd>
<p><code>signature(x = "numeric", coef = "raggedCoef", index = "numeric")</code>:
Apply a mixture filter to a time series.

</p>
</dd>
<dt>row_lengths</dt>
<dd>
<p><code>signature(x = "raggedCoef")</code>:
Gives <code>x@p</code>, which is the same as <code>lengths(x@a)</code>.
</p>
</dd>
<dt>length</dt>
<dd>
<p><code>signature(x = "raggedCoef")</code>:
Gives the total number of coefficients (<code>sum(x@p)</code>).
</p>
</dd>
<dt>anyNA</dt>
<dd>
<p><code>signature(x = "raggedCoef")</code>:
Are there <code>NA</code>'s in <code>x@a</code>?
</p>
</dd>
<dt>dim</dt>
<dd>
<p><code>signature(x = "raggedCoef")</code>:
The dimension of the object, when viewed as a matrix.
The presence of this method also ensures that <code>nrow()</code>
and related functions give the expected result.
</p>
</dd>
</dl>
<h3>Note</h3>

<p>Slot <code>p</code> is redundant but convenient.
</p>




<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p>class <code>"MixARGaussian"</code>



</p>


<h3>Examples</h3>

<pre><code class="language-R">ragged1 &lt;- list(1, 2:3, 4:6)
ragged2 &lt;- list(a = 1, b = 2:3, c = 4:6)

raggedCoef(1:3)          # only order given, fill with NA's
raggedCoef(1:3, 0)       # fill with a number (zero in this case)

## init with a list
raggedCoef(ragged1)
raggedCoef(value = ragged1) 

## error, since the shape of ragged1 is not c(2, 2, 3):
## raggedCoef(c(2, 2, 3), value = ragged1)

## init with a flattened list
raggedCoef(p = 1:3, value = 1:6)

## specify each component separately
ragA &lt;- new("raggedCoef", 1, 2:3, 4:6)
ragB &lt;- new("raggedCoef", list(1, 2:3, 4:6))  # same
identical(ragA, ragB) #TRUE

## extract as a matrix
ragA[]

## extract the 2nd component
ragA[2]      # c(2, 3, 0) ("[" pads with 0's)
ragA[[2]]    # c(2, 3)    ("[[" does not pad)

## get the 2nd and 3rd components as a matrix
ragA[2:3, ]    # "[" treats object (almost) as matrix
ragA[2:3]      # same (though not as for "matrix")

## names are kept in the list but currently not used 
ragC  &lt;- new("raggedCoef", list(a = 1, b = 2:3, c = 4:6))
ragC1 &lt;- new("raggedCoef", a = 1, b = 2:3, c = 4:6)
identical(ragC, ragC1) # TRUE
names(ragC@a) # [1] "a" "b" "c"

length(ragA)
dim(ragA)
c(nrow(ragA), ncol(ragA))
c(NROW(ragA), NCOL(ragA))
</code></pre>


</div>