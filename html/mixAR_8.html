<div class="container">

<table style="width: 100%;"><tr>
<td>MixComp-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class <code>"MixComp"</code> — manipulation of MixAR time series</h2>

<h3>Description</h3>

<p>Class <code>"MixComp"</code> represents components of mixture autoregressive
time series and their transformations obtained by arithmetic and
related operations. Methods are provided to allow convenient
computation with such time series.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("MixComp", ...)</code>. 
It is more usual however to obtain such objects initially
from functions such as <code>mix_ek</code>. Methods are defined to allow for
convenient and intuitive further manipulation of such objects.
</p>
<p>Internally, an object of class <code>MixComp</code> is a matrix with one column
for each component. However, methods for arithmetic operations
involving <code>MixComp</code> objects  are defined to perform natural
operations for mixture objects. For example, multiplication by
vectors is commutative and “does the right thing”.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>m</code>:</dt>
<dd>
<p>Object of class <code>"matrix"</code> with one column correponding to
each component of the mixture AR model.
</p>
</dd>
</dl>
<h3>Methods</h3>

<p>Arithmetic operations involving <code>MixComp</code> objects are defined
to allow for convenient execution of computations for mixture
autoregressive models, see class <code>"MixComp"</code>.
</p>

<dl>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "MixComp", e2 = "missing")</code>:
unary minus for "MixComp" objects.
</p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "MixComp")</code>:
</p>
<p>If <code>e2</code> is thought of as a matrix, <code class="reqn">m</code>, then the number
of elements of <code>e1</code> must be the same as the number of rows
of <code class="reqn">m</code> and each column of <code class="reqn">m</code> is subtracted from
<code>e1</code>, see also <code>"mix_ek"</code>, <code>"mix_hatk"</code>.
</p>
<p>As a special case, if <code class="reqn">m</code> has only one row, then it is
subtracted from each element of <code>e1</code>, i.e. that row is
replicated to obtain a matrix with as many rows as the length of
<code>e1</code> and then subtracted from <code>e1</code> as above.
</p>
<p>The result is a <code>MixComp</code> object.
</p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "MixComp", e2 = "numeric")</code>:
This is analogous to the above method. (<b>FIXME:</b> the code
of this function does not deal with the special case as in the
above method. Is this an omission or I have done it on purpose?)
</p>
</dd>
<dt>%of%</dt>
<dd>
<p><code>signature(e1 = "function", e2 = "MixComp")</code>:
This applies the function <code>e1</code> to each element of
<code>e2</code>. Together with the arithmetic operations this allows for
easy computation with MixComp objects (e.g. pdfs, likelihoods).
</p>
</dd>
<dt>%of%</dt>
<dd>
<p><code>signature(e1 = "character", e2 = "MixComp")</code>:</p>
</dd>
<dt>%of%</dt>
<dd>
<p><code>signature(e1 = "list", e2 = "MixComp")</code>:
If <code>e1</code> is of length one it specifies a function to be
applied to each element of <code>e2</code>, otherwise it is a list of
functions, such that the <code class="reqn">i</code>th function is applied to the
<code class="reqn">i</code>th column of <code>e2@m</code>.
</p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "MixComp", e2 = "MixComp")</code>: ... </p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "MixComp", e2 = "numeric")</code>:
see the following.
</p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "MixComp")</code>:
“Column” <code class="reqn">i</code> of the <code>MixComp</code> object is multiplied by
the <code class="reqn">i</code>th element of the numeric vector, i.e. each “row”
of the <code>MixComp</code> object is multiplied by the vector (or, the
vector is replicated to a matrix to be multiplied by the
<code>MixComp</code> object).
</p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "function", e2 = "MixComp")</code>:
Multiplying a function by  a <code>MixComp</code> object actually
applies the function to each element of the object.
This is a misuse of methods, prefer operator
<code>%of%</code> which does the same.
</p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "character", e2 = "MixComp")</code>:
The first argument is a name of a function which is
applied to each element of the <code>MixComp</code> object. This is a
misuse of methods, see operator <code>%of%</code>
which does the same.  


</p>
</dd>
<dt>/</dt>
<dd>
<p><code>signature(e1 = "MixComp", e2 = "numeric")</code>:
</p>
</dd>
<dt>/</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "MixComp")</code>:
Division works analogously to <code>"*"</code>.
</p>
</dd>
<dt>^</dt>
<dd>
<p><code>signature(e1 = "MixComp", e2 = "numeric")</code>:
If <code>k</code> is a scalar, raise each element of <code>e1@m</code> to
power <code>k</code>.
</p>

<p>(For consistency this operation should have the
semantics of "*" and "/" but this operator probably makes sense
only for scalar 'e2', where the semantics doesn't matter. So,
don't bother for now.)
</p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "MixComp")</code>:
</p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "MixComp", e2 = "numeric")</code>:
Addition involving <code>MixComp</code> objects works analogously to subtraction.
</p>
</dd>
<dt>inner</dt>
<dd>
<p><code>signature(x = "MixComp", y = "missing", star = "missing", plus = "missing")</code>:
With one argument <code>inner</code> computes the sum of the columns of
the argument. This is conceptually equivalent to <code>y</code> being a
vector of ones.
</p>
</dd>
<dt>inner</dt>
<dd>
<p><code>signature(x = "MixComp", y = "numeric", star = "missing", plus = "missing")</code>:
</p>
</dd>
<dt>inner</dt>
<dd>
<p><code>signature(x = "numeric", y = "MixComp", star = "missing", plus = "missing")</code>:
The number of elements of the numeric argument should be equal to
the number of rows of the <code>MixComp</code> object. Effectively,
computes the inner product of the two arguments. The order of the
arguments does not matter.

</p>
<p>Returns a numeric vector.
</p>
</dd>
<dt>inner</dt>
<dd>
<p><code>signature(x = "MixComp", y = "numeric", star = "ANY", plus = "ANY")</code>:
Computes a generalised inner product of <code>x</code> with <code>y</code> using the
specified functions in place of the usual "*" and "+"
operations. The defaults for <code>star</code> and <code>+</code> are
equivalent to multiplication and addition, respectively.
</p>
<p>Note that "+" is a binary operation (not <code class="reqn">n</code>-ary) in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>. So
technically the correct way to specify the default operation here
is "sum" or <code>sum</code>. Since it is easy to make this mistake, if
<code>plus == "+"</code>, it is replaced by "sum".
(In fact, <code>plus</code> is given a single argument, the vector of
values to work on. Since "+" works as a unary operator on one
argument, it would give surprising results if left as is.)
</p>
</dd>
<dt>inner</dt>
<dd>
<p><code>signature(x = "MixComp", y = "numeric", star = "ANY", plus = "missing")</code>:
This is a more efficient implementation for the case when
<code>plus = sum</code>.
</p>
</dd>
<dt>mix_ncomp</dt>
<dd>
<p><code>signature(x = "MixComp")</code>:
Number of components.
</p>
</dd>
<dt><code>signature(x = "MixComp")</code></dt>
<dd>
<p>A <code>"MixComp"</code> object is essentially a matrix. This method
gives the dimension of the underlying matrix. This method
indirectly ensures that <code>nrow()</code> and <code>ncol()</code> work
naturally for <code>"MixComp"</code> objects.
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class="language-R">
## dim, nrow, ncol
a &lt;- new("MixComp", m = matrix(c(1:7, 11:17, 21:27), ncol = 3))
a
dim(a)
nrow(a)
ncol(a)
mix_ncomp(a)

-a
a - 1:7 
1:7 + a
2*a


b &lt;- new("MixComp", m = matrix(rnorm(18), ncol = 3))

## apply a function to the columns of a MixComp object
pnorm %of% b

## apply a separate function to to each column
flist &lt;- list(function(x) pnorm(x),
              function(x) pt(x, df = 5),
              function(x) pt(x, df = 4) )
flist %of% b
</code></pre>


</div>