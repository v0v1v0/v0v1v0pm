<div class="container">

<table style="width: 100%;"><tr>
<td>combine.kernels</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Combine multiple kernels into a meta-kernel</h2>

<h3>Description</h3>

<p>Compute multiple kernels into a single meta-kernel
</p>


<h3>Usage</h3>

<pre><code class="language-R">combine.kernels(
  ...,
  scale = TRUE,
  method = c("full-UMKL", "STATIS-UMKL", "sparse-UMKL"),
  knn = 5,
  rho = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>list of kernels (called 'blocks') computed on different datasets 
and measured on the same samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>boleean. If <code>scale = TRUE</code>, each block is standardized to 
zero mean and unit variance and cosine normalization is performed on the 
kernel. Default: <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character. Which method should be used to compute the 
meta-kernel. Default: <code>"full-UMKL"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knn</code></td>
<td>
<p>integer. If <code>method = "sparse-UMKL"</code> or
<code>method = "full-UMKL"</code>, number of neighbors used to get a proxy of the 
local topology of the datasets from each kernel. Default: <code>5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>integer. Parameters for the augmented Lagrangian method. Default: 
<code>20</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The arguments <code>method</code> allows to specify the Unsupervised Multiple
Kernel Learning (UMKL) method to use: </p>

<ul>
<li> <p><code>"STATIS-UMKL"</code>: combines input kernels into the best 
consensus of all kernels;
</p>
</li>
<li> <p><code>"full-UMKL"</code>: computes a kernel that minimizes the distortion 
between the meta-kernel and the k-NN graphs obtained from all input 
kernels;
</p>
</li>
<li> <p><code>"sparse-UMKL"</code>: a sparse variant of the <code>"full-UMKL"</code> 
approach.
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>combine.kernels</code> returns an object of classes <code>"kernel"</code> 
and <code>"metaKernel"</code>, a list that contains the following components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>: the computed meta-kernel matrix;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>: the dataset from which the kernel has been computed, as given by
the function <code>compute.kernel</code>. Can be <code>NULL</code> if a kernel
matrix was passed to this function;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>: a vector containing the weights used to combine the 
kernels.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jerome Mariette &lt;jerome.mariette@inrae.fr&gt;
Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;
</p>


<h3>References</h3>

<p>Mariette J. and Villa-Vialaneix N. (2018). Unsupervised multiple 
kernel learning for heterogeneous data integration . <em>Bioinformatics</em>, 
<b>34</b>(6), 1009-1015. DOI: <a href="https://doi.org/10.1093/bioinformatics/btx682">doi:10.1093/bioinformatics/btx682</a>.
</p>


<h3>See Also</h3>

<p><code>compute.kernel</code>, <code>kernel.pca</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(TARAoceans)

# compute one kernel per dataset
phychem.kernel &lt;- compute.kernel(TARAoceans$phychem, kernel.func = "linear")
pro.phylo.kernel &lt;- compute.kernel(TARAoceans$pro.phylo, kernel.func = "abundance")
pro.NOGs.kernel &lt;- compute.kernel(TARAoceans$pro.NOGs, kernel.func = "abundance")

# compute the meta kernel
meta.kernel &lt;- combine.kernels(phychem = phychem.kernel,
                               pro.phylo = pro.phylo.kernel,
                               pro.NOGs = pro.NOGs.kernel, 
                               method = "full-UMKL")

</code></pre>


</div>