<div class="container">

<table style="width: 100%;"><tr>
<td>EMGr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function for model-based clustering with the multivariate power exponential (MPE) or the skew power exponential (MSPE) distribution.
</h2>

<h3>Description</h3>

<p>For fitting of a family of 16 mixture models based on mixtures of multivariate skew power exponential distributions with eigen-decomposed covariance structures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">EMGr(data = NULL, initialization = 10, iModel = "EIIE", G = 2, max.iter = 500,
epsilon = 0.01, label = NULL, modelSet = "all", skewness = FALSE,
keepResults = FALSE, seedno = 1, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>A matrix such that rows correspond to observations and columns correspond to variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initialization</code></td>
<td>

<p>0 means a k-means start. A single positive number indicates the number of random soft starts in addition to 10 k-means starts, done via short EM runs; the best initialization is followed by a single long EM run until convergence. A single negative number indicates initializing with multiple random soft starts only; this is akin to taking the best initialization from multiple short EM runs for a long EM run until convergence. A z matrix can be provided directly here as well. Finally, a list can be provided with the same format as modelfit$bestmod$gpar.
Often, it is helpful to run a long random-starts only run and a long k-means start run, and pick between those two based on BIC. See Dang et al 2023 for an example.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iModel</code></td>
<td>

<p>Initialization model used to generate initial parameter estimates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>

<p>A sequence of integers corresponding to the number of components to be fitted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>

<p>Maximum number of GEM iterations allowed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>

<p>Threshold for convergence for the GEM algorithm used in the Aitken's stopping criterion.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>

<p>Used for model-based classification aka semi-supervised classification. This is a vector of group labels with 0 for unlabelled observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelSet</code></td>
<td>

<p>A total of 16 models are provided: "EIIE", "VIIE", "EEIE", "VVIE", "EEEE", "EEVE", "VVEE", "VVVE", "EIIV", "VIIV", "EEIV", "VVIV", "EEEV", "EEVV", "VVEV", "VVVV". modelSet="all" fits all models automatically. Otherwise, a character vector of a subset of these models can be provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skewness</code></td>
<td>

<p>If FALSE (default), fits mixtures of multivariate power exponential distributions that cannot model skewness. If TRUE, fits mixtures of multivariate skewed power exponential distributions that can model skewness.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepResults</code></td>
<td>

<p>Keep results from all models
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seedno</code></td>
<td>

<p>Seed number for initialization of k-means or random starts.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>

<p>If TRUE, scales the data before model fitting. Recommended unless to check parameter recovery.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The component scale matrix is decomposed using an eigen-decomposition:<br><strong><code class="reqn">\Sigma_g</code></strong> = <code class="reqn">\lambda_g</code> <strong><code class="reqn">\Gamma_g</code></strong> <strong><code class="reqn">\Delta_g</code></strong> <strong><code class="reqn">\Gamma'_g</code></strong>  <br>
The nomenclature is as follows: a EEVE model denotes a model with equal constants associated with the eigenvalues (<code class="reqn">\lambda</code>) for each group, equal orthogonal matrix of eigenvectors (<strong><code class="reqn">\Gamma</code></strong>), variable diagonal matrices with values proportional to the eigenvalues of each component scale matrix (<strong><code class="reqn">\Delta_g</code></strong>), and equal shape parameter (<code class="reqn">\beta</code>).
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>allModels</code></td>
<td>
<p>Output for each model run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bestmod</code></td>
<td>
<p>Output for the best model chosen by the BIC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>Maximum log likelihood for each model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.iter</code></td>
<td>
<p>Number of iterations required for convergence for each model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.par</code></td>
<td>
<p>Number of parameters fit for each model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BIC</code></td>
<td>
<p>BIC for each model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bestBIC</code></td>
<td>
<p>Which model was selected by the BIC in the BIC matrix?</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Ryan P. Browne, Utkarsh J. Dang, Michael P. B. Gallaugher, and Paul D. McNicholas
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
Nobs1 &lt;- 200
Nobs2 &lt;- 250
X1 &lt;- rpe(n = Nobs1, mean = c(0,0), scale = diag(2), beta = 1)
X2 &lt;- rpe(n = Nobs2, mean = c(3,0), scale = diag(2), beta = 2)
x &lt;- as.matrix(rbind(X1, X2))
membership &lt;- c(rep(1, Nobs1), rep(2, Nobs2))
mperun &lt;- EMGr(data=x, initialization=0, iModel="EIIV", G=2:3,
max.iter=500, epsilon=5e-3, label=NULL, modelSet=c("EIIV"),
skewness=FALSE, keepResults=TRUE, seedno=1, scale=FALSE) #use "all" in modelSet for all models
print(mperun)
print(table(membership,mperun$bestmod$map))
msperun &lt;- EMGr(data=x, initialization=0, iModel="EIIV", G=2:3,
max.iter=500, epsilon=5e-3, label=NULL, modelSet=c("EIIV"),
skewness=TRUE, keepResults=TRUE, seedno=1, scale=FALSE) #usually data should be scaled.
#print(msperun)
#print(table(membership,msperun$bestmod$map))

set.seed(1)
data(iris)
membership &lt;- as.numeric(factor(iris[, "Species"]))
label &lt;- membership
label[sample(x = 1:length(membership),size = ceiling(0.6*length(membership)),replace = FALSE)] &lt;- 0
#40% supervision (known groups) and 60% unlabeled.
dat &lt;- data.matrix(iris[, 1:4])
semisup_class_skewed = EMGr(data=dat, initialization=10, iModel="EIIV",
G=3, max.iter=500, epsilon=5e-3, label=label, modelSet=c("VVVE"),
skewness=TRUE, keepResults=TRUE, seedno=5, scale=TRUE)
#table(membership,semisup_class_skewed$bestmod$map)
</code></pre>


</div>