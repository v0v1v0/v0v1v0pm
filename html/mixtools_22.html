<div class="container">

<table style="width: 100%;"><tr>
<td>ise.npEM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Integrated Squared Error for a selected density from npEM output</h2>

<h3>Description</h3>

<p>Computes the integrated squared error for a selected estimated density 
from <code>npEM</code> output (selected by specifying the component 
and block number), 
relative to a true pdf that must be specified by the user.
The range for the numerical integration must be specified.  This function
also returns (by default) a plot of the
true and estimated densities.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ise.npEM(npEMout, component=1, block=1, truepdf, lower=-Inf, 
         upper=Inf, plots = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>npEMout</code></td>
<td>
<p>An object of class <code>npEM</code> such as the output
of the <code>npEM</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>component, block</code></td>
<td>
<p>Component and block of particular density to analyze
from <code>npEMout</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>truepdf</code></td>
<td>
<p>an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function taking a numeric first argument and 
returning a numeric vector of the same length. Returning a 
non-finite element will generate an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower, upper</code></td>
<td>
<p>the limits of integration.  Can be infinite.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plots</code></td>
<td>
<p>logical:  Should plots be produced?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to <code>truepdf</code>
(and that may be mandatory like, e.g., the <code>df = </code> argument of <code>dt</code>). 
Remember to use argument names not matching those of <code>ise.npRM</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function calls the <code>wkde</code> (weighted kernel
density estimate) function.
</p>


<h3>Value</h3>

<p>Just as for the <code>integrate</code> function,
a list of class <code>"integrate"</code> with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>the final estimate of the integral.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abs.error</code></td>
<td>
<p>estimate of the modulus of the absolute error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subdivisions</code></td>
<td>
<p>the number of subintervals produced in the
subdivision process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p><code>"OK"</code> or a character string giving the error message.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
</table>
<h3>References</h3>


<ul>
<li>
<p> Benaglia, T., Chauveau, D., and Hunter, D. R. (2009), An EM-like algorithm
for semi- and non-parametric estimation in multivariate mixtures, 
Journal of Computational and Graphical Statistics, 18, 505-526.
</p>
</li>
<li>
<p> Benaglia, T., Chauveau, D., Hunter, D. R., and Young, D. (2009),
mixtools: An R package for analyzing finite mixture models.
Journal of Statistical Software, 32(6):1-29.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>npEM</code>, <code>wkde</code>, <code>integrate</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Mixture with mv gaussian model
set.seed(100)
m &lt;- 2 # no. of components
r &lt;- 3 # no. of repeated measures (coordinates)
lambda &lt;- c(0.4, 0.6)
# Note:  Need first 2 coordinates conditionally iid due to block structure
mu &lt;- matrix(c(0, 0, 0, 3, 3, 5), m, r, byrow=TRUE) # means 
sigma &lt;- matrix(rep(1, 6), m, r, byrow=TRUE) # stdevs
blockid = c(1,1,2) # block structure of coordinates
n &lt;- 200
x &lt;- rmvnormmix(n, lambda, mu, sigma) # simulated data

# fit the model with "arbitrary" initial centers
centers &lt;- matrix(c(0, 0, 0, 4, 4, 4), 2, 3, byrow=TRUE) 
a &lt;- npEM(x, centers, blockid, eps=1e-8, verb=FALSE)

# Calculate integrated squared error for j=2, b=1:
j &lt;- 2 # component
b &lt;- 1 # block
coords &lt;- a$blockid == b
ise.npEM(a, j, b, dnorm, lower=0, upper=10, plots=TRUE,
         mean=mu[j,coords][1], sd=sigma[j, coords][1])


# The following (lengthy) example recreates the normal multivariate 
# mixture model simulation from Benaglia et al (2009).  
mu &lt;- matrix(c(0, 0, 0, 3, 4, 5), m, r, byrow=TRUE) 
nbrep &lt;- 5  # Benaglia et al use 300 replications

# matrix for storing sums of Integrated Squared Errors 
ISE &lt;- matrix(0,m,r,dimnames=list(Components=1:m, Blocks=1:r)) 

nblabsw &lt;- 0 # no. of label switches
for (mc in 1:nbrep) {
  print(paste("REPETITION", mc))
	x &lt;- rmvnormmix(n,lambda,mu,sigma) # simulated data
  a &lt;- npEM(x, centers, verb=FALSE) #default:
	if (a$lambda[1] &gt; a$lambda[2]) nblabsw &lt;- nblabsw + 1
	for (j in 1:m) {  # for each component
		for (k in 1:r) { # for each coordinate; not assuming iid!
      # dnorm with correct mean, sd is the true density:
      ISE[j,k] &lt;- ISE[j,k] + ise.npEM(a, j, k, dnorm, lower=mu[j,k]-5, 
               upper=mu[j,k]+5, plots=FALSE, mean=mu[j,k], 
               sd=sigma[j,k])$value
    }
  }
	MISE &lt;- ISE/nbrep # Mean ISE
	sqMISE &lt;- sqrt(MISE) # root-mean-integrated-squared error
}
sqMISE
</code></pre>


</div>