<div class="container">

<table style="width: 100%;"><tr>
<td>main_loop_gh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>GHPCM Internal C++ Call</h2>

<h3>Description</h3>

<p>This function is the internal C++ function call within the <code>ghpcm</code> function. 
This is a raw C++ function call,  meaning it has no checks for proper inputs so it may fail to run without giving proper errors. 
Please ensure all arguements are valid. <code>main_loop_gh</code> is useful for writing parallizations of the ghpcm function. All arguement descriptions are given in terms of their corresponding C++ types.   
</p>


<h3>Usage</h3>

<pre><code class="language-R">main_loop_gh(X, G, model_id, 
        model_type, in_zigs, 
        in_nmax, in_l_tol, in_m_iter_max,
        in_m_tol, anneals, t_burn = 5L) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>A matrix or data frame such that rows correspond to observations and columns correspond to variables. Note that this function currently only works with multivariate data p &gt; 1. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>

<p>A single positive integer value representing number of groups. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_id</code></td>
<td>

<p>An integer representing the model_id, is useful for keeping track within parallizations. Not to be confused with model_type.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_type</code></td>
<td>

<p>The type of covariance model you wish to run. Lexicon is given as follows: 
"0" = "EII", "1" = "VII",  "2" = "EEI" ,  "3" = "EVI", "4" = "VEI",  "5" = "VVI", "6" = "EEE",  
"7" = "VEE", "8" = "EVE", "9" = "EEV", "10" = "VVE", "11" = "EVV", "12" = "VEV", "13" = "VVV"
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in_zigs</code></td>
<td>

<p>A n times G a posteriori matrix resembling the probability of observation i belonging to group G. Rows must sum to one, have the proper dimensions, and be positive.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in_nmax</code></td>
<td>

<p>Positive integer value resembling the maximum amount of iterations for the EM. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in_l_tol</code></td>
<td>

<p>A likelihood tolerance for convergence. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in_m_iter_max</code></td>
<td>

<p>For certain models, where applicable, the number of iterations for the maximization step. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in_m_tol</code></td>
<td>

<p>For certain models, where applicable, the tolerance for the maximization step. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anneals</code></td>
<td>

<p>A vector of doubles representing the deterministic annealing settings.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_burn</code></td>
<td>

<p>A positive integer representing the number of burn steps if missing data (NAs) are detected. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Be extremly careful running this function, it is known to crash systems without proper exception handling. Consider using the package <code>parallel</code> to estimate all possible models at the same time.
Or run several possible initializations with random seeds.  
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>zigs</code></td>
<td>
<p> a postereori matrix </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>An integer representing the number of groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigs</code></td>
<td>
<p>A vector of covariance matrices for each group (note you may have to reshape this)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mus</code></td>
<td>
<p>A vector of locational vectors for each group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphas</code></td>
<td>
<p>A vector of skewness vectors for each group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omegas</code></td>
<td>
<p>First set of gamma parameters for each group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>Second set of gamma parameters for each group</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Nik Pocuca, Ryan P. Browne and Paul D. McNicholas.
</p>
<p>Maintainer: Paul D. McNicholas &lt;mcnicholas@math.mcmaster.ca&gt;
</p>


<h3>References</h3>

<p>McNicholas, P.D. (2016), <em>Mixture Model-Based Classification</em>. Boca Raton: Chapman &amp; Hall/CRC Press
</p>
<p>Browne, R.P. and McNicholas, P.D. (2014). Estimating common principal components in high dimensions. <em>Advances in Data Analysis and Classification</em> <b>8</b>(2), 217-226.
</p>
<p>Browne, R.P. and McNicholas, P.D. (2015), 'A mixture of generalized hyperbolic distributions', Canadian Journal of Statistics 43(2), 176-198.
</p>
<p>Zhou, H. and Lange, K. (2010). On the bumpy road to the dominant mode. <em>Scandinavian Journal of Statistics</em> <b>37</b>, 612-631. 
</p>
<p>Celeux, G., Govaert, G. (1995). Gaussian parsimonious clustering models. <em>Pattern Recognition</em> <b>28</b>(5), 781-793.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

data("sx2")
data_in = as.matrix(sx2,ncol = 2)
n_iter = 300

in_g = 2
n = dim(data_in)[1]
model_string &lt;- "VVV"
in_model_type &lt;- switch(model_string, "EII" = 0,"VII" = 1,  
              "EEI" = 2,  "EVI" = 3,  "VEI" = 4,  "VVI" = 5,  "EEE" = 6,  
              "VEE" = 7,  "EVE" = 8,  "EEV" = 9,  "VVE" = 10,
              "EVV" = 11,"VEV" = 12,"VVV" = 13)

zigs_in &lt;- z_ig_random_soft(n,in_g)

m2 = main_loop_gh(X = t(data_in), # data in has to be in column major form 
               G = 2, # number of groups
               model_id = 1, # model id for parallelization later
               model_type = in_model_type,
               in_zigs = zigs_in, # initializaiton
               in_nmax = n_iter, # number of iterations
               in_l_tol = 1e-8, # likilihood tolerance
               in_m_iter_max = 20, # maximium iterations for matrices
               in_m_tol = 1e-8,
               anneals=c(0.5,0.7,0.9,1))
                
plot(sx2,col = MAP(m2$zigs) + 1, cex = 0.5, pch = 20)

## End(Not run)
</code></pre>


</div>