<div class="container">

<table style="width: 100%;"><tr>
<td>covlmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a Variable Length Markov Chain with Covariates (coVLMC)</h2>

<h3>Description</h3>

<p>This function fits a  Variable Length Markov Chain with covariates (coVLMC)
to a discrete time series coupled with a time series of covariates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">covlmc(
  x,
  covariate,
  alpha = 0.05,
  min_size = 5L,
  max_depth = 100L,
  keep_data = TRUE,
  control = covlmc_control(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a discrete time series; can be numeric, character, factor or logical.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate</code></td>
<td>
<p>a data frame of covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>number in (0,1) (default: 0.05) cut off value in the pruning
phase (in quantile scale).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_size</code></td>
<td>
<p>number &gt;= 1 (default: 5). Tune the minimum number of
observations for a context in the growing phase of the context tree (see
below for details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_depth</code></td>
<td>
<p>integer &gt;= 1 (default: 100). Longest context considered in
growing phase of the context tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_data</code></td>
<td>
<p>logical (defaults to <code>TRUE</code>). If <code>TRUE</code>, the original data
are stored in the resulting object to enable post pruning (see
<code>prune.covlmc()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list with control parameters, see <code>covlmc_control()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>covlmc_control()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model is built using the algorithm described in Zanin Zambom et al. As
for the <code>vlmc()</code> approach, the algorithm builds first a context tree (see
<code>ctx_tree()</code>). The <code>min_size</code> parameter is used to compute the actual number
of observations per context in the growing phase of the tree. It is computed
as <code>min_size*(1+ncol(covariate)*d)*(s-1)</code> where <code>d</code> is the length of the
context (a.k.a. the depth in the tree) and <code>s</code> is the number of states. This
corresponds to ensuring min_size observations per parameter of the logistic
regression during the estimation phase.
</p>
<p>Then logistic models are adjusted in the leaves at the tree: the goal of each
logistic model is to estimate the conditional distribution of the next state
of the times series given the context (the recent past of the time series)
and delayed versions of the covariates. A pruning strategy is used to
simplified the models (mainly to reduce the time window associated to the
covariates) and the tree itself.
</p>
<p>Parameters specified by <code>control</code> are used to fine tune the behaviour of the
algorithm.
</p>


<h3>Value</h3>

<p>a fitted covlmc model.
</p>


<h3>Logistic models</h3>

<p>By default, <code>covlmc</code> uses two different computing <em>engines</em> for logistic
models:
</p>

<ul>
<li>
<p> when the time series has only two states, <code>covlmc</code> uses <code>stats::glm()</code>
with a binomial link (<code>stats::binomial()</code>);
</p>
</li>
<li>
<p> when the time series has at least three
states, <code>covlmc</code> use <code>VGAM::vglm()</code> with a multinomial link
(<code>VGAM::multinomial()</code>).
</p>
</li>
</ul>
<p>Both engines are able to detect degenerate cases and lead to more robust
results that using <code>nnet::multinom()</code>. It is nevertheless possible to
replace <code>stats::glm()</code> and <code>VGAM::vglm()</code> with <code>nnet::multinom()</code> by setting
the global option <code>mixvlmc.predictive</code> to <code>"multinom"</code> (the default value is
<code>"glm"</code>). Notice that while results should be comparable, there is no
guarantee that they will be identical.
</p>


<h3>References</h3>


<ul>
<li>
<p> BÃ¼hlmann, P. and Wyner, A. J. (1999), "Variable length Markov chains." Ann.
Statist. 27 (2) 480-513 <a href="https://doi.org/10.1214/aos/1018031204">doi:10.1214/aos/1018031204</a>
</p>
</li>
<li>
<p> Zanin Zambom, A., Kim, S. and Lopes Garcia, N. (2022), "Variable length Markov chain
with exogenous covariates." J. Time Ser. Anal., 43 (2)
312-328 <a href="https://doi.org/10.1111/jtsa.12615">doi:10.1111/jtsa.12615</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>cutoff.covlmc()</code> and <code>prune.covlmc()</code> for post-pruning.
</p>


<h3>Examples</h3>

<pre><code class="language-R">pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(1 / 3, 2 / 3, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 15)
draw(m_cov)
withr::with_options(
  list(mixvlmc.predictive = "multinom"),
  m_cov_nnet &lt;- covlmc(dts, dts_cov, min_size = 15)
)
draw(m_cov_nnet)
</code></pre>


</div>