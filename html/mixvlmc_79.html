<div class="container">

<table style="width: 100%;"><tr>
<td>predict.vlmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Next state prediction in a discrete time series for a VLMC</h2>

<h3>Description</h3>

<p>This function computes one step ahead predictions for a discrete time series
based on a VLMC.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'vlmc'
predict(object, newdata, type = c("raw", "probs"), final_pred = TRUE, ...)

## S3 method for class 'vlmc_cpp'
predict(object, newdata, type = c("raw", "probs"), final_pred = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted vlmc object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a time series adapted to the vlmc object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character indicating the type of prediction required. The default
<code>"raw"</code> returns actual predictions in the form of a new time series. The
alternative <code>"probs"</code> returns a matrix of prediction probabilities (see
details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>final_pred</code></td>
<td>
<p>if <code>TRUE</code> (default value), the predictions include a final
prediction step, made by computing the context of the full time series.
When <code>FALSE</code> this final prediction is not included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a time series <code>X</code>, at time step <code>t</code>, a context is computed using
observations from <code>X[1]</code> to <code>X[t-1]</code> (see the dedicated section). The
prediction is then the most probable state for <code>X[t]</code> given this contexts.
Ties are broken according to the natural order in the state space, favouring
"small" values. The time series of predictions is returned by the function
when <code>type="raw"</code> (default case).
</p>
<p>When <code>type="probs"</code>, each <code>X[t]</code> is associated to the conditional
probabilities of the next state given the context. Those probabilities are
returned as a matrix of probabilities with column names given by the state
names.
</p>


<h3>Value</h3>

<p>A vector of predictions if <code>type="raw"</code> or a matrix of state
probabilities if <code>type="probs"</code>.
</p>


<h3>Extended contexts</h3>

<p>As explained in details in <code>loglikelihood.vlmc()</code> documentation and in the
dedicated <code>vignette("likelihood", package = "mixvlmc")</code>, the first initial
values of a time series do not in general have a proper context for a VLMC
with a non zero order. In order to predict something meaningful for those
values, we rely on the notion of extended context defined in the documents
mentioned above. This follows the same logic as using
<code>loglikelihood.vlmc()</code> with the parameter <code>initial="extended"</code>. All vlmc
functions that need to manipulate initial values with no proper context use
the same approach.
</p>


<h3>Examples</h3>

<pre><code class="language-R">pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts, min_size = 5)
predict(model, dts[1:5])
predict(model, dts[1:5], "probs")
## C++ backend
pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts, min_size = 5, backend = "C++")
predict(model, dts[1:5])
predict(model, dts[1:5], "probs")
</code></pre>


</div>