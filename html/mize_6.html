<div class="container">

<table style="width: 100%;"><tr>
<td>mize_step_summary</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mize Step Summary</h2>

<h3>Description</h3>

<p>Produces a result summary for an optimization iteration. Information such as
function value, gradient norm and step size may be returned.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mize_step_summary(opt, par, fg, par_old = NULL, calc_fn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>opt</code></td>
<td>
<p>Optimizer to generate summary for, from return value of
<code>mize_step</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>Vector of parameters at the end of the iteration, from return value
of <code>mize_step</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fg</code></td>
<td>
<p>Function and gradient list. See the documentation of
<code>mize</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_old</code></td>
<td>
<p>(Optional). Vector of parameters at the end of the previous
iteration. Used to calculate step size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calc_fn</code></td>
<td>
<p>(Optional). If <code>TRUE</code>, force calculation of function if
not already cached in <code>opt</code>, even if it would not be needed for
convergence checking.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default, convergence tolerance parameters will be used to determine what
function and gradient data is returned. The function value will be returned if
it was already calculated and cached in the optimization iteration. Otherwise,
it will be calculated only if a non-null absolute or relative tolerance value
was asked for. A gradient norm will be returned only if a non-null gradient
tolerance was specified, even if the gradient is available.
</p>
<p>Note that if a function tolerance was specified, but was not calculated for
the relevant value of <code>par</code>, they will be calculated here and the
calculation does contribute to the total function count (and will be cached
for potential use in the next iteration). The same applies for gradient
tolerances and gradient calculation. Function and gradient calculation can
also be forced here by setting the <code>calc_fn</code> and <code>calc_gr</code>
(respectively) parameters to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A list with the following items: </p>

<ul>
<li> <p><code>opt</code> Optimizer with updated state (e.g. function and gradient
counts).
</p>
</li>
<li> <p><code>iter</code> Iteration number.
</p>
</li>
<li> <p><code>f</code> Function value at <code>par</code>.
</p>
</li>
<li> <p><code>g2n</code> 2-norm of the gradient at <code>par</code>.
</p>
</li>
<li> <p><code>ginfn</code> Infinity-norm of the gradient at <code>par</code>.
</p>
</li>
<li> <p><code>nf</code> Number of function evaluations so far.
</p>
</li>
<li> <p><code>ng</code> Number of gradient evaluations so far.
</p>
</li>
<li> <p><code>step</code> Size of the step between <code>par_old</code> and <code>par</code>,
if <code>par_old</code> is provided.
</p>
</li>
<li> <p><code>alpha</code> Step length of the gradient descent part of the step.
</p>
</li>
<li> <p><code>mu</code> Momentum coefficient for this iteration</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">rb_fg &lt;- list(
  fn = function(x) {
    100 * (x[2] - x[1] * x[1])^2 + (1 - x[1])^2
  },
  gr = function(x) {
    c(
      -400 * x[1] * (x[2] - x[1] * x[1]) - 2 * (1 - x[1]),
      200 * (x[2] - x[1] * x[1])
    )
  }
)
rb0 &lt;- c(-1.2, 1)

opt &lt;- make_mize(method = "BFGS", par = rb0, fg = rb_fg, max_iter = 30)
mize_res &lt;- mize_step(opt = opt, par = rb0, fg = rb_fg)
# Get info about first step, use rb0 to compare new par with initial value
step_info &lt;- mize_step_summary(mize_res$opt, mize_res$par, rb_fg, rb0)
</code></pre>


</div>