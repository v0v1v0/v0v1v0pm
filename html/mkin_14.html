<div class="container">

<table style="width: 100%;"><tr>
<td>confint.mkinfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Confidence intervals for parameters of mkinfit objects</h2>

<h3>Description</h3>

<p>The default method 'quadratic' is based on the quadratic approximation of
the curvature of the likelihood function at the maximum likelihood parameter
estimates.
The alternative method 'profile' is based on the profile likelihood for each
parameter. The 'profile' method uses two nested optimisations and can take a
very long time, even if parallelized by specifying 'cores' on unixoid
platforms. The speed of the method could likely be improved by using the
method of Venzon and Moolgavkar (1988).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mkinfit'
confint(
  object,
  parm,
  level = 0.95,
  alpha = 1 - level,
  cutoff,
  method = c("quadratic", "profile"),
  transformed = TRUE,
  backtransform = TRUE,
  cores = parallel::detectCores(),
  rel_tol = 0.01,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An <code>mkinfit</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>A vector of names of the parameters which are to be given
confidence intervals. If missing, all parameters are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>The confidence level required</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The allowed error probability, overrides 'level' if specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>Possibility to specify an alternative cutoff for the difference
in the log-likelihoods at the confidence boundary. Specifying an explicit
cutoff value overrides arguments 'level' and 'alpha'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The 'quadratic' method approximates the likelihood function at
the optimised parameters using the second term of the Taylor expansion,
using a second derivative (hessian) contained in the object.
The 'profile' method searches the parameter space for the
cutoff of the confidence intervals by means of a likelihood ratio test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transformed</code></td>
<td>
<p>If the quadratic approximation is used, should it be
applied to the likelihood based on the transformed parameters?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backtransform</code></td>
<td>
<p>If we approximate the likelihood in terms of the
transformed parameters, should we backtransform the parameters with
their confidence intervals?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>The number of cores to be used for multicore processing.
On Windows machines, cores &gt; 1 is currently not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel_tol</code></td>
<td>
<p>If the method is 'profile', what should be the accuracy
of the lower and upper bounds, relative to the estimate obtained from
the quadratic method?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>Should we suppress the message "Profiling the likelihood"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A matrix with columns giving lower and upper confidence limits for
each parameter.
</p>


<h3>References</h3>

<p>Bates DM and Watts GW (1988) Nonlinear regression analysis &amp; its applications
</p>
<p>Pawitan Y (2013) In all likelihood - Statistical modelling and
inference using likelihood. Clarendon Press, Oxford.
</p>
<p>Venzon DJ and Moolgavkar SH (1988) A Method for Computing
Profile-Likelihood Based Confidence Intervals, Applied Statistics, 37,
87â€“94.
</p>


<h3>Examples</h3>

<pre><code class="language-R">f &lt;- mkinfit("SFO", FOCUS_2006_C, quiet = TRUE)
confint(f, method = "quadratic")

## Not run: 
confint(f, method = "profile")

# Set the number of cores for the profiling method for further examples
if (identical(Sys.getenv("NOT_CRAN"), "true")) {
  n_cores &lt;- parallel::detectCores() - 1
} else {
  n_cores &lt;- 1
}
if (Sys.getenv("TRAVIS") != "") n_cores = 1
if (Sys.info()["sysname"] == "Windows") n_cores = 1

SFO_SFO &lt;- mkinmod(parent = mkinsub("SFO", "m1"), m1 = mkinsub("SFO"),
  use_of_ff = "min", quiet = TRUE)
SFO_SFO.ff &lt;- mkinmod(parent = mkinsub("SFO", "m1"), m1 = mkinsub("SFO"),
  use_of_ff = "max", quiet = TRUE)
f_d_1 &lt;- mkinfit(SFO_SFO, subset(FOCUS_2006_D, value != 0), quiet = TRUE)
system.time(ci_profile &lt;- confint(f_d_1, method = "profile", cores = 1, quiet = TRUE))
# Using more cores does not save much time here, as parent_0 takes up most of the time
# If we additionally exclude parent_0 (the confidence of which is often of
# minor interest), we get a nice performance improvement if we use at least 4 cores
system.time(ci_profile_no_parent_0 &lt;- confint(f_d_1, method = "profile",
  c("k_parent_sink", "k_parent_m1", "k_m1_sink", "sigma"), cores = n_cores))
ci_profile
ci_quadratic_transformed &lt;- confint(f_d_1, method = "quadratic")
ci_quadratic_transformed
ci_quadratic_untransformed &lt;- confint(f_d_1, method = "quadratic", transformed = FALSE)
ci_quadratic_untransformed
# Against the expectation based on Bates and Watts (1988), the confidence
# intervals based on the internal parameter transformation are less
# congruent with the likelihood based intervals. Note the superiority of the
# interval based on the untransformed fit for k_m1_sink
rel_diffs_transformed &lt;- abs((ci_quadratic_transformed - ci_profile)/ci_profile)
rel_diffs_untransformed &lt;- abs((ci_quadratic_untransformed - ci_profile)/ci_profile)
rel_diffs_transformed &lt; rel_diffs_untransformed
signif(rel_diffs_transformed, 3)
signif(rel_diffs_untransformed, 3)


# Investigate a case with formation fractions
f_d_2 &lt;- mkinfit(SFO_SFO.ff, subset(FOCUS_2006_D, value != 0), quiet = TRUE)
ci_profile_ff &lt;- confint(f_d_2, method = "profile", cores = n_cores)
ci_profile_ff
ci_quadratic_transformed_ff &lt;- confint(f_d_2, method = "quadratic")
ci_quadratic_transformed_ff
ci_quadratic_untransformed_ff &lt;- confint(f_d_2, method = "quadratic", transformed = FALSE)
ci_quadratic_untransformed_ff
rel_diffs_transformed_ff &lt;- abs((ci_quadratic_transformed_ff - ci_profile_ff)/ci_profile_ff)
rel_diffs_untransformed_ff &lt;- abs((ci_quadratic_untransformed_ff - ci_profile_ff)/ci_profile_ff)
# While the confidence interval for the parent rate constant is closer to
# the profile based interval when using the internal parameter
# transformation, the interval for the metabolite rate constant is 'better
# without internal parameter transformation.
rel_diffs_transformed_ff &lt; rel_diffs_untransformed_ff
rel_diffs_transformed_ff
rel_diffs_untransformed_ff

# The profiling for the following fit does not finish in a reasonable time,
# therefore we use the quadratic approximation
m_synth_DFOP_par &lt;- mkinmod(parent = mkinsub("DFOP", c("M1", "M2")),
  M1 = mkinsub("SFO"),
  M2 = mkinsub("SFO"),
  use_of_ff = "max", quiet = TRUE)
DFOP_par_c &lt;- synthetic_data_for_UBA_2014[[12]]$data
f_tc_2 &lt;- mkinfit(m_synth_DFOP_par, DFOP_par_c, error_model = "tc",
  error_model_algorithm = "direct", quiet = TRUE)
confint(f_tc_2, method = "quadratic")
confint(f_tc_2, "parent_0", method = "quadratic")

## End(Not run)
</code></pre>


</div>