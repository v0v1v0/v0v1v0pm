<div class="container">

<table style="width: 100%;"><tr>
<td>nlme.mmkin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create an nlme model for an mmkin row object</h2>

<h3>Description</h3>

<p>This functions sets up a nonlinear mixed effects model for an mmkin row
object. An mmkin row object is essentially a list of mkinfit objects that
have been obtained by fitting the same model to a list of datasets.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mmkin'
nlme(
  model,
  data = "auto",
  fixed = lapply(as.list(names(mean_degparms(model))), function(el) eval(parse(text =
    paste(el, 1, sep = "~")))),
  random = pdDiag(fixed),
  groups,
  start = mean_degparms(model, random = TRUE, test_log_parms = TRUE),
  correlation = NULL,
  weights = NULL,
  subset,
  method = c("ML", "REML"),
  na.action = na.fail,
  naPattern,
  control = list(),
  verbose = FALSE
)

## S3 method for class 'nlme.mmkin'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'nlme.mmkin'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>An mmkin row object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Ignored, data are taken from the mmkin model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Ignored, all degradation parameters fitted in the
mmkin model are used as fixed parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>If not specified, no correlations between random effects are
set up for the optimised degradation model parameters. This is
achieved by using the nlme::pdDiag method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>See the documentation of nlme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>If not specified, mean values of the fitted degradation
parameters taken from the mmkin object are used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correlation</code></td>
<td>
<p>See the documentation of nlme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>passed to nlme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>passed to nlme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>passed to nlme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>passed to nlme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>naPattern</code></td>
<td>
<p>passed to nlme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>passed to nlme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>passed to nlme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An nlme.mmkin object to print</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits to use for printing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Update specifications passed to update.nlme</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An nlme.mmkin object to update</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that the convergence of the nlme algorithms depends on the quality
of the data. In degradation kinetics, we often only have few datasets
(e.g. data for few soils) and complicated degradation models, which may
make it impossible to obtain convergence with nlme.
</p>


<h3>Value</h3>

<p>Upon success, a fitted 'nlme.mmkin' object, which is an nlme object
with additional elements. It also inherits from 'mixed.mmkin'.
</p>


<h3>Note</h3>

<p>As the object inherits from nlme::nlme, there is a wealth of
methods that will automatically work on 'nlme.mmkin' objects, such as
<code>nlme::intervals()</code>, <code>nlme::anova.lme()</code> and <code>nlme::coef.lme()</code>.
</p>


<h3>See Also</h3>

<p><code>nlme_function()</code>, plot.mixed.mmkin, summary.nlme.mmkin
</p>


<h3>Examples</h3>

<pre><code class="language-R">ds &lt;- lapply(experimental_data_for_UBA_2019[6:10],
 function(x) subset(x$data[c("name", "time", "value")], name == "parent"))

## Not run: 
  f &lt;- mmkin(c("SFO", "DFOP"), ds, quiet = TRUE, cores = 1)
  library(nlme)
  f_nlme_sfo &lt;- nlme(f["SFO", ])
  f_nlme_dfop &lt;- nlme(f["DFOP", ])
  anova(f_nlme_sfo, f_nlme_dfop)
  print(f_nlme_dfop)
  plot(f_nlme_dfop)
  endpoints(f_nlme_dfop)

  ds_2 &lt;- lapply(experimental_data_for_UBA_2019[6:10],
   function(x) x$data[c("name", "time", "value")])
  m_sfo_sfo &lt;- mkinmod(parent = mkinsub("SFO", "A1"),
    A1 = mkinsub("SFO"), use_of_ff = "min", quiet = TRUE)
  m_sfo_sfo_ff &lt;- mkinmod(parent = mkinsub("SFO", "A1"),
    A1 = mkinsub("SFO"), use_of_ff = "max", quiet = TRUE)
  m_dfop_sfo &lt;- mkinmod(parent = mkinsub("DFOP", "A1"),
    A1 = mkinsub("SFO"), quiet = TRUE)

  f_2 &lt;- mmkin(list("SFO-SFO" = m_sfo_sfo,
   "SFO-SFO-ff" = m_sfo_sfo_ff,
   "DFOP-SFO" = m_dfop_sfo),
    ds_2, quiet = TRUE)

  f_nlme_sfo_sfo &lt;- nlme(f_2["SFO-SFO", ])
  plot(f_nlme_sfo_sfo)

  # With formation fractions this does not coverge with defaults
  # f_nlme_sfo_sfo_ff &lt;- nlme(f_2["SFO-SFO-ff", ])
  #plot(f_nlme_sfo_sfo_ff)

  # For the following, we need to increase pnlsMaxIter and the tolerance
  # to get convergence
  f_nlme_dfop_sfo &lt;- nlme(f_2["DFOP-SFO", ],
    control = list(pnlsMaxIter = 120, tolerance = 5e-4))

  plot(f_nlme_dfop_sfo)

  anova(f_nlme_dfop_sfo, f_nlme_sfo_sfo)

  endpoints(f_nlme_sfo_sfo)
  endpoints(f_nlme_dfop_sfo)

  if (length(findFunction("varConstProp")) &gt; 0) { # tc error model for nlme available
    # Attempts to fit metabolite kinetics with the tc error model are possible,
    # but need tweeking of control values and sometimes do not converge

    f_tc &lt;- mmkin(c("SFO", "DFOP"), ds, quiet = TRUE, error_model = "tc")
    f_nlme_sfo_tc &lt;- nlme(f_tc["SFO", ])
    f_nlme_dfop_tc &lt;- nlme(f_tc["DFOP", ])
    AIC(f_nlme_sfo, f_nlme_sfo_tc, f_nlme_dfop, f_nlme_dfop_tc)
    print(f_nlme_dfop_tc)
  }

  f_2_obs &lt;- update(f_2, error_model = "obs")
  f_nlme_sfo_sfo_obs &lt;- nlme(f_2_obs["SFO-SFO", ])
  print(f_nlme_sfo_sfo_obs)
  f_nlme_dfop_sfo_obs &lt;- nlme(f_2_obs["DFOP-SFO", ],
    control = list(pnlsMaxIter = 120, tolerance = 5e-4))

  f_2_tc &lt;- update(f_2, error_model = "tc")
  # f_nlme_sfo_sfo_tc &lt;- nlme(f_2_tc["SFO-SFO", ]) # No convergence with 50 iterations
  # f_nlme_dfop_sfo_tc &lt;- nlme(f_2_tc["DFOP-SFO", ],
  #  control = list(pnlsMaxIter = 120, tolerance = 5e-4)) # Error in X[, fmap[[nm]]] &lt;- gradnm

  anova(f_nlme_dfop_sfo, f_nlme_dfop_sfo_obs)


## End(Not run)
</code></pre>


</div>