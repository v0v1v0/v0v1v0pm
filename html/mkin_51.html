<div class="container">

<table style="width: 100%;"><tr>
<td>ilr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to perform isometric log-ratio transformation</h2>

<h3>Description</h3>

<p>This implementation is a special case of the class of isometric log-ratio
transformations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ilr(x)

invilr(x)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A numeric vector. Naturally, the forward transformation is only
sensible for vectors with all elements being greater than zero.</p>
</td>
</tr></table>
<h3>Value</h3>

<p>The result of the forward or backward transformation. The returned
components always sum to 1 for the case of the inverse log-ratio
transformation.
</p>


<h3>Author(s)</h3>

<p>Ren√© Lehmann and Johannes Ranke
</p>


<h3>References</h3>

<p>Peter Filzmoser, Karel Hron (2008) Outlier Detection for
Compositional Data Using Robust Methods. Math Geosci 40 233-248
</p>


<h3>See Also</h3>

<p>Another implementation can be found in R package
<code>robCompositions</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Order matters
ilr(c(0.1, 1, 10))
ilr(c(10, 1, 0.1))
# Equal entries give ilr transformations with zeros as elements
ilr(c(3, 3, 3))
# Almost equal entries give small numbers
ilr(c(0.3, 0.4, 0.3))
# Only the ratio between the numbers counts, not their sum
invilr(ilr(c(0.7, 0.29, 0.01)))
invilr(ilr(2.1 * c(0.7, 0.29, 0.01)))
# Inverse transformation of larger numbers gives unequal elements
invilr(-10)
invilr(c(-10, 0))
# The sum of the elements of the inverse ilr is 1
sum(invilr(c(-10, 0)))
# This is why we do not need all elements of the inverse transformation to go back:
a &lt;- c(0.1, 0.3, 0.5)
b &lt;- invilr(a)
length(b) # Four elements
ilr(c(b[1:3], 1 - sum(b[1:3]))) # Gives c(0.1, 0.3, 0.5)

</code></pre>


</div>