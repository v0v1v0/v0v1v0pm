<div class="container">

<table style="width: 100%;"><tr>
<td>mhmkin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit nonlinear mixed-effects models built from one or more kinetic
degradation models and one or more error models</h2>

<h3>Description</h3>

<p>The name of the methods expresses that (<strong>m</strong>ultiple) <strong>h</strong>ierarchichal
(also known as multilevel) <strong>m</strong>ulticompartment <strong>kin</strong>etic models are
fitted. Our kinetic models are nonlinear, so we can use various nonlinear
mixed-effects model fitting functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mhmkin(objects, ...)

## S3 method for class 'mmkin'
mhmkin(objects, ...)

## S3 method for class 'list'
mhmkin(
  objects,
  backend = "saemix",
  algorithm = "saem",
  no_random_effect = NULL,
  ...,
  cores = if (Sys.info()["sysname"] == "Windows") 1 else parallel::detectCores(),
  cluster = NULL
)

## S3 method for class 'mhmkin'
x[i, j, ..., drop = FALSE]

## S3 method for class 'mhmkin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>objects</code></td>
<td>
<p>A list of mmkin objects containing fits of the same
degradation models to the same data, but using different error models.
Alternatively, a single mmkin object containing fits of several
degradation models to the same data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments that will be passed to the nonlinear mixed-effects
model fitting function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backend</code></td>
<td>
<p>The backend to be used for fitting. Currently, only saemix is
supported</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>The algorithm to be used for fitting (currently not used)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no_random_effect</code></td>
<td>
<p>Default is NULL and will be passed to saem. If a
character vector is supplied, it will be passed to all calls to saem,
which will exclude random effects for all matching parameters. Alternatively,
a list of character vectors or an object of class illparms.mhmkin can be
specified. They have to have the same dimensions that the return object of
the current call will have, i.e. the number of rows must match the number
of degradation models in the mmkin object(s), and the number of columns must
match the number of error models used in the mmkin object(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>The number of cores to be used for multicore processing. This
is only used when the <code>cluster</code> argument is <code>NULL</code>. On Windows
machines, cores &gt; 1 is not supported, you need to use the <code>cluster</code>
argument to use multiple logical processors. Per default, all cores detected
by <code>parallel::detectCores()</code> are used, except on Windows where the default
is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>A cluster as returned by makeCluster to be used for
parallel execution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An mhmkin object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>Row index selecting the fits for specific models</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>j</code></td>
<td>
<p>Column index selecting the fits to specific datasets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>If FALSE, the method always returns an mhmkin object, otherwise
either a list of fit objects or a single fit object.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A two-dimensional array of fit objects and/or try-errors that can
be indexed using the degradation model names for the first index (row index)
and the error model names for the second index (column index), with class
attribute 'mhmkin'.
</p>
<p>An object inheriting from <code>mhmkin</code>.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>See Also</h3>

<p><code>[.mhmkin</code> for subsetting mhmkin objects
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# We start with separate evaluations of all the first six datasets with two
# degradation models and two error models
f_sep_const &lt;- mmkin(c("SFO", "FOMC"), ds_fomc[1:6], cores = 2, quiet = TRUE)
f_sep_tc &lt;- update(f_sep_const, error_model = "tc")
# The mhmkin function sets up hierarchical degradation models aka
# nonlinear mixed-effects models for all four combinations, specifying
# uncorrelated random effects for all degradation parameters
f_saem_1 &lt;- mhmkin(list(f_sep_const, f_sep_tc), cores = 2)
status(f_saem_1)
# The 'illparms' function shows that in all hierarchical fits, at least
# one random effect is ill-defined (the confidence interval for the
# random effect expressed as standard deviation includes zero)
illparms(f_saem_1)
# Therefore we repeat the fits, excluding the ill-defined random effects
f_saem_2 &lt;- update(f_saem_1, no_random_effect = illparms(f_saem_1))
status(f_saem_2)
illparms(f_saem_2)
# Model comparisons show that FOMC with two-component error is preferable,
# and confirms our reduction of the default parameter model
anova(f_saem_1)
anova(f_saem_2)
# The convergence plot for the selected model looks fine
saemix::plot(f_saem_2[["FOMC", "tc"]]$so, plot.type = "convergence")
# The plot of predictions versus data shows that we have a pretty data-rich
# situation with homogeneous distribution of residuals, because we used the
# same degradation model, error model and parameter distribution model that
# was used in the data generation.
plot(f_saem_2[["FOMC", "tc"]])
# We can specify the same parameter model reductions manually
no_ranef &lt;- list("parent_0", "log_beta", "parent_0", c("parent_0", "log_beta"))
dim(no_ranef) &lt;- c(2, 2)
f_saem_2m &lt;- update(f_saem_1, no_random_effect = no_ranef)
anova(f_saem_2m)

## End(Not run)
</code></pre>


</div>