<div class="container">

<table style="width: 100%;"><tr>
<td>mlapiDecomposition</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Base abstract class for all decompositions</h2>

<h3>Description</h3>

<p>Base class for all <b>decompositions</b> which are methods which can decompose matrix into
2 low-dimensional matrices <code>x = f(A, B)</code>.
(Think of this Latent Dirichlet Allocation, Non-negative Matrix Factorization, etc).
It iherits from mlapiTransformation and additionally requires to implement <code>components</code> member.
</p>
<p>Base class for all <b>decompositions</b> which are methods which can decompose matrix into
2 low-dimensional matrices <code>x = f(A, B)</code> <b>incrementally</b>.
It iherits from mlapiDecomposition and additionally requires
to implement <code>partial_fit</code> method which can learn <code>components</code> incrementally.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mlapiDecomposition

mlapiDecompositionOnline
</code></pre>


<h3>Format</h3>

<p><code>R6Class</code> object.</p>


<h3>Fields</h3>


<dl>
<dt><code>components</code></dt>
<dd>
<p>features embeddings. So if matrix is decomposed in a form <code>x = f(A, B)</code> where
X = n\*m, A = n\*k, B = k\*m them <code>B = components</code></p>
</dd>
<dt><code>components</code></dt>
<dd>
<p>features embeddings. So if matrix is decomposed in a form <code>x = f(A, B)</code> where
X = n\*m, A = n\*k, B = k\*m them <code>B = components</code></p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt><code>$fit_transform(x, y = NULL, ...)</code></dt>
<dd></dd>
<dt><code>$transform(x, ...)</code></dt>
<dd>
<p>Performs transformation of the new data (after model was trained)</p>
</dd>
</dl>
<dl>
<dt><code>$fit_transform(x, y = NULL, ...)</code></dt>
<dd></dd>
<dt><code>$partial_fit(x, y = NULL, ...)</code></dt>
<dd></dd>
<dt><code>$transform(x, ...)</code></dt>
<dd>
<p>Performs transformation of the new data (after model was trained)</p>
</dd>
</dl>
<h3>Arguments</h3>


<dl>
<dt>x</dt>
<dd>
<p>A matrix like object, should <b>inherit from <code>Matrix</code> or <code>matrix</code></b>.
Allowed classes should be defined in child classes.</p>
</dd>
<dt>y</dt>
<dd>
<p><code>NULL</code>. Optional taget variable. Usually this should be <code>NULL</code>.
There few cases when it could be used.</p>
</dd>
<dt>...</dt>
<dd>
<p>additional parameters <b>with default values</b></p>
</dd>
</dl>
<dl>
<dt>x</dt>
<dd>
<p>A matrix like object, should <b>inherit from <code>Matrix</code> or <code>matrix</code></b>.
Allowed classes should be defined in child classes.</p>
</dd>
<dt>y</dt>
<dd>
<p><code>NULL</code>. Optional taget variable. Usually this should be <code>NULL</code>.
There few cases when it could be used.</p>
</dd>
<dt>...</dt>
<dd>
<p>additional parameters <b>with default values</b></p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">TruncatedSVD = R6::R6Class(
  classname = "TruncatedSVD",
  inherit = mlapi::mlapiDecomposition,
  public = list(
    initialize = function(rank = 10) {
      private$rank = rank
      super$set_internal_matrix_formats(dense = "matrix", sparse = NULL)
    },
    fit_transform = function(x, ...) {
      x = super$check_convert_input(x)
      private$n_features = ncol(x)
      svd_fit = svd(x, nu = private$rank, nv = private$rank, ...)
      sing_values = svd_fit$d[seq_len(private$rank)]
      result = svd_fit$u %*% diag(x = sqrt(sing_values))
      private$components_ = t(svd_fit$v %*% diag(x = sqrt(sing_values)))
      rm(svd_fit)
      rownames(result) = rownames(x)
      colnames(private$components_) = colnames(x)
      private$fitted = TRUE
      invisible(result)
    },
    transform = function(x, ...) {
      if (private$fitted) {
        stopifnot(ncol(x) == ncol(private$components_))
        lhs = tcrossprod(private$components_)
        rhs = as.matrix(tcrossprod(private$components_, x))
        t(solve(lhs, rhs))
      }
      else
        stop("Fit the model first woth model$fit_transform()!")
    }
  ),
  private = list(
    rank = NULL,
    n_features = NULL,
    fitted = NULL
  )
)
set.seed(1)
model = TruncatedSVD$new(2)
x = matrix(sample(100 * 10, replace = TRUE), ncol = 10)
x_trunc = model$fit_transform(x)
dim(x_trunc)

x_trunc_2 = model$transform(x)
sum(x_trunc_2 - x_trunc)

#' check pipe-compatible S3 interface
x_trunc_2_s3 = transform(x, model)
identical(x_trunc_2, x_trunc_2_s3)
</code></pre>


</div>