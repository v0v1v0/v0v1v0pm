<div class="container">

<table style="width: 100%;"><tr>
<td>mlegp-svd-functions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Singular Value Decomposition functions for mlegp </h2>

<h3>Description</h3>

<p>Functions that deal with the singular value decomposition of an output Y, for use with Gaussian process lists
</p>


<h3>Usage</h3>

<pre><code class="language-R">pcweights(Y, weights.num = NULL, cutoff = 99)
getSingularValues(Y)
singularValueImportance(Y)
numSingularValues(Y, cutoff = 99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p> the output to decompose, where each column of <code>Y</code> correspond to k-dimensional output </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.num</code></td>
<td>
<p> optionally, the number of principle component weights to keep </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p> if specified, <code>weights.num</code> is set to correspond to number of principle component weights that account for <code>cutoff</code> percent of the total variation in <code>Y</code>; if both <code>cutoff</code> and <code>weights.num</code> are specified, <code>weights.num</code> will be used</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Utilizes the singular value decomposition (SVD) of <code>Y</code>, Y = UDVprime. Columns of <code>Y</code> should correspond to a single k-dimensional observation (e.g., functional output of a computer model, evaluated at a particular input).      
</p>
<p>For a k x m matrix <code>Y</code>, and r = min(k,m), in the complete SVD, <code>U</code> is k x r, <code>D</code> is r x r, containing the singular values along the diagonal, and <code>Vprime</code> is r x m. The output <code>Y</code> is approximated by keeping l &lt; r singular values, keeping a UD matrix of dimension k x l, and the <code>Vprime</code> matrix of dimension l x m. Each column of <code>Vprime</code> now contains l principle component weights, which can be used to reconstruct the functional output.        
</p>


<h3>Value</h3>

<p><code>pcweights</code> returns a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>UD</code></td>
<td>
<p>the UD matrix corresponding to the number of principle components kept</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vprime</code></td>
<td>
<p>The Vprime matrix corresponding to the number of principle components kept</p>
</td>
</tr>
</table>
<p>Note: the number of principle component weights kept is equal to dim(UD)[2]
</p>
<p><code>getSingularValues</code> returns a matrix containing the singular values of <code>Y</code>
</p>
<p><code>numSingularValues</code> returns the minimum number of singular values accounting for <code>cutoff</code> percent of the variation in <code>Y</code>
</p>
<p><code>singularValueImportance</code> returns a matrix where element i corresponds to the percentage of total variation in <code>Y</code> accounted for by the first i singular values 
</p>


<h3>Note</h3>

<p> these functions are utilized by <code>mlegp</code> to fit Gaussian processes to principle component weights</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

<p> Heitmann, K., Higdon, D., Nakhleh, C., Habib, S., 2006. Cosmic Calibration. The Astrophysical Journal, 646, 2, L1-L4.
</p>
<p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> 
</p>


<h3>See Also</h3>

 <p><code>mlegp</code></p>


<h3>Examples</h3>

<pre><code class="language-R">

## create functional output that varies based on parameter 'p' ##
x = seq(-5,5,by=.2)
p = 1:50
y = matrix(0,length(p), length(x))
for (i in p) {
	y[i,] = sin(x) + i + rnorm(length(x), sd  = .1)
}

singularValueImportance(t(y))
numSingularValues(t(y), cutoff = 99.99)

</code></pre>


</div>