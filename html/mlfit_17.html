<div class="container">

<table style="width: 100%;"><tr>
<td>ml_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate weights for a fitting problem</h2>

<h3>Description</h3>

<p>These functions reweight a reference sample to match constraints given by
aggregate controls.
</p>
<p><code>ml_fit()</code> accepts an algorithm as argument and calls the
corresponding function. This is useful if the result of multiple algorithms
are compared to each other.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ml_fit(
  ml_problem,
  algorithm = c("entropy_o", "dss", "ipu", "hipf"),
  verbose = FALSE,
  ...,
  tol = 1e-06
)

is_ml_fit(x)

## S3 method for class 'ml_fit'
format(x, ...)

## S3 method for class 'ml_fit'
print(x, ...)

ml_fit_dss(
  ml_problem,
  method = c("raking", "linear", "logit"),
  ginv = gginv(),
  tol = 1e-06,
  verbose = FALSE
)

ml_fit_entropy_o(
  ml_problem,
  verbose = FALSE,
  tol = 1e-06,
  dfsane_args = list()
)

ml_fit_hipf(
  ml_problem,
  diff_tol = 16 * .Machine$double.eps,
  tol = 1e-06,
  maxiter = 2000,
  verbose = FALSE
)

ml_fit_ipu(
  ml_problem,
  diff_tol = 16 * .Machine$double.eps,
  tol = 1e-06,
  maxiter = 2000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ml_problem</code></td>
<td>
<p>A fitting problem created by
<code>ml_problem()</code> or returned by <code>flatten_ml_fit_problem()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>Algorithm to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, print diagnostic output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further parameters passed to the algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance, the algorithm has succeeded when all target values are
reached within this tolerance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Calibration method, one of <code>"raking"</code> (default),
<code>"linear"</code>, or <code>"logit"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ginv</code></td>
<td>
<p>Function that computes the Moore-Penrose pseudoinverse.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfsane_args</code></td>
<td>
<p>Additional arguments (as a named list) passed to the
<code>BB::dfsane()</code> function used internally for the optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diff_tol</code></td>
<td>
<p>Tolerance, the algorithm stops when relative difference of
control values between iterations drops below this value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>All functions return an object of class <code>ml_fit</code>, which is
a named list under the hood.  The class matches the function called,
e.g., the return value of the <code>ml_fit_ipu</code> function also is of class
<code>ml_fit_ipu</code>.
</p>
<p>All returned objects contain at least the following components, which can be
accessed with <code>$</code> or <code>[[</code>:
</p>

<ul>
<li> <p><code>weights</code>: Resulting weights, compatible to the original reference sample
</p>
</li>
<li> <p><code>tol</code>: The input tolerance
</p>
</li>
<li> <p><code>iterations</code>: The actual number of iterations required to obtain the result
</p>
</li>
<li> <p><code>flat</code>: The flattened fitting problem, see <code>flatten_ml_fit_problem()</code>
</p>
</li>
<li> <p><code>flat_weights</code>: Weights in terms of the flattened fitting problem
</p>
</li>
<li> <p><code>residuals</code>: Absolute residuals
</p>
</li>
</ul>
<ul>
<li> <p><code>rel_residuals</code>: Relative residuals
</p>
</li>
<li> <p><code>success</code>: Are the residuals within the tolerance?
</p>
</li>
</ul>
<p><code>is_ml_fit()</code> returns a logical.
</p>


<h3>References</h3>

<p>Deville, J.-C. and Särndal, C.-E. (1992)
Calibration estimators in survey sampling. <em>Journal of the American
Statistical Association</em>, <strong>87</strong> (418), 376–382.
</p>
<p>Deville, J.-C., Särndal, C.-E. and Sautory, O. (1993)
Generalized raking procedures in survey sampling. <em>Journal of the
American Statistical Association</em>, <strong>88</strong> (423), 1013–1020.
</p>
<p>Bar-Gera, H., Konduri, K. C., Sana, B., Ye, X., &amp; Pendyala, R. M.
(2009, January). Estimating survey weights with multiple
constraints using entropy optimization methods. In 88th Annual
Meeting of the Transportation Research Board, Washington, DC.
</p>
<p>Müller, K. and Axhausen, K. W. (2011), Hierarchical IPF: Generating a
synthetic population for Switzerland, paper presented at the 51st
Congress of the European Regional Science Association, University of
Barcelona, Barcelona.
</p>
<p>Ye, X., K. Konduri, R. M. Pendyala, B. Sana and P. A. Waddell (2009)
A methodology to match distributions of both household and person attributes
in the generation of synthetic populations, paper presented at the <em>88th
Annual Meeting of the Transportation Research Board</em>, Washington, D.C.,
January 2009.
</p>


<h3>See Also</h3>

<p><code>dss()</code>, <code>gginv()</code>
</p>
<p><code>BB::dfsane()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">path &lt;- toy_example("Tiny")
fit &lt;- ml_fit(ml_problem = readRDS(path), algorithm = "entropy_o")
fit
fit$weights
fit$tol
fit$iterations
fit$flat
fit$flat_weights
fit$residuals
fit$rel_residuals
fit$success
ml_fit_dss(ml_problem = readRDS(path))
ml_fit_dss(ml_problem = readRDS(path), ginv = solve)
ml_fit_entropy_o(ml_problem = readRDS(path))
ml_fit_hipf(ml_problem = readRDS(path))
ml_fit_ipu(ml_problem = readRDS(path))
</code></pre>


</div>