<div class="container">

<table style="width: 100%;"><tr>
<td>mlim.error</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>imputation error</h2>

<h3>Description</h3>

<p>calculates NRMSE, missclassification rate, and miss-ranking
absolute mean distance, scaled between 0 to 1, where 1 means
maximum distance between the actual rank of a level and the
imputed level.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mlim.error(
  imputed,
  incomplete,
  complete,
  transform = NULL,
  varwise = FALSE,
  ignore.missclass = TRUE,
  ignore.rank = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>imputed</code></td>
<td>
<p>the imputed dataframe</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incomplete</code></td>
<td>
<p>the dataframe with missing values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete</code></td>
<td>
<p>the original dataframe with no missing values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>
<p>character. it can be either "standardize", which standardizes the
numeric variables before evaluating the imputation error, or
"normalize", which change the scale of continuous variables to
range from 0 to 1. the default is NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varwise</code></td>
<td>
<p>logical, default is FALSE. if TRUE, in addition to
mean accuracy for each variable type, the algorithm's
performance for each variable (column) of the datast is
also returned. if TRUE, instead of a numeric vector, a
list is retuned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.missclass</code></td>
<td>
<p>logical. the default is TRUE. if FALSE, the overall
missclassification rate for imputed unordered factors will be
returned. in general, missclassification is not recommended,
particularly for multinomial factors because it is not robust
to imbalanced data. in other words, an imputation might show
a very high accuracy, because it is biased towards the majority
class, ignoring the minority levels. to avoid this error,
Mean Per Class Error (MPCE) is returned, which is the average
missclassification of each class and thus, it is a fairer
criteria for evaluating multinomial classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.rank</code></td>
<td>
<p>logical (default is FALSE, which is recommended). if TRUE,
the accuracy of imputation of ordered factors (ordinal variables)
will be evaluated based on 'missclassification rate' instead of
normalized euclidean distance. this practice is not recommended
because higher classification rate for ordinal variables does not
guarantee lower distances between the imputed levels, despite the
popularity of evaluating ordinal variables based on missclassification
rate. in other words, assume an ordinal variable has 5 levels (1. strongly
disagree, 2. disagree, 3. uncertain, 4. agree, 5.strongly agree). in this
example, if "ignore.rank = TRUE", then an imputation that imputes level
"5" as "4" is equally inaccurate as other algorithm that imputes level "5"
as "1". therefore, if you have ordinal variables in your dataset, make sure
you declare them as "ordered" factors to get the best imputation accuracy.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>E. F. Haghish
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
data(iris)

# add 10% missing values, ensure missingness is stratified for factors
irisNA &lt;- mlim.na(iris, p = 0.1, stratify = TRUE, seed = 2022)

# run the default imputation
MLIM &lt;- mlim(irisNA)
mlim.error(MLIM, irisNA, iris)

# get error estimations for each variable
mlim.error(MLIM, irisNA, iris, varwise = TRUE)

## End(Not run)
</code></pre>


</div>