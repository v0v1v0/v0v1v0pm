<div class="container">

<table style="width: 100%;"><tr>
<td>scoreBased</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Score based variance estimation for multiple imputation</h2>

<h3>Description</h3>

<p>This function implements the score based variance estimation approach described by von Hippel
and Bartlett (2021), which is based on earlier work by Wang and Robins (1998).
</p>


<h3>Usage</h3>

<pre><code class="language-R">scoreBased(imps, analysisFun, scoreFun, pd = NULL, dfComplete = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>imps</code></td>
<td>
<p>A list of imputed datasets produced by one of the imputation functions
in <code>mlmi</code> or another package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>analysisFun</code></td>
<td>
<p>A function to analyse the imputed datasets that when applied to
a dataset returns a list containing a vector <code>est</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scoreFun</code></td>
<td>
<p>A function whose first argument is a dataset and whose second argument is
a vector of parameter values. It should return a matrix of subject level scores
evaluated at the parameter value passed to it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pd</code></td>
<td>
<p>If <code>imps</code> was not generated by one of the imputation functions in
<code>mlmi</code>, this argument must be specified to indicate whether the imputations
were generated using posterior draws (TRUE) or not (FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfComplete</code></td>
<td>
<p>The complete data degrees of freedom. If <code>analysisFun</code> returns a vector
of parameter estimates, <code>dfComplete</code> should be a vector of the same length. If not
specified, it is assumed that the complete data degrees of freedom is effectively infinite (1e+05).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other parameters that are to be passed through to <code>analysisFun</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the overall parameter estimates, its corresponding covariance matrix, and
degrees of freedom for each parameter.
</p>


<h3>References</h3>

<p>Wang N., Robins J.M. (1998) Large-sample theory for parametric multiple imputation procedures.
Biometrika 85(4): 935-948. <a href="https://doi.org/10.1093/biomet/85.4.935">doi:10.1093/biomet/85.4.935</a>.
</p>
<p>von Hippel P.T. and Bartlett J.W. Maximum likelihood multiple imputation: faster,
more efficient imputation without posterior draws. Statistical Science 2021; 36(3) 400-420 <a href="https://doi.org/10.1214/20-STS793">doi:10.1214/20-STS793</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#simulate a partially observed dataset
set.seed(1234)
n &lt;- 100
x &lt;- rnorm(n)
y &lt;- x+rnorm(n)
y[1:50] &lt;- NA
temp &lt;- data.frame(x,y)
#impute using normUniImp, without posterior draws
imps &lt;- normUniImp(temp, y~x, M=10, pd=FALSE)

#define a function which performs our desired analysis on a dataset, returning
#the parameter estimates
yonx &lt;- function(inputData) {
  fitmod &lt;- lm(y~x, data=inputData)
  list(est=c(fitmod$coef,sigma(fitmod)^2))
}

#define a function which when passed a dataset and parameter
#vector, calculates the likelihood score vector
myScore &lt;- function(inputData, parm) {
  beta0 &lt;- parm[1]
  beta1 &lt;- parm[2]
  sigmasq &lt;- parm[3]
  res &lt;- inputData$y - beta0 - beta1*inputData$x
  cbind(res/sigmasq, (res*inputData$x)/sigmasq, res^2/(2*sigmasq^2)-1/(2*sigmasq))
}

#call scoreBased to perform variance estimation
scoreBased(imps, analysisFun=yonx, scoreFun=myScore)
</code></pre>


</div>