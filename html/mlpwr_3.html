<div class="container">

<table style="width: 100%;"><tr>
<td>find.design</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find optimal study designs</h2>

<h3>Description</h3>

<p>Perform a surrogate modeling approach to search for optimal study design parameters. For further guidance on how to use the package and the <code>find.design</code> function specifically, see the <a href="https://github.com/flxzimmer/mlpwr">Readme.md file</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">find.design(
  simfun,
  boundaries,
  power = NULL,
  evaluations = 4000,
  ci = NULL,
  ci_perc = 0.95,
  time = NULL,
  costfun = NULL,
  cost = NULL,
  surrogate = NULL,
  n.startsets = 4,
  init.perc = 0.2,
  setsize = NULL,
  continue = NULL,
  dat = NULL,
  silent = FALSE,
  autosave_dir = NULL,
  control = list(),
  goodvals = "high",
  aggregate_fun = mean,
  noise_fun = "bernoulli",
  integer = TRUE,
  use_noise = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>simfun</code></td>
<td>
<p>function to generate hypothesis test results with. Takes design parameters as input and outputs a logical (result of the hypothesis test). The function can take the designs through one argument as a vector or through multiple arguments. For example, function(x) where x is later used with x=c(n,k) for two design parameters n and k is valid. Also valid is a definition using function(n,k).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundaries</code></td>
<td>
<p>list containing lower and upper bounds of the design space. The list should consist of named vectors, each containing the upper and lower bound for the respective design parameter dimensions. For one design parameter dimension, can also be a vector containing the upper and lower bounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p>numeric; desired statistical power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaluations</code></td>
<td>
<p>integer; number of simfun evaluations to be performed before termination</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>numeric; desired width of the confidence interval at the predicted value on termination.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci_perc</code></td>
<td>
<p>numeric; specifying the desired confidence interval, e.g. 95% or 99%.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>integer; seconds until termination</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>costfun</code></td>
<td>
<p>function that takes a vector of design parameters as input and outputs a cost, e.g. monetary costs. Necessary for simfuns with multiple input dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>numeric; cost threshold. Design parameter set with highest power is searched among sets that fulfill this cost threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>surrogate</code></td>
<td>
<p>character; which surrogate model should be used. The default is 'logreg' for one design parameter and 'gpr' for multiple design parameters. The current options are: 'gpr', 'svr', 'logreg', 'reg' for one-dimensional designs and 'gpr' and 'svr' for multi-dimensional designs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.startsets</code></td>
<td>
<p>integer; number of startsets used per dimension of simfun</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.perc</code></td>
<td>
<p>numeric; percentage of evaluations used for the initialization phase</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>setsize</code></td>
<td>
<p>The number of draws from the simfun in each iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>continue</code></td>
<td>
<p>Object of class designresult as created by the find.design function. Will be used to continue the search, using all collected simulation results so far.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>list of data from a previous design result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>logical; suppresses output during the search.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autosave_dir</code></td>
<td>
<p>character; file location for saving the <code>dat</code> object after each update. The <code>dat</code> object is saved in <code>autosave_dir/dat_autosave.Rdata</code>. It can be loaded for example using <code>load(paste0(autosave_dir,"/dat_autosave.Rdata"))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list specifying arguments passed to the surrogate models. For example, list(covtype='gauss') can be used with the gpr surrogate to use a different covariance structure than the default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>goodvals</code></td>
<td>
<p>character indicating whether higher or lower criterion values are preferable given equal cost; the default is "high" for statistical power, the other option is "low".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate_fun</code></td>
<td>
<p>function to aggregate results of the evaluations of the simulation function; the default is <code>mean</code>, as for statistical power.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise_fun</code></td>
<td>
<p>function to calculate the noise or variance of the aggregated results of the Monte Carlo evaluations; can also be the character value "bernoulli" (default) to indicate the variance of the Bernoulli distribution used for statistical power. This function is <code class="reqn">p(1-p)/n</code>, where <code class="reqn">p</code> is the statistical power and <code class="reqn">n</code> is the number of performed evaluations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integer</code></td>
<td>
<p>logical  indicating whether the design parameters are integers or not; the default is <code>TRUE</code>, which is suitable for sample size, for example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_noise</code></td>
<td>
<p>logical indicating whether noise variance should be used; the default is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>function returns an object of class designresult
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## T-test example:

# Load a simulation function
simfun &lt;- example.simfun('ttest')
# Perform the search
ds &lt;- find.design(simfun = simfun, boundaries = c(100,300), power = .95)
# Output the results
summary(ds)
# Plot results
plot(ds)

## Two-dimensional simulation function:

simfun &lt;- example.simfun('anova')
# Perform the search
ds &lt;- find.design(simfun = simfun,
 costfun = function(n,n.groups) 5*n+20*n.groups,
 boundaries = list(n = c(10, 150), n.groups = c(5, 30)),
 power = .95)
# Output the results
summary(ds)
# Plot results
plot(ds)


##  Mixed model example with a custom, two-dimensional simulation function:

library(lme4)
library(lmerTest)

# Simulation function
simfun_multilevel &lt;- function(n.per.school,n.schools) {

  # generate data
  group = rep(1:n.schools,each=n.per.school)
  pred = factor(rep(c("old","new"),n.per.school*n.schools),levels=c("old","new"))
  dat = data.frame(group = group, pred = pred)

  params &lt;- list(theta = c(.5,0,.5), beta = c(0,1),sigma = 1.5)
  names(params$theta) = c("group.(Intercept)","group.prednew.(Intercept)","group.prednew")
  names(params$beta) = c("(Intercept)","prednew")
  dat$y &lt;- simulate.formula(~pred + (1 + pred | group), newdata = dat, newparams = params)[[1]]

  # test hypothesis
  mod &lt;- lmer(y ~ pred + (1 + pred | group), data = dat)
  pvalue &lt;- summary(mod)[["coefficients"]][2,"Pr(&gt;|t|)"]
  pvalue &lt; .01
}
# Cost function
costfun_multilevel &lt;- function(n.per.school, n.schools) {
  100 * n.per.school + 200 * n.schools
}
# Perform the search, can take a few minutes to run
ds &lt;- find.design(simfun = simfun_multilevel, costfun = costfun_multilevel,
boundaries = list(n.per.school = c(5, 25), n.schools = c(10, 30)), power = .95,
evaluations = 1000)
# Output the results
summary(ds)
# Plot results
plot(ds)


</code></pre>


</div>