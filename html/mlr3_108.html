<div class="container">

<table style="width: 100%;"><tr>
<td>DataBackendMatrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>DataBackend for Matrix</h2>

<h3>Description</h3>

<p>DataBackend for <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a>.
Data is split into a (numerical) sparse part and an optional dense part.
These parts are automatically merged to a sparse format during <code style="white-space: pre;">⁠$data()⁠</code>.
Note that merging both parts potentially comes with a data loss, as all
dense columns are converted to numeric columns.
</p>


<h3>Super class</h3>

<p><code>mlr3::DataBackend</code> -&gt; <code>DataBackendMatrix</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>rownames</code></dt>
<dd>
<p>(<code>integer()</code>)<br>
Returns vector of all distinct row identifiers, i.e. the contents of the primary key column.</p>
</dd>
<dt><code>colnames</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Returns vector of all column names, including the primary key column.</p>
</dd>
<dt><code>nrow</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
Number of rows (observations).</p>
</dd>
<dt><code>ncol</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
Number of columns (variables), including the primary key column.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataBackendMatrix-new"><code>DataBackendMatrix$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendMatrix-data"><code>DataBackendMatrix$data()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendMatrix-head"><code>DataBackendMatrix$head()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendMatrix-distinct"><code>DataBackendMatrix$distinct()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendMatrix-missings"><code>DataBackendMatrix$missings()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="format"><a href="../../mlr3/html/DataBackend.html#method-DataBackend-format"><code>mlr3::DataBackend$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="print"><a href="../../mlr3/html/DataBackend.html#method-DataBackend-print"><code>mlr3::DataBackend$print()</code></a></span></li>
</ul></details><hr>
<a id="method-DataBackendMatrix-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates a new instance of this R6 class.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendMatrix$new(data, dense, primary_key = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p><code>Matrix::Matrix()</code><br>
The input <code>Matrix::Matrix()</code>.</p>
</dd>
<dt><code>dense</code></dt>
<dd>
<p><code>data.frame()</code>.
Dense data, converted to <code>data.table::data.table()</code>.</p>
</dd>
<dt><code>primary_key</code></dt>
<dd>
<p>(<code>character(1)</code> | <code>integer()</code>)<br>
Name of the primary key column, or integer vector of row ids.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-DataBackendMatrix-data"></a>



<h4>Method <code>data()</code>
</h4>

<p>Returns a slice of the data as <code>"data.table"</code>.
The rows must be addressed as vector of primary key values, columns must be referred to via column names.
Queries for rows with no matching row id and queries for columns with no matching column name are silently ignored.
Rows are guaranteed to be returned in the same order as <code>rows</code>, columns may be returned in an arbitrary order.
Duplicated row ids result in duplicated rows, duplicated column names lead to an exception.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendMatrix$data(rows, cols, data_format)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt>
<dd>
<p>(positive <code>integer()</code>)<br>
Vector or row indices.
Always refers to the complete data set, even after filtering.</p>
</dd>
<dt><code>cols</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Vector of column names.</p>
</dd>
<dt><code>data_format</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Deprecated. Ignored, and will be removed in the future.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-DataBackendMatrix-head"></a>



<h4>Method <code>head()</code>
</h4>

<p>Retrieve the first <code>n</code> rows.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendMatrix$head(n = 6L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
Number of rows.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>data.table::data.table()</code> of the first <code>n</code> rows.
</p>


<hr>
<a id="method-DataBackendMatrix-distinct"></a>



<h4>Method <code>distinct()</code>
</h4>

<p>Returns a named list of vectors of distinct values for each column
specified. If <code>na_rm</code> is <code>TRUE</code>, missing values are removed from the
returned vectors of distinct values. Non-existing rows and columns are
silently ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendMatrix$distinct(rows, cols, na_rm = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt>
<dd>
<p>(positive <code>integer()</code>)<br>
Vector or row indices.
Always refers to the complete data set, even after filtering.</p>
</dd>
<dt><code>cols</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Vector of column names.</p>
</dd>
<dt><code>na_rm</code></dt>
<dd>
<p><code>logical(1)</code><br>
Whether to remove NAs or not.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Named <code>list()</code> of distinct values.
</p>


<hr>
<a id="method-DataBackendMatrix-missings"></a>



<h4>Method <code>missings()</code>
</h4>

<p>Returns the number of missing values per column in the specified slice
of data. Non-existing rows and columns are silently ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendMatrix$missings(rows, cols)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt>
<dd>
<p>(positive <code>integer()</code>)<br>
Vector or row indices.
Always refers to the complete data set, even after filtering.</p>
</dd>
<dt><code>cols</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Vector of column names.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Total of missing values per column (named <code>numeric()</code>).
</p>




<h3>See Also</h3>


<ul>
<li>
<p> Chapter in the <a href="https://mlr3book.mlr-org.com/">mlr3book</a>:
<a href="https://mlr3book.mlr-org.com/chapters/chapter10/advanced_technical_aspects_of_mlr3.html#sec-backends">https://mlr3book.mlr-org.com/chapters/chapter10/advanced_technical_aspects_of_mlr3.html#sec-backends</a>
</p>
</li>
<li>
<p> Package <a href="https://CRAN.R-project.org/package=mlr3db"><span class="pkg">mlr3db</span></a> to interface out-of-memory data,
e.g. SQL servers or <a href="https://CRAN.R-project.org/package=duckdb"><span class="pkg">duckdb</span></a>.
</p>
</li>
</ul>
<p>Other DataBackend: 
<code>DataBackend</code>,
<code>DataBackendDataTable</code>,
<code>as_data_backend.Matrix()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">requireNamespace("Matrix")
data = Matrix::Matrix(sample(0:1, 20, replace = TRUE), ncol = 2)
colnames(data) = c("x1", "x2")
dense = data.frame(
  ..row_id = 1:10,
  num = runif(10),
  fact = factor(sample(c("a", "b"), 10, replace = TRUE), levels = c("a", "b"))
)

b = as_data_backend(data, dense = dense, primary_key = "..row_id")
b$head()
b$data(1:3, b$colnames)
</code></pre>


</div>