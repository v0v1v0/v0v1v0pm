<div class="container">

<table style="width: 100%;"><tr>
<td>marshaling</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>(Un)marshal a Learner</h2>

<h3>Description</h3>

<p>Marshaling is the process of processing the model of a trained <code>Learner</code> so it an be successfully serialized and
deserialized. The naming is inspired by the <a href="https://github.com/futureverse/marshal">marshal package</a> and we
plan to fully migrate to this package once it is on CRAN.
The current implementation should therfore be considered as a temporary solution and is likely
to change in the future.
</p>
<p>The central functions (and the only methods that are used by <code>mlr3</code> internally) are:
</p>

<ul>
<li>
<p> the S3 generic <code>marshal_model(model, inplace, ...)</code>.
Which takes in a model and returns it in marshaled form.
This means, that the resulting object can be serialized and de-serialzed without loss of information.
If a model is serializable anyway, nothing has to be implemented and the generic will fall back to the
default implementation of <code>marshal_model</code>, which is to return the object as-is.
Otherwise, the marshaled object should be a list with named elements <code>marshaled</code> and <code>packages</code>, where the former contains
the marshaled object, and the latter the package that contains the packages required to unmarshal.
Most importantly, this list should contain the package that contains the <code>unmarshal_model</code> method.
The returned object should have the classes of the original object with the suffix <code>"_marshaled"</code> appended and the
root class should be set to <code>"marshaled"</code>.
</p>
</li>
<li>
<p> the S3 generic <code style="white-space: pre;">⁠unmarshal_model(model, inplace ...)⁠</code>.
Which takes in the marshaled model and returns it in unmarshaled form.
The generic takes care that the packages specified during <code>"marshal"</code> are loaded, and errs if they are not availabe.
Calling this function on a marshaled model should reconstruct the original model, i.e.
<code>unmarshal_model(marshal_model(x))</code> should return <code>x</code>.
The default implementation of this generic returns <code>x</code> as-is.
</p>
</li>
<li>
<p> the function <code>is_marshaled_model(model)</code>.
This (helper) function returns <code>TRUE</code> if the model inherits from class <code>"marshaled"</code> and <code>FALSE</code> otherwise.
Note that it is not guarateed that <code>is_marshaled_model(marshal_model(x))</code> returns <code>TRUE</code>.
This is because the default <code>marshal_model(x)</code> returns <code>x</code> as-is.
</p>
</li>
</ul>
<p>For both <code>marshal_model</code> and <code>unmarshal_model</code>, the <code>inplace</code> argument determines whether in-place marshaling
should be performed. This is especially relevant in the context of references semantics.
If <code>inplace</code> is <code>FALSE</code>, the original input should not be modified, otherwise this is allowed.
Note that the input and output can still share references, even when <code>inplace</code> is <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">learner_unmarshal(.learner, ...)

learner_marshal(.learner, ...)

learner_marshaled(.learner)

marshal_model(model, inplace = FALSE, ...)

unmarshal_model(model, inplace = FALSE, ...)

is_marshaled_model(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.learner</code></td>
<td>
<p><code>Learner</code><br>
The learner.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(any)<br>
Additional parameters, currently unused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>(any)<br>
Model to marshal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inplace</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Whether to marshal in-place.</p>
</td>
</tr>
</table>
<h3>Implementing Marshaling</h3>

<p>In order to implement marshaling for a Learner, you need to overload the <code>marshal_model</code> and <code>unmarshal_model</code>
methods for the class of the learner's model and tag the learner with the <code>"marshal"</code> property.
To make marshaling accessible in an R6-manner, you should also add the public methods <code style="white-space: pre;">⁠$marshal()⁠</code>, <code style="white-space: pre;">⁠$unmarshal()⁠</code>
and the active binding <code style="white-space: pre;">⁠$marshaled⁠</code>.
To make this as convenient as possible, the functions <code>learner_marshal(.learner, ...)</code>, <code>learner_unmarshal(.learner, ...)</code>
and <code>learner_marshaled(.learner)</code> are provided and can be called from the public methods.
</p>
<p>You can verify whether you have correctly implemented marshaling by using the internal test helper
<code>expect_marshalable_learner(learner, task)</code>. This is also run by <code>expect_learner()</code> if a task is provided.
</p>
<p>For a concrete example on how to implement marshaling, see <code>LearnerClassifDebug</code>.
</p>


</div>