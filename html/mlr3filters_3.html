<div class="container">

<table style="width: 100%;"><tr>
<td>Filter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter Base Class</h2>

<h3>Description</h3>

<p>Base class for filters. Predefined filters are stored in the
dictionary mlr_filters. A Filter calculates a score
for each feature of a task. Important features get a large value and
unimportant features get a small value. Note that filter scores may also be
negative.
</p>


<h3>Details</h3>

<p>Some features support partial scoring of the feature set:
If <code>nfeat</code> is not <code>NULL</code>, only the best <code>nfeat</code> features are guaranteed to
get a score. Additional features may be ignored for computational reasons,
and then get a score value of <code>NA</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>id</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Identifier of the object.
Used in tables, plot and text output.</p>
</dd>
<dt><code>label</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Label for this object.
Can be used in tables, plot and text output instead of the ID.</p>
</dd>
<dt><code>task_types</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Set of supported task types, e.g. <code>"classif"</code> or <code>"regr"</code>.
Can be set to the scalar value <code>NA</code> to allow any task type.
</p>
<p>For a complete list of possible task types (depending on the loaded packages),
see <code>mlr_reflections$task_types$type</code>.</p>
</dd>
<dt><code>task_properties</code></dt>
<dd>
<p>(<code>character()</code>)<br>
mlr3::Tasktask properties.</p>
</dd>
<dt><code>param_set</code></dt>
<dd>
<p>(paradox::ParamSet)<br>
Set of hyperparameters.</p>
</dd>
<dt><code>feature_types</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Feature types of the filter.</p>
</dd>
<dt><code>packages</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Packages which this filter is relying on.</p>
</dd>
<dt><code>man</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
String in the format <code style="white-space: pre;">⁠[pkg]::[topic]⁠</code> pointing to a manual page for this object.
Defaults to <code>NA</code>, but can be set by child classes.</p>
</dd>
<dt><code>scores</code></dt>
<dd>
<p>Stores the calculated filter score values as named numeric vector.
The vector is sorted in decreasing order with possible <code>NA</code> values
last. The more important the feature, the higher the score.
Tied values (this includes <code>NA</code> values) appear in a random,
non-deterministic order.</p>
</dd>
</dl>
</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>properties</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Properties of the filter. Currently, only <code>"missings"</code> is supported.
A filter has the property <code>"missings"</code>, iff the filter can handle missing values
in the features in a graceful way. Otherwise, an assertion is thrown if missing
values are detected.</p>
</dd>
<dt><code>hash</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Hash (unique identifier) for this object.</p>
</dd>
<dt><code>phash</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Hash (unique identifier) for this partial object, excluding some components
which are varied systematically during tuning (parameter values) or feature
selection (feature names).</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Filter-new"><code>Filter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Filter-format"><code>Filter$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Filter-print"><code>Filter$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Filter-help"><code>Filter$help()</code></a>
</p>
</li>
<li> <p><a href="#method-Filter-calculate"><code>Filter$calculate()</code></a>
</p>
</li>
<li> <p><a href="#method-Filter-clone"><code>Filter$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-Filter-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a Filter object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Filter$new(
  id,
  task_types,
  task_properties = character(),
  param_set = ps(),
  feature_types = character(),
  packages = character(),
  label = NA_character_,
  man = NA_character_
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Identifier for the filter.</p>
</dd>
<dt><code>task_types</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Types of the task the filter can operator on. E.g., <code>"classif"</code> or
<code>"regr"</code>. Can be set to scalar <code>NA</code> to allow any task type.</p>
</dd>
<dt><code>task_properties</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Required task properties, see mlr3::Task.
Must be a subset of
<code>mlr_reflections$task_properties</code>.</p>
</dd>
<dt><code>param_set</code></dt>
<dd>
<p>(paradox::ParamSet)<br>
Set of hyperparameters.</p>
</dd>
<dt><code>feature_types</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Feature types the filter operates on.
Must be a subset of
<code>mlr_reflections$task_feature_types</code>.</p>
</dd>
<dt><code>packages</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Set of required packages.
Note that these packages will be loaded via <code>requireNamespace()</code>, and
are not attached.</p>
</dd>
<dt><code>label</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Label for the new instance.</p>
</dd>
<dt><code>man</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
String in the format <code style="white-space: pre;">⁠[pkg]::[topic]⁠</code> pointing to a manual page for
this object. The referenced help package can be opened via method
<code style="white-space: pre;">⁠$help()⁠</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Filter-format"></a>



<h4>Method <code>format()</code>
</h4>

<p>Format helper for Filter class
</p>


<h5>Usage</h5>

<div class="r"><pre>Filter$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>(ignored).</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Filter-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Printer for Filter class
</p>


<h5>Usage</h5>

<div class="r"><pre>Filter$print()</pre></div>


<hr>
<a id="method-Filter-help"></a>



<h4>Method <code>help()</code>
</h4>

<p>Opens the corresponding help page referenced by field <code style="white-space: pre;">⁠$man⁠</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Filter$help()</pre></div>


<hr>
<a id="method-Filter-calculate"></a>



<h4>Method <code>calculate()</code>
</h4>

<p>Calculates the filter score values for the provided mlr3::Task and
stores them in field <code>scores</code>. <code>nfeat</code> determines the minimum number of
features to score (see details), and defaults to the number
of features in <code>task</code>. Loads required packages and then calls
<code>private$.calculate()</code> of the respective subclass.
</p>
<p>This private method is is expected to return a numeric vector, uniquely named
with (a subset of) feature names. The returned vector may have missing
values.
Features with missing values as well as features with no calculated
score are automatically ranked last, in a random order.
If the task has no rows, each feature gets the score <code>NA</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Filter$calculate(task, nfeat = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt>
<dd>
<p>(mlr3::Task)<br>
mlr3::Task to calculate the filter scores for.</p>
</dd>
<dt><code>nfeat</code></dt>
<dd>
<p>(<code>integer()</code>)<br>
The minimum number of features to calculate filter scores for.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Filter-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Filter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>Other Filter: 
<code>mlr_filters</code>,
<code>mlr_filters_anova</code>,
<code>mlr_filters_auc</code>,
<code>mlr_filters_boruta</code>,
<code>mlr_filters_carscore</code>,
<code>mlr_filters_carsurvscore</code>,
<code>mlr_filters_cmim</code>,
<code>mlr_filters_correlation</code>,
<code>mlr_filters_disr</code>,
<code>mlr_filters_find_correlation</code>,
<code>mlr_filters_importance</code>,
<code>mlr_filters_information_gain</code>,
<code>mlr_filters_jmi</code>,
<code>mlr_filters_jmim</code>,
<code>mlr_filters_kruskal_test</code>,
<code>mlr_filters_mim</code>,
<code>mlr_filters_mrmr</code>,
<code>mlr_filters_njmim</code>,
<code>mlr_filters_performance</code>,
<code>mlr_filters_permutation</code>,
<code>mlr_filters_relief</code>,
<code>mlr_filters_selected_features</code>,
<code>mlr_filters_univariate_cox</code>,
<code>mlr_filters_variance</code>
</p>


</div>