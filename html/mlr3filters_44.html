<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_filters_kruskal_test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kruskal-Wallis Test Filter</h2>

<h3>Description</h3>

<p>Kruskal-Wallis rank sum test filter calling <code>stats::kruskal.test()</code>.
</p>
<p>The filter value is <code>-log10(p)</code> where <code>p</code> is the <code class="reqn">p</code>-value. This
transformation is necessary to ensure numerical stability for very small
<code class="reqn">p</code>-values.
</p>


<h3>Super class</h3>

<p><code>mlr3filters::Filter</code> -&gt; <code>FilterKruskalTest</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FilterKruskalTest-new"><code>FilterKruskalTest$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterKruskalTest-clone"><code>FilterKruskalTest$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="mlr3filters" data-topic="Filter" data-id="calculate"><a href="../../mlr3filters/html/Filter.html#method-Filter-calculate"><code>mlr3filters::Filter$calculate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3filters" data-topic="Filter" data-id="format"><a href="../../mlr3filters/html/Filter.html#method-Filter-format"><code>mlr3filters::Filter$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3filters" data-topic="Filter" data-id="help"><a href="../../mlr3filters/html/Filter.html#method-Filter-help"><code>mlr3filters::Filter$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3filters" data-topic="Filter" data-id="print"><a href="../../mlr3filters/html/Filter.html#method-Filter-print"><code>mlr3filters::Filter$print()</code></a></span></li>
</ul></details><hr>
<a id="method-FilterKruskalTest-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a FilterKruskalTest object.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterKruskalTest$new()</pre></div>


<hr>
<a id="method-FilterKruskalTest-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterKruskalTest$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Note</h3>

<p>This filter, in its default settings, can handle missing values in the features.
However, the resulting filter scores may be misleading or at least difficult to compare
if some features have a large proportion of missing values.
</p>
<p>If a feature has not at least one non-missing observation per label, the resulting score will be NA.
Missing scores  appear in a random, non-deterministic order at the end of the vector of scores.
</p>


<h3>References</h3>

<p>For a benchmark of filter methods:
</p>
<p>Bommert A, Sun X, Bischl B, Rahnenführer J, Lang M (2020).
“Benchmark for filter methods for feature selection in high-dimensional classification data.”
<em>Computational Statistics &amp; Data Analysis</em>, <b>143</b>, 106839.
<a href="https://doi.org/10.1016/j.csda.2019.106839">doi:10.1016/j.csda.2019.106839</a>.
</p>


<h3>See Also</h3>


<ul>
<li> <p>PipeOpFilter for filter-based feature selection.
</p>
</li>
<li> <p>Dictionary of Filters: mlr_filters
</p>
</li>
</ul>
<p>Other Filter: 
<code>Filter</code>,
<code>mlr_filters</code>,
<code>mlr_filters_anova</code>,
<code>mlr_filters_auc</code>,
<code>mlr_filters_boruta</code>,
<code>mlr_filters_carscore</code>,
<code>mlr_filters_carsurvscore</code>,
<code>mlr_filters_cmim</code>,
<code>mlr_filters_correlation</code>,
<code>mlr_filters_disr</code>,
<code>mlr_filters_find_correlation</code>,
<code>mlr_filters_importance</code>,
<code>mlr_filters_information_gain</code>,
<code>mlr_filters_jmi</code>,
<code>mlr_filters_jmim</code>,
<code>mlr_filters_mim</code>,
<code>mlr_filters_mrmr</code>,
<code>mlr_filters_njmim</code>,
<code>mlr_filters_performance</code>,
<code>mlr_filters_permutation</code>,
<code>mlr_filters_relief</code>,
<code>mlr_filters_selected_features</code>,
<code>mlr_filters_univariate_cox</code>,
<code>mlr_filters_variance</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">task = mlr3::tsk("iris")
filter = flt("kruskal_test")
filter$calculate(task)
as.data.table(filter)

# transform to p-value
10^(-filter$scores)

if (mlr3misc::require_namespaces(c("mlr3pipelines", "rpart"), quietly = TRUE)) {
  library("mlr3pipelines")
  task = mlr3::tsk("spam")

  # Note: `filter.frac` is selected randomly and should be tuned.

  graph = po("filter", filter = flt("kruskal_test"), filter.frac = 0.5) %&gt;&gt;%
    po("learner", mlr3::lrn("classif.rpart"))

  graph$train(task)
}
</code></pre>


</div>