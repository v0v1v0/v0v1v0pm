<div class="container">

<table style="width: 100%;"><tr>
<td>auto_fselector</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for Automatic Feature Selection</h2>

<h3>Description</h3>

<p>The AutoFSelector wraps a mlr3::Learner and augments it with an automatic feature selection.
The <code>auto_fselector()</code> function creates an AutoFSelector object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">auto_fselector(
  fselector,
  learner,
  resampling,
  measure = NULL,
  term_evals = NULL,
  term_time = NULL,
  terminator = NULL,
  store_fselect_instance = TRUE,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  check_values = FALSE,
  callbacks = NULL,
  ties_method = "least_features"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fselector</code></td>
<td>
<p>(FSelector)<br>
Optimization algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>(mlr3::Learner)<br>
Learner to optimize the feature subset for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resampling</code></td>
<td>
<p>(mlr3::Resampling)<br>
Resampling that is used to evaluated the performance of the feature subsets.
Uninstantiated resamplings are instantiated during construction so that all feature subsets are evaluated on the same data splits.
Already instantiated resamplings are kept unchanged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measure</code></td>
<td>
<p>(mlr3::Measure)<br>
Measure to optimize. If <code>NULL</code>, default measure is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term_evals</code></td>
<td>
<p>(<code>integer(1)</code>)<br>
Number of allowed evaluations.
Ignored if <code>terminator</code> is passed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term_time</code></td>
<td>
<p>(<code>integer(1)</code>)<br>
Maximum allowed time in seconds.
Ignored if <code>terminator</code> is passed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminator</code></td>
<td>
<p>(bbotk::Terminator)<br>
Stop criterion of the feature selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store_fselect_instance</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
If <code>TRUE</code> (default), stores the internally created FSelectInstanceBatchSingleCrit with all intermediate results in slot <code style="white-space: pre;">⁠$fselect_instance⁠</code>.
Is set to <code>TRUE</code>, if <code>store_models = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store_benchmark_result</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Store benchmark result in archive?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store_models</code></td>
<td>
<p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_values</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Check the parameters before the evaluation and the results for
validity?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>callbacks</code></td>
<td>
<p>(list of CallbackBatchFSelect)<br>
List of callbacks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ties_method</code></td>
<td>
<p>(<code>character(1)</code>)<br>
The method to break ties when selecting sets while optimizing and when selecting the best set.
Can be <code>"least_features"</code> or <code>"random"</code>.
The option <code>"least_features"</code> (default) selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.
Ignored if multiple measures are used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The AutoFSelector is a mlr3::Learner which wraps another mlr3::Learner and performs the following steps during <code style="white-space: pre;">⁠$train()⁠</code>:
</p>

<ol>
<li>
<p> The wrapped (inner) learner is trained on the feature subsets via resampling.
The feature selection can be specified by providing a FSelector, a bbotk::Terminator, a mlr3::Resampling and a mlr3::Measure.
</p>
</li>
<li>
<p> A final model is fit on the complete training data with the best-found feature subset.
</p>
</li>
</ol>
<p>During <code style="white-space: pre;">⁠$predict()⁠</code> the AutoFSelector just calls the predict method of the wrapped (inner) learner.
</p>


<h3>Value</h3>

<p>AutoFSelector.
</p>


<h3>Resources</h3>

<p>There are several sections about feature selection in the <a href="https://mlr3book.mlr-org.com">mlr3book</a>.
</p>

<ul><li>
<p> Estimate Model Performance with <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-autofselect">nested resampling</a>.
</p>
</li></ul>
<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>


<h3>Nested Resampling</h3>

<p>Nested resampling can be performed by passing an AutoFSelector object to <code>mlr3::resample()</code> or <code>mlr3::benchmark()</code>.
To access the inner resampling results, set <code>store_fselect_instance = TRUE</code> and execute <code>mlr3::resample()</code> or <code>mlr3::benchmark()</code> with <code>store_models = TRUE</code> (see examples).
The mlr3::Resampling passed to the AutoFSelector is meant to be the inner resampling, operating on the training set of an arbitrary outer resampling.
For this reason it is not feasible to pass an instantiated mlr3::Resampling here.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Automatic Feature Selection


# split to train and external set
task = tsk("penguins")
split = partition(task, ratio = 0.8)

# create auto fselector
afs = auto_fselector(
  fselector = fs("random_search"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measure = msr("classif.ce"),
  term_evals = 4)

# optimize feature subset and fit final model
afs$train(task, row_ids = split$train)

# predict with final model
afs$predict(task, row_ids = split$test)

# show result
afs$fselect_result

# model slot contains trained learner and fselect instance
afs$model

# shortcut trained learner
afs$learner

# shortcut fselect instance
afs$fselect_instance


# Nested Resampling

afs = auto_fselector(
  fselector = fs("random_search"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measure = msr("classif.ce"),
  term_evals = 4)

resampling_outer = rsmp("cv", folds = 3)
rr = resample(task, afs, resampling_outer, store_models = TRUE)

# retrieve inner feature selection results.
extract_inner_fselect_results(rr)

# performance scores estimated on the outer resampling
rr$score()

# unbiased performance of the final model trained on the full data set
rr$aggregate()

</code></pre>


</div>