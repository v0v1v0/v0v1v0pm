<div class="container">

<table style="width: 100%;"><tr>
<td>ArchiveBatchFSelect</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class for Logging Evaluated Feature Sets</h2>

<h3>Description</h3>

<p>The ArchiveBatchFSelect stores all evaluated feature sets and performance scores.
</p>


<h3>Details</h3>

<p>The ArchiveBatchFSelect is a container around a <code>data.table::data.table()</code>.
Each row corresponds to a single evaluation of a feature set.
See the section on Data Structure for more information.
The archive stores additionally a mlr3::BenchmarkResult (<code style="white-space: pre;">⁠$benchmark_result⁠</code>) that records the resampling experiments.
Each experiment corresponds to a single evaluation of a feature set.
The table (<code style="white-space: pre;">⁠$data⁠</code>) and the benchmark result (<code style="white-space: pre;">⁠$benchmark_result⁠</code>) are linked by the <code>uhash</code> column.
If the archive is passed to <code>as.data.table()</code>, both are joined automatically.
</p>


<h3>Data structure</h3>

<p>The table (<code style="white-space: pre;">⁠$data⁠</code>) has the following columns:
</p>

<ul>
<li>
<p> One column for each feature of the task (<code style="white-space: pre;">⁠$search_space⁠</code>).
</p>
</li>
<li>
<p> One column for each performance measure (<code style="white-space: pre;">⁠$codomain⁠</code>).
</p>
</li>
<li> <p><code>runtime_learners</code> (<code>numeric(1)</code>)<br>
Sum of training and predict times logged in learners per mlr3::ResampleResult / evaluation.
This does not include potential overhead time.
</p>
</li>
<li> <p><code>timestamp</code> (<code>POSIXct</code>)<br>
Time stamp when the evaluation was logged into the archive.
</p>
</li>
<li> <p><code>batch_nr</code> (<code>integer(1)</code>)<br>
Feature sets are evaluated in batches. Each batch has a unique batch number.
</p>
</li>
<li> <p><code>uhash</code> (<code>character(1)</code>)<br>
Connects each feature set to the resampling experiment stored in the mlr3::BenchmarkResult.
</p>
</li>
</ul>
<h3>Analysis</h3>

<p>For analyzing the feature selection results, it is recommended to pass the archive to <code>as.data.table()</code>.
The returned data table is joined with the benchmark result which adds the mlr3::ResampleResult for each feature set.
</p>
<p>The archive provides various getters (e.g. <code style="white-space: pre;">⁠$learners()⁠</code>) to ease the access.
All getters extract by position (<code>i</code>) or unique hash (<code>uhash</code>).
For a complete list of all getters see the methods section.
</p>
<p>The benchmark result (<code style="white-space: pre;">⁠$benchmark_result⁠</code>) allows to score the feature sets again on a different measure.
Alternatively, measures can be supplied to <code>as.data.table()</code>.
</p>


<h3>S3 Methods</h3>


<ul><li> <p><code>as.data.table.ArchiveBatchFSelect(x, exclude_columns = "uhash", measures = NULL)</code><br>
Returns a tabular view of all evaluated feature sets.<br>
ArchiveBatchFSelect -&gt; <code>data.table::data.table()</code><br></p>

<ul>
<li> <p><code>x</code> (ArchiveBatchFSelect)
</p>
</li>
<li> <p><code>exclude_columns</code> (<code>character()</code>)<br>
Exclude columns from table. Set to <code>NULL</code> if no column should be excluded.
</p>
</li>
<li> <p><code>measures</code> (list of mlr3::Measure)<br>
Score feature sets on additional measures.
</p>
</li>
</ul>
</li></ul>
<h3>Super classes</h3>

<p><code>bbotk::Archive</code> -&gt; <code>bbotk::ArchiveBatch</code> -&gt; <code>ArchiveBatchFSelect</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>benchmark_result</code></dt>
<dd>
<p>(mlr3::BenchmarkResult)<br>
Benchmark result.</p>
</dd>
</dl>
</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>ties_method</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Method to handle ties.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ArchiveBatchFSelect-new"><code>ArchiveBatchFSelect$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-add_evals"><code>ArchiveBatchFSelect$add_evals()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-learner"><code>ArchiveBatchFSelect$learner()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-learners"><code>ArchiveBatchFSelect$learners()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-predictions"><code>ArchiveBatchFSelect$predictions()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-resample_result"><code>ArchiveBatchFSelect$resample_result()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-print"><code>ArchiveBatchFSelect$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-best"><code>ArchiveBatchFSelect$best()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-clone"><code>ArchiveBatchFSelect$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Archive" data-id="format"><a href="../../bbotk/html/Archive.html#method-Archive-format"><code>bbotk::Archive$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Archive" data-id="help"><a href="../../bbotk/html/Archive.html#method-Archive-help"><code>bbotk::Archive$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="ArchiveBatch" data-id="clear"><a href="../../bbotk/html/ArchiveBatch.html#method-ArchiveBatch-clear"><code>bbotk::ArchiveBatch$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="ArchiveBatch" data-id="nds_selection"><a href="../../bbotk/html/ArchiveBatch.html#method-ArchiveBatch-nds_selection"><code>bbotk::ArchiveBatch$nds_selection()</code></a></span></li>
</ul></details><hr>
<a id="method-ArchiveBatchFSelect-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates a new instance of this R6 class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$new(
  search_space,
  codomain,
  check_values = TRUE,
  ties_method = "least_features"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>search_space</code></dt>
<dd>
<p>(paradox::ParamSet)<br>
Search space.
Internally created from provided mlr3::Task by instance.</p>
</dd>
<dt><code>codomain</code></dt>
<dd>
<p>(bbotk::Codomain)<br>
Specifies codomain of objective function i.e. a set of performance measures.
Internally created from provided mlr3::Measures by instance.</p>
</dd>
<dt><code>check_values</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
If <code>TRUE</code> (default), hyperparameter configurations are check for validity.</p>
</dd>
<dt><code>ties_method</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
The method to break ties when selecting sets while optimizing and when selecting the best set.
Can be <code>"least_features"</code> or <code>"random"</code>.
The option <code>"least_features"</code> (default) selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.
Ignored if multiple measures are used.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ArchiveBatchFSelect-add_evals"></a>



<h4>Method <code>add_evals()</code>
</h4>

<p>Adds function evaluations to the archive table.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$add_evals(xdt, xss_trafoed = NULL, ydt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt>
<dd>
<p>(<code>data.table::data.table()</code>)<br>
x values as <code>data.table</code>. Each row is one point. Contains the value in
the <em>search space</em> of the FSelectInstanceBatchMultiCrit object. Can contain
additional columns for extra information.</p>
</dd>
<dt><code>xss_trafoed</code></dt>
<dd>
<p>(<code>list()</code>)<br>
Ignored in feature selection.</p>
</dd>
<dt><code>ydt</code></dt>
<dd>
<p>(<code>data.table::data.table()</code>)<br>
Optimal outcome.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ArchiveBatchFSelect-learner"></a>



<h4>Method <code>learner()</code>
</h4>

<p>Retrieve mlr3::Learner of the i-th evaluation, by position or by unique hash <code>uhash</code>.
<code>i</code> and <code>uhash</code> are mutually exclusive.
Learner does not contain a model. Use <code style="white-space: pre;">⁠$learners()⁠</code> to get learners with models.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$learner(i = NULL, uhash = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
The iteration value to filter for.</p>
</dd>
<dt><code>uhash</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
The <code>uhash</code> value to filter for.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ArchiveBatchFSelect-learners"></a>



<h4>Method <code>learners()</code>
</h4>

<p>Retrieve list of trained mlr3::Learner objects of the i-th evaluation,
by position or by unique hash <code>uhash</code>. <code>i</code> and <code>uhash</code> are mutually
exclusive.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$learners(i = NULL, uhash = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
The iteration value to filter for.</p>
</dd>
<dt><code>uhash</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
The <code>uhash</code> value to filter for.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ArchiveBatchFSelect-predictions"></a>



<h4>Method <code>predictions()</code>
</h4>

<p>Retrieve list of mlr3::Prediction objects of the i-th evaluation, by
position or by unique hash <code>uhash</code>. <code>i</code> and <code>uhash</code> are mutually
exclusive.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$predictions(i = NULL, uhash = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
The iteration value to filter for.</p>
</dd>
<dt><code>uhash</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
The <code>uhash</code> value to filter for.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ArchiveBatchFSelect-resample_result"></a>



<h4>Method <code>resample_result()</code>
</h4>

<p>Retrieve mlr3::ResampleResult of the i-th evaluation, by position
or by unique hash <code>uhash</code>. <code>i</code> and <code>uhash</code> are mutually exclusive.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$resample_result(i = NULL, uhash = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
The iteration value to filter for.</p>
</dd>
<dt><code>uhash</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
The <code>uhash</code> value to filter for.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ArchiveBatchFSelect-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$print()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>(ignored).</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ArchiveBatchFSelect-best"></a>



<h4>Method <code>best()</code>
</h4>

<p>Returns the best scoring feature sets.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$best(batch = NULL, ties_method = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>batch</code></dt>
<dd>
<p>(<code>integer()</code>)<br>
The batch number(s) to limit the best results to.
Default is all batches.</p>
</dd>
<dt><code>ties_method</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Method to handle ties.
If <code>NULL</code> (default), the global ties method set during initialization is used.
The default global ties method is <code>least_features</code> which selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>data.table::data.table()</code>
</p>


<hr>
<a id="method-ArchiveBatchFSelect-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




</div>