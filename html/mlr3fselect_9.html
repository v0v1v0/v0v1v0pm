<div class="container">

<table style="width: 100%;"><tr>
<td>AutoFSelector</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class for Automatic Feature Selection</h2>

<h3>Description</h3>

<p>The AutoFSelector wraps a mlr3::Learner and augments it with an automatic feature selection.
The <code>auto_fselector()</code> function creates an AutoFSelector object.
</p>


<h3>Details</h3>

<p>The AutoFSelector is a mlr3::Learner which wraps another mlr3::Learner and performs the following steps during <code style="white-space: pre;">⁠$train()⁠</code>:
</p>

<ol>
<li>
<p> The wrapped (inner) learner is trained on the feature subsets via resampling.
The feature selection can be specified by providing a FSelector, a bbotk::Terminator, a mlr3::Resampling and a mlr3::Measure.
</p>
</li>
<li>
<p> A final model is fit on the complete training data with the best-found feature subset.
</p>
</li>
</ol>
<p>During <code style="white-space: pre;">⁠$predict()⁠</code> the AutoFSelector just calls the predict method of the wrapped (inner) learner.
</p>


<h3>Resources</h3>

<p>There are several sections about feature selection in the <a href="https://mlr3book.mlr-org.com">mlr3book</a>.
</p>

<ul><li>
<p> Estimate Model Performance with <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-autofselect">nested resampling</a>.
</p>
</li></ul>
<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>


<h3>Nested Resampling</h3>

<p>Nested resampling can be performed by passing an AutoFSelector object to <code>mlr3::resample()</code> or <code>mlr3::benchmark()</code>.
To access the inner resampling results, set <code>store_fselect_instance = TRUE</code> and execute <code>mlr3::resample()</code> or <code>mlr3::benchmark()</code> with <code>store_models = TRUE</code> (see examples).
The mlr3::Resampling passed to the AutoFSelector is meant to be the inner resampling, operating on the training set of an arbitrary outer resampling.
For this reason it is not feasible to pass an instantiated mlr3::Resampling here.
</p>


<h3>Super class</h3>

<p><code>mlr3::Learner</code> -&gt; <code>AutoFSelector</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>instance_args</code></dt>
<dd>
<p>(<code>list()</code>)<br>
All arguments from construction to create the FSelectInstanceBatchSingleCrit.</p>
</dd>
<dt><code>fselector</code></dt>
<dd>
<p>(FSelector)<br>
Optimization algorithm.</p>
</dd>
</dl>
</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>archive</code></dt>
<dd>
<p>([ArchiveBatchFSelect)<br>
Returns FSelectInstanceBatchSingleCrit archive.</p>
</dd>
<dt><code>learner</code></dt>
<dd>
<p>(mlr3::Learner)<br>
Trained learner.</p>
</dd>
<dt><code>fselect_instance</code></dt>
<dd>
<p>(FSelectInstanceBatchSingleCrit)<br>
Internally created feature selection instance with all intermediate results.</p>
</dd>
<dt><code>fselect_result</code></dt>
<dd>
<p>(data.table::data.table)<br>
Short-cut to <code style="white-space: pre;">⁠$result⁠</code> from FSelectInstanceBatchSingleCrit.</p>
</dd>
<dt><code>predict_type</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Stores the currently active predict type, e.g. <code>"response"</code>.
Must be an element of <code style="white-space: pre;">⁠$predict_types⁠</code>.</p>
</dd>
<dt><code>hash</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Hash (unique identifier) for this object.</p>
</dd>
<dt><code>phash</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Hash (unique identifier) for this partial object, excluding some components which are varied systematically during tuning (parameter values) or feature selection (feature names).</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AutoFSelector-new"><code>AutoFSelector$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-base_learner"><code>AutoFSelector$base_learner()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-importance"><code>AutoFSelector$importance()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-selected_features"><code>AutoFSelector$selected_features()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-oob_error"><code>AutoFSelector$oob_error()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-loglik"><code>AutoFSelector$loglik()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-print"><code>AutoFSelector$print()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-clone"><code>AutoFSelector$clone()</code></a>
</p>
</li>
</ul>
<details><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="encapsulate"><a href="../../mlr3/html/Learner.html#method-Learner-encapsulate"><code>mlr3::Learner$encapsulate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="format"><a href="../../mlr3/html/Learner.html#method-Learner-format"><code>mlr3::Learner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="help"><a href="../../mlr3/html/Learner.html#method-Learner-help"><code>mlr3::Learner$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="predict"><a href="../../mlr3/html/Learner.html#method-Learner-predict"><code>mlr3::Learner$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="predict_newdata"><a href="../../mlr3/html/Learner.html#method-Learner-predict_newdata"><code>mlr3::Learner$predict_newdata()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="reset"><a href="../../mlr3/html/Learner.html#method-Learner-reset"><code>mlr3::Learner$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="train"><a href="../../mlr3/html/Learner.html#method-Learner-train"><code>mlr3::Learner$train()</code></a></span></li>
</ul></details><hr>
<a id="method-AutoFSelector-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates a new instance of this R6 class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$new(
  fselector,
  learner,
  resampling,
  measure = NULL,
  terminator,
  store_fselect_instance = TRUE,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  check_values = FALSE,
  callbacks = NULL,
  ties_method = "least_features"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fselector</code></dt>
<dd>
<p>(FSelector)<br>
Optimization algorithm.</p>
</dd>
<dt><code>learner</code></dt>
<dd>
<p>(mlr3::Learner)<br>
Learner to optimize the feature subset for.</p>
</dd>
<dt><code>resampling</code></dt>
<dd>
<p>(mlr3::Resampling)<br>
Resampling that is used to evaluated the performance of the feature subsets.
Uninstantiated resamplings are instantiated during construction so that all feature subsets are evaluated on the same data splits.
Already instantiated resamplings are kept unchanged.</p>
</dd>
<dt><code>measure</code></dt>
<dd>
<p>(mlr3::Measure)<br>
Measure to optimize. If <code>NULL</code>, default measure is used.</p>
</dd>
<dt><code>terminator</code></dt>
<dd>
<p>(bbotk::Terminator)<br>
Stop criterion of the feature selection.</p>
</dd>
<dt><code>store_fselect_instance</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
If <code>TRUE</code> (default), stores the internally created FSelectInstanceBatchSingleCrit with all intermediate results in slot <code style="white-space: pre;">⁠$fselect_instance⁠</code>.
Is set to <code>TRUE</code>, if <code>store_models = TRUE</code></p>
</dd>
<dt><code>store_benchmark_result</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Store benchmark result in archive?</p>
</dd>
<dt><code>store_models</code></dt>
<dd>
<p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</dd>
<dt><code>check_values</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Check the parameters before the evaluation and the results for
validity?</p>
</dd>
<dt><code>callbacks</code></dt>
<dd>
<p>(list of CallbackBatchFSelect)<br>
List of callbacks.</p>
</dd>
<dt><code>ties_method</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
The method to break ties when selecting sets while optimizing and when selecting the best set.
Can be <code>"least_features"</code> or <code>"random"</code>.
The option <code>"least_features"</code> (default) selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.
Ignored if multiple measures are used.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-AutoFSelector-base_learner"></a>



<h4>Method <code>base_learner()</code>
</h4>

<p>Extracts the base learner from nested learner objects like <code>GraphLearner</code> in <a href="https://CRAN.R-project.org/package=mlr3pipelines"><span class="pkg">mlr3pipelines</span></a>.
If <code>recursive = 0</code>, the (tuned) learner is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$base_learner(recursive = Inf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>recursive</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
Depth of recursion for multiple nested objects.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>mlr3::Learner.
</p>


<hr>
<a id="method-AutoFSelector-importance"></a>



<h4>Method <code>importance()</code>
</h4>

<p>The importance scores of the final model.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$importance()</pre></div>



<h5>Returns</h5>

<p>Named <code>numeric()</code>.
</p>


<hr>
<a id="method-AutoFSelector-selected_features"></a>



<h4>Method <code>selected_features()</code>
</h4>

<p>The selected features of the final model.
These features are selected internally by the learner.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$selected_features()</pre></div>



<h5>Returns</h5>

<p><code>character()</code>.
</p>


<hr>
<a id="method-AutoFSelector-oob_error"></a>



<h4>Method <code>oob_error()</code>
</h4>

<p>The out-of-bag error of the final model.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$oob_error()</pre></div>



<h5>Returns</h5>

<p><code>numeric(1)</code>.
</p>


<hr>
<a id="method-AutoFSelector-loglik"></a>



<h4>Method <code>loglik()</code>
</h4>

<p>The log-likelihood of the final model.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$loglik()</pre></div>



<h5>Returns</h5>

<p><code>logLik</code>.
Printer.
</p>


<hr>
<a id="method-AutoFSelector-print"></a>



<h4>Method <code>print()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$print()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>(ignored).</p>
</dd>
</dl>
</div>


<hr>
<a id="method-AutoFSelector-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R"># Automatic Feature Selection


# split to train and external set
task = tsk("penguins")
split = partition(task, ratio = 0.8)

# create auto fselector
afs = auto_fselector(
  fselector = fs("random_search"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measure = msr("classif.ce"),
  term_evals = 4)

# optimize feature subset and fit final model
afs$train(task, row_ids = split$train)

# predict with final model
afs$predict(task, row_ids = split$test)

# show result
afs$fselect_result

# model slot contains trained learner and fselect instance
afs$model

# shortcut trained learner
afs$learner

# shortcut fselect instance
afs$fselect_instance


# Nested Resampling

afs = auto_fselector(
  fselector = fs("random_search"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measure = msr("classif.ce"),
  term_evals = 4)

resampling_outer = rsmp("cv", folds = 3)
rr = resample(task, afs, resampling_outer, store_models = TRUE)

# retrieve inner feature selection results.
extract_inner_fselect_results(rr)

# performance scores estimated on the outer resampling
rr$score()

# unbiased performance of the final model trained on the full data set
rr$aggregate()

</code></pre>


</div>