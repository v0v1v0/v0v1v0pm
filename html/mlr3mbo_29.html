<div class="container">

<table style="width: 100%;"><tr>
<td>default_surrogate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Default Surrogate</h2>

<h3>Description</h3>

<p>This is a helper function that constructs a default Surrogate based on properties of the
bbotk::OptimInstance.
</p>
<p>For numeric-only (including integers) parameter spaces without any dependencies a Gaussian Process is constricted via
<code>default_gp()</code>.
For mixed numeric-categorical parameter spaces, or spaces with conditional parameters a random forest is constructed via
<code>default_rf()</code>.
</p>
<p>In any case, learners are encapsulated using “"evaluate"”, and a fallback learner is set,
in cases where the surrogate learner errors.
Currently, the following learner is used as a fallback:
<code>lrn("regr.ranger", num.trees = 10L, keep.inbag = TRUE, se.method = "jack")</code>.
</p>
<p>If additionally dependencies are present in the parameter space, inactive conditional parameters
are represented by missing <code>NA</code> values in the training design data.
We simply handle those with an imputation method, added to the random forest, more
concretely we use <code>po("imputesample")</code> (for logicals) and <code>po("imputeoor")</code> (for anything else) from
package <a href="https://CRAN.R-project.org/package=mlr3pipelines"><span class="pkg">mlr3pipelines</span></a>.
Characters are always encoded as factors via <code>po("colapply")</code>.
Out of range imputation makes sense for tree-based methods and is usually hard to beat, see Ding et al. (2010).
In the case of dependencies, the following learner is used as a fallback:
<code>lrn("regr.featureless")</code>.
</p>
<p>If the instance is of class bbotk::OptimInstanceBatchSingleCrit the learner is wrapped as a
SurrogateLearner.
</p>
<p>If the instance is of class bbotk::OptimInstanceBatchMultiCrit multiple deep clones of the learner are
wrapped as a SurrogateLearnerCollection.
</p>


<h3>Usage</h3>

<pre><code class="language-R">default_surrogate(instance, learner = NULL, n_learner = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>instance</code></td>
<td>
<p>(bbotk::OptimInstance)<br>
An object that inherits from bbotk::OptimInstance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>(<code>NULL</code> | mlr3::Learner).
If specified, this learner will be used instead of the defaults described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_learner</code></td>
<td>
<p>(<code>NULL</code> | <code>integer(1)</code>).
Number of learners to be considered in the construction of the SurrogateLearner or SurrogateLearnerCollection.
If not specified will be based on the number of objectives as stated by the instance.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Surrogate
</p>


<h3>References</h3>


<ul><li>
<p> Ding, Yufeng, Simonoff, S J (2010).
“An Investigation of Missing Data Methods for Classification Trees Applied to Binary Response Data.”
<em>Journal of Machine Learning Research</em>, <b>11</b>(1), 131–170.
</p>
</li></ul>
<h3>See Also</h3>

<p>Other mbo_defaults: 
<code>default_acqfunction()</code>,
<code>default_acqoptimizer()</code>,
<code>default_gp()</code>,
<code>default_loop_function()</code>,
<code>default_result_assigner()</code>,
<code>default_rf()</code>,
<code>mbo_defaults</code>
</p>


</div>