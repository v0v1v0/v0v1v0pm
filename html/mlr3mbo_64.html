<div class="container">

<table style="width: 100%;"><tr>
<td>SurrogateLearnerCollection</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Surrogate Model Containing Multiple Learners</h2>

<h3>Description</h3>

<p>Surrogate model containing multiple mlr3::LearnerRegr.
The mlr3::LearnerRegr are fit on the target variables as indicated via <code>cols_y</code>.
Note that redundant mlr3::LearnerRegr must be deep clones.
</p>


<h3>Parameters</h3>


<dl>
<dt><code>assert_insample_perf</code></dt>
<dd>
<p><code>logical(1)</code><br>
Should the insample performance of the mlr3::LearnerRegr be asserted after updating the surrogate?
If the assertion fails (i.e., the insample performance based on the <code>perf_measure</code> does not meet the
<code>perf_threshold</code>), an error is thrown.
Default is <code>FALSE</code>.
</p>
</dd>
<dt><code>perf_measure</code></dt>
<dd>
<p>List of mlr3::MeasureRegr<br>
Performance measures which should be use to assert the insample performance of the mlr3::LearnerRegr.
Only relevant if <code>assert_insample_perf = TRUE</code>.
Default is mlr3::mlr_measures_regr.rsq for each learner.
</p>
</dd>
<dt><code>perf_threshold</code></dt>
<dd>
<p>List of <code>numeric(1)</code><br>
Thresholds the insample performance of the mlr3::LearnerRegr should be asserted against.
Only relevant if <code>assert_insample_perf = TRUE</code>.
Default is <code>0</code> for each learner.
</p>
</dd>
<dt><code>catch_errors</code></dt>
<dd>
<p><code>logical(1)</code><br>
Should errors during updating the surrogate be caught and propagated to the <code>loop_function</code> which can then handle
the failed acquisition function optimization (as a result of the failed surrogate) appropriately by, e.g., proposing a randomly sampled point for evaluation?
Default is <code>TRUE</code>.
</p>
</dd>
</dl>
<h3>Super class</h3>

<p><code>mlr3mbo::Surrogate</code> -&gt; <code>SurrogateLearnerCollection</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>print_id</code></dt>
<dd>
<p>(<code>character</code>)<br>
Id used when printing.</p>
</dd>
<dt><code>n_learner</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
Returns the number of surrogate models.</p>
</dd>
<dt><code>assert_insample_perf</code></dt>
<dd>
<p>(<code>numeric()</code>)<br>
Asserts whether the current insample performance meets the performance threshold.</p>
</dd>
<dt><code>packages</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Set of required packages.
A warning is signaled if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code>requireNamespace()</code>.</p>
</dd>
<dt><code>feature_types</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Stores the feature types the surrogate can handle, e.g. <code>"logical"</code>, <code>"numeric"</code>, or <code>"factor"</code>.
A complete list of candidate feature types, grouped by task type, is stored in <code>mlr_reflections$task_feature_types</code>.</p>
</dd>
<dt><code>properties</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Stores a set of properties/capabilities the surrogate has.
A complete list of candidate properties, grouped by task type, is stored in <code>mlr_reflections$learner_properties</code>.</p>
</dd>
<dt><code>predict_type</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Retrieves the currently active predict type, e.g. <code>"response"</code>.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SurrogateLearnerCollection-new"><code>SurrogateLearnerCollection$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SurrogateLearnerCollection-predict"><code>SurrogateLearnerCollection$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-SurrogateLearnerCollection-clone"><code>SurrogateLearnerCollection$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="format"><a href="../../mlr3mbo/html/Surrogate.html#method-Surrogate-format"><code>mlr3mbo::Surrogate$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="print"><a href="../../mlr3mbo/html/Surrogate.html#method-Surrogate-print"><code>mlr3mbo::Surrogate$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="update"><a href="../../mlr3mbo/html/Surrogate.html#method-Surrogate-update"><code>mlr3mbo::Surrogate$update()</code></a></span></li>
</ul></details><hr>
<a id="method-SurrogateLearnerCollection-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates a new instance of this R6 class.
</p>


<h5>Usage</h5>

<div class="r"><pre>SurrogateLearnerCollection$new(
  learners,
  archive = NULL,
  cols_x = NULL,
  cols_y = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>learners</code></dt>
<dd>
<p>(list of mlr3::LearnerRegr).</p>
</dd>
<dt><code>archive</code></dt>
<dd>
<p>(bbotk::Archive | <code>NULL</code>)<br>
bbotk::Archive of the bbotk::OptimInstance.</p>
</dd>
<dt><code>cols_x</code></dt>
<dd>
<p>(<code>character()</code> | <code>NULL</code>)<br>
Column id's of variables that should be used as features.
By default, automatically inferred based on the archive.</p>
</dd>
<dt><code>cols_y</code></dt>
<dd>
<p>(<code>character()</code> | <code>NULL</code>)<br>
Column id's of variables that should be used as targets.
By default, automatically inferred based on the archive.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-SurrogateLearnerCollection-predict"></a>



<h4>Method <code>predict()</code>
</h4>

<p>Predict mean response and standard error.
Returns a named list of data.tables.
Each contains the mean response and standard error for one <code>col_y</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SurrogateLearnerCollection$predict(xdt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt>
<dd>
<p>(<code>data.table::data.table()</code>)<br>
New data. One row per observation.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>list of <code>data.table::data.table()</code>s with the columns <code>mean</code> and <code>se</code>.
</p>


<hr>
<a id="method-SurrogateLearnerCollection-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SurrogateLearnerCollection$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud") &amp;
    requireNamespace("ranger")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)

  fun = function(xs) {
    list(y1 = xs$x^2, y2 = (xs$x - 2) ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y1 = p_dbl(tags = "minimize"), y2 = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchMultiCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))
  xdt = generate_design_random(instance$search_space, n = 4)$data

  instance$eval_batch(xdt)

  learner1 = default_gp()

  learner2 = default_rf()

  surrogate = srlrn(list(learner1, learner2), archive = instance$archive)

  surrogate$update()

  surrogate$learner

  surrogate$learner[["y2"]]$model
}
</code></pre>


</div>