<div class="container">

<table style="width: 100%;"><tr>
<td>compat-map</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply Functions in the spirit of 'purrr'</h2>

<h3>Description</h3>

<p><code>map</code>-like functions, similar to the ones implemented in <a href="https://CRAN.R-project.org/package=purrr"><span class="pkg">purrr</span></a>:
</p>

<ul>
<li> <p><code>map()</code> returns the results of <code>.f</code> applied to <code>.x</code> as list.
If <code>.f</code> is not a function, <code>map</code> will call <code>[[</code> on all elements of <code>.x</code> using the value of <code>.f</code> as index.
</p>
</li>
<li> <p><code>imap()</code> applies <code>.f</code> to each value of <code>.x</code> (passed as first argument) and its name (passed as second argument).
If <code>.x</code> does not have names, a sequence along <code>.x</code> is passed as second argument instead.
</p>
</li>
<li> <p><code>pmap()</code> expects <code>.x</code> to be a list of vectors of equal length, and then applies <code>.f</code> to the first element of
each vector of <code>.x</code>, then the second element of <code>.x</code>, and so on.
</p>
</li>
<li> <p><code>map_if()</code> applies <code>.f</code> to each element of <code>.x</code> where the predicate <code>.p</code> evaluates to <code>TRUE</code>.
</p>
</li>
<li> <p><code>map_at()</code> applies <code>.f</code> to each element of <code>.x</code> referenced by <code>.at</code>. All other elements remain unchanged.
</p>
</li>
<li> <p><code>keep()</code> keeps those elements of <code>.x</code> where predicate <code>.p</code> evaluates to <code>TRUE</code>.
</p>
</li>
<li> <p><code>discard()</code> discards those elements of <code>.x</code> where predicate <code>.p</code> evaluates to <code>TRUE</code>.
</p>
</li>
<li> <p><code>every()</code> is <code>TRUE</code> if predicate <code>.p</code> evaluates to <code>TRUE</code> for each <code>.x</code>.
</p>
</li>
<li> <p><code>some()</code> is <code>TRUE</code> if predicate <code>.p</code> evaluates to <code>TRUE</code> for at least one <code>.x</code>.
</p>
</li>
<li> <p><code>detect()</code> returns the first element where predicate <code>.p</code> evaluates to <code>TRUE</code>.
</p>
</li>
<li> <p><code>walk()</code>, <code>iwalk()</code> and <code>pwalk()</code> are the counterparts to <code>map()</code>, <code>imap()</code> and <code>pmap()</code>, but
just visit (or change by reference) the elements of <code>.x</code>. They return input <code>.x</code> invisibly.
</p>
</li>
</ul>
<p>Additionally, the functions <code>map()</code>, <code>imap()</code> and <code>pmap()</code> have type-safe variants with the following suffixes:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠*_lgl()⁠</code> returns a <code>logical(length(.x))</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠*_int()⁠</code> returns a <code>integer(length(.x))</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠*_dbl()⁠</code> returns a <code>double(length(.x))</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠*_chr()⁠</code> returns a <code>character(length(.x))</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠*_br()⁠</code> returns an object where the results of <code>.f</code> are put together with <code>base::rbind()</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠*_bc()⁠</code> returns an object where the results of <code>.f</code> are put together with <code>base::cbind()</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠*_dtr()⁠</code> returns a <code>data.table::data.table()</code> where the results of <code>.f</code> are put together
in an <code>base::rbind()</code> fashion.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠*_dtc()⁠</code> returns a <code>data.table::data.table()</code> where the results of <code>.f</code> are put
together in an <code>base::cbind()</code> fashion.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">map(.x, .f, ...)

map_lgl(.x, .f, ...)

map_int(.x, .f, ...)

map_dbl(.x, .f, ...)

map_chr(.x, .f, ...)

map_br(.x, .f, ...)

map_bc(.x, .f, ...)

map_dtr(.x, .f, ..., .fill = FALSE, .idcol = NULL)

map_dtc(.x, .f, ...)

pmap(.x, .f, ...)

pmap_lgl(.x, .f, ...)

pmap_int(.x, .f, ...)

pmap_dbl(.x, .f, ...)

pmap_chr(.x, .f, ...)

pmap_dtr(.x, .f, ..., .fill = FALSE, .idcol = NULL)

pmap_dtc(.x, .f, ...)

imap(.x, .f, ...)

imap_lgl(.x, .f, ...)

imap_int(.x, .f, ...)

imap_dbl(.x, .f, ...)

imap_chr(.x, .f, ...)

imap_dtr(.x, .f, ..., .fill = FALSE, .idcol = NULL)

imap_dtc(.x, .f, ...)

keep(.x, .f, ...)

discard(.x, .p, ...)

map_if(.x, .p, .f, ...)

## Default S3 method:
map_if(.x, .p, .f, ...)

map_at(.x, .at, .f, ...)

every(.x, .p, ...)

some(.x, .p, ...)

detect(.x, .p, ...)

walk(.x, .f, ...)

iwalk(.x, .f, ...)

pwalk(.x, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.x</code></td>
<td>
<p>(<code>list()</code> | atomic <code>vector()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p>(<code style="white-space: pre;">⁠function()⁠</code> | <code>character()</code> | <code>integer()</code>)<br>
Function to apply, or element to extract by name (if <code>.f</code> is <code>character()</code>) or position (if <code>.f</code> is <code>integer()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(<code>any</code>)<br>
Additional arguments passed down to <code>.f</code> or <code>.p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.fill</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Passed down to <code>data.table::rbindlist()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.idcol</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Passed down to <code>data.table::rbindlist()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.p</code></td>
<td>
<p>(<code style="white-space: pre;">⁠function()⁠</code> | <code>logical()</code>)<br>
Predicate function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.at</code></td>
<td>
<p>(<code>character()</code> | <code>integer()</code> | <code>logical()</code>)<br>
Index vector.</p>
</td>
</tr>
</table>
</div>