<div class="container">

<table style="width: 100%;"><tr>
<td>PipeOpEnsemble</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Ensembling Base Class</h2>

<h3>Description</h3>

<p>Parent class for <code>PipeOp</code>s that aggregate predictions. Implements the <code>private$.train()</code> and <code>private$.predict()</code> methods necessary
for a <code>PipeOp</code> and requires deriving classes to create the <code>private$weighted_avg_predictions()</code> function.
</p>


<h3>Format</h3>

<p>Abstract <code>R6Class</code> inheriting from <code>PipeOp</code>.
</p>


<h3>Construction</h3>

<p>Note: This object is typically constructed via a derived class, e.g. <code>PipeOpClassifAvg</code> or <code>PipeOpRegrAvg</code>.
</p>
<div class="sourceCode"><pre>PipeOpEnsemble$new(innum = 0, collect_multiplicity = FALSE, id, param_set = ps(), param_vals = list(), packages = character(0), prediction_type = "Prediction")
</pre></div>

<ul>
<li> <p><code>innum</code> :: <code>numeric(1)</code><br>
Determines the number of input channels.
If <code>innum</code> is 0 (default), a vararg input channel is created that can take an arbitrary number of inputs.
</p>
</li>
<li> <p><code>collect_multiplicity</code> :: <code>logical(1)</code><br>
If <code>TRUE</code>, the input is a <code>Multiplicity</code> collecting channel. This means, a
<code>Multiplicity</code> input, instead of multiple normal inputs, is accepted and the members are aggregated. This requires <code>innum</code> to be 0.
Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>id</code> :: <code>character(1)</code><br>
Identifier of the resulting  object.
</p>
</li>
<li> <p><code>param_set</code> :: <code>ParamSet</code><br>
("Hyper"-)Parameters in form of a <code>ParamSet</code> for the resulting <code>PipeOp</code>.
</p>
</li>
<li> <p><code>param_vals</code> :: named <code>list</code><br>
List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise be set during construction. Default <code>list()</code>.
</p>
</li>
<li> <p><code>packages</code> :: <code>character</code><br>
Set of packages required for this <code>PipeOp</code>. These packages are loaded during <code style="white-space: pre;">⁠$train()⁠</code> and <code style="white-space: pre;">⁠$predict()⁠</code>, but not attached.
Default <code>character(0)</code>.
</p>
</li>
<li> <p><code>prediction_type</code> :: <code>character(1)</code><br>
The <code>predict</code> entry of the <code style="white-space: pre;">⁠$input⁠</code> and <code style="white-space: pre;">⁠$output⁠</code> type specifications.
Should be <code>"Prediction"</code> (default) or one of its subclasses, e.g. <code>"PredictionClassif"</code>, and correspond to the type accepted by
<code>private$.train()</code> and <code>private$.predict()</code>.
</p>
</li>
</ul>
<h3>Input and Output Channels</h3>

<p><code>PipeOpEnsemble</code> has multiple input channels depending on the <code>innum</code> construction argument, named <code>"input1"</code>, <code>"input2"</code>, ...
if <code>innum</code> is nonzero; if <code>innum</code> is 0, there is only one <em>vararg</em> input channel named <code>"..."</code>.
All input channels take only <code>NULL</code> during training and take a <code>Prediction</code> during prediction.
</p>
<p><code>PipeOpEnsemble</code> has one output channel named <code>"output"</code>, producing <code>NULL</code> during training and a <code>Prediction</code> during prediction.
</p>
<p>The output during prediction is in some way a weighted averaged representation of the input.
</p>


<h3>State</h3>

<p>The <code style="white-space: pre;">⁠$state⁠</code> is left empty (<code>list()</code>).
</p>


<h3>Parameters</h3>


<ul><li> <p><code>weights</code> :: <code>numeric</code><br>
Relative weights of input predictions. If this has length 1, it is ignored and weighs all inputs equally. Otherwise it must have
length equal to the number of connected inputs. Initialized to 1 (equal weights).
</p>
</li></ul>
<h3>Internals</h3>

<p>The commonality of ensemble methods using <code>PipeOpEnsemble</code> is that they take a <code>NULL</code>-input during training and save an empty <code style="white-space: pre;">⁠$state⁠</code>. They can be
used following a set of <code>PipeOpLearner</code> <code>PipeOp</code>s to perform (possibly weighted) prediction averaging. See e.g.
<code>PipeOpClassifAvg</code> and <code>PipeOpRegrAvg</code> which both inherit from this class.
</p>
<p>Should it be necessary to use the output of preceding <code>Learner</code>s
during the "training" phase, then <code>PipeOpEnsemble</code> should not be used. In fact, if training time behaviour of a <code>Learner</code> is important, then
one should use a <code>PipeOpLearnerCV</code> instead of a <code>PipeOpLearner</code>, and the ensemble can be created with a <code>Learner</code> encapsulated by a <code>PipeOpLearner</code>.
See <code>LearnerClassifAvg</code> and <code>LearnerRegrAvg</code> for examples.
</p>


<h3>Fields</h3>

<p>Only fields inherited from <code>PipeOp</code>.
</p>


<h3>Methods</h3>

<p>Methods inherited from <code>PipeOp</code> as well as:
</p>

<ul><li> <p><code>weighted_avg_prediction(inputs, weights, row_ids, truth)</code><br>
(<code>list</code> of <code>Prediction</code>, <code>numeric</code>, <code>integer</code> | <code>character</code>, <code>list</code>) -&gt; <code>NULL</code><br>
Create <code>Prediction</code>s that correspond to the weighted average of incoming <code>Prediction</code>s. This is
called by <code>private$.predict()</code> with cleaned and sanity-checked values: <code>inputs</code> are guaranteed to fit together,
<code>row_ids</code> and <code>truth</code> are guaranteed to be the same as each one in <code>inputs</code>, and <code>weights</code> is guaranteed to have the same length as <code>inputs</code>.<br>
This method is abstract, it must be implemented by deriving classes.
</p>
</li></ul>
<h3>See Also</h3>

<p>https://mlr-org.com/pipeops.html
</p>
<p>Other PipeOps: 
<code>PipeOp</code>,
<code>PipeOpImpute</code>,
<code>PipeOpTargetTrafo</code>,
<code>PipeOpTaskPreproc</code>,
<code>PipeOpTaskPreprocSimple</code>,
<code>mlr_pipeops</code>,
<code>mlr_pipeops_adas</code>,
<code>mlr_pipeops_blsmote</code>,
<code>mlr_pipeops_boxcox</code>,
<code>mlr_pipeops_branch</code>,
<code>mlr_pipeops_chunk</code>,
<code>mlr_pipeops_classbalancing</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_classweights</code>,
<code>mlr_pipeops_colapply</code>,
<code>mlr_pipeops_collapsefactors</code>,
<code>mlr_pipeops_colroles</code>,
<code>mlr_pipeops_copy</code>,
<code>mlr_pipeops_datefeatures</code>,
<code>mlr_pipeops_encode</code>,
<code>mlr_pipeops_encodeimpact</code>,
<code>mlr_pipeops_encodelmer</code>,
<code>mlr_pipeops_featureunion</code>,
<code>mlr_pipeops_filter</code>,
<code>mlr_pipeops_fixfactors</code>,
<code>mlr_pipeops_histbin</code>,
<code>mlr_pipeops_ica</code>,
<code>mlr_pipeops_imputeconstant</code>,
<code>mlr_pipeops_imputehist</code>,
<code>mlr_pipeops_imputelearner</code>,
<code>mlr_pipeops_imputemean</code>,
<code>mlr_pipeops_imputemedian</code>,
<code>mlr_pipeops_imputemode</code>,
<code>mlr_pipeops_imputeoor</code>,
<code>mlr_pipeops_imputesample</code>,
<code>mlr_pipeops_kernelpca</code>,
<code>mlr_pipeops_learner</code>,
<code>mlr_pipeops_missind</code>,
<code>mlr_pipeops_modelmatrix</code>,
<code>mlr_pipeops_multiplicityexply</code>,
<code>mlr_pipeops_multiplicityimply</code>,
<code>mlr_pipeops_mutate</code>,
<code>mlr_pipeops_nmf</code>,
<code>mlr_pipeops_nop</code>,
<code>mlr_pipeops_ovrsplit</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_pca</code>,
<code>mlr_pipeops_proxy</code>,
<code>mlr_pipeops_quantilebin</code>,
<code>mlr_pipeops_randomprojection</code>,
<code>mlr_pipeops_randomresponse</code>,
<code>mlr_pipeops_regravg</code>,
<code>mlr_pipeops_removeconstants</code>,
<code>mlr_pipeops_renamecolumns</code>,
<code>mlr_pipeops_replicate</code>,
<code>mlr_pipeops_rowapply</code>,
<code>mlr_pipeops_scale</code>,
<code>mlr_pipeops_scalemaxabs</code>,
<code>mlr_pipeops_scalerange</code>,
<code>mlr_pipeops_select</code>,
<code>mlr_pipeops_smote</code>,
<code>mlr_pipeops_smotenc</code>,
<code>mlr_pipeops_spatialsign</code>,
<code>mlr_pipeops_subsample</code>,
<code>mlr_pipeops_targetinvert</code>,
<code>mlr_pipeops_targetmutate</code>,
<code>mlr_pipeops_targettrafoscalerange</code>,
<code>mlr_pipeops_textvectorizer</code>,
<code>mlr_pipeops_threshold</code>,
<code>mlr_pipeops_tunethreshold</code>,
<code>mlr_pipeops_unbranch</code>,
<code>mlr_pipeops_updatetarget</code>,
<code>mlr_pipeops_vtreat</code>,
<code>mlr_pipeops_yeojohnson</code>
</p>
<p>Other Multiplicity PipeOps: 
<code>Multiplicity()</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_featureunion</code>,
<code>mlr_pipeops_multiplicityexply</code>,
<code>mlr_pipeops_multiplicityimply</code>,
<code>mlr_pipeops_ovrsplit</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_regravg</code>,
<code>mlr_pipeops_replicate</code>
</p>
<p>Other Ensembles: 
<code>mlr_learners_avg</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_regravg</code>
</p>


</div>