<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_pipeops_featureunion</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate Features from Multiple Inputs</h2>

<h3>Description</h3>

<p>Aggregates features from all input tasks by <code>cbind()</code>ing them together into a single
<code>Task</code>.
</p>
<p><code>DataBackend</code> primary keys and <code>Task</code> targets have to be equal
across all <code>Task</code>s. Only the target column(s) of the first <code>Task</code>
are kept.
</p>
<p>If <code>assert_targets_equal</code> is <code>TRUE</code> then target column names are compared and an error is thrown
if they differ across inputs.
</p>
<p>If input tasks share some feature names but these features are not identical an error is thrown.
This check is performed by first comparing the features names and if duplicates are found, also
the values of these possibly duplicated features. True duplicated features are only added a
single time to the output task.
</p>


<h3>Format</h3>

<p><code>R6Class</code> object inheriting from <code>PipeOp</code>.
</p>


<h3>Construction</h3>

<div class="sourceCode"><pre>PipeOpFeatureUnion$new(innum = 0, collect_multiplicity = FALSE, id = "featureunion", param_vals = list(),
  assert_targets_equal = TRUE)
</pre></div>

<ul>
<li> <p><code>innum</code> :: <code>numeric(1)</code> | <code>character</code><br>
Determines the number of input channels.
If <code>innum</code> is 0 (default), a vararg input channel is created that can take an arbitrary number
of inputs. If <code>innum</code> is a <code>character</code> vector, the number of input channels is the length of
<code>innum</code>, and the columns of the result are prefixed with the values.
</p>
</li>
<li> <p><code>collect_multiplicity</code> :: <code>logical(1)</code><br>
If <code>TRUE</code>, the input is a <code>Multiplicity</code> collecting channel. This means, a
<code>Multiplicity</code> input, instead of multiple normal inputs, is accepted and the members are aggregated. This requires <code>innum</code> to be 0.
Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>id</code> :: <code>character(1)</code><br>
Identifier of the resulting object, default <code>"featureunion"</code>.
</p>
</li>
<li> <p><code>param_vals</code> :: named <code>list</code><br>
List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise
be set during construction. Default <code>list()</code>.
</p>
</li>
<li> <p><code>assert_targets_equal</code> :: <code>logical(1)</code><br>
If <code>assert_targets_equal</code> is <code>TRUE</code> (Default), task target column names are checked for
agreement. Disagreeing target column names are usually a bug, so this should often be left at
the default.
</p>
</li>
</ul>
<h3>Input and Output Channels</h3>

<p><code>PipeOpFeatureUnion</code> has multiple input channels depending on the <code>innum</code> construction
argument, named <code>"input1"</code>, <code>"input2"</code>, ... if <code>innum</code> is nonzero; if <code>innum</code> is 0, there is
only one <em>vararg</em> input channel named <code>"..."</code>. All input channels take a <code>Task</code>
both during training and prediction.
</p>
<p><code>PipeOpFeatureUnion</code> has one output channel named <code>"output"</code>, producing a <code>Task</code>
both during training and prediction.
</p>
<p>The output is a <code>Task</code> constructed by <code>cbind()</code>ing all features from all input
<code>Task</code>s, both during training and prediction.
</p>


<h3>State</h3>

<p>The <code style="white-space: pre;">⁠$state⁠</code> is left empty (<code>list()</code>).
</p>


<h3>Parameters</h3>

<p><code>PipeOpFeatureUnion</code> has no Parameters.
</p>


<h3>Internals</h3>

<p><code>PipeOpFeatureUnion</code> uses the <code>Task</code> <code style="white-space: pre;">⁠$cbind()⁠</code> method to bind the input values
beyond the first input to the first <code>Task</code>. This means if the <code>Task</code>s
are database-backed, all of them except the first will be fetched into R memory for this. This
behaviour may change in the future.
</p>


<h3>Fields</h3>

<p>Only fields inherited from <code>PipeOp</code>.
</p>


<h3>Methods</h3>

<p>Only methods inherited from <code>PipeOp</code>.
</p>


<h3>See Also</h3>

<p>https://mlr-org.com/pipeops.html
</p>
<p>Other PipeOps: 
<code>PipeOp</code>,
<code>PipeOpEnsemble</code>,
<code>PipeOpImpute</code>,
<code>PipeOpTargetTrafo</code>,
<code>PipeOpTaskPreproc</code>,
<code>PipeOpTaskPreprocSimple</code>,
<code>mlr_pipeops</code>,
<code>mlr_pipeops_adas</code>,
<code>mlr_pipeops_blsmote</code>,
<code>mlr_pipeops_boxcox</code>,
<code>mlr_pipeops_branch</code>,
<code>mlr_pipeops_chunk</code>,
<code>mlr_pipeops_classbalancing</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_classweights</code>,
<code>mlr_pipeops_colapply</code>,
<code>mlr_pipeops_collapsefactors</code>,
<code>mlr_pipeops_colroles</code>,
<code>mlr_pipeops_copy</code>,
<code>mlr_pipeops_datefeatures</code>,
<code>mlr_pipeops_encode</code>,
<code>mlr_pipeops_encodeimpact</code>,
<code>mlr_pipeops_encodelmer</code>,
<code>mlr_pipeops_filter</code>,
<code>mlr_pipeops_fixfactors</code>,
<code>mlr_pipeops_histbin</code>,
<code>mlr_pipeops_ica</code>,
<code>mlr_pipeops_imputeconstant</code>,
<code>mlr_pipeops_imputehist</code>,
<code>mlr_pipeops_imputelearner</code>,
<code>mlr_pipeops_imputemean</code>,
<code>mlr_pipeops_imputemedian</code>,
<code>mlr_pipeops_imputemode</code>,
<code>mlr_pipeops_imputeoor</code>,
<code>mlr_pipeops_imputesample</code>,
<code>mlr_pipeops_kernelpca</code>,
<code>mlr_pipeops_learner</code>,
<code>mlr_pipeops_missind</code>,
<code>mlr_pipeops_modelmatrix</code>,
<code>mlr_pipeops_multiplicityexply</code>,
<code>mlr_pipeops_multiplicityimply</code>,
<code>mlr_pipeops_mutate</code>,
<code>mlr_pipeops_nmf</code>,
<code>mlr_pipeops_nop</code>,
<code>mlr_pipeops_ovrsplit</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_pca</code>,
<code>mlr_pipeops_proxy</code>,
<code>mlr_pipeops_quantilebin</code>,
<code>mlr_pipeops_randomprojection</code>,
<code>mlr_pipeops_randomresponse</code>,
<code>mlr_pipeops_regravg</code>,
<code>mlr_pipeops_removeconstants</code>,
<code>mlr_pipeops_renamecolumns</code>,
<code>mlr_pipeops_replicate</code>,
<code>mlr_pipeops_rowapply</code>,
<code>mlr_pipeops_scale</code>,
<code>mlr_pipeops_scalemaxabs</code>,
<code>mlr_pipeops_scalerange</code>,
<code>mlr_pipeops_select</code>,
<code>mlr_pipeops_smote</code>,
<code>mlr_pipeops_smotenc</code>,
<code>mlr_pipeops_spatialsign</code>,
<code>mlr_pipeops_subsample</code>,
<code>mlr_pipeops_targetinvert</code>,
<code>mlr_pipeops_targetmutate</code>,
<code>mlr_pipeops_targettrafoscalerange</code>,
<code>mlr_pipeops_textvectorizer</code>,
<code>mlr_pipeops_threshold</code>,
<code>mlr_pipeops_tunethreshold</code>,
<code>mlr_pipeops_unbranch</code>,
<code>mlr_pipeops_updatetarget</code>,
<code>mlr_pipeops_vtreat</code>,
<code>mlr_pipeops_yeojohnson</code>
</p>
<p>Other Multiplicity PipeOps: 
<code>Multiplicity()</code>,
<code>PipeOpEnsemble</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_multiplicityexply</code>,
<code>mlr_pipeops_multiplicityimply</code>,
<code>mlr_pipeops_ovrsplit</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_regravg</code>,
<code>mlr_pipeops_replicate</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("mlr3")

task1 = tsk("iris")
gr = gunion(list(
  po("nop"),
  po("pca")
)) %&gt;&gt;% po("featureunion")

gr$train(task1)

task2 = tsk("iris")
task3 = tsk("iris")
po = po("featureunion", innum = c("a", "b"))

po$train(list(task2, task3))
</code></pre>


</div>