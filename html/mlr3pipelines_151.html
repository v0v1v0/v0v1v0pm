<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_pipeops_imputelearner</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Impute Features by Fitting a Learner</h2>

<h3>Description</h3>

<p>Impute features by fitting a <code>Learner</code> for each feature.
Uses the features indicated by the <code>context_columns</code> parameter as features to train the imputation <code>Learner</code>.
Note this parameter is part of the <code>PipeOpImpute</code> base class and explained there.
</p>
<p>Additionally, only features supported by the learner can be imputed; i.e. learners of type
<code>regr</code> can only impute features of type <code>integer</code> and <code>numeric</code>, while <code>classif</code> can impute
features of type <code>factor</code>, <code>ordered</code> and <code>logical</code>.
</p>
<p>The <code>Learner</code> used for imputation is trained on all <code>context_columns</code>; if these contain missing values,
the <code>Learner</code> typically either needs to be able to handle missing values itself, or needs to do its
own imputation (see examples).
</p>


<h3>Format</h3>

<p><code>R6Class</code> object inheriting from <code>PipeOpImpute</code>/<code>PipeOp</code>.
</p>


<h3>Construction</h3>

<div class="sourceCode"><pre>PipeOpImputeLearner$new(learner, id = NULL, param_vals = list())
</pre></div>

<ul>
<li> <p><code>id</code> :: <code>character(1)</code><br>
Identifier of resulting object, default <code>"impute."</code>, followed by the <code>id</code> of the <code>Learner</code>.
</p>
</li>
<li> <p><code>learner</code> :: <code>Learner</code> | <code>character(1)</code>
<code>Learner</code> to wrap, or a string identifying a <code>Learner</code> in the <code>mlr3::mlr_learners</code> <code>Dictionary</code>.
The <code>Learner</code> usually needs to be able to handle missing values, i.e. have the <code>missings</code> property, unless care is taken
that <code>context_columns</code> do not contain missings; see examples.<br>
This argument is always cloned; to access the <code>Learner</code> inside <code>PipeOpImputeLearner</code> by-reference, use <code style="white-space: pre;">⁠$learner⁠</code>.<br></p>
</li>
<li> <p><code>param_vals</code> :: named <code>list</code><br>
List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise be set during construction. Default <code>list()</code>.
</p>
</li>
</ul>
<h3>Input and Output Channels</h3>

<p>Input and output channels are inherited from <code>PipeOpImpute</code>.
</p>
<p>The output is the input <code>Task</code> with missing values from all affected features imputed by the trained model.
</p>


<h3>State</h3>

<p>The <code style="white-space: pre;">⁠$state⁠</code> is a named <code>list</code> with the <code style="white-space: pre;">⁠$state⁠</code> elements inherited from <code>PipeOpImpute</code>.
</p>
<p>The <code style="white-space: pre;">⁠$state$models⁠</code> is a named <code>list</code> of <code>models</code> created by the <code>Learner</code>'s <code style="white-space: pre;">⁠$.train()⁠</code> function
for each column. If a column consists of missing values only during training, the <code>model</code> is <code>0</code> or the levels of the
feature; these are used for sampling during prediction.
</p>
<p>This state is given the class <code>"pipeop_impute_learner_state"</code>.
</p>


<h3>Parameters</h3>

<p>The parameters are the parameters inherited from <code>PipeOpImpute</code>, in addition to the parameters of the <code>Learner</code>
used for imputation.
</p>


<h3>Internals</h3>

<p>Uses the <code style="white-space: pre;">⁠$train⁠</code> and <code style="white-space: pre;">⁠$predict⁠</code> functions of the provided learner. Features that are entirely <code>NA</code> are imputed as <code>0</code>
or randomly sampled from available (<code>factor</code> / <code>logical</code>) levels.
</p>
<p>The <code>Learner</code> does <em>not</em> necessarily need to handle missing values in cases
where <code>context_columns</code> is chosen well (or there is only one column with missing values present).
</p>


<h3>Fields</h3>

<p>Fields inherited from <code>PipeOpTaskPreproc</code>/<code>PipeOp</code>, as well as:
</p>

<ul>
<li> <p><code>learner</code> :: <code>Learner</code><br><code>Learner</code> that is being wrapped. Read-only.
</p>
</li>
<li> <p><code>learner_models</code> :: <code>list</code> of <code>Learner</code> | <code>NULL</code><br><code>Learner</code> that is being wrapped. This list is named by features for which a <code>Learner</code> was fitted, and
contains the same <code>Learner</code>, but with different respective models for each feature. If this <code>PipeOp</code> is not trained,
this is an empty <code>list</code>. For features that were entirely <code>NA</code> during training, the <code>list</code> contains <code>NULL</code> elements.
</p>
</li>
</ul>
<h3>Methods</h3>

<p>Only methods inherited from <code>PipeOpImpute</code>/<code>PipeOp</code>.
</p>


<h3>See Also</h3>

<p>https://mlr-org.com/pipeops.html
</p>
<p>Other PipeOps: 
<code>PipeOp</code>,
<code>PipeOpEnsemble</code>,
<code>PipeOpImpute</code>,
<code>PipeOpTargetTrafo</code>,
<code>PipeOpTaskPreproc</code>,
<code>PipeOpTaskPreprocSimple</code>,
<code>mlr_pipeops</code>,
<code>mlr_pipeops_adas</code>,
<code>mlr_pipeops_blsmote</code>,
<code>mlr_pipeops_boxcox</code>,
<code>mlr_pipeops_branch</code>,
<code>mlr_pipeops_chunk</code>,
<code>mlr_pipeops_classbalancing</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_classweights</code>,
<code>mlr_pipeops_colapply</code>,
<code>mlr_pipeops_collapsefactors</code>,
<code>mlr_pipeops_colroles</code>,
<code>mlr_pipeops_copy</code>,
<code>mlr_pipeops_datefeatures</code>,
<code>mlr_pipeops_encode</code>,
<code>mlr_pipeops_encodeimpact</code>,
<code>mlr_pipeops_encodelmer</code>,
<code>mlr_pipeops_featureunion</code>,
<code>mlr_pipeops_filter</code>,
<code>mlr_pipeops_fixfactors</code>,
<code>mlr_pipeops_histbin</code>,
<code>mlr_pipeops_ica</code>,
<code>mlr_pipeops_imputeconstant</code>,
<code>mlr_pipeops_imputehist</code>,
<code>mlr_pipeops_imputemean</code>,
<code>mlr_pipeops_imputemedian</code>,
<code>mlr_pipeops_imputemode</code>,
<code>mlr_pipeops_imputeoor</code>,
<code>mlr_pipeops_imputesample</code>,
<code>mlr_pipeops_kernelpca</code>,
<code>mlr_pipeops_learner</code>,
<code>mlr_pipeops_missind</code>,
<code>mlr_pipeops_modelmatrix</code>,
<code>mlr_pipeops_multiplicityexply</code>,
<code>mlr_pipeops_multiplicityimply</code>,
<code>mlr_pipeops_mutate</code>,
<code>mlr_pipeops_nmf</code>,
<code>mlr_pipeops_nop</code>,
<code>mlr_pipeops_ovrsplit</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_pca</code>,
<code>mlr_pipeops_proxy</code>,
<code>mlr_pipeops_quantilebin</code>,
<code>mlr_pipeops_randomprojection</code>,
<code>mlr_pipeops_randomresponse</code>,
<code>mlr_pipeops_regravg</code>,
<code>mlr_pipeops_removeconstants</code>,
<code>mlr_pipeops_renamecolumns</code>,
<code>mlr_pipeops_replicate</code>,
<code>mlr_pipeops_rowapply</code>,
<code>mlr_pipeops_scale</code>,
<code>mlr_pipeops_scalemaxabs</code>,
<code>mlr_pipeops_scalerange</code>,
<code>mlr_pipeops_select</code>,
<code>mlr_pipeops_smote</code>,
<code>mlr_pipeops_smotenc</code>,
<code>mlr_pipeops_spatialsign</code>,
<code>mlr_pipeops_subsample</code>,
<code>mlr_pipeops_targetinvert</code>,
<code>mlr_pipeops_targetmutate</code>,
<code>mlr_pipeops_targettrafoscalerange</code>,
<code>mlr_pipeops_textvectorizer</code>,
<code>mlr_pipeops_threshold</code>,
<code>mlr_pipeops_tunethreshold</code>,
<code>mlr_pipeops_unbranch</code>,
<code>mlr_pipeops_updatetarget</code>,
<code>mlr_pipeops_vtreat</code>,
<code>mlr_pipeops_yeojohnson</code>
</p>
<p>Other Imputation PipeOps: 
<code>PipeOpImpute</code>,
<code>mlr_pipeops_imputeconstant</code>,
<code>mlr_pipeops_imputehist</code>,
<code>mlr_pipeops_imputemean</code>,
<code>mlr_pipeops_imputemedian</code>,
<code>mlr_pipeops_imputemode</code>,
<code>mlr_pipeops_imputeoor</code>,
<code>mlr_pipeops_imputesample</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library("mlr3")

task = tsk("pima")
task$missings()

po = po("imputelearner", lrn("regr.rpart"))
new_task = po$train(list(task = task))[[1]]
new_task$missings()

# '$state' of the "regr.rpart" Learner, trained to predict the 'mass' column:
po$state$model$mass

library("mlr3learners")
# to use the "regr.kknn" Learner, prefix it with its own imputation method!
# The "imputehist" PipeOp is used to train "regr.kknn"; predictions of this
# trained Learner are then used to impute the missing values in the Task.
po = po("imputelearner",
  po("imputehist") %&gt;&gt;% lrn("regr.kknn")
)

new_task = po$train(list(task = task))[[1]]
new_task$missings()


</code></pre>


</div>