<div class="container">

<table style="width: 100%;"><tr>
<td>CnfAtom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Atoms for CNF Formulas</h2>

<h3>Description</h3>

<p><code>CnfAtom</code> objects represent a single statement that is used to build up CNF formulae.
They are mostly intermediate, created using the <code>%among%</code> operator or <code>CnfAtom()</code>
directly, and combined into <code>CnfClause</code> and <code>CnfFormula</code> objects.
<code>CnfClause</code> and <code>CnfFormula</code> do not, however, contain <code>CnfAtom</code> objects directly,
</p>
<p><code>CnfAtom</code>s contain an indirect reference to a <code>CnfSymbol</code> by referencing its name
and its <code>CnfUniverse</code>. They furthermore contain a set of values. An <code>CnfAtom</code>
represents a statement asserting that the given symbol takes up one of the
given values.
</p>
<p>If the set of values is empty, the <code>CnfAtom</code> represents a contradiction (FALSE).
If it is the full domain of the symbol, the <code>CnfAtom</code> represents a tautology (TRUE).
These values can be converted to, and from, <code>logical(1)</code> values using <code>as.logical()</code>
and <code>as.CnfAtom()</code>.
</p>
<p><code>CnfAtom</code> objects can be negated using the <code>!</code> operator, which will return the <code>CnfAtom</code>
representing set membership in the complement of the symbol with respect to its domain.
<code>CnfAtom</code>s can furthermore be combined using the <code>|</code> operator to form a <code>CnfClause</code>,
and using the <code>&amp;</code> operator to form a <code>CnfFormula</code>. This happens even if the
resulting statement could be represented as a single <code>CnfAtom</code>.
</p>
<p>This is part of the CNF representation tooling, which is currently considered
experimental; it is for internal use.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CnfAtom(symbol, values)

e1 %among% e2

as.CnfAtom(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>symbol</code></td>
<td>
<p>(<code>CnfSymbol</code>) <br>
The symbol to which the atom refers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>(<code>character</code>) <br>
The values that the symbol can take.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e1</code></td>
<td>
<p>(<code>CnfSymbol</code>) <br>
Left-hand side of the <code style="white-space: pre;">⁠%among%⁠</code> operator.
Passed as <code>symbol</code> to <code>CnfAtom()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e2</code></td>
<td>
<p>(<code>character</code>) <br>
Right-hand side of the <code style="white-space: pre;">⁠%among%⁠</code> operator.
Passed as <code>values</code> to <code>CnfAtom()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>(any) <br>
The object to be coerced to a <code>CnfAtom</code> by <code>as.CnfAtom</code>.
Only <code>logical(1)</code> and <code>CnfAtom</code> itself are currently supported.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We would have preferred to overload the <code>%in%</code> operator, but this is currently
not easily possible in R. We therefore created the <code style="white-space: pre;">⁠%among%⁠</code> operator.
</p>
<p>The internal representation of a <code>CnfAtom</code> may change in the future.
</p>


<h3>Value</h3>

<p>A new <code>CnfAtom</code> object.
</p>


<h3>See Also</h3>

<p>Other CNF representation objects: 
<code>CnfClause()</code>,
<code>CnfFormula()</code>,
<code>CnfSymbol()</code>,
<code>CnfUniverse()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">u = CnfUniverse()
X = CnfSymbol(u, "X", c("a", "b", "c"))

CnfAtom(X, c("a", "b"))
X %among% "a"
X %among% character(0)
X %among% c("a", "b", "c")

as.logical(X %among% character(0))
as.CnfAtom(TRUE)

!(X %among% "a")

X %among% "a" | X %among% "b"  # creates a CnfClause

X %among% "a" &amp; X %among% c("a", "b")  # creates a CnfFormula
</code></pre>


</div>