<div class="container">

<table style="width: 100%;"><tr>
<td>CnfClause</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Clauses in CNF Formulas</h2>

<h3>Description</h3>

<p>A <code>CnfClause</code> is a disjunction of <code>CnfAtom</code> objects. It represents a statement
that is true if at least one of the atoms is true. These are for example of the form
</p>
<div class="sourceCode r"><pre>  X %among% c("a", "b", "c") | Y %among% c("d", "e", "f") | ...
</pre></div>
<p><code>CnfClause</code> objects can be constructed explicitly, using the <code>CnfClause()</code> constructor,
or implicitly, by using the <code>|</code> operator on <code>CnfAtom</code>s or other <code>CnfClause</code> objects.
</p>
<p><code>CnfClause</code> objects which are not tautologies or contradictions are named lists;
the value ranges of each symbol can be accessed using <code>[[</code>, and these clauses
can be subset using <code>[</code> to get clauses containing only the indicated symbols.
However, to get a list of <code>CnfAtom</code> objects, use <code>as.list()</code>.
Note that the simplified form of a clause containing a contradiction is the empty list.
</p>
<p>Upon construction, the <code>CnfClause</code> is simplified by (1) removing contradictions, (2) unifying
atoms that refer to the same symbol, and (3) evaluating to <code>TRUE</code> if any atom is <code>TRUE</code>.
Note that the order of atoms in a clause is not preserved.
</p>
<p>Using <code>CnfClause()</code> on lists that contain other <code>CnfClause</code> objects will create
a clause that is the disjunction of all atoms in all clauses.
</p>
<p>If a <code>CnfClause</code> contains no atoms, or only <code>FALSE</code> atoms, it evaluates to <code>FALSE</code>.
If it contains at least one atom that is always true, the clause evaluates to <code>TRUE</code>.
These values can be converted to, and from, <code>logical(1)</code> values using <code>as.logical()</code>
and <code>as.CnfClause()</code>.
</p>
<p><code>CnfClause</code> objects can be negated using the <code>!</code> operator, and combined using the
<code>&amp;</code> operator. Both of these operations return a <code>CnfFormula</code>, even if the result
could in principle be represented as a single <code>CnfClause</code>.
</p>
<p>This is part of the CNF representation tooling, which is currently considered
experimental; it is for internal use.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CnfClause(atoms)

as.CnfClause(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>atoms</code></td>
<td>
<p>(<code>list</code> of (<code>CnfAtom</code> | <code>CnfClause</code>)) <br>
A list of <code>CnfAtom</code> or other <code>CnfClause</code> objects.
The clause represents the disjunction of these atoms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>(any) <br>
The object to be coerced to a <code>CnfClause</code> by <code>as.CnfClause</code>.
Only <code>logical(1)</code>, <code>CnfAtom</code>, and <code>CnfClause</code> itself are currently supported.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We are undecided whether it is a better idea to have <code>as.list()</code> return a named list
or an unnamed one. Calling <code>as.list()</code> on a <code>CnfClause</code> with a tautology returns
a tautology-atom, which does not have a name. We currently return a named list
for other clauses, as this makes subsetting by name commute with <code>as.list()</code>.
However, this behaviour may change in the future.
</p>


<h3>Value</h3>

<p>A new <code>CnfClause</code> object.
</p>


<h3>See Also</h3>

<p>Other CNF representation objects: 
<code>CnfAtom()</code>,
<code>CnfFormula()</code>,
<code>CnfSymbol()</code>,
<code>CnfUniverse()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">u = CnfUniverse()
X = CnfSymbol(u, "X", c("a", "b", "c"))
Y = CnfSymbol(u, "Y", c("d", "e", "f"))

CnfClause(list(X %among% c("a", "b"), Y %among% c("d", "e")))
cls = X %among% c("a", "b") | Y %among% c("d", "e")
cls

as.list(cls)

as.CnfClause(X %among% c("a", "b"))

# The same symbols are unified
X %among% "a" | Y %among% "d" | X %among% "b"

# tautology evaluates to TRUE
X %among% "a" | X %among% "b" | X %among% "c"

# contradictions are removed
X %among% "a" | Y %among% character(0)

# create CnfFormula:
!(X %among% "a" | Y %among% "d")

# also a CnfFormula, even if it contains a single clause:
!CnfClause(list(X %among% "a"))
(X %among% c("a", "c") | Y %among% "d") &amp;
  (X %among% c("a", "b") | Y %among% "d")
</code></pre>


</div>