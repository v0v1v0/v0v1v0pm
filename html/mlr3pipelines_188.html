<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_pipeops_targetmutate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transform a Target by a Function</h2>

<h3>Description</h3>

<p>Changes the <em>target</em> of a <code>Task</code> according to a function given as hyperparameter.
An inverter-function that undoes the transformation during prediction must also be given.
</p>


<h3>Format</h3>

<p><code>R6Class</code> object inheriting from <code>PipeOpTargetTrafo</code>/<code>PipeOp</code>
</p>


<h3>Construction</h3>

<div class="sourceCode"><pre>PipeOpTargetMutate$new(id = "targetmutate", param_vals = list(), new_task_type = NULL)
</pre></div>

<ul>
<li> <p><code>id</code> :: <code>character(1)</code><br>
Identifier of resulting object, default <code>"targetmutate"</code>.
</p>
</li>
<li> <p><code>param_vals</code> :: named <code>list</code><br>
List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise
be set during construction. Default <code>list()</code>.
</p>
</li>
<li> <p><code>new_task_type</code> :: <code>character(1)</code> | <code>NULL</code><br>
The task type to which the output is converted, must be one of <code>mlr_reflections$task_types$type</code>.
Defaults to <code>NULL</code>: no change in task type.
</p>
</li>
</ul>
<h3>Input and Output Channels</h3>

<p>Input and output channels are inherited from <code>PipeOpTargetTrafo</code>.
</p>


<h3>State</h3>

<p>The <code style="white-space: pre;">⁠$state⁠</code> is left empty (<code>list()</code>).
</p>


<h3>Parameters</h3>

<p>The parameters are the parameters inherited from <code>PipeOpTargetTrafo</code>, as well as:
</p>

<ul>
<li> <p><code>trafo</code> :: <code>function</code> <code>data.table</code> -&gt; <code>data.table</code><br>
Transformation function for the target. Should only be a function of the target, i.e., taking a
single <code>data.table</code> argument, typically with one column. The return value is used as the new
target of the resulting <code>Task</code>. To change target names, change the column name of the data
using e.g. <code>setnames()</code>.<br>
Note that this function also gets called during prediction and should thus gracefully handle <code>NA</code> values.<br>
Initialized to <code>identity()</code>.
</p>
</li>
<li> <p><code>inverter</code> :: <code>function</code> <code>data.table</code> -&gt; <code>data.table</code> | named <code>list</code><br>
Inversion of the transformation function for the target. Called on a <code>data.table</code> created from a <code>Prediction</code>
using <code>as.data.table()</code>, without the <code style="white-space: pre;">⁠$row_ids⁠</code> and <code style="white-space: pre;">⁠$truth⁠</code> columns,
and should return a <code>data.table</code> or named <code>list</code> that contains the new relevant slots of a
<code>Prediction</code> subclass (e.g., <code style="white-space: pre;">⁠$response⁠</code>, <code style="white-space: pre;">⁠$prob⁠</code>, <code style="white-space: pre;">⁠$se⁠</code>, ...). Initialized to <code>identity()</code>.
</p>
</li>
</ul>
<h3>Internals</h3>

<p>Overloads <code>PipeOpTargetTrafo</code>'s <code>.transform()</code> and
<code>.invert()</code> functions. Should be used in combination with <code>PipeOpTargetInvert</code>.
</p>


<h3>Fields</h3>

<p>Fields inherited from <code>PipeOp</code>, as well as:
</p>

<ul><li> <p><code>new_task_type</code> :: <code>character(1)</code><br><code>new_task_type</code> construction argument. Read-only.
</p>
</li></ul>
<h3>Methods</h3>

<p>Only methods inherited from <code>PipeOpTargetTrafo</code>/<code>PipeOp</code>.
</p>


<h3>See Also</h3>

<p>https://mlr-org.com/pipeops.html
</p>
<p>Other PipeOps: 
<code>PipeOp</code>,
<code>PipeOpEnsemble</code>,
<code>PipeOpImpute</code>,
<code>PipeOpTargetTrafo</code>,
<code>PipeOpTaskPreproc</code>,
<code>PipeOpTaskPreprocSimple</code>,
<code>mlr_pipeops</code>,
<code>mlr_pipeops_adas</code>,
<code>mlr_pipeops_blsmote</code>,
<code>mlr_pipeops_boxcox</code>,
<code>mlr_pipeops_branch</code>,
<code>mlr_pipeops_chunk</code>,
<code>mlr_pipeops_classbalancing</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_classweights</code>,
<code>mlr_pipeops_colapply</code>,
<code>mlr_pipeops_collapsefactors</code>,
<code>mlr_pipeops_colroles</code>,
<code>mlr_pipeops_copy</code>,
<code>mlr_pipeops_datefeatures</code>,
<code>mlr_pipeops_encode</code>,
<code>mlr_pipeops_encodeimpact</code>,
<code>mlr_pipeops_encodelmer</code>,
<code>mlr_pipeops_featureunion</code>,
<code>mlr_pipeops_filter</code>,
<code>mlr_pipeops_fixfactors</code>,
<code>mlr_pipeops_histbin</code>,
<code>mlr_pipeops_ica</code>,
<code>mlr_pipeops_imputeconstant</code>,
<code>mlr_pipeops_imputehist</code>,
<code>mlr_pipeops_imputelearner</code>,
<code>mlr_pipeops_imputemean</code>,
<code>mlr_pipeops_imputemedian</code>,
<code>mlr_pipeops_imputemode</code>,
<code>mlr_pipeops_imputeoor</code>,
<code>mlr_pipeops_imputesample</code>,
<code>mlr_pipeops_kernelpca</code>,
<code>mlr_pipeops_learner</code>,
<code>mlr_pipeops_missind</code>,
<code>mlr_pipeops_modelmatrix</code>,
<code>mlr_pipeops_multiplicityexply</code>,
<code>mlr_pipeops_multiplicityimply</code>,
<code>mlr_pipeops_mutate</code>,
<code>mlr_pipeops_nmf</code>,
<code>mlr_pipeops_nop</code>,
<code>mlr_pipeops_ovrsplit</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_pca</code>,
<code>mlr_pipeops_proxy</code>,
<code>mlr_pipeops_quantilebin</code>,
<code>mlr_pipeops_randomprojection</code>,
<code>mlr_pipeops_randomresponse</code>,
<code>mlr_pipeops_regravg</code>,
<code>mlr_pipeops_removeconstants</code>,
<code>mlr_pipeops_renamecolumns</code>,
<code>mlr_pipeops_replicate</code>,
<code>mlr_pipeops_rowapply</code>,
<code>mlr_pipeops_scale</code>,
<code>mlr_pipeops_scalemaxabs</code>,
<code>mlr_pipeops_scalerange</code>,
<code>mlr_pipeops_select</code>,
<code>mlr_pipeops_smote</code>,
<code>mlr_pipeops_smotenc</code>,
<code>mlr_pipeops_spatialsign</code>,
<code>mlr_pipeops_subsample</code>,
<code>mlr_pipeops_targetinvert</code>,
<code>mlr_pipeops_targettrafoscalerange</code>,
<code>mlr_pipeops_textvectorizer</code>,
<code>mlr_pipeops_threshold</code>,
<code>mlr_pipeops_tunethreshold</code>,
<code>mlr_pipeops_unbranch</code>,
<code>mlr_pipeops_updatetarget</code>,
<code>mlr_pipeops_vtreat</code>,
<code>mlr_pipeops_yeojohnson</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(mlr3)
task = tsk("boston_housing")
po = PipeOpTargetMutate$new("logtrafo", param_vals = list(
  trafo = function(x) log(x, base = 2),
  inverter = function(x) list(response = 2 ^ x$response))
)
# Note that this example is ill-equipped to work with
# `predict_type == "se"` predictions.

po$train(list(task))
po$predict(list(task))

g = Graph$new()
g$add_pipeop(po)
g$add_pipeop(LearnerRegrRpart$new())
g$add_pipeop(PipeOpTargetInvert$new())
g$add_edge(src_id = "logtrafo", dst_id = "targetinvert",
  src_channel = 1, dst_channel = 1)
g$add_edge(src_id = "logtrafo", dst_id = "regr.rpart",
  src_channel = 2, dst_channel = 1)
g$add_edge(src_id = "regr.rpart", dst_id = "targetinvert",
  src_channel = 1, dst_channel = 2)

g$train(task)
g$predict(task)

#syntactic sugar using ppl():
tt = ppl("targettrafo", graph = PipeOpLearner$new(LearnerRegrRpart$new()))
tt$param_set$values$targetmutate.trafo = function(x) log(x, base = 2)
tt$param_set$values$targetmutate.inverter = function(x) list(response = 2 ^ x$response)

</code></pre>


</div>