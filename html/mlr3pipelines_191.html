<div class="container">

<table style="width: 100%;"><tr>
<td>PipeOpTaskPreproc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Task Preprocessing Base Class</h2>

<h3>Description</h3>

<p>Base class for handling most "preprocessing" operations. These
are operations that have exactly one <code>Task</code> input and one <code>Task</code> output,
and expect the column layout of these <code>Task</code>s during input and output
to be the same.
</p>
<p>Prediction-behavior of preprocessing operations should always be independent for each row in the input-<code>Task</code>.
This means that the prediction-operation of preprocessing-<code>PipeOp</code>s should commute with <code>rbind()</code>: Running prediction
on an <code>n</code>-row <code>Task</code> should result in the same result as <code>rbind()</code>-ing the prediction-result from <code>n</code>
1-row <code>Task</code>s with the same content. In the large majority of cases, the number and order of rows
should also not be changed during prediction.
</p>
<p>Users must implement <code>private$.train_task()</code> and <code>private$.predict_task()</code>, which have a <code>Task</code>
input and should return that <code>Task</code>. The <code>Task</code> should, if possible, be
manipulated in-place, and should not be cloned.
</p>
<p>Alternatively, the <code>private$.train_dt()</code> and <code>private$.predict_dt()</code> functions can be implemented, which operate on
<code>data.table</code> objects instead. This should generally only be done if all
data is in some way altered (e.g. PCA changing all columns to principal components) and not if only
a few columns are added or removed (e.g. feature selection) because this should be done at the <code>Task</code>-level
with <code>private$.train_task()</code>. The <code>private$.select_cols()</code> function can be overloaded for <code>private$.train_dt()</code> and <code>private$.predict_dt()</code>
to operate only on subsets of the <code>Task</code>'s data, e.g. only on numerical columns.
</p>
<p>If the <code>can_subset_cols</code> argument of the constructor is <code>TRUE</code> (the default), then the hyperparameter <code>affect_columns</code>
is added, which can limit the columns of the <code>Task</code> that is modified by the <code>PipeOpTaskPreproc</code>
using a <code>Selector</code> function. Note this functionality is entirely independent of the <code>private$.select_cols()</code> functionality.
</p>
<p><code>PipeOpTaskPreproc</code> is useful for operations that behave differently during training and prediction. For operations
that perform essentially the same operation and only need to perform extra work to build a <code style="white-space: pre;">⁠$state⁠</code> during training,
the <code>PipeOpTaskPreprocSimple</code> class can be used instead.
</p>


<h3>Format</h3>

<p>Abstract <code>R6Class</code> inheriting from <code>PipeOp</code>.
</p>


<h3>Construction</h3>

<div class="sourceCode"><pre>PipeOpTaskPreproc$new(id, param_set = ps(), param_vals = list(), can_subset_cols = TRUE,
  packages = character(0), task_type = "Task", tags = NULL, feature_types = mlr_reflections$task_feature_types)
</pre></div>

<ul>
<li> <p><code>id</code> :: <code>character(1)</code><br>
Identifier of resulting object. See <code style="white-space: pre;">⁠$id⁠</code> slot of <code>PipeOp</code>.
</p>
</li>
<li> <p><code>param_set</code> :: <code>ParamSet</code><br>
Parameter space description. This should be created by the subclass and given to <code>super$initialize()</code>.
</p>
</li>
<li> <p><code>param_vals</code> :: named <code>list</code><br>
List of hyperparameter settings, overwriting the hyperparameter settings given in <code>param_set</code>. The
subclass should have its own <code>param_vals</code> parameter and pass it on to <code>super$initialize()</code>. Default <code>list()</code>.
</p>
</li>
<li> <p><code>can_subset_cols</code> :: <code>logical(1)</code><br>
Whether the <code>affect_columns</code> parameter should be added which lets the user limit the columns that are
modified by the <code>PipeOpTaskPreproc</code>. This should generally be <code>FALSE</code> if the operation adds or removes
rows from the <code>Task</code>, and <code>TRUE</code> otherwise. Default is <code>TRUE</code>.
</p>
</li>
<li>
<p> packages :: <code>character</code><br>
Set of all required packages for the <code>PipeOp</code>'s <code>private$.train()</code> and <code>private$.predict()</code> methods. See <code style="white-space: pre;">⁠$packages⁠</code> slot.
Default is <code>character(0)</code>.
</p>
</li>
<li> <p><code>task_type</code> :: <code>character(1)</code><br>
The class of <code>Task</code> that should be accepted as input and will be returned as output. This
should generally be a <code>character(1)</code> identifying a type of <code>Task</code>, e.g. <code>"Task"</code>, <code>"TaskClassif"</code> or
<code>"TaskRegr"</code> (or another subclass introduced by other packages). Default is <code>"Task"</code>.
</p>
</li>
<li>
<p> tags :: <code>character</code> | <code>NULL</code><br>
Tags of the resulting <code>PipeOp</code>. This is added to the tag <code>"data transform"</code>. Default <code>NULL</code>.
</p>
</li>
<li> <p><code>feature_types</code> :: <code>character</code><br>
Feature types affected by the <code>PipeOp</code>. See <code>private$.select_cols()</code> for more information.
Defaults to all available feature types.
</p>
</li>
</ul>
<h3>Input and Output Channels</h3>

<p><code>PipeOpTaskPreproc</code> has one input channel named <code>"input"</code>, taking a <code>Task</code>, or a subclass of
<code>Task</code> if the <code>task_type</code> construction argument is given as such; both during training and prediction.
</p>
<p><code>PipeOpTaskPreproc</code> has one output channel named <code>"output"</code>, producing a <code>Task</code>, or a subclass;
the <code>Task</code> type is the same as for input; both during training and prediction.
</p>
<p>The output <code>Task</code> is the modified input <code>Task</code> according to the overloaded
<code>private$.train_task()</code>/<code>private$.predict_taks()</code> or <code>private$.train_dt()</code>/<code>private$.predict_dt()</code> functions.
</p>


<h3>State</h3>

<p>The <code style="white-space: pre;">⁠$state⁠</code> is a named <code>list</code>; besides members added by inheriting classes, the members are:
</p>

<ul>
<li> <p><code>affect_cols</code> :: <code>character</code><br>
Names of features being selected by the <code>affect_columns</code> parameter, if present; names of <em>all</em> present features otherwise.
</p>
</li>
<li> <p><code>intasklayout</code> :: <code>data.table</code><br>
Copy of the training <code>Task</code>'s <code style="white-space: pre;">⁠$feature_types⁠</code> slot. This is used during prediction to ensure that
the prediction <code>Task</code> has the same features, feature layout, and feature types as during training.
</p>
</li>
<li> <p><code>outtasklayout</code> :: <code>data.table</code><br>
Copy of the trained <code>Task</code>'s <code style="white-space: pre;">⁠$feature_types⁠</code> slot. This is used during prediction to ensure that
the <code>Task</code> resulting from the prediction operation has the same features, feature layout, and feature types as after training.
</p>
</li>
<li> <p><code>dt_columns</code> :: <code>character</code><br>
Names of features selected by the <code>private$.select_cols()</code> call during training. This is only present if the <code>private$.train_dt()</code> functionality is used,
and not present if the <code>private$.train_task()</code> function is overloaded instead.
</p>
</li>
<li> <p><code>feature_types</code> :: <code>character</code><br>
Feature types affected by the <code>PipeOp</code>. See <code>private$.select_cols()</code> for more information.
</p>
</li>
</ul>
<h3>Parameters</h3>


<ul><li> <p><code>affect_columns</code> :: <code>function</code> | <code>Selector</code> | <code>NULL</code> <br>
What columns the <code>PipeOpTaskPreproc</code> should operate on. This parameter is only present if the constructor is called with
the <code>can_subset_cols</code> argument set to <code>TRUE</code> (the default).<br>
The parameter must be a <code>Selector</code> function, which takes a <code>Task</code> as argument and returns a <code>character</code>
of features to use.<br>
See <code>Selector</code> for example functions. Defaults to <code>NULL</code>, which selects all features.
</p>
</li></ul>
<h3>Internals</h3>

<p><code>PipeOpTaskPreproc</code> is an abstract class inheriting from <code>PipeOp</code>. It implements the <code>private$.train()</code> and
<code style="white-space: pre;">⁠$.predict()⁠</code> functions. These functions perform checks and go on to call <code>private$.train_task()</code> and <code>private$.predict_task()</code>.
A subclass of <code>PipeOpTaskPreproc</code> may implement these functions, or implement <code>private$.train_dt()</code> and <code>private$.predict_dt()</code> instead.
This works by having the default implementations of <code>private$.train_task()</code> and <code>private$.predict_task()</code> call <code>private$.train_dt()</code> and <code>private$.predict_dt()</code>,
respectively.
</p>
<p>The <code>affect_columns</code> functionality works by unsetting columns by removing their "col_role" before
processing, and adding them afterwards by setting the col_role to <code>"feature"</code>.
</p>


<h3>Fields</h3>

<p>Fields inherited from <code>PipeOp</code>.
</p>


<h3>Methods</h3>

<p>Methods inherited from <code>PipeOp</code>, as well as:
</p>

<ul>
<li> <p><code>.train_task</code><br>
(<code>Task</code>) -&gt; <code>Task</code><br>
Called by the <code>PipeOpTaskPreproc</code>'s implementation of <code>private$.train()</code>. Takes a single <code>Task</code> as input
and modifies it (ideally in-place without cloning) while storing information in the <code style="white-space: pre;">⁠$state⁠</code> slot. Note that unlike
<code style="white-space: pre;">⁠$.train()⁠</code>, the argument is <em>not</em> a list but a singular <code>Task</code>, and the return object is also <em>not</em> a list but
a singular <code>Task</code>. Also, contrary to <code>private$.train()</code>, the <code style="white-space: pre;">⁠$state⁠</code> being generated must be a <code>list</code>, which
the <code>PipeOpTaskPreproc</code> will add additional slots to (see Section <em>State</em>). Care should be taken to avoid name collisions between
<code style="white-space: pre;">⁠$state⁠</code> elements added by <code>private$.train_task()</code> and <code>PipeOpTaskPreproc</code>.<br>
By default this function calls the <code>private$.train_dt()</code> function, but it can be overloaded to perform operations on the <code>Task</code>
directly.
</p>
</li>
<li> <p><code>.predict_task</code><br>
(<code>Task</code>) -&gt; <code>Task</code><br>
Called by the <code>PipeOpTaskPreproc</code>'s implementation of <code style="white-space: pre;">⁠$.predict()⁠</code>. Takes a single <code>Task</code> as input
and modifies it (ideally in-place without cloning) while using information in the <code style="white-space: pre;">⁠$state⁠</code> slot. Works analogously to
<code>private$.train_task()</code>. If <code>private$.predict_task()</code> should only be overloaded if <code>private$.train_task()</code> is overloaded (i.e. <code>private$.train_dt()</code> is <em>not</em> used).
</p>
</li>
<li> <p><code>.train_dt(dt, levels, target)</code> <br>
(<code>data.table</code>, named <code>list</code>, <code>any</code>) -&gt; <code>data.table</code> | <code>data.frame</code> | <code>matrix</code> <br>
Train <code>PipeOpTaskPreproc</code> on <code>dt</code>, transform it and store a state in <code style="white-space: pre;">⁠$state⁠</code>. A transformed object must be returned
that can be converted to a <code>data.table</code> using <code>as.data.table</code>. <code>dt</code> does not need to be copied deliberately, it
is possible and encouraged to change it in-place.<br>
The <code>levels</code> argument is a named list of factor levels for factorial or character features.
If the input <code>Task</code> inherits from <code>TaskSupervised</code>, the <code>target</code> argument
contains the <code style="white-space: pre;">⁠$truth()⁠</code> information of the training <code>Task</code>; its type depends on the <code>Task</code>
type being trained on.<br>
This method can be overloaded when inheriting from <code>PipeOpTaskPreproc</code>, together with <code>private$.predict_dt()</code> and optionally
<code>private$.select_cols()</code>; alternatively, <code>private$.train_task()</code> and <code>private$.predict_task()</code> can be overloaded.
</p>
</li>
<li> <p><code>.predict_dt(dt, levels)</code> <br>
(<code>data.table</code>, named <code>list</code>) -&gt; <code>data.table</code> | <code>data.frame</code> | <code>matrix</code> <br>
Predict on new data in <code>dt</code>, possibly using the stored <code style="white-space: pre;">⁠$state⁠</code>. A transformed object must be returned
that can be converted to a <code>data.table</code> using <code>as.data.table</code>. <code>dt</code> does not need to be copied deliberately, it
is possible and encouraged to change it in-place.<br>
The <code>levels</code> argument is a named list of factor levels for factorial or character features.<br>
This method can be overloaded when inheriting <code>PipeOpTaskPreproc</code>, together with <code>private$.train_dt()</code> and optionally
<code>private$.select_cols()</code>; alternatively, <code>private$.train_task()</code> and <code>private$.predict_task()</code> can be overloaded.
</p>
</li>
<li> <p><code>.select_cols(task)</code> <br>
(<code>Task</code>) -&gt; <code>character</code> <br>
Selects which columns the <code>PipeOp</code> operates on, if <code>private$.train_dt()</code> and <code>private$.predict_dt()</code> are overloaded. This function
is not called if <code>private$.train_task()</code> and <code>private$.predict_task()</code> are overloaded. In contrast to
the <code>affect_columns</code> parameter. <code>private$.select_cols()</code> is for the <em>inheriting class</em> to determine which columns
the operator should function on, e.g. based on feature type, while <code>affect_columns</code> is a way for the <em>user</em>
to limit the columns that a <code>PipeOpTaskPreproc</code> should operate on.<br>
This method can optionally be overloaded when inheriting <code>PipeOpTaskPreproc</code>, together with <code>private$.train_dt()</code> and
<code>private$.predict_dt()</code>; alternatively, <code>private$.train_task()</code> and <code>private$.predict_task()</code> can be overloaded.<br>
If this method is not overloaded, it defaults to selecting of type indicated by the <code>feature_types</code> construction argument.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>https://mlr-org.com/pipeops.html
</p>
<p>Other mlr3pipelines backend related: 
<code>Graph</code>,
<code>PipeOp</code>,
<code>PipeOpTargetTrafo</code>,
<code>PipeOpTaskPreprocSimple</code>,
<code>mlr_graphs</code>,
<code>mlr_pipeops</code>,
<code>mlr_pipeops_updatetarget</code>
</p>
<p>Other PipeOps: 
<code>PipeOp</code>,
<code>PipeOpEnsemble</code>,
<code>PipeOpImpute</code>,
<code>PipeOpTargetTrafo</code>,
<code>PipeOpTaskPreprocSimple</code>,
<code>mlr_pipeops</code>,
<code>mlr_pipeops_adas</code>,
<code>mlr_pipeops_blsmote</code>,
<code>mlr_pipeops_boxcox</code>,
<code>mlr_pipeops_branch</code>,
<code>mlr_pipeops_chunk</code>,
<code>mlr_pipeops_classbalancing</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_classweights</code>,
<code>mlr_pipeops_colapply</code>,
<code>mlr_pipeops_collapsefactors</code>,
<code>mlr_pipeops_colroles</code>,
<code>mlr_pipeops_copy</code>,
<code>mlr_pipeops_datefeatures</code>,
<code>mlr_pipeops_encode</code>,
<code>mlr_pipeops_encodeimpact</code>,
<code>mlr_pipeops_encodelmer</code>,
<code>mlr_pipeops_featureunion</code>,
<code>mlr_pipeops_filter</code>,
<code>mlr_pipeops_fixfactors</code>,
<code>mlr_pipeops_histbin</code>,
<code>mlr_pipeops_ica</code>,
<code>mlr_pipeops_imputeconstant</code>,
<code>mlr_pipeops_imputehist</code>,
<code>mlr_pipeops_imputelearner</code>,
<code>mlr_pipeops_imputemean</code>,
<code>mlr_pipeops_imputemedian</code>,
<code>mlr_pipeops_imputemode</code>,
<code>mlr_pipeops_imputeoor</code>,
<code>mlr_pipeops_imputesample</code>,
<code>mlr_pipeops_kernelpca</code>,
<code>mlr_pipeops_learner</code>,
<code>mlr_pipeops_missind</code>,
<code>mlr_pipeops_modelmatrix</code>,
<code>mlr_pipeops_multiplicityexply</code>,
<code>mlr_pipeops_multiplicityimply</code>,
<code>mlr_pipeops_mutate</code>,
<code>mlr_pipeops_nmf</code>,
<code>mlr_pipeops_nop</code>,
<code>mlr_pipeops_ovrsplit</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_pca</code>,
<code>mlr_pipeops_proxy</code>,
<code>mlr_pipeops_quantilebin</code>,
<code>mlr_pipeops_randomprojection</code>,
<code>mlr_pipeops_randomresponse</code>,
<code>mlr_pipeops_regravg</code>,
<code>mlr_pipeops_removeconstants</code>,
<code>mlr_pipeops_renamecolumns</code>,
<code>mlr_pipeops_replicate</code>,
<code>mlr_pipeops_rowapply</code>,
<code>mlr_pipeops_scale</code>,
<code>mlr_pipeops_scalemaxabs</code>,
<code>mlr_pipeops_scalerange</code>,
<code>mlr_pipeops_select</code>,
<code>mlr_pipeops_smote</code>,
<code>mlr_pipeops_smotenc</code>,
<code>mlr_pipeops_spatialsign</code>,
<code>mlr_pipeops_subsample</code>,
<code>mlr_pipeops_targetinvert</code>,
<code>mlr_pipeops_targetmutate</code>,
<code>mlr_pipeops_targettrafoscalerange</code>,
<code>mlr_pipeops_textvectorizer</code>,
<code>mlr_pipeops_threshold</code>,
<code>mlr_pipeops_tunethreshold</code>,
<code>mlr_pipeops_unbranch</code>,
<code>mlr_pipeops_updatetarget</code>,
<code>mlr_pipeops_vtreat</code>,
<code>mlr_pipeops_yeojohnson</code>
</p>


</div>