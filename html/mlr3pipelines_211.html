<div class="container">

<table style="width: 100%;"><tr>
<td>Selector</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Selector Functions</h2>

<h3>Description</h3>

<p>A <code>Selector</code> function is used by different <code>PipeOp</code>s, most prominently <code>PipeOpSelect</code> and many <code>PipeOp</code>s inheriting
from <code>PipeOpTaskPreproc</code>, to determine a subset of <code>Task</code>s to operate on.
</p>
<p>Even though a <code>Selector</code> is a <code>function</code> that can be written itself, it is preferable to use the <code>Selector</code> constructors
shown here. Each of these can be called with its arguments to create a <code>Selector</code>, which can then be given to the <code>PipeOpSelect</code>
<code>selector</code> parameter, or many <code>PipeOpTaskPreproc</code>s' <code>affect_columns</code> parameter. See there for examples of this usage.
</p>


<h3>Usage</h3>

<pre><code class="language-R">selector_all()

selector_none()

selector_type(types)

selector_grep(pattern, ignore.case = FALSE, perl = FALSE, fixed = FALSE)

selector_name(feature_names, assert_present = FALSE)

selector_invert(selector)

selector_intersect(selector_x, selector_y)

selector_union(selector_x, selector_y)

selector_setdiff(selector_x, selector_y)

selector_missing()

selector_cardinality_greater_than(min_cardinality)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>types</code></td>
<td>
<p>(<code>character</code>) <br>
Type of feature to select</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>(<code>character(1)</code>) <br>
grep pattern</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.case</code></td>
<td>
<p>(<code>logical(1)</code>) <br>
ignore case</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perl</code></td>
<td>
<p>(<code>logical(1)</code>) <br>
perl regex</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>(<code>logical(1)</code>) <br>
fixed pattern instead of regex</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>feature_names</code></td>
<td>
<p>(<code>character</code>)<br>
Select features by exact name match.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assert_present</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Throw an error if <code>feature_names</code> are not all present in the task being operated on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selector</code></td>
<td>
<p>(<code>Selector</code>)<br><code>Selector</code> to invert.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selector_x</code></td>
<td>
<p>(<code>Selector</code>)<br>
First <code>Selector</code> to query.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selector_y</code></td>
<td>
<p>(<code>Selector</code>)<br>
Second <code>Selector</code> to query.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_cardinality</code></td>
<td>
<p>(<code>integer</code>) <br>
Minimum number of levels required to be selected.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>function</code>: A <code>Selector</code> function that takes a <code>Task</code> and returns the feature names to be processed.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>selector_all()</code>: <code>selector_all</code> selects all features.
</p>
</li>
<li> <p><code>selector_none()</code>: <code>selector_none</code> selects none of the  features.
</p>
</li>
<li> <p><code>selector_type()</code>: <code>selector_type</code> selects features according to type. Legal types are listed in <code>mlr_reflections$task_feature_types</code>.
</p>
</li>
<li> <p><code>selector_grep()</code>: <code>selector_grep</code> selects features with names matching the <code>grep()</code> pattern.
</p>
</li>
<li> <p><code>selector_name()</code>: <code>selector_name</code> selects features with names matching exactly the names listed.
</p>
</li>
<li> <p><code>selector_invert()</code>: <code>selector_invert</code> inverts a given <code>Selector</code>: It always selects the features
that would be <em>dropped</em> by the other <code>Selector</code>, and drops the features that
would be kept.
</p>
</li>
<li> <p><code>selector_intersect()</code>: <code>selector_intersect</code> selects the intersection of two <code>Selector</code>s: Only features
selected by both <code>Selector</code>s are selected in the end.
</p>
</li>
<li> <p><code>selector_union()</code>: <code>selector_union</code> selects the union of two <code>Selector</code>s: Features
selected by either <code>Selector</code> are selected in the end.
</p>
</li>
<li> <p><code>selector_setdiff()</code>: <code>selector_setdiff</code> selects the setdiff of two <code>Selector</code>s: Features
selected by <code>selector_x</code> are selected, unless they are also selected
by <code>selector_y</code>.
</p>
</li>
<li> <p><code>selector_missing()</code>: <code>selector_missing</code> selects features with missing values.
</p>
</li>
<li> <p><code>selector_cardinality_greater_than()</code>: <code>selector_cardinality_greater_than</code> selects categorical features with cardinality
greater then a given threshold.
</p>
</li>
</ul>
<h3>Details</h3>

<p>A <code>Selector</code> is a <code>function</code>
that has one input argument (commonly named <code>task</code>). The function is called with the <code>Task</code> that a <code>PipeOp</code>
is operating on. The return value of the function must be a <code>character</code> vector that is a subset of the feature names present
in the <code>Task</code>.
</p>
<p>For example, a <code>Selector</code> that selects all columns is
</p>
<div class="sourceCode r"><pre>function(task) {
  task$feature_names
}
</pre></div>
<p>(this is the <code>selector_all()</code>-<code>Selector</code>.) A <code>Selector</code> that selects
all columns that have names shorter than four letters would be:
</p>
<div class="sourceCode r"><pre>function(task) {
  task$feature_names[
    nchar(task$feature_names) &lt; 4
  ]
}
</pre></div>
<p>A <code>Selector</code> that selects only the column <code>"Sepal.Length"</code> (as in the iris task), if present, is
</p>
<div class="sourceCode r"><pre>function(task) {
  intersect(task$feature_names, "Sepal.Length")
}
</pre></div>
<p>It is preferable to use the <code>Selector</code> construction functions like <code>select_type</code>, <code>select_grep</code> etc. if possible, instead of writing custom <code>Selector</code>s.
</p>


<h3>See Also</h3>

<p>Other Selectors: 
<code>mlr_pipeops_select</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("mlr3")

iris_task = tsk("iris")
bh_task = tsk("boston_housing")

sela = selector_all()
sela(iris_task)
sela(bh_task)

self = selector_type("factor")
self(iris_task)
self(bh_task)

selg = selector_grep("a.*i")
selg(iris_task)
selg(bh_task)

selgi = selector_invert(selg)
selgi(iris_task)
selgi(bh_task)

selgf = selector_union(selg, self)
selgf(iris_task)
selgf(bh_task)
</code></pre>


</div>