<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_pipeops_branch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Path Branching</h2>

<h3>Description</h3>

<p>Perform alternative path branching: <code>PipeOpBranch</code> has multiple output channels
that connect to different paths in a <code>Graph</code>. At any time, only one of these
paths will be taken for execution. At the end of the different paths, the
<code>PipeOpUnbranch</code> <code>PipeOp</code> must be used to indicate the end of alternative paths.
</p>
<p>Not to be confused with <code>PipeOpCopy</code>, the naming scheme is a bit unfortunate.
</p>


<h3>Format</h3>

<p><code>R6Class</code> object inheriting from <code>PipeOp</code>.
</p>


<h3>Construction</h3>

<div class="sourceCode"><pre>PipeOpBranch$new(options, id = "branch", param_vals = list())
</pre></div>

<ul>
<li> <p><code>options</code> :: <code>numeric(1)</code> | <code>character</code><br>
If <code>options</code> is an integer number, it determines the number of
output channels / options that are created, named <code>output1</code>...<code style="white-space: pre;">⁠output&lt;n&gt;⁠</code>. The
<code style="white-space: pre;">⁠$selection⁠</code> parameter will then be an integer.
If <code>options</code> is a <code>character</code>, it determines the names of channels directly.
The <code style="white-space: pre;">⁠$selection⁠</code> parameter will then be factorial.
</p>
</li>
<li> <p><code>id</code> :: <code>character(1)</code><br>
Identifier of resulting object, default <code>"branch"</code>.
</p>
</li>
<li> <p><code>param_vals</code> :: named <code>list</code><br>
List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise be set during construction. Default <code>list()</code>.
</p>
</li>
</ul>
<h3>Input and Output Channels</h3>

<p><code>PipeOpBranch</code> has one input channel named <code>"input"</code>, taking any input (<code>"*"</code>) both during training and prediction.
</p>
<p><code>PipeOpBranch</code> has multiple output channels depending on the <code>options</code> construction argument, named <code>"output1"</code>, <code>"output2"</code>, ...
if <code>options</code> is <code>numeric</code>, and named after each <code>options</code> value if <code>options</code> is a <code>character</code>.
All output channels produce the object given as input (<code>"*"</code>) or <code>NO_OP</code>, both during training and prediction.
</p>


<h3>State</h3>

<p>The <code style="white-space: pre;">⁠$state⁠</code> is left empty (<code>list()</code>).
</p>


<h3>Parameters</h3>


<ul><li> <p><code>selection</code> :: <code>numeric(1)</code> | <code>character(1)</code><br>
Selection of branching path to take. Is a <code>ParamInt</code> if the <code>options</code> parameter
during construction was a <code>numeric(1)</code>, and ranges from 1 to <code>options</code>. Is a
<code>ParamFct</code> if the <code>options</code> parameter was a <code>character</code> and its possible values
are the <code>options</code> values. Initialized to either 1 (if the <code>options</code> construction argument is <code>numeric(1)</code>)
or the first element of <code>options</code> (if it is <code>character</code>).
</p>
</li></ul>
<h3>Internals</h3>

<p>Alternative path branching is handled by the <code>PipeOp</code> backend. To indicate that
a path should not be taken, <code>PipeOpBranch</code> returns the <code>NO_OP</code> object on its
output channel. The <code>PipeOp</code> handles each <code>NO_OP</code> input by automatically
returning a <code>NO_OP</code> output without calling <code>private$.train()</code> or <code>private$.predict()</code>,
until <code>PipeOpUnbranch</code> is reached. <code>PipeOpUnbranch</code> will then take multiple inputs,
all except one of which must be a <code>NO_OP</code>, and forward the only non-<code>NO_OP</code>
object on its output.
</p>


<h3>Fields</h3>

<p>Only fields inherited from <code>PipeOp</code>.
</p>


<h3>Methods</h3>

<p>Only methods inherited from <code>PipeOp</code>.
</p>


<h3>See Also</h3>

<p>https://mlr-org.com/pipeops.html
</p>
<p>Other PipeOps: 
<code>PipeOp</code>,
<code>PipeOpEnsemble</code>,
<code>PipeOpImpute</code>,
<code>PipeOpTargetTrafo</code>,
<code>PipeOpTaskPreproc</code>,
<code>PipeOpTaskPreprocSimple</code>,
<code>mlr_pipeops</code>,
<code>mlr_pipeops_adas</code>,
<code>mlr_pipeops_blsmote</code>,
<code>mlr_pipeops_boxcox</code>,
<code>mlr_pipeops_chunk</code>,
<code>mlr_pipeops_classbalancing</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_classweights</code>,
<code>mlr_pipeops_colapply</code>,
<code>mlr_pipeops_collapsefactors</code>,
<code>mlr_pipeops_colroles</code>,
<code>mlr_pipeops_copy</code>,
<code>mlr_pipeops_datefeatures</code>,
<code>mlr_pipeops_encode</code>,
<code>mlr_pipeops_encodeimpact</code>,
<code>mlr_pipeops_encodelmer</code>,
<code>mlr_pipeops_featureunion</code>,
<code>mlr_pipeops_filter</code>,
<code>mlr_pipeops_fixfactors</code>,
<code>mlr_pipeops_histbin</code>,
<code>mlr_pipeops_ica</code>,
<code>mlr_pipeops_imputeconstant</code>,
<code>mlr_pipeops_imputehist</code>,
<code>mlr_pipeops_imputelearner</code>,
<code>mlr_pipeops_imputemean</code>,
<code>mlr_pipeops_imputemedian</code>,
<code>mlr_pipeops_imputemode</code>,
<code>mlr_pipeops_imputeoor</code>,
<code>mlr_pipeops_imputesample</code>,
<code>mlr_pipeops_kernelpca</code>,
<code>mlr_pipeops_learner</code>,
<code>mlr_pipeops_missind</code>,
<code>mlr_pipeops_modelmatrix</code>,
<code>mlr_pipeops_multiplicityexply</code>,
<code>mlr_pipeops_multiplicityimply</code>,
<code>mlr_pipeops_mutate</code>,
<code>mlr_pipeops_nmf</code>,
<code>mlr_pipeops_nop</code>,
<code>mlr_pipeops_ovrsplit</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_pca</code>,
<code>mlr_pipeops_proxy</code>,
<code>mlr_pipeops_quantilebin</code>,
<code>mlr_pipeops_randomprojection</code>,
<code>mlr_pipeops_randomresponse</code>,
<code>mlr_pipeops_regravg</code>,
<code>mlr_pipeops_removeconstants</code>,
<code>mlr_pipeops_renamecolumns</code>,
<code>mlr_pipeops_replicate</code>,
<code>mlr_pipeops_rowapply</code>,
<code>mlr_pipeops_scale</code>,
<code>mlr_pipeops_scalemaxabs</code>,
<code>mlr_pipeops_scalerange</code>,
<code>mlr_pipeops_select</code>,
<code>mlr_pipeops_smote</code>,
<code>mlr_pipeops_smotenc</code>,
<code>mlr_pipeops_spatialsign</code>,
<code>mlr_pipeops_subsample</code>,
<code>mlr_pipeops_targetinvert</code>,
<code>mlr_pipeops_targetmutate</code>,
<code>mlr_pipeops_targettrafoscalerange</code>,
<code>mlr_pipeops_textvectorizer</code>,
<code>mlr_pipeops_threshold</code>,
<code>mlr_pipeops_tunethreshold</code>,
<code>mlr_pipeops_unbranch</code>,
<code>mlr_pipeops_updatetarget</code>,
<code>mlr_pipeops_vtreat</code>,
<code>mlr_pipeops_yeojohnson</code>
</p>
<p>Other Path Branching: 
<code>NO_OP</code>,
<code>filter_noop()</code>,
<code>is_noop()</code>,
<code>mlr_pipeops_unbranch</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("mlr3")

pca = po("pca")
nop = po("nop")
choices = c("pca", "nothing")
gr = po("branch", choices) %&gt;&gt;%
  gunion(list(pca, nop)) %&gt;&gt;%
  po("unbranch", choices)

gr$param_set$values$branch.selection = "pca"
gr$train(tsk("iris"))

gr$param_set$values$branch.selection = "nothing"
gr$train(tsk("iris"))
</code></pre>


</div>