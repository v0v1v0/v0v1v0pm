<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_pipeops_encode</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Factor Encoding</h2>

<h3>Description</h3>

<p>Encodes columns of type <code>factor</code> and <code>ordered</code>.
</p>
<p>Possible encodings are <code>"one-hot"</code> encoding, as well as encoding according to <code>stats::contr.helmert()</code>, <code>stats::contr.poly()</code>,
<code>stats::contr.sum()</code> and <code>stats::contr.treatment()</code>.
Newly created columns are named via pattern <code style="white-space: pre;">⁠[column-name].[x]⁠</code> where <code>x</code> is the respective factor level for <code>"one-hot"</code> and
<code>"treatment"</code> encoding, and an integer sequence otherwise.
</p>
<p>Use the <code>PipeOpTaskPreproc</code> <code style="white-space: pre;">⁠$affect_columns⁠</code> functionality to only encode a subset of columns, or only encode columns of a certain type.
</p>
<p><code>character</code>-type features can be encoded by converting them <code>factor</code> features first, using <code>ppl("convert_types", "character", "factor")</code>.
</p>


<h3>Format</h3>

<p><code>R6Class</code> object inheriting from <code>PipeOpTaskPreprocSimple</code>/<code>PipeOpTaskPreproc</code>/<code>PipeOp</code>.
</p>


<h3>Construction</h3>

<div class="sourceCode"><pre>PipeOpEncode$new(id = "encode", param_vals = list())
</pre></div>

<ul>
<li> <p><code>id</code> :: <code>character(1)</code><br>
Identifier of resulting object, default <code>"encode"</code>.
</p>
</li>
<li> <p><code>param_vals</code> :: named <code>list</code><br>
List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise be set during construction. Default <code>list()</code>.
</p>
</li>
</ul>
<h3>Input and Output Channels</h3>

<p>Input and output channels are inherited from <code>PipeOpTaskPreproc</code>.
</p>
<p>The output is the input <code>Task</code> with all affected <code>factor</code> and <code>ordered</code> parameters encoded according to the <code>method</code>
parameter.
</p>


<h3>State</h3>

<p>The <code style="white-space: pre;">⁠$state⁠</code> is a named <code>list</code> with the <code style="white-space: pre;">⁠$state⁠</code> elements inherited from <code>PipeOpTaskPreproc</code>, as well as:
</p>

<ul><li> <p><code>constrasts</code> :: named <code>list</code> of <code>matrix</code><br>
List of contrast matrices, one for each affected discrete feature. The rows of each matrix correspond to (training task) levels, the the
columns to the new columns that replace the old discrete feature. See <code>stats::contrasts</code>.
</p>
</li></ul>
<h3>Parameters</h3>

<p>The parameters are the parameters inherited from <code>PipeOpTaskPreproc</code>, as well as:
</p>

<ul><li> <p><code>method</code>  :: <code>character(1)</code> <br>
Initialized to <code>"one-hot"</code>. One of:
</p>

<ul>
<li> <p><code>"one-hot"</code>: create a new column for each factor level.
</p>
</li>
<li> <p><code>"treatment"</code>: create <code class="reqn">n-1</code> columns leaving out the first factor level of each factor variable (see <code>stats::contr.treatment()</code>).
</p>
</li>
<li> <p><code>"helmert"</code>: create columns according to Helmert contrasts (see <code>stats::contr.helmert()</code>).
</p>
</li>
<li> <p><code>"poly"</code>: create columns with contrasts based on orthogonal polynomials (see <code>stats::contr.poly()</code>).
</p>
</li>
<li> <p><code>"sum"</code>: create columns with contrasts summing to zero, (see <code>stats::contr.sum()</code>).
</p>
</li>
</ul>
</li></ul>
<h3>Internals</h3>

<p>Uses the <code>stats::contrasts</code> functions. This is relatively inefficient for features with a large number of levels.
</p>


<h3>Methods</h3>

<p>Only methods inherited from <code>PipeOpTaskPreprocSimple</code>/<code>PipeOpTaskPreproc</code>/<code>PipeOp</code>.
</p>


<h3>See Also</h3>

<p>https://mlr-org.com/pipeops.html
</p>
<p>Other PipeOps: 
<code>PipeOp</code>,
<code>PipeOpEnsemble</code>,
<code>PipeOpImpute</code>,
<code>PipeOpTargetTrafo</code>,
<code>PipeOpTaskPreproc</code>,
<code>PipeOpTaskPreprocSimple</code>,
<code>mlr_pipeops</code>,
<code>mlr_pipeops_adas</code>,
<code>mlr_pipeops_blsmote</code>,
<code>mlr_pipeops_boxcox</code>,
<code>mlr_pipeops_branch</code>,
<code>mlr_pipeops_chunk</code>,
<code>mlr_pipeops_classbalancing</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_classweights</code>,
<code>mlr_pipeops_colapply</code>,
<code>mlr_pipeops_collapsefactors</code>,
<code>mlr_pipeops_colroles</code>,
<code>mlr_pipeops_copy</code>,
<code>mlr_pipeops_datefeatures</code>,
<code>mlr_pipeops_encodeimpact</code>,
<code>mlr_pipeops_encodelmer</code>,
<code>mlr_pipeops_featureunion</code>,
<code>mlr_pipeops_filter</code>,
<code>mlr_pipeops_fixfactors</code>,
<code>mlr_pipeops_histbin</code>,
<code>mlr_pipeops_ica</code>,
<code>mlr_pipeops_imputeconstant</code>,
<code>mlr_pipeops_imputehist</code>,
<code>mlr_pipeops_imputelearner</code>,
<code>mlr_pipeops_imputemean</code>,
<code>mlr_pipeops_imputemedian</code>,
<code>mlr_pipeops_imputemode</code>,
<code>mlr_pipeops_imputeoor</code>,
<code>mlr_pipeops_imputesample</code>,
<code>mlr_pipeops_kernelpca</code>,
<code>mlr_pipeops_learner</code>,
<code>mlr_pipeops_missind</code>,
<code>mlr_pipeops_modelmatrix</code>,
<code>mlr_pipeops_multiplicityexply</code>,
<code>mlr_pipeops_multiplicityimply</code>,
<code>mlr_pipeops_mutate</code>,
<code>mlr_pipeops_nmf</code>,
<code>mlr_pipeops_nop</code>,
<code>mlr_pipeops_ovrsplit</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_pca</code>,
<code>mlr_pipeops_proxy</code>,
<code>mlr_pipeops_quantilebin</code>,
<code>mlr_pipeops_randomprojection</code>,
<code>mlr_pipeops_randomresponse</code>,
<code>mlr_pipeops_regravg</code>,
<code>mlr_pipeops_removeconstants</code>,
<code>mlr_pipeops_renamecolumns</code>,
<code>mlr_pipeops_replicate</code>,
<code>mlr_pipeops_rowapply</code>,
<code>mlr_pipeops_scale</code>,
<code>mlr_pipeops_scalemaxabs</code>,
<code>mlr_pipeops_scalerange</code>,
<code>mlr_pipeops_select</code>,
<code>mlr_pipeops_smote</code>,
<code>mlr_pipeops_smotenc</code>,
<code>mlr_pipeops_spatialsign</code>,
<code>mlr_pipeops_subsample</code>,
<code>mlr_pipeops_targetinvert</code>,
<code>mlr_pipeops_targetmutate</code>,
<code>mlr_pipeops_targettrafoscalerange</code>,
<code>mlr_pipeops_textvectorizer</code>,
<code>mlr_pipeops_threshold</code>,
<code>mlr_pipeops_tunethreshold</code>,
<code>mlr_pipeops_unbranch</code>,
<code>mlr_pipeops_updatetarget</code>,
<code>mlr_pipeops_vtreat</code>,
<code>mlr_pipeops_yeojohnson</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("mlr3")

data = data.table::data.table(x = factor(letters[1:3]), y = factor(letters[1:3]))
task = TaskClassif$new("task", data, "x")

poe = po("encode")

# poe is initialized with encoding: "one-hot"
poe$train(list(task))[[1]]$data()

# other kinds of encoding:
poe$param_set$values$method = "treatment"
poe$train(list(task))[[1]]$data()

poe$param_set$values$method = "helmert"
poe$train(list(task))[[1]]$data()

poe$param_set$values$method = "poly"
poe$train(list(task))[[1]]$data()

poe$param_set$values$method = "sum"
poe$train(list(task))[[1]]$data()

# converting character-columns
data_chr = data.table::data.table(x = factor(letters[1:3]), y = letters[1:3])
task_chr = TaskClassif$new("task_chr", data_chr, "x")

goe = ppl("convert_types", "character", "factor") %&gt;&gt;% po("encode")

goe$train(task_chr)[[1]]$data()
</code></pre>


</div>