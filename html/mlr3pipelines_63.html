<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_pipeops_filter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Feature Filtering</h2>

<h3>Description</h3>

<p>Feature filtering using a <code>mlr3filters::Filter</code> object, see the
<a href="https://CRAN.R-project.org/package=mlr3filters"><span class="pkg">mlr3filters</span></a> package.
</p>
<p>If a <code>Filter</code> can only operate on a subset of columns based on column type, then only these features are considered and filtered.
<code>nfeat</code> and <code>frac</code> will count for the features of the type that the <code>Filter</code> can operate on;
this means e.g. that setting <code>nfeat</code> to 0 will only remove features of the type that the <code>Filter</code> can work with.
</p>


<h3>Format</h3>

<p><code>R6Class</code> object inheriting from <code>PipeOpTaskPreprocSimple</code>/<code>PipeOpTaskPreproc</code>/<code>PipeOp</code>.
</p>


<h3>Construction</h3>

<div class="sourceCode"><pre>PipeOpFilter$new(filter, id = filter$id, param_vals = list())
</pre></div>

<ul>
<li> <p><code>filter</code> :: <code>Filter</code><br><code>Filter</code> used for feature filtering.
This argument is always cloned; to access the <code>Filter</code> inside <code>PipeOpFilter</code> by-reference, use <code style="white-space: pre;">⁠$filter⁠</code>.<br></p>
</li>
<li> <p><code>id</code> :: <code>character(1)</code>
Identifier of the resulting  object, defaulting to the <code>id</code> of the <code>Filter</code> being used.
</p>
</li>
<li> <p><code>param_vals</code> :: named <code>list</code><br>
List of hyperparameter settings, overwriting the hyperparameter settings that would otherwise be set during construction. Default <code>list()</code>.
</p>
</li>
</ul>
<h3>Input and Output Channels</h3>

<p>Input and output channels are inherited from <code>PipeOpTaskPreproc</code>.
</p>
<p>The output is the input <code>Task</code> with features removed that were filtered out.
</p>


<h3>State</h3>

<p>The <code style="white-space: pre;">⁠$state⁠</code> is a named <code>list</code> with the <code style="white-space: pre;">⁠$state⁠</code> elements inherited from <code>PipeOpTaskPreproc</code>, as well as:
</p>

<ul>
<li> <p><code>scores</code> :: named <code>numeric</code><br>
Scores calculated for all features of the training <code>Task</code> which are being used
as cutoff for feature filtering. If <code>frac</code> or <code>nfeat</code> is given, the underlying <code>Filter</code> may choose to not calculate scores for
all features that are given. This only includes features on which the <code>Filter</code> can operate; e.g.
if the <code>Filter</code> can only operate on numeric features, then scores for factorial features will not be given.
</p>
</li>
<li> <p><code>features</code> :: <code>character</code><br>
Names of features that are being kept. Features of types that the <code>Filter</code> can not operate on are always being kept.
</p>
</li>
</ul>
<h3>Parameters</h3>

<p>The parameters are the parameters inherited from the <code>PipeOpTaskPreproc</code>, as well as the parameters of the <code>Filter</code>
used by this object. Besides, parameters introduced are:
</p>

<ul>
<li> <p><code>filter.nfeat</code> :: <code>numeric(1)</code> <br>
Number of features to select.
Mutually exclusive with <code>frac</code>, <code>cutoff</code>, and <code>permuted</code>.
</p>
</li>
<li> <p><code>filter.frac</code> :: <code>numeric(1)</code> <br>
Fraction of features to keep.
Mutually exclusive with <code>nfeat</code>, <code>cutoff</code>, and <code>permuted</code>.
</p>
</li>
<li> <p><code>filter.cutoff</code> :: <code>numeric(1)</code> <br>
Minimum value of filter heuristic for which to keep features.
Mutually exclusive with <code>nfeat</code>, <code>frac</code>, and <code>permuted</code>.
</p>
</li>
<li> <p><code>filter.permuted</code> :: <code>integer(1)</code> <br>
If this parameter is set, a random permutation of each feature is added to the task before
applying the filter. All features selected before the <code>permuted</code>-th permuted features is selected
are kept. This is similar to the approach in Wu (2007) and Thomas (2017).
Mutually exclusive with <code>nfeat</code>, <code>frac</code>, and <code>cutoff</code>.
</p>
</li>
</ul>
<p>Note that at least one of <code>filter.nfeat</code>, <code>filter.frac</code>, <code>filter.cutoff</code>, and <code>filter.permuted</code> must be given.
</p>


<h3>Internals</h3>

<p>This does <em>not</em> use the <code style="white-space: pre;">⁠$.select_cols⁠</code> feature of <code>PipeOpTaskPreproc</code> to select only features compatible with the <code>Filter</code>;
instead the whole <code>Task</code> is used by <code>private$.get_state()</code> and subset internally.
</p>


<h3>Fields</h3>

<p>Fields inherited from <code>PipeOpTaskPreproc</code>, as well as:
</p>

<ul><li> <p><code>filter</code> :: <code>Filter</code><br><code>Filter</code> that is being used for feature filtering. Do <em>not</em> use this slot to get to the feature filtering scores
after training; instead, use <code style="white-space: pre;">⁠$state$scores⁠</code>. Read-only.
</p>
</li></ul>
<h3>Methods</h3>

<p>Methods inherited from <code>PipeOpTaskPreprocSimple</code>/<code>PipeOpTaskPreproc</code>/<code>PipeOp</code>.
</p>


<h3>References</h3>

<p>Wu Y, Boos DD, Stefanski LA (2007).
“Controlling Variable Selection by the Addition of Pseudovariables.”
<em>Journal of the American Statistical Association</em>, <b>102</b>(477), 235–243.
<a href="https://doi.org/10.1198/016214506000000843">doi:10.1198/016214506000000843</a>.
</p>
<p>Thomas J, Hepp T, Mayr A, Bischl B (2017).
“Probing for Sparse and Fast Variable Selection with Model-Based Boosting.”
<em>Computational and Mathematical Methods in Medicine</em>, <b>2017</b>, 1–8.
<a href="https://doi.org/10.1155/2017/1421409">doi:10.1155/2017/1421409</a>.
</p>


<h3>See Also</h3>

<p>https://mlr-org.com/pipeops.html
</p>
<p>Other PipeOps: 
<code>PipeOp</code>,
<code>PipeOpEnsemble</code>,
<code>PipeOpImpute</code>,
<code>PipeOpTargetTrafo</code>,
<code>PipeOpTaskPreproc</code>,
<code>PipeOpTaskPreprocSimple</code>,
<code>mlr_pipeops</code>,
<code>mlr_pipeops_adas</code>,
<code>mlr_pipeops_blsmote</code>,
<code>mlr_pipeops_boxcox</code>,
<code>mlr_pipeops_branch</code>,
<code>mlr_pipeops_chunk</code>,
<code>mlr_pipeops_classbalancing</code>,
<code>mlr_pipeops_classifavg</code>,
<code>mlr_pipeops_classweights</code>,
<code>mlr_pipeops_colapply</code>,
<code>mlr_pipeops_collapsefactors</code>,
<code>mlr_pipeops_colroles</code>,
<code>mlr_pipeops_copy</code>,
<code>mlr_pipeops_datefeatures</code>,
<code>mlr_pipeops_encode</code>,
<code>mlr_pipeops_encodeimpact</code>,
<code>mlr_pipeops_encodelmer</code>,
<code>mlr_pipeops_featureunion</code>,
<code>mlr_pipeops_fixfactors</code>,
<code>mlr_pipeops_histbin</code>,
<code>mlr_pipeops_ica</code>,
<code>mlr_pipeops_imputeconstant</code>,
<code>mlr_pipeops_imputehist</code>,
<code>mlr_pipeops_imputelearner</code>,
<code>mlr_pipeops_imputemean</code>,
<code>mlr_pipeops_imputemedian</code>,
<code>mlr_pipeops_imputemode</code>,
<code>mlr_pipeops_imputeoor</code>,
<code>mlr_pipeops_imputesample</code>,
<code>mlr_pipeops_kernelpca</code>,
<code>mlr_pipeops_learner</code>,
<code>mlr_pipeops_missind</code>,
<code>mlr_pipeops_modelmatrix</code>,
<code>mlr_pipeops_multiplicityexply</code>,
<code>mlr_pipeops_multiplicityimply</code>,
<code>mlr_pipeops_mutate</code>,
<code>mlr_pipeops_nmf</code>,
<code>mlr_pipeops_nop</code>,
<code>mlr_pipeops_ovrsplit</code>,
<code>mlr_pipeops_ovrunite</code>,
<code>mlr_pipeops_pca</code>,
<code>mlr_pipeops_proxy</code>,
<code>mlr_pipeops_quantilebin</code>,
<code>mlr_pipeops_randomprojection</code>,
<code>mlr_pipeops_randomresponse</code>,
<code>mlr_pipeops_regravg</code>,
<code>mlr_pipeops_removeconstants</code>,
<code>mlr_pipeops_renamecolumns</code>,
<code>mlr_pipeops_replicate</code>,
<code>mlr_pipeops_rowapply</code>,
<code>mlr_pipeops_scale</code>,
<code>mlr_pipeops_scalemaxabs</code>,
<code>mlr_pipeops_scalerange</code>,
<code>mlr_pipeops_select</code>,
<code>mlr_pipeops_smote</code>,
<code>mlr_pipeops_smotenc</code>,
<code>mlr_pipeops_spatialsign</code>,
<code>mlr_pipeops_subsample</code>,
<code>mlr_pipeops_targetinvert</code>,
<code>mlr_pipeops_targetmutate</code>,
<code>mlr_pipeops_targettrafoscalerange</code>,
<code>mlr_pipeops_textvectorizer</code>,
<code>mlr_pipeops_threshold</code>,
<code>mlr_pipeops_tunethreshold</code>,
<code>mlr_pipeops_unbranch</code>,
<code>mlr_pipeops_updatetarget</code>,
<code>mlr_pipeops_vtreat</code>,
<code>mlr_pipeops_yeojohnson</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

library("mlr3")
library("mlr3filters")


# setup PipeOpFilter to keep the 5 most important
# features of the spam task w.r.t. their AUC
task = tsk("spam")
filter = flt("auc")
po = po("filter", filter = filter)
po$param_set
po$param_set$values$filter.nfeat = 5

# filter the task
filtered_task = po$train(list(task))[[1]]

# filtered task + extracted AUC scores
filtered_task$feature_names
head(po$state$scores, 10)

# feature selection embedded in a 3-fold cross validation
# keep 30% of features based on their AUC score
task = tsk("spam")
gr = po("filter", filter = flt("auc"), filter.frac = 0.5) %&gt;&gt;%
  po("learner", lrn("classif.rpart"))
learner = GraphLearner$new(gr)
rr = resample(task, learner, rsmp("holdout"), store_models = TRUE)
rr$learners[[1]]$model$auc$scores


</code></pre>


</div>