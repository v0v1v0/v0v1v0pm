<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_resamplings_repeated_spcv_knndm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>(CAST) Repeated K-fold Nearest Neighbour Distance Matching</h2>

<h3>Description</h3>

<p>This function implements the kNNDM algorithm and returns the necessary
indices to perform a k-fold NNDM CV for map validation.
</p>


<h3>Details</h3>

<p>knndm is a k-fold version of NNDM LOO CV for medium and large datasets. Brielfy, the algorithm tries to
find a k-fold configuration such that the integral of the absolute differences (Wasserstein W statistic)
between the empirical nearest neighbour distance distribution function between the test and training data during CV (Gj*),
and the empirical nearest neighbour distance distribution function between the prediction and training points (Gij),
is minimised. It does so by performing clustering of the training points' coordinates for different numbers of
clusters that range from k to N (number of observations), merging them into k final folds,
and selecting the configuration with the lowest W.
</p>
<p>Using a projected CRS in 'knndm' has large computational advantages since fast nearest neighbour search can be
done via the 'FNN' package, while working with geographic coordinates requires computing the full
spherical distance matrices. As a clustering algorithm, 'kmeans' can only be used for
projected CRS while 'hierarchical' can work with both projected and geographical coordinates, though it requires
calculating the full distance matrix of the training points even for a projected CRS.
</p>
<p>In order to select between clustering algorithms and number of folds 'k', different 'knndm' configurations can be run
and compared, being the one with a lower W statistic the one that offers a better match. W statistics between 'knndm'
runs are comparable as long as 'tpoints' and 'predpoints' or 'modeldomain' stay the same.
</p>
<p>Map validation using 'knndm' should be used using 'CAST::global_validation', i.e. by stacking all out-of-sample
predictions and evaluating them all at once. The reasons behind this are 1) The resulting folds can be
unbalanced and 2) nearest neighbour functions are constructed and matched using all CV folds simultaneously.
</p>
<p>If training data points are very clustered with respect to the prediction area and the presented 'knndm'
configuration still show signs of Gj* &gt; Gij, there are several things that can be tried. First, increase
the 'maxp' parameter; this may help to control for strong clustering (at the cost of having unbalanced folds).
Secondly, decrease the number of final folds 'k', which may help to have larger clusters.
</p>
<p>The 'modeldomain' is either a sf polygon that defines the prediction area, or alternatively a SpatRaster out of which a polygon,
transformed into the CRS of the training points, is defined as the outline of all non-NA cells.
Then, the function takes a regular point sample (amount defined by 'samplesize') from the spatial extent.
As an alternative use 'predpoints' instead of 'modeldomain', if you have already defined the prediction locations (e.g. raster pixel centroids).
When using either 'modeldomain' or 'predpoints', we advise to plot the study area polygon and the training/prediction points as a previous step to ensure they are aligned.
</p>
<p>'knndm' can also be performed in the feature space by setting 'space' to "feature".
Euclidean distances or Mahalanobis distances can be used for distance calculation, but only Euclidean are tested.
In this case, nearest neighbour distances are calculated in n-dimensional feature space rather than in geographical space.
'tpoints' and 'predpoints' can be data frames or sf objects containing the values of the features. Note that the names of 'tpoints' and 'predpoints' must be the same.
'predpoints' can also be missing, if 'modeldomain' is of class SpatRaster. In this case, the values of of the SpatRaster will be extracted to the 'predpoints'.
In the case of any categorical features, Gower distances will be used to calculate the Nearest Neighbour distances [Experimental]. If categorical
features are present, and 'clustering' = "kmeans", K-Prototype clustering will be performed instead.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>folds</code> (<code>integer(1)</code>)<br>
Number of folds.
</p>
</li>
<li> <p><code>stratify</code><br>
If <code>TRUE</code>, stratify on the target column.
</p>
</li>
</ul>
<ul><li> <p><code>repeats</code> (<code>integer(1)</code>)<br>
Number of repeats.
</p>
</li></ul>
<h3>Super class</h3>

<p><code>mlr3::Resampling</code> -&gt; <code>ResamplingRepeatedSpCVKnndm</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt>
<dd>
<p><code>integer(1)</code><br>
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingRepeatedSpCVKnndm-new"><code>ResamplingRepeatedSpCVKnndm$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVKnndm-folds"><code>ResamplingRepeatedSpCVKnndm$folds()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVKnndm-repeats"><code>ResamplingRepeatedSpCVKnndm$repeats()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVKnndm-instantiate"><code>ResamplingRepeatedSpCVKnndm$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVKnndm-clone"><code>ResamplingRepeatedSpCVKnndm$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href="../../mlr3/html/Resampling.html#method-Resampling-format"><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href="../../mlr3/html/Resampling.html#method-Resampling-help"><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href="../../mlr3/html/Resampling.html#method-Resampling-print"><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href="../../mlr3/html/Resampling.html#method-Resampling-test_set"><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href="../../mlr3/html/Resampling.html#method-Resampling-train_set"><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul></details><hr>
<a id="method-ResamplingRepeatedSpCVKnndm-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a "K-fold Nearest Neighbour Distance Matching" resampling instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVKnndm$new(id = "repeated_spcv_knndm")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt>
<dd>
<p><code>character(1)</code><br>
Identifier for the resampling strategy.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ResamplingRepeatedSpCVKnndm-folds"></a>



<h4>Method <code>folds()</code>
</h4>

<p>Translates iteration numbers to fold number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVKnndm$folds(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt>
<dd>
<p><code>integer()</code><br>
Iteration number.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ResamplingRepeatedSpCVKnndm-repeats"></a>



<h4>Method <code>repeats()</code>
</h4>

<p>Translates iteration numbers to repetition number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVKnndm$repeats(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt>
<dd>
<p><code>integer()</code><br>
Iteration number.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ResamplingRepeatedSpCVKnndm-instantiate"></a>



<h4>Method <code>instantiate()</code>
</h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVKnndm$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt>
<dd>
<p>Task<br>
A task to instantiate.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ResamplingRepeatedSpCVKnndm-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVKnndm$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>References</h3>

<p>Linnenbrink, J., Mila, C., Ludwig, M., Meyer, H. (2023).
“kNNDM: k-fold Nearest Neighbour Distance Matching Cross-Validation for map accuracy estimation.”
<em>EGUsphere</em>, <b>2023</b>, 1–16.
<a href="https://doi.org/10.5194/egusphere-2023-1308">doi:10.5194/egusphere-2023-1308</a>, <a href="https://egusphere.copernicus.org/preprints/2023/egusphere-2023-1308/">https://egusphere.copernicus.org/preprints/2023/egusphere-2023-1308/</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(mlr3)
library(mlr3spatial)
set.seed(42)
simarea = list(matrix(c(0, 0, 0, 100, 100, 100, 100, 0, 0, 0), ncol = 2, byrow = TRUE))
simarea = sf::st_polygon(simarea)
train_points = sf::st_sample(simarea, 1000, type = "random")
train_points = sf::st_as_sf(train_points)
train_points$target = as.factor(sample(c("TRUE", "FALSE"), 1000, replace = TRUE))
pred_points = sf::st_sample(simarea, 1000, type = "regular")

task = mlr3spatial::as_task_classif_st(sf::st_as_sf(train_points), "target", positive = "TRUE")

cv_knndm = rsmp("repeated_spcv_knndm", predpoints = pred_points, repeats = 2)
cv_knndm$instantiate(task)
#' ### Individual sets:
# cv_knndm$train_set(1)
# cv_knndm$test_set(1)
# check that no obs are in both sets
intersect(cv_knndm$train_set(1), cv_knndm$test_set(1)) # good!

# Internal storage:
# cv_knndm$instance # table
</code></pre>


</div>