<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_resamplings_spcv_tiles</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>(sperrorest) Spatial "Tiles" resampling</h2>

<h3>Description</h3>

<p>Spatial partitioning using rectangular tiles.
Small partitions can optionally be merged into adjacent ones to avoid
partitions with too few observations.
This method is similar to <code>ResamplingSpCVBlock</code> by making use of
rectangular zones in the coordinate space.
See the upstream implementation at <code>sperrorest::partition_disc()</code> and
Brenning (2012) for further information.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>dsplit</code> (<code>integer(2)</code>)<br>
Equidistance of splits in (possibly rotated) x direction (<code>dsplit[1]</code>) and y direction (<code>dsplit[2]</code>) used to define tiles.
If dsplit is of length 1, its value is recycled.
Either <code>dsplit</code> or <code>nsplit</code> must be specified.
</p>
</li>
<li> <p><code>nsplit</code> (<code>integer(2)</code>)<br>
Number of splits in (possibly rotated) x direction (<code>nsplit[1]</code>) and y direction (<code>nsplit[2]</code>) used to define tiles.
If <code>nsplit</code> is of length 1, its value is recycled.
</p>
</li>
<li> <p><code>rotation</code> (<code>character(1)</code>)<br>
Whether and how the rectangular grid should be rotated; random rotation is only possible between -45 and +45 degrees.
Accepted values: One of <code>c("none", "random", "user")</code>.
</p>
</li>
<li> <p><code>user_rotation</code> (<code>character(1)</code>)<br>
Only used when <code>rotation = "user"</code>.
Angle(s) (in degrees) by which the rectangular grid is to be rotated in
each repetition.
Either a vector of same length as <code>repeats</code>, or a single number that
will be replicated <code>length(repeats)</code> times.
</p>
</li>
<li> <p><code>offset</code> (<code>logical(1)</code>)<br>
Whether and how the rectangular grid should be shifted by an offset.
Accepted values: One of <code>c("none", "random", "user")</code>.
</p>
</li>
<li> <p><code>user_offset</code> (<code>logical(1)</code>)<br>
Only used when <code>offset = "user"</code>.
A list (or vector) of two components specifying a shift of the rectangular
grid in (possibly rotated) x and y direction.
The offset values are relative values, a value of 0.5 resulting in a
one-half tile shift towards the left, or upward.
If this is a list, its first (second) component refers to the rotated
x (y) direction, and both components must have same length as <code>repeats</code>
(or length 1).
If a vector of length 2 (or list components have length 1), the two values
will be interpreted as relative shifts in (rotated) x and y direction,
respectively, and will therefore be recycled as needed (<code>length(repeats)</code>
times each).
</p>
</li>
<li> <p><code>reassign</code> (<code>logical(1)</code>)<br>
If <code>TRUE</code>, 'small' tiles (as per <code>min_frac</code> and <code>min_n</code>) are merged with
(smallest) adjacent tiles.
If <code>FALSE</code>, small tiles are 'eliminated', i.e., set to <code>NA.</code>
</p>
</li>
<li> <p><code>min_frac</code> (<code>numeric(1)</code>)<br>
Value must be &gt;=0, &lt;1.
Minimum relative size of partition as percentage of sample.
</p>
</li>
<li> <p><code>min_n</code> (<code>integer(1)</code>)<br>
Minimum number of samples per partition.
</p>
</li>
<li> <p><code>iterate</code> (<code>integer(1)</code>)<br>
Passed down to <code>sperrorest::tile_neighbors()</code>.
</p>
</li>
</ul>
<h3>Super class</h3>

<p><code>mlr3::Resampling</code> -&gt; <code>ResamplingSpCVTiles</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt>
<dd>
<p><code>integer(1)</code><br>
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingSpCVTiles-new"><code>ResamplingSpCVTiles$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVTiles-instantiate"><code>ResamplingSpCVTiles$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVTiles-clone"><code>ResamplingSpCVTiles$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href="../../mlr3/html/Resampling.html#method-Resampling-format"><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href="../../mlr3/html/Resampling.html#method-Resampling-help"><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href="../../mlr3/html/Resampling.html#method-Resampling-print"><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href="../../mlr3/html/Resampling.html#method-Resampling-test_set"><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href="../../mlr3/html/Resampling.html#method-Resampling-train_set"><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul></details><hr>
<a id="method-ResamplingSpCVTiles-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a "Spatial 'Tiles' resampling" resampling instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVTiles$new(id = "spcv_tiles")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt>
<dd>
<p><code>character(1)</code><br>
Identifier for the resampling strategy.
For a list of available arguments, please see
sperrorest::partition_tiles.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ResamplingSpCVTiles-instantiate"></a>



<h4>Method <code>instantiate()</code>
</h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVTiles$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt>
<dd>
<p>Task<br>
A task to instantiate.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ResamplingSpCVTiles-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVTiles$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>References</h3>

<p>Brenning A (2012).
“Spatial cross-validation and bootstrap for the assessment of prediction rules in remote sensing: The R package sperrorest.”
In <em>2012 IEEE International Geoscience and Remote Sensing Symposium</em>.
<a href="https://doi.org/10.1109/igarss.2012.6352393">doi:10.1109/igarss.2012.6352393</a>.
</p>


<h3>See Also</h3>

<p>ResamplingSpCVBlock
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (mlr3misc::require_namespaces("sperrorest", quietly = TRUE)) {
  library(mlr3)
  task = tsk("ecuador")

  # Instantiate Resampling
  rcv = rsmp("spcv_tiles", nsplit = c(4L, 3L), reassign = FALSE)
  rcv$instantiate(task)

  # Individual sets:
  rcv$train_set(1)
  rcv$test_set(1)
  # check that no obs are in both sets
  intersect(rcv$train_set(1), rcv$test_set(1)) # good!

  # Internal storage:
  rcv$instance # table
}
</code></pre>


</div>