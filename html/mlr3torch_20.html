<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_backends_lazy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Lazy Data Backend</h2>

<h3>Description</h3>

<p>This lazy data backend wraps a constructor that lazily creates another backend, e.g. by downloading
(and caching) some data from the internet.
This backend should be used, when some metadata of the backend is known in advance and should be accessible
before downloading the actual data.
When the backend is first constructed, it is verified that the provided metadata was correct, otherwise
an informative error message is thrown.
After the construction of the lazily constructed backend, calls like <code style="white-space: pre;">⁠$data()⁠</code>, <code style="white-space: pre;">⁠$missings()⁠</code>, <code style="white-space: pre;">⁠$distinct()⁠</code>,
or <code style="white-space: pre;">⁠$hash()⁠</code> are redirected to it.
</p>
<p>Information that is available before the backend is constructed is:
</p>

<ul>
<li> <p><code>nrow</code> - The number of rows (set as the length of the <code>rownames</code>).
</p>
</li>
<li> <p><code>ncol</code> - The number of columns (provided via the <code>id</code> column of <code>col_info</code>).
</p>
</li>
<li> <p><code>colnames</code> - The column names.
</p>
</li>
<li> <p><code>rownames</code> - The row names.
</p>
</li>
<li> <p><code>col_info</code> - The column information, which can be obtained via <code>mlr3::col_info()</code>.
</p>
</li>
</ul>
<p>Beware that accessing the backend's hash also contructs the backend.
</p>
<p>Note that while in most cases the data contains <code>lazy_tensor</code> columns, this is not necessary and the naming
of this class has nothing to do with the <code>lazy_tensor</code> data type.
</p>
<p><strong>Important</strong>
</p>
<p>When the constructor generates <code>factor()</code> variables it is important that the ordering of the levels in data
corresponds to the ordering of the levels in the <code>col_info</code> argument.
</p>


<h3>Super class</h3>

<p><code>mlr3::DataBackend</code> -&gt; <code>DataBackendLazy</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>backend</code></dt>
<dd>
<p>(<code>DataBackend</code>)<br>
The wrapped backend that is lazily constructed when first accessed.</p>
</dd>
<dt><code>nrow</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
Number of rows (observations).</p>
</dd>
<dt><code>ncol</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
Number of columns (variables), including the primary key column.</p>
</dd>
<dt><code>rownames</code></dt>
<dd>
<p>(<code>integer()</code>)<br>
Returns vector of all distinct row identifiers, i.e. the contents of the primary key column.</p>
</dd>
<dt><code>colnames</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Returns vector of all column names, including the primary key column.</p>
</dd>
<dt><code>is_constructed</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Whether the backend has already been constructed.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataBackendLazy-new"><code>DataBackendLazy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendLazy-data"><code>DataBackendLazy$data()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendLazy-head"><code>DataBackendLazy$head()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendLazy-distinct"><code>DataBackendLazy$distinct()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendLazy-missings"><code>DataBackendLazy$missings()</code></a>
</p>
</li>
<li> <p><a href="#method-DataBackendLazy-print"><code>DataBackendLazy$print()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="DataBackend" data-id="format"><a href="../../mlr3/html/DataBackend.html#method-DataBackend-format"><code>mlr3::DataBackend$format()</code></a></span></li>
</ul></details><hr>
<a id="method-DataBackendLazy-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates a new instance of this R6 class.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendLazy$new(constructor, rownames, col_info, primary_key, data_formats)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>constructor</code></dt>
<dd>
<p>(<code>function</code>)<br>
A function with argument <code>backend</code> (the lazy backend), whose return value must be the actual backend.
This function is called the first time the field <code style="white-space: pre;">⁠$backend⁠</code> is accessed.</p>
</dd>
<dt><code>rownames</code></dt>
<dd>
<p>(<code>integer()</code>)<br>
The row names. Must be a permutation of the rownames of the lazily constructed backend.</p>
</dd>
<dt><code>col_info</code></dt>
<dd>
<p>(<code>data.table::data.table()</code>)<br>
A data.table with columns <code>id</code>, <code>type</code> and <code>levels</code> containing the column id, type and levels.
Note that the levels must be provided in the correct order.</p>
</dd>
<dt><code>primary_key</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Name of the primary key column.</p>
</dd>
<dt><code>data_formats</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Set of supported data formats. E.g. <code>"data.table"</code>.
These must be a subset of the data formats of the lazily constructed backend.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-DataBackendLazy-data"></a>



<h4>Method <code>data()</code>
</h4>

<p>Returns a slice of the data in the specified format.
The rows must be addressed as vector of primary key values, columns must be referred to via column names.
Queries for rows with no matching row id and queries for columns with no matching column name are silently ignored.
Rows are guaranteed to be returned in the same order as <code>rows</code>, columns may be returned in an arbitrary order.
Duplicated row ids result in duplicated rows, duplicated column names lead to an exception.
</p>
<p>Accessing the data triggers the construction of the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendLazy$data(rows, cols, data_format = "data.table")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt>
<dd>
<p>(<code>integer()</code>)<br>
Row indices.</p>
</dd>
<dt><code>cols</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Column names.</p>
</dd>
<dt><code>data_format</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Desired data format, e.g. <code>"data.table"</code> or <code>"Matrix"</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-DataBackendLazy-head"></a>



<h4>Method <code>head()</code>
</h4>

<p>Retrieve the first <code>n</code> rows.
This triggers the construction of the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendLazy$head(n = 6L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
Number of rows.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>data.table::data.table()</code> of the first <code>n</code> rows.
</p>


<hr>
<a id="method-DataBackendLazy-distinct"></a>



<h4>Method <code>distinct()</code>
</h4>

<p>Returns a named list of vectors of distinct values for each column
specified. If <code>na_rm</code> is <code>TRUE</code>, missing values are removed from the
returned vectors of distinct values. Non-existing rows and columns are
silently ignored.
</p>
<p>This triggers the construction of the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendLazy$distinct(rows, cols, na_rm = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt>
<dd>
<p>(<code>integer()</code>)<br>
Row indices.</p>
</dd>
<dt><code>cols</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Column names.</p>
</dd>
<dt><code>na_rm</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Whether to remove NAs or not.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Named <code>list()</code> of distinct values.
</p>


<hr>
<a id="method-DataBackendLazy-missings"></a>



<h4>Method <code>missings()</code>
</h4>

<p>Returns the number of missing values per column in the specified slice
of data. Non-existing rows and columns are silently ignored.
</p>
<p>This triggers the construction of the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendLazy$missings(rows, cols)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt>
<dd>
<p>(<code>integer()</code>)<br>
Row indices.</p>
</dd>
<dt><code>cols</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Column names.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Total of missing values per column (named <code>numeric()</code>).
</p>


<hr>
<a id="method-DataBackendLazy-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataBackendLazy$print()</pre></div>




<h3>Examples</h3>

<pre><code class="language-R">
# We first define a backend constructor
constructor = function(backend) {
  cat("Data is constructed!\n")
  DataBackendDataTable$new(
    data.table(x = rnorm(10), y = rnorm(10), row_id = 1:10),
    primary_key = "row_id"
  )
}

# to wrap this backend constructor in a lazy backend, we need to provide the correct metadata for it
column_info = data.table(
  id = c("x", "y", "row_id"),
  type = c("numeric", "numeric", "integer"),
  levels = list(NULL, NULL, NULL)
)
backend_lazy = DataBackendLazy$new(
  constructor = constructor,
  rownames = 1:10,
  col_info = column_info,
  data_formats = "data.table",
  primary_key = "row_id"
)

# Note that the constructor is not called for the calls below
# as they can be read from the metadata
backend_lazy$nrow
backend_lazy$rownames
backend_lazy$ncol
backend_lazy$colnames
col_info(backend_lazy)

# Only now the backend is constructed
backend_lazy$data(1, "x")
# Is the same as:
backend_lazy$backend$data(1, "x")

</code></pre>


</div>