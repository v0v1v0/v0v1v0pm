<div class="container">

<table style="width: 100%;"><tr>
<td>DataDescriptor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Data Descriptor</h2>

<h3>Description</h3>

<p>A data descriptor is a rather internal data structure used in the <code>lazy_tensor</code> data type.
In essence it is an annotated <code>torch::dataset</code> and a preprocessing graph (consisting mosty of <code>PipeOpModule</code>
operators). The additional meta data (e.g. pointer, shapes) allows to preprocess <code>lazy_tensor</code>s in an
<code>mlr3pipelines::Graph</code> just like any (non-lazy) data types.
The preprocessing is applied when <code>materialize()</code> is called on the <code>lazy_tensor</code>.
</p>
<p>To create a data descriptor, you can also use the <code>as_data_descriptor()</code> function.
</p>


<h3>Details</h3>

<p>While it would be more natural to define this as an S3 class, we opted for an R6 class to avoid the usual
trouble of serializing S3 objects.
If each row contained a DataDescriptor as an S3 class, this would copy the object when serializing.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>dataset</code></dt>
<dd>
<p>(<code>torch::dataset</code>)<br>
The dataset.</p>
</dd>
<dt><code>graph</code></dt>
<dd>
<p>(<code>Graph</code>)<br>
The preprocessing graph.</p>
</dd>
<dt><code>dataset_shapes</code></dt>
<dd>
<p>(named <code>list()</code> of (<code>integer()</code> or <code>NULL</code>))<br>
The shapes of the output.</p>
</dd>
<dt><code>input_map</code></dt>
<dd>
<p>(<code>character()</code>)<br>
The input map from the dataset to the preprocessing graph.</p>
</dd>
<dt><code>pointer</code></dt>
<dd>
<p>(<code>character(2)</code>)<br>
The output pointer.</p>
</dd>
<dt><code>pointer_shape</code></dt>
<dd>
<p>(<code>integer()</code> | <code>NULL</code>)<br>
The shape of the output indicated by <code>pointer</code>.</p>
</dd>
<dt><code>dataset_hash</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Hash for the wrapped dataset.</p>
</dd>
<dt><code>hash</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
Hash for the data descriptor.</p>
</dd>
<dt><code>graph_input</code></dt>
<dd>
<p>(<code>character()</code>)<br>
The input channels of the preprocessing graph (cached to save time).</p>
</dd>
<dt><code>pointer_shape_predict</code></dt>
<dd>
<p>(<code>integer()</code> or <code>NULL</code>)<br>
Internal use only.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataDescriptor-new"><code>DataDescriptor$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DataDescriptor-print"><code>DataDescriptor$print()</code></a>
</p>
</li>
<li> <p><a href="#method-DataDescriptor-clone"><code>DataDescriptor$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-DataDescriptor-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates a new instance of this R6 class.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataDescriptor$new(
  dataset,
  dataset_shapes = NULL,
  graph = NULL,
  input_map = NULL,
  pointer = NULL,
  pointer_shape = NULL,
  pointer_shape_predict = NULL,
  clone_graph = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt>
<dd>
<p>(<code>torch::dataset</code>)<br>
The torch dataset.
It should return a named <code>list()</code> of <code>torch_tensor</code> objects.</p>
</dd>
<dt><code>dataset_shapes</code></dt>
<dd>
<p>(named <code>list()</code> of (<code>integer()</code> or <code>NULL</code>))<br>
The shapes of the output.
Names are the elements of the list returned by the dataset.
If the shape is not <code>NULL</code> (unknown, e.g. for images of different sizes) the first dimension must be <code>NA</code> to
indicate the batch dimension.</p>
</dd>
<dt><code>graph</code></dt>
<dd>
<p>(<code>Graph</code>)<br>
The preprocessing graph.
If left <code>NULL</code>, no preprocessing is applied to the data and <code>input_map</code>, <code>pointer</code>, <code>pointer_shape</code>, and
<code>pointer_shape_predict</code> are inferred in case the dataset returns only one element.</p>
</dd>
<dt><code>input_map</code></dt>
<dd>
<p>(<code>character()</code>)<br>
Character vector that must have the same length as the input of the graph.
Specifies how the data from the <code>dataset</code> is fed into the preprocessing graph.</p>
</dd>
<dt><code>pointer</code></dt>
<dd>
<p>(<code>character(2)</code> | <code>NULL</code>)<br>
Points to an output channel within <code>graph</code>:
Element 1 is the <code>PipeOp</code>'s id and element 2 is that <code>PipeOp</code>'s output channel.</p>
</dd>
<dt><code>pointer_shape</code></dt>
<dd>
<p>(<code>integer()</code> | <code>NULL</code>)<br>
Shape of the output indicated by <code>pointer</code>.</p>
</dd>
<dt><code>pointer_shape_predict</code></dt>
<dd>
<p>(<code>integer()</code> or <code>NULL</code>)<br>
Internal use only.
Used in a <code>Graph</code> to anticipate possible mismatches between train and predict shapes.</p>
</dd>
<dt><code>clone_graph</code></dt>
<dd>
<p>(<code>logical(1)</code>)<br>
Whether to clone the preprocessing graph.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-DataDescriptor-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Prints the object
</p>


<h5>Usage</h5>

<div class="r"><pre>DataDescriptor$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>(any)<br>
Unused</p>
</dd>
</dl>
</div>


<hr>
<a id="method-DataDescriptor-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataDescriptor$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>ModelDescriptor, lazy_tensor
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Create a dataset
ds = dataset(
  initialize = function() self$x = torch_randn(10, 3, 3),
  .getitem = function(i) list(x = self$x[i, ]),
  .length = function() nrow(self$x)
)()
dd = DataDescriptor$new(ds, list(x = c(NA, 3, 3)))
dd
# is the same as using the converter:
as_data_descriptor(ds, list(x = c(NA, 3, 3)))

</code></pre>


</div>