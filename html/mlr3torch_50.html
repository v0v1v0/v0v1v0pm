<div class="container">

<table style="width: 100%;"><tr>
<td>mlr_learners_torch_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Learner Torch Model</h2>

<h3>Description</h3>

<p>Create a torch learner from an instantiated <code>nn_module()</code>.
For classification, the output of the network must be the scores (before the softmax).
</p>


<h3>Parameters</h3>

<p>See <code>LearnerTorch</code>
</p>


<h3>Super classes</h3>

<p><code>mlr3::Learner</code> -&gt; <code>mlr3torch::LearnerTorch</code> -&gt; <code>LearnerTorchModel</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>network_stored</code></dt>
<dd>
<p>(<code>nn_module</code> or <code>NULL</code>)<br>
The network that will be trained.
After calling <code style="white-space: pre;">⁠$train()⁠</code>, this is <code>NULL</code>.</p>
</dd>
<dt><code>ingress_tokens</code></dt>
<dd>
<p>(named <code>list()</code> with <code>TorchIngressToken</code> or <code>NULL</code>)<br>
The ingress tokens. Must be non-<code>NULL</code> when calling <code style="white-space: pre;">⁠$train()⁠</code>.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LearnerTorchModel-new"><code>LearnerTorchModel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LearnerTorchModel-clone"><code>LearnerTorchModel$clone()</code></a>
</p>
</li>
</ul>
<details><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="base_learner"><a href="../../mlr3/html/Learner.html#method-Learner-base_learner"><code>mlr3::Learner$base_learner()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="help"><a href="../../mlr3/html/Learner.html#method-Learner-help"><code>mlr3::Learner$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="predict"><a href="../../mlr3/html/Learner.html#method-Learner-predict"><code>mlr3::Learner$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="predict_newdata"><a href="../../mlr3/html/Learner.html#method-Learner-predict_newdata"><code>mlr3::Learner$predict_newdata()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="reset"><a href="../../mlr3/html/Learner.html#method-Learner-reset"><code>mlr3::Learner$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="train"><a href="../../mlr3/html/Learner.html#method-Learner-train"><code>mlr3::Learner$train()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3torch" data-topic="LearnerTorch" data-id="dataset"><a href="../../mlr3torch/html/LearnerTorch.html#method-LearnerTorch-dataset"><code>mlr3torch::LearnerTorch$dataset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3torch" data-topic="LearnerTorch" data-id="format"><a href="../../mlr3torch/html/LearnerTorch.html#method-LearnerTorch-format"><code>mlr3torch::LearnerTorch$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3torch" data-topic="LearnerTorch" data-id="marshal"><a href="../../mlr3torch/html/LearnerTorch.html#method-LearnerTorch-marshal"><code>mlr3torch::LearnerTorch$marshal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3torch" data-topic="LearnerTorch" data-id="print"><a href="../../mlr3torch/html/LearnerTorch.html#method-LearnerTorch-print"><code>mlr3torch::LearnerTorch$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3torch" data-topic="LearnerTorch" data-id="unmarshal"><a href="../../mlr3torch/html/LearnerTorch.html#method-LearnerTorch-unmarshal"><code>mlr3torch::LearnerTorch$unmarshal()</code></a></span></li>
</ul></details><hr>
<a id="method-LearnerTorchModel-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates a new instance of this R6 class.
</p>


<h5>Usage</h5>

<div class="r"><pre>LearnerTorchModel$new(
  network = NULL,
  ingress_tokens = NULL,
  task_type,
  properties = NULL,
  optimizer = NULL,
  loss = NULL,
  callbacks = list(),
  packages = character(0),
  feature_types = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>network</code></dt>
<dd>
<p>(<code>nn_module</code>)<br>
An instantiated <code>nn_module</code>. Is not cloned during construction.
For classification, outputs must be the scores (before the softmax).</p>
</dd>
<dt><code>ingress_tokens</code></dt>
<dd>
<p>(<code>list</code> of <code>TorchIngressToken()</code>)<br>
A list with ingress tokens that defines how the dataloader will be defined.</p>
</dd>
<dt><code>task_type</code></dt>
<dd>
<p>(<code>character(1)</code>)<br>
The task type.</p>
</dd>
<dt><code>properties</code></dt>
<dd>
<p>(<code>NULL</code> or <code>character()</code>)<br>
The properties of the learner.
Defaults to all available properties for the given task type.</p>
</dd>
<dt><code>optimizer</code></dt>
<dd>
<p>(<code>TorchOptimizer</code>)<br>
The torch optimizer.</p>
</dd>
<dt><code>loss</code></dt>
<dd>
<p>(<code>TorchLoss</code>)<br>
The loss to use for training.</p>
</dd>
<dt><code>callbacks</code></dt>
<dd>
<p>(<code>list()</code> of <code>TorchCallback</code>s)<br>
The callbacks used during training.
Must have unique ids.
They are executed in the order in which they are provided</p>
</dd>
<dt><code>packages</code></dt>
<dd>
<p>(<code>character()</code>)<br>
The R packages this object depends on.</p>
</dd>
<dt><code>feature_types</code></dt>
<dd>
<p>(<code>NULL</code> or <code>character()</code>)<br>
The feature types. Defaults to all available feature types.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-LearnerTorchModel-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LearnerTorchModel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>Other Learner: 
<code>mlr_learners.mlp</code>,
<code>mlr_learners.tab_resnet</code>,
<code>mlr_learners.torch_featureless</code>,
<code>mlr_learners_torch</code>,
<code>mlr_learners_torch_image</code>
</p>
<p>Other Graph Network: 
<code>ModelDescriptor()</code>,
<code>TorchIngressToken()</code>,
<code>mlr_pipeops_module</code>,
<code>mlr_pipeops_torch</code>,
<code>mlr_pipeops_torch_ingress</code>,
<code>mlr_pipeops_torch_ingress_categ</code>,
<code>mlr_pipeops_torch_ingress_ltnsr</code>,
<code>mlr_pipeops_torch_ingress_num</code>,
<code>model_descriptor_to_learner()</code>,
<code>model_descriptor_to_module()</code>,
<code>model_descriptor_union()</code>,
<code>nn_graph()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# We show the learner using a classification task

# The iris task has 4 features and 3 classes
network = nn_linear(4, 3)
task = tsk("iris")

# This defines the dataloader.
# It loads all 4 features, which are also numeric.
# The shape is (NA, 4) because the batch dimension is generally NA
ingress_tokens = list(
  input = TorchIngressToken(task$feature_names, batchgetter_num, c(NA, 4))
)

# Creating the learner and setting required parameters
learner = lrn("classif.torch_model",
  network = network,
  ingress_tokens = ingress_tokens,
  batch_size = 16,
  epochs = 1,
  device = "cpu"
)

# A simple train-predict
ids = partition(task)
learner$train(task, ids$train)
learner$predict(task, ids$test)

</code></pre>


</div>