<div class="container">

<table style="width: 100%;"><tr>
<td>tune_nested</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for Nested Resampling</h2>

<h3>Description</h3>

<p>Function to conduct nested resampling.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tune_nested(
  tuner,
  task,
  learner,
  inner_resampling,
  outer_resampling,
  measure = NULL,
  term_evals = NULL,
  term_time = NULL,
  terminator = NULL,
  search_space = NULL,
  store_tuning_instance = TRUE,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  check_values = FALSE,
  callbacks = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tuner</code></td>
<td>
<p>(Tuner)<br>
Optimization algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>task</code></td>
<td>
<p>(mlr3::Task)<br>
Task to operate on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>(mlr3::Learner)<br>
Learner to tune.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inner_resampling</code></td>
<td>
<p>(mlr3::Resampling)<br>
Resampling used for the inner loop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outer_resampling</code></td>
<td>
<p>mlr3::Resampling)<br>
Resampling used for the outer loop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measure</code></td>
<td>
<p>(mlr3::Measure)<br>
Measure to optimize. If <code>NULL</code>, default measure is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term_evals</code></td>
<td>
<p>(<code>integer(1)</code>)<br>
Number of allowed evaluations.
Ignored if <code>terminator</code> is passed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term_time</code></td>
<td>
<p>(<code>integer(1)</code>)<br>
Maximum allowed time in seconds.
Ignored if <code>terminator</code> is passed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminator</code></td>
<td>
<p>(bbotk::Terminator)<br>
Stop criterion of the tuning process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>search_space</code></td>
<td>
<p>(paradox::ParamSet)<br>
Hyperparameter search space. If <code>NULL</code> (default), the search space is
constructed from the paradox::TuneToken of the learner's parameter set
(learner$param_set).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store_tuning_instance</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
If <code>TRUE</code> (default), stores the internally created TuningInstanceBatchSingleCrit with all intermediate results in slot <code style="white-space: pre;">⁠$tuning_instance⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store_benchmark_result</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
If <code>TRUE</code> (default), store resample result of evaluated hyperparameter
configurations in archive as mlr3::BenchmarkResult.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store_models</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
If <code>TRUE</code>, fitted models are stored in the benchmark result
(<code>archive$benchmark_result</code>). If <code>store_benchmark_result = FALSE</code>, models
are only stored temporarily and not accessible after the tuning. This
combination is needed for measures that require a model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_values</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
If <code>TRUE</code>, hyperparameter values are checked before evaluation and
performance scores after. If <code>FALSE</code> (default), values are unchecked but
computational overhead is reduced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>callbacks</code></td>
<td>
<p>(list of mlr3misc::Callback)<br>
List of callbacks.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>mlr3::ResampleResult
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Nested resampling on Palmer Penguins data set
rr = tune_nested(
  tuner = tnr("random_search", batch_size = 2),
  task = tsk("penguins"),
  learner = lrn("classif.rpart", cp = to_tune(1e-04, 1e-1, logscale = TRUE)),
  inner_resampling = rsmp ("holdout"),
  outer_resampling = rsmp("cv", folds = 2),
  measure = msr("classif.ce"),
  term_evals = 2)

# Performance scores estimated on the outer resampling
rr$score()

# Unbiased performance of the final model trained on the full data set
rr$aggregate()
</code></pre>


</div>