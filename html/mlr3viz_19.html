<div class="container">

<table style="width: 100%;"><tr>
<td>autoplot.OptimInstanceBatchSingleCrit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plots for Optimization Instances</h2>

<h3>Description</h3>

<p>Visualizations for bbotk::OptimInstanceBatchSingleCrit.
The argument <code>type</code> controls what kind of plot is drawn.
Possible choices are:
</p>

<ul>
<li> <p><code>"marginal"</code> (default): Scatter plots of x versus y.
The color of the points shows the batch number.
</p>
</li>
<li> <p><code>"performance"</code>: Scatter plots of batch number versus y
</p>
</li>
<li> <p><code>"parameter"</code>: Scatter plots of batch number versus input.
The color of the points shows the y values.
</p>
</li>
<li> <p><code>"parallel"</code>: Parallel coordinates plot.
x values are rescaled by <code>(x - mean(x)) / sd(x)</code>.
</p>
</li>
<li> <p><code>"points"</code>: Scatter plot of two x dimensions versus.
The color of the points shows the y values.
</p>
</li>
<li> <p><code>"surface"</code>: Surface plot of two x dimensions versus y values.
The y values are interpolated with the supplied mlr3::Learner.
</p>
</li>
<li> <p><code>"pairs"</code>: Plots all x and y values against each other.
</p>
</li>
<li> <p><code>"incumbent"</code>: Plots the incumbent versus the number of configurations.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'OptimInstanceBatchSingleCrit'
autoplot(
  object,
  type = "marginal",
  cols_x = NULL,
  trafo = FALSE,
  learner = mlr3::lrn("regr.ranger"),
  grid_resolution = 100,
  batch = NULL,
  theme = theme_minimal(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>(bbotk::OptimInstanceBatchSingleCrit).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>(character(1)):<br>
Type of the plot. See description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols_x</code></td>
<td>
<p>(<code>character()</code>)<br>
Column names of x values.
By default, all untransformed x values from the search space are plotted.
Transformed hyperparameters are prefixed with <code>x_domain_</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trafo</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
If <code>FALSE</code> (default), the untransformed x values are plotted.
If <code>TRUE</code>, the transformed x values are plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>(mlr3::Learner)<br>
Regression learner used to interpolate the data of the surface plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_resolution</code></td>
<td>
<p>(<code>numeric()</code>)<br>
Resolution of the surface plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch</code></td>
<td>
<p>(<code>integer()</code>)<br>
The batch number(s) to limit the plot to.
The default is all batches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theme</code></td>
<td>
<p>(<code>ggplot2::theme()</code>)<br>
The <code>ggplot2::theme_minimal()</code> is applied by default to all plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(ignored).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>ggplot2::ggplot()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (requireNamespace("mlr3") &amp;&amp; requireNamespace("bbotk") &amp;&amp; requireNamespace("patchwork")) {
  library(bbotk)
  library(paradox)

  fun = function(xs) {
    c(y = -(xs[[1]] - 2)^2 - (xs[[2]] + 3)^2 + 10)
  }
  domain = ps(
    x1 = p_dbl(-10, 10),
    x2 = p_dbl(-5, 5)
  )
  codomain = ps(
    y = p_dbl(tags = "maximize")
  )
  obfun = ObjectiveRFun$new(
    fun = fun,
    domain = domain,
    codomain = codomain
  )

  instance = oi(objective = obfun, terminator = trm("evals", n_evals = 20))

  optimizer = opt("random_search", batch_size = 2)
  optimizer$optimize(instance)

  # plot y versus batch number
  print(autoplot(instance, type = "performance"))

  # plot x1 values versus performance
  print(autoplot(instance, type = "marginal", cols_x = "x1"))

  # plot parallel coordinates plot
  print(autoplot(instance, type = "parallel"))

  # plot pairs
  print(autoplot(instance, type = "pairs"))

  # plot incumbent
  print(autoplot(instance, type = "incumbent"))
}
</code></pre>


</div>