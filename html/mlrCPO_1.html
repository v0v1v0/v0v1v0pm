<div class="container">

<table style="width: 100%;"><tr>
<td>mlrCPO-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Composable Preprocessing Operators</h2>

<h3>Description</h3>

<p><b>mlrCPO</b> is a toolset that enriches <code>mlr</code> with a diverse set of preprocessing operators.
Composable Preprocessing Operators (“CPO”s) are first-class R objects that can be applied to
<code>data.frame</code>s and <code>mlr</code> <code>Task</code>s to modify data, they can be attached to <code>mlr</code>
<code>Learner</code>s to add preprocessing to machine learning algorithms, and they can be composed to form
preprocessing pipelines.
</p>
<p><code>mlrCPO</code> focuses on preprocessing as part of automated machine learning pipelines. This means that
it is designed with the expectation that the same preprocessing options are applied to incoming training data,
and test data. A common mistake in machine learning is that a machine learning method is evaluated (e.g. using
resampling) on a dataset <em>after</em> that dataset has been cleaned up and preprocessed in one go. The proper evaluation
would need to consider that the preprocessing of training data may not be influenced by any information contained
in the test data set. <code>mlrCPO</code> takes this duality into account by providing <code>CPO</code> objects that
run on training data, and which then create <code>CPOTrained</code> objects that can be used on test data (or entirely new
prediction data).
</p>
<p>This focus on preprocessing is the reason for a strict separation between “Feature Operation” <code>CPO</code>s,
“Target Operation” <code>CPO</code>s, and “Retrafoless” <code>CPO</code>s (see OperatingType).
The first class only changes
(predictor) features of a dataset, and does so in a way reproducible on test data. The second class only changes
(outcome) target data of a dataset, and is then able to <code>invert</code> the prediction, made by a learner
on new data, back to the space of the original target data. The “Retrafoless” <code>CPO</code> only operates
during training and may only add or subtract data rows (e.g. for SMOTE-ing or subsampling), without transforming
the space of either predictor or outcome variables.
</p>
<p><code>CPO</code>'s design is supposed to help its user avoid bugs and errors. Therefore it often avoids doing things
implicitly and relies on explicit commands e.g. for removing data or converting between datatypes. It has certain
restrictions in place (e.g. CPOProperties, CPOTrainedCapability) that try to make it hard to do the
wrong thing while not being in the way of the right thing.
</p>
<p>Other packages with similar, partially overlapping functionality are <a href="https://cran.r-project.org/package=recipes">recipes</a>,
<a href="https://cran.r-project.org/package=dplyr">dplyr</a>, and <a href="https://cran.r-project.org/package=caret">caret</a>.
</p>


</div>