<div class="container">

<table style="width: 100%;"><tr>
<td>%&gt;&gt;%</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>CPO Composition / Attachment / Application Operator</h2>

<h3>Description</h3>

<p>This operator “pipes” data from the source into the sink object.
</p>
<p>If both objects are a <code>CPO</code> object, or both are a <code>CPOTrained</code> object,
they will be composed. A new object, representing the operation of performing both object's operations in succession,
will be created, which can be handled like a new CPO or CPOTrained object. See <code>composeCPO</code>.
</p>
<p>If the source object is a <code>data.frame</code> or a <code>link[mlr]{Task}</code>, the
transformation operation will be applied to this data, and the same resulting
data will be returned. See <code>applyCPO</code>.
</p>
<p>If the sink object is a <code>Learner</code>, the CPO will be attached to
this learner. The same operation will be performed during the <code>train</code> and
<code>predict</code> phase; the behaviour during the predict phase may furthermore
be depend on the training data. See <code>attachCPO</code>.
</p>
<p>Note that you can not link a <code>data.frame</code> or <code>Task</code> directly
to a <code>Learner</code>, since this operation is not algebraically associative
with the composition of CPOs. Use <code>train</code> for this.
</p>
<p>The <code>%&lt;&lt;%</code> operator is synonymous with <code>%&gt;&gt;%</code> with source and sink argument swapped.
</p>
<p>The <code>%&gt;|%</code> and <code>%|&lt;%</code> operators perform piping followed by application of <code>retrafo</code>.
The <code>%&gt;|%</code> evaluates the expression to its right before the expression to its left, so it may be
used in the most natural way without parentheses:
</p>
<p><code>data %&gt;|% cpo1 %&gt;&gt;% cpo2</code>
</p>
<p>is the same as
</p>
<p><code>retrafo(data %&gt;&gt;% cpo1 %&gt;&gt;% cpo2)</code>.
</p>
<p>The <code>%&lt;&gt;&gt;%</code> and <code>%&lt;&lt;&lt;%</code> operators perform the piping operation and assign the result
to the left hand variable. This way it is possible to apply a <code>CPO</code>, or to
attach a <code>CPO</code> to a <code>Learner</code>, and just keep the resulting
object. The assignment operators evaluate their right hand side before their left hand side, so
it is possible to build long chains that end up writing to the leftmost variable. Therefore the expression
</p>
<p><code>data %&lt;&gt;&gt;% cpo1 %&lt;&gt;&gt;% cpo2 %&gt;&gt;% cpo3</code>
</p>
<p>is the same as
</p>
<pre>cpo1 = cpo1 %&gt;&gt;% cpo2 %&gt;&gt;% cpo3
data = data %&gt;&gt;% cpo1</pre>


<h3>Usage</h3>

<pre><code class="language-R">cpo1 %&gt;&gt;% cpo2

cpo2 %&lt;&lt;% cpo1

cpo1 %&lt;&gt;&gt;% cpo2

cpo2 %&lt;&lt;&lt;% cpo1

cpo1 %&gt;|% cpo2

cpo2 %|&lt;% cpo1
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cpo1</code></td>
<td>
<p>[<code>data.frame</code> | <code>Task</code> | <code>CPO</code> | <code>CPOTrained</code>]<br>
The source object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpo2</code></td>
<td>
<p>[<code>CPO</code> | <code>CPOTrained</code> | <code>Learner</code>]<br>
The sink object.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>[<code>data.frame</code> | <code>Task</code> | <code>CPO</code> | <code>CPOTrained</code>].
</p>


<h3>See Also</h3>

<p>Other operators: 
<code>CPO</code>,
<code>applyCPO()</code>,
<code>as.list.CPO</code>,
<code>attachCPO()</code>,
<code>composeCPO()</code>,
<code>pipeCPO()</code>
</p>
<p>Other retrafo related: 
<code>CPOTrained</code>,
<code>NULLCPO</code>,
<code>applyCPO()</code>,
<code>as.list.CPO</code>,
<code>clearRI()</code>,
<code>getCPOClass()</code>,
<code>getCPOName()</code>,
<code>getCPOOperatingType()</code>,
<code>getCPOPredictType()</code>,
<code>getCPOProperties()</code>,
<code>getCPOTrainedCPO()</code>,
<code>getCPOTrainedCapability()</code>,
<code>getCPOTrainedState()</code>,
<code>is.retrafo()</code>,
<code>makeCPOTrainedFromState()</code>,
<code>pipeCPO()</code>,
<code>print.CPOConstructor()</code>
</p>
<p>Other inverter related: 
<code>CPOTrained</code>,
<code>NULLCPO</code>,
<code>applyCPO()</code>,
<code>as.list.CPO</code>,
<code>clearRI()</code>,
<code>getCPOClass()</code>,
<code>getCPOName()</code>,
<code>getCPOOperatingType()</code>,
<code>getCPOPredictType()</code>,
<code>getCPOProperties()</code>,
<code>getCPOTrainedCPO()</code>,
<code>getCPOTrainedCapability()</code>,
<code>getCPOTrainedState()</code>,
<code>is.inverter()</code>,
<code>makeCPOTrainedFromState()</code>,
<code>pipeCPO()</code>,
<code>print.CPOConstructor()</code>
</p>
<p>Other CPO lifecycle related: 
<code>CPOConstructor</code>,
<code>CPOLearner</code>,
<code>CPOTrained</code>,
<code>CPO</code>,
<code>NULLCPO</code>,
<code>attachCPO()</code>,
<code>composeCPO()</code>,
<code>getCPOClass()</code>,
<code>getCPOConstructor()</code>,
<code>getCPOTrainedCPO()</code>,
<code>identicalCPO()</code>,
<code>makeCPO()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># PCA-rotate pid.task
rotated.pid.task = pid.task %&gt;&gt;% cpoScale() %&gt;&gt;% cpoPca()

# Centering / Scaling *after* PCA
newPCA = cpoPca() %&gt;&gt;% cpoScale()

# Attach the above to learner
pcaLogreg = newPCA %&gt;&gt;% makeLearner("classif.logreg")

# append cpoAsNumeric to newPCA
newPCA %&lt;&gt;&gt;% cpoAsNumeric()
print(newPCA)

# prepend cpoAsNumeric to pcaLogreg
pcaLogreg %&lt;&lt;&lt;% cpoAsNumeric()

</code></pre>


</div>