<div class="container">

<table style="width: 100%;"><tr>
<td>error_handling</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Error handling for mlrMBO</h2>

<h3>Description</h3>

<p>There are multiple types of errors that can occur during one optimization
process. mlrMBO tries to handle most of them as smart as possible.
</p>
<p>The target function could
</p>

<ul>
<li>
<p>1The target function returns NA(s) or NaN(s) (plural for the multi-objective case).
</p>
</li>
<li>
<p>2The target function stops with an error.
</p>
</li>
<li>
<p>3The target function does not return at all (infinite or very long execution time).
</p>
</li>
<li>
<p>4The target function crashes the whole R process.
</p>
</li>
<li>
<p>5The surrogate machine learning model might crash.
Kriging quite often can run into numerical problems.
</p>
</li>
<li>
<p>6The proposal mechanism - in multi-point or single point mode - produces
a point which is either close to another candidate point in the same iteration or
an already visited point in a previous iteration.
</p>
</li>
<li>
<p>7The mbo process exits / stops / crashes itself. Maybe because it hit a walltime.
</p>
</li>
</ul>
<p><strong>Mechanism I - Objective value imputation</strong>
Issues 1-4 all have in common that the optimizer does not obtain a useful
objective value. 3-4 are problematic, because we completely lose control of the R process.
We are currently only able to handle them, if you are parallelizing your optimization
via <code>parallelMap</code> and use the BatchJobs mode.
In this case, you can specify a walltime (handles 3) and the function evaluation is performed
in a separate R process (handles 4). A later path might be to allow function evaluation in
a separate process in general, with a capping time. If you really need this now, you can always
do this yourself.
</p>
<p>Now back to the problem of invalid objective values. By default, the mbo function stops with an error
(if it still has control of the process). But in many cases you still want the algorithm to continue.
Hence, mbo allows imputation of bad values via the control option <code>impute.y.fun</code>.
</p>
<p><strong>Logging:</strong> All error messages are logged into the optimization path <code>opt.path</code> if problems occur.
</p>
<p><strong>Mechanism II - The mlr's on.learner.error</strong>
If your surrogate learner crashes you can set <code>on.surrogate.error</code> in <code>makeMBOControl</code> to “quiet” or “warn”.
This will set mlr's <code>on.learner.error</code> for the surrogate.
It prevents MBO from crashing in total (issue 5), if the surrogate learner produces an error.
As a resort a FailureModel will be returned instead of a the surrogate.
Subsequently a random point (or multiple ones) are proposed now for the current iteration.
And we pray that we can fit the model again in the next iteration.
<strong>Logging:</strong> The entry “model.error” is set in the <code>opt.path</code>.
</p>
<p><strong>Mechanism III - Filtering of proposed point which are too close</strong>
</p>
<p>Issue 6 is solved by filtering points that are to close to other proposed points or points already
proposed in preceding iterations. Filtering in this context means replacing the proposed points by
a randomly generated new point. The heuristics mechanism is (de)activated via the logical
<code>filter.proposed.points.tol</code> parameter of the <code>setMBOControlInfill</code> function, which defaults to
<code>TRUE</code>.(closeness of two points is determined via the <code>filter.proposed.points.tol</code> parameter).
</p>
<p><strong>Logging:</strong> The logical entry “filtered.point” is set in the opt.path indicating whether the
corresponding point was filtered.
</p>
<p><strong>Mechanism IV - Continue optimization process</strong>
</p>
<p>The mechanism is a save-state-then-continue-mechanism, that allows you to continue
your optimization after your system or the optimization process crashed for
some reason (issue 7). The <code>mbo</code> function has the option to save the
current state after certain iterations of the main loop on disk via the control
option <code>save.on.disk.at</code> of <code>makeMBOControl</code>.
Note that this saving mechanism is <em>disabled</em> by default.
Here you can specify, after which iteration you want the current state to be
saved (option <code>save.on.disk.at</code>). Notice that 0 denotes saving the initial
design and <code>iters</code> + 1 denotes saving the final results.
With <code>mboContinue</code> you can continue the optimization from the last
saved state. This function only requires the path of the saved state.
</p>
<p>You will get a warning if you turn on saving in general, but not for the the final result, as
this seems a bit stupid. <code>save.file.path</code> defines the path of the RData file where
the state is stored. It is overwritten (= extended) in each saving iteration.
</p>


</div>