<div class="container">

<table style="width: 100%;"><tr>
<td>mbo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimizes a function with sequential model based optimization.</h2>

<h3>Description</h3>

<p>See mbo_parallel for all parallelization options.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mbo(
  fun,
  design = NULL,
  learner = NULL,
  control = NULL,
  show.info = getOption("mlrMBO.show.info", TRUE),
  more.args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>[<code>smoof_function</code>]<br>
Fitness function to optimize.
For one dimensional target functions you can obtain a <code>smoof_function</code> by using <code>makeSingleObjectiveFunction</code>.
For multi dimensional functions use <code>makeMultiObjectiveFunction</code>.
It is possible to return even more information which will be stored
in the optimization path. To achieve this, simply append the attribute “extras”
to the return value of the target function. This has to be a named list of scalar values.
Each of these values will be stored additionally in the optimization path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>[<code>data.frame</code>]<br>
Initial design as data frame.
If the y-values are not already present in design, mbo will evaluate the points.
If the parameters have corresponding trafo functions, the design must not be transformed before it is passed!
Functions to generate designs are available in <code>ParamHelpers</code>: <code>generateDesign</code>, <code>generateGridDesign</code>, <code>generateRandomDesign</code>.
Default is <code>NULL</code>, which means <code>generateDesign</code> is called and a design of size 4 times number of all parameters is created
The points are drawn via <code>maximinLHS</code> to maximize the minimal distance between design points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>[<code>Learner</code>]<br>
Regression learner from mlr, which is used as a surrogate to model our fitness function.
If <code>NULL</code> (default), the default learner is determined as described here: mbo_default_learner.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>[<code>MBOControl</code>]<br>
Control object for mbo.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.info</code></td>
<td>
<p>[<code>logical(1)</code>]<br>
Verbose output on console?
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>more.args</code></td>
<td>
<p>[list]<br>
Further arguments passed to fitness function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>[<code>MBOSingleObjResult</code> | <code>MBOMultiObjResult</code>]
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simple 2d objective function
obj.fun = makeSingleObjectiveFunction(
 fn = function(x) x[1]^2 + sin(x[2]),
 par.set = makeNumericParamSet(id = "x", lower = -1, upper = 1, len = 2)
)

# create base control object
ctrl = makeMBOControl()

# do three MBO iterations
ctrl = setMBOControlTermination(ctrl, iters = 3L)

# use 500 points in the focussearch (should be sufficient for 2d)
ctrl = setMBOControlInfill(ctrl, opt.focussearch.points = 500)
# create initial design
des = generateDesign(n = 5L, getParamSet(obj.fun), fun = lhs::maximinLHS)

# start mbo
res = mbo(obj.fun, design = des, control = ctrl)

print(res)
## Not run: 
plot(res)

## End(Not run)
</code></pre>


</div>