<div class="container">

<table style="width: 100%;"><tr>
<td>calculateConfusionMatrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Confusion matrix.</h2>

<h3>Description</h3>

<p>Calculates the confusion matrix for a (possibly resampled) prediction.
Rows indicate true classes, columns predicted classes. The marginal elements count the number of
classification errors for the respective row or column, i.e., the number of errors
when you condition on the corresponding true (rows) or predicted (columns) class.
The last bottom right element displays the total amount of errors.
</p>
<p>A list is returned that contains multiple matrices.
If <code>relative = TRUE</code> we compute three matrices, one with absolute values and two with relative.
The relative confusion matrices are normalized based on rows and columns respectively,
if <code>FALSE</code> we only compute the absolute value matrix.
</p>
<p>The <code>print</code> function returns the relative matrices in
a compact way so that both row and column marginals can be seen in one matrix.
For details see ConfusionMatrix.
</p>
<p>Note that for resampling no further aggregation is currently performed.
All predictions on all test sets are joined to a vector yhat, as are all labels
joined to a vector y. Then yhat is simply tabulated vs. y, as if both were computed on
a single test set. This probably mainly makes sense when cross-validation is used for resampling.
</p>


<h3>Usage</h3>

<pre><code class="language-R">calculateConfusionMatrix(pred, relative = FALSE, sums = FALSE, set = "both")

## S3 method for class 'ConfusionMatrix'
print(x, both = TRUE, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>(Prediction)<br>
Prediction object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relative</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
If <code>TRUE</code> two additional matrices are calculated. One is normalized by rows and one by
columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sums</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
If <code>TRUE</code> add absolute number of observations in each group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set</code></td>
<td>
<p>(<code>character(1)</code>)<br>
Specifies which part(s) of the data are used for the calculation.
If <code>set</code> equals <code>train</code> or <code>test</code>, the <code>pred</code> object must be the result of a
resampling, otherwise an error is thrown.
Defaults to “both”. Possible values are “train”, “test”, or “both”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>(ConfusionMatrix)<br>
Object to print.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>both</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
If <code>TRUE</code> both the absolute and relative confusion matrices are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>(<code>integer(1)</code>)<br>
How many numbers after the decimal point should be printed, only relevant for relative confusion matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(any)<br>
Currently not used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>(ConfusionMatrix).
</p>


<h3>Functions</h3>


<ul><li> <p><code>print(ConfusionMatrix)</code>: 
</p>
</li></ul>
<h3>See Also</h3>

<p>Other performance: 
<code>ConfusionMatrix</code>,
<code>calculateROCMeasures()</code>,
<code>estimateRelativeOverfitting()</code>,
<code>makeCostMeasure()</code>,
<code>makeCustomResampledMeasure()</code>,
<code>makeMeasure()</code>,
<code>measures</code>,
<code>performance()</code>,
<code>setAggregation()</code>,
<code>setMeasurePars()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># get confusion matrix after simple manual prediction
allinds = 1:150
train = sample(allinds, 75)
test = setdiff(allinds, train)
mod = train("classif.lda", iris.task, subset = train)
pred = predict(mod, iris.task, subset = test)
print(calculateConfusionMatrix(pred))
print(calculateConfusionMatrix(pred, sums = TRUE))
print(calculateConfusionMatrix(pred, relative = TRUE))

# now after cross-validation
r = crossval("classif.lda", iris.task, iters = 2L)
print(calculateConfusionMatrix(r$pred))
</code></pre>


</div>