<div class="container">

<table style="width: 100%;"><tr>
<td>makeFeatSelWrapper</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fuse learner with feature selection.</h2>

<h3>Description</h3>

<p>Fuses a base learner with a search strategy to select variables.
Creates a learner object, which can be used like any other learner object,
but which internally uses selectFeatures.
If the train function is called on it, the search strategy and resampling are
invoked to select an optimal set of variables. Finally, a model is fitted on
the complete training data with these variables and returned. See
selectFeatures for more details.
</p>
<p>After training, the optimal features (and other related information) can be
retrieved with getFeatSelResult.
</p>


<h3>Usage</h3>

<pre><code class="language-R">makeFeatSelWrapper(
  learner,
  resampling,
  measures,
  bit.names,
  bits.to.features,
  control,
  show.info = getMlrOption("show.info")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>(Learner | <code>character(1)</code>)<br>
The learner.
If you pass a string the learner will be created via makeLearner.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resampling</code></td>
<td>
<p>(ResampleInstance | ResampleDesc)<br>
Resampling strategy for feature selection. If you pass a description, it is
instantiated once at the beginning by default, so all points are evaluated
on the same training/test sets. If you want to change that behavior, look
at FeatSelControl.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measures</code></td>
<td>
<p>(list of Measure | Measure)<br>
Performance measures to evaluate. The first measure, aggregated by the first aggregation function
is optimized, others are simply evaluated.
Default is the default measure for the task, see here getDefaultMeasure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bit.names</code></td>
<td>
<p>character<br>
Names of bits encoding the solutions. Also defines the total number of bits
in the encoding. Per default these are the feature names of the task. Has
to be used together with <code>bits.to.features</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bits.to.features</code></td>
<td>
<p>(<code style="white-space: pre;">⁠function(x, task)⁠</code>)<br>
Function which transforms an integer-0-1 vector into a character vector of
selected features. Per default a value of 1 in the ith bit selects the ith
feature to be in the candidate solution. The vector <code>x</code> will correspond to
the <code>bit.names</code> and has to be of the same length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>[see FeatSelControl)
Control object for search method.
Also selects the optimization algorithm for feature selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.info</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Print verbose output on console?
Default is set via configureMlr.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Learner.
</p>


<h3>See Also</h3>

<p>Other featsel: 
<code>FeatSelControl</code>,
<code>analyzeFeatSelResult()</code>,
<code>getFeatSelResult()</code>,
<code>selectFeatures()</code>
</p>
<p>Other wrapper: 
<code>makeBaggingWrapper()</code>,
<code>makeClassificationViaRegressionWrapper()</code>,
<code>makeConstantClassWrapper()</code>,
<code>makeCostSensClassifWrapper()</code>,
<code>makeCostSensRegrWrapper()</code>,
<code>makeDownsampleWrapper()</code>,
<code>makeDummyFeaturesWrapper()</code>,
<code>makeExtractFDAFeatsWrapper()</code>,
<code>makeFilterWrapper()</code>,
<code>makeImputeWrapper()</code>,
<code>makeMulticlassWrapper()</code>,
<code>makeMultilabelBinaryRelevanceWrapper()</code>,
<code>makeMultilabelClassifierChainsWrapper()</code>,
<code>makeMultilabelDBRWrapper()</code>,
<code>makeMultilabelNestedStackingWrapper()</code>,
<code>makeMultilabelStackingWrapper()</code>,
<code>makeOverBaggingWrapper()</code>,
<code>makePreprocWrapper()</code>,
<code>makePreprocWrapperCaret()</code>,
<code>makeRemoveConstantFeaturesWrapper()</code>,
<code>makeSMOTEWrapper()</code>,
<code>makeTuneWrapper()</code>,
<code>makeUndersampleWrapper()</code>,
<code>makeWeightedClassesWrapper()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# nested resampling with feature selection (with a nonsense algorithm for selection)
outer = makeResampleDesc("CV", iters = 2L)
inner = makeResampleDesc("Holdout")
ctrl = makeFeatSelControlRandom(maxit = 1)
lrn = makeFeatSelWrapper("classif.ksvm", resampling = inner, control = ctrl)
# we also extract the selected features for all iteration here
r = resample(lrn, iris.task, outer, extract = getFeatSelResult)

</code></pre>


</div>