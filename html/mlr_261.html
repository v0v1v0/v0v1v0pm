<div class="container">

<table style="width: 100%;"><tr>
<td>makeFilterWrapper</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fuse learner with a feature filter method.</h2>

<h3>Description</h3>

<p>Fuses a base learner with a filter method. Creates a learner
object, which can be used like any other learner object. Internally uses
filterFeatures before every model fit.
</p>


<h3>Usage</h3>

<pre><code class="language-R">makeFilterWrapper(
  learner,
  fw.method = "FSelectorRcpp_information.gain",
  fw.base.methods = NULL,
  fw.perc = NULL,
  fw.abs = NULL,
  fw.threshold = NULL,
  fw.fun = NULL,
  fw.fun.args = NULL,
  fw.mandatory.feat = NULL,
  cache = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>(Learner | <code>character(1)</code>)<br>
The learner.
If you pass a string the learner will be created via makeLearner.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fw.method</code></td>
<td>
<p>(<code>character(1)</code>)<br>
Filter method. See listFilterMethods.
Default is “FSelectorRcpp_information.gain”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fw.base.methods</code></td>
<td>
<p>(<code>character(1)</code>)<br>
Simple Filter methods for ensemble filters. See listFilterMethods. Can
only be used in combination with ensemble filters. See
listFilterEnsembleMethods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fw.perc</code></td>
<td>
<p>(<code>numeric(1)</code>)<br>
If set, select <code>fw.perc</code>*100 top scoring features. Mutually exclusive with
arguments <code>fw.abs</code>, <code>fw.threshold</code> and 'fw.fun.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fw.abs</code></td>
<td>
<p>(<code>numeric(1)</code>)<br>
If set, select <code>fw.abs</code> top scoring features.
Mutually exclusive with arguments <code>fw.perc</code>, <code>fw.threshold</code> and <code>fw.fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fw.threshold</code></td>
<td>
<p>(<code>numeric(1)</code>)<br>
If set, select features whose score exceeds <code>fw.threshold</code>. Mutually
exclusive with arguments <code>fw.perc</code>, <code>fw.abs</code> and <code>fw.fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fw.fun</code></td>
<td>
<p>(<code style="white-space: pre;">⁠function)⁠</code>)<br>
If set, select features via a custom thresholding function, which must
return the number of top scoring features to select. Mutually exclusive
with arguments <code>fw.perc</code>, <code>fw.abs</code> and <code>fw.threshold</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fw.fun.args</code></td>
<td>
<p>(any)<br>
Arguments passed to the custom thresholding function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fw.mandatory.feat</code></td>
<td>
<p>(character)<br>
Mandatory features which are always
included regardless of their scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache</code></td>
<td>
<p>(<code>character(1)</code> | logical)<br>
Whether to use caching during
filter value creation. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(any)<br>
Additional parameters passed down to the filter. If you are using more than
one filter method, you need to pass the arguments in a named list via
<code>more.args</code>. For example <code>more.args = list("FSelectorRcpp_information.gain" = list(equal = TRUE))</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>ensemble = TRUE</code>, ensemble feature selection using all methods specified
in <code>fw.method</code> is performed. At least two methods need to be selected.
</p>
<p>After training, the selected features can be retrieved with
getFilteredFeatures.
</p>
<p>Note that observation weights do not influence the filtering and are simply
passed down to the next learner.
</p>


<h3>Value</h3>

<p>Learner.
</p>


<h3>Caching</h3>

<p>If <code>cache = TRUE</code>, the default mlr cache directory is used to cache filter
values. The directory is operating system dependent and can be checked with
<code>getCacheDir()</code>. Alternatively a custom directory can be passed to store
the cache. The cache can be cleared with <code>deleteCacheDir()</code>. Caching is
disabled by default. Care should be taken when operating on large clusters
due to possible write conflicts to disk if multiple workers try to write
the same cache at the same time.
</p>


<h3>See Also</h3>

<p>Other filter: 
<code>filterFeatures()</code>,
<code>generateFilterValuesData()</code>,
<code>getFilteredFeatures()</code>,
<code>listFilterEnsembleMethods()</code>,
<code>listFilterMethods()</code>,
<code>makeFilter()</code>,
<code>makeFilterEnsemble()</code>,
<code>plotFilterValues()</code>
</p>
<p>Other wrapper: 
<code>makeBaggingWrapper()</code>,
<code>makeClassificationViaRegressionWrapper()</code>,
<code>makeConstantClassWrapper()</code>,
<code>makeCostSensClassifWrapper()</code>,
<code>makeCostSensRegrWrapper()</code>,
<code>makeDownsampleWrapper()</code>,
<code>makeDummyFeaturesWrapper()</code>,
<code>makeExtractFDAFeatsWrapper()</code>,
<code>makeFeatSelWrapper()</code>,
<code>makeImputeWrapper()</code>,
<code>makeMulticlassWrapper()</code>,
<code>makeMultilabelBinaryRelevanceWrapper()</code>,
<code>makeMultilabelClassifierChainsWrapper()</code>,
<code>makeMultilabelDBRWrapper()</code>,
<code>makeMultilabelNestedStackingWrapper()</code>,
<code>makeMultilabelStackingWrapper()</code>,
<code>makeOverBaggingWrapper()</code>,
<code>makePreprocWrapper()</code>,
<code>makePreprocWrapperCaret()</code>,
<code>makeRemoveConstantFeaturesWrapper()</code>,
<code>makeSMOTEWrapper()</code>,
<code>makeTuneWrapper()</code>,
<code>makeUndersampleWrapper()</code>,
<code>makeWeightedClassesWrapper()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

task = makeClassifTask(data = iris, target = "Species")
lrn = makeLearner("classif.lda")
inner = makeResampleDesc("Holdout")
outer = makeResampleDesc("CV", iters = 2)
lrn = makeFilterWrapper(lrn, fw.perc = 0.5)
mod = train(lrn, task)
print(getFilteredFeatures(mod))
# now nested resampling, where we extract the features that the filter method selected
r = resample(lrn, task, outer, extract = function(model) {
  getFilteredFeatures(model)
})
print(r$extract)

# usage of an ensemble filter
lrn = makeLearner("classif.lda")
lrn = makeFilterWrapper(lrn, fw.method = "E-Borda",
  fw.base.methods = c("FSelectorRcpp_gain.ratio", "FSelectorRcpp_information.gain"),
  fw.perc = 0.5)
r = resample(lrn, task, outer, extract = function(model) {
  getFilteredFeatures(model)
})
print(r$extract)

# usage of a custom thresholding function
biggest_gap = function(values, diff) {
  gap_size = 0
  gap_location = 0

  for (i in (diff + 1):length(values)) {
    gap = values[[i - diff]] - values[[i]]
    if (gap &gt; gap_size) {
      gap_size = gap
      gap_location = i - 1
    }
  }
  return(gap_location)
}

lrn = makeLearner("classif.lda")
lrn = makeFilterWrapper(lrn, fw.method = "FSelectorRcpp_information.gain",
  fw.fun = biggest_gap, fw.fun.args = list("diff" = 1))
r = resample(lrn, task, outer, extract = function(model) {
  getFilteredFeatures(model)
})
print(r$extract)


</code></pre>


</div>