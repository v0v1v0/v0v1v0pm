<div class="container">

<table style="width: 100%;"><tr>
<td>makeMultilabelClassifierChainsWrapper</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Use classifier chains method (CC) to create a multilabel learner.</h2>

<h3>Description</h3>

<p>Every learner which is implemented in mlr and which supports binary
classification can be converted to a wrapped classifier chains multilabel learner.
CC trains a binary classifier for each label following a given order. In training phase,
the feature space of each classifier is extended with true label information of all previous
labels in the chain. During the prediction phase, when true labels are not available, they are
replaced by predicted labels.
</p>
<p>Models can easily be accessed via getLearnerModel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">makeMultilabelClassifierChainsWrapper(learner, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>(Learner | <code>character(1)</code>)<br>
The learner.
If you pass a string the learner will be created via makeLearner.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>(character)<br>
Specifies the chain order using the names of the target labels.
E.g. for <code>m</code> target labels, this must be a character vector of length <code>m</code> that contains a permutation of the target label names.
Default is <code>NULL</code> which uses a random ordering of the target label names.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Learner.
</p>


<h3>References</h3>

<p>Montanes, E. et al. (2013)
<em>Dependent binary relevance models for multi-label classification</em>
Artificial Intelligence Center, University of Oviedo at Gijon, Spain.
</p>


<h3>See Also</h3>

<p>Other wrapper: 
<code>makeBaggingWrapper()</code>,
<code>makeClassificationViaRegressionWrapper()</code>,
<code>makeConstantClassWrapper()</code>,
<code>makeCostSensClassifWrapper()</code>,
<code>makeCostSensRegrWrapper()</code>,
<code>makeDownsampleWrapper()</code>,
<code>makeDummyFeaturesWrapper()</code>,
<code>makeExtractFDAFeatsWrapper()</code>,
<code>makeFeatSelWrapper()</code>,
<code>makeFilterWrapper()</code>,
<code>makeImputeWrapper()</code>,
<code>makeMulticlassWrapper()</code>,
<code>makeMultilabelBinaryRelevanceWrapper()</code>,
<code>makeMultilabelDBRWrapper()</code>,
<code>makeMultilabelNestedStackingWrapper()</code>,
<code>makeMultilabelStackingWrapper()</code>,
<code>makeOverBaggingWrapper()</code>,
<code>makePreprocWrapper()</code>,
<code>makePreprocWrapperCaret()</code>,
<code>makeRemoveConstantFeaturesWrapper()</code>,
<code>makeSMOTEWrapper()</code>,
<code>makeTuneWrapper()</code>,
<code>makeUndersampleWrapper()</code>,
<code>makeWeightedClassesWrapper()</code>
</p>
<p>Other multilabel: 
<code>getMultilabelBinaryPerformances()</code>,
<code>makeMultilabelBinaryRelevanceWrapper()</code>,
<code>makeMultilabelDBRWrapper()</code>,
<code>makeMultilabelNestedStackingWrapper()</code>,
<code>makeMultilabelStackingWrapper()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (requireNamespace("rpart")) {
d = getTaskData(yeast.task)
# drop some labels so example runs faster
d = d[seq(1, nrow(d), by = 20), c(1:2, 15:17)]
task = makeMultilabelTask(data = d, target = c("label1", "label2"))
lrn = makeLearner("classif.rpart")
lrn = makeMultilabelBinaryRelevanceWrapper(lrn)
lrn = setPredictType(lrn, "prob")
# train, predict and evaluate
mod = train(lrn, task)
pred = predict(mod, task)
performance(pred, measure = list(multilabel.hamloss, multilabel.subset01, multilabel.f1))
# the next call basically has the same structure for any multilabel meta wrapper
getMultilabelBinaryPerformances(pred, measures = list(mmce, auc))
# above works also with predictions from resample!
}
</code></pre>


</div>