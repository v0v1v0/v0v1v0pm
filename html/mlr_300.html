<div class="container">

<table style="width: 100%;"><tr>
<td>makeStackedLearner</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a stacked learner object.</h2>

<h3>Description</h3>

<p>A stacked learner uses predictions of several base learners and
fits a super learner using these predictions as features in order to
predict the outcome. The following stacking methods are available:
</p>

<ul>
<li> <p><code>average</code><br> Averaging of base learner predictions without weights.
</p>
</li>
<li> <p><code>stack.nocv</code><br> Fits the super learner, where in-sample predictions of
the base learners are used.
</p>
</li>
<li> <p><code>stack.cv</code><br> Fits the super learner, where the base learner predictions
are computed by cross-validated predictions (the resampling strategy can be
set via the <code>resampling</code> argument).
</p>
</li>
<li> <p><code>hill.climb</code><br> Select a subset of base learner predictions by hill
climbing algorithm.
</p>
</li>
<li> <p><code>compress</code><br> Train a neural network to compress the model from a
collection of base learners.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">makeStackedLearner(
  base.learners,
  super.learner = NULL,
  predict.type = NULL,
  method = "stack.nocv",
  use.feat = FALSE,
  resampling = NULL,
  parset = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>base.learners</code></td>
<td>
<p>((list of) Learner)<br>
A list of learners created with <code>makeLearner</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>super.learner</code></td>
<td>
<p>(Learner | character(1))<br>
The super learner that makes the final prediction based on the base
learners. If you pass a string, the super learner will be created via
<code>makeLearner</code>. Not used for <code>method = 'average'</code>. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict.type</code></td>
<td>
<p>(<code>character(1)</code>)<br>
Sets the type of the final prediction for <code>method = 'average'</code>. For other
methods, the predict type should be set within <code>super.learner</code>. If the type
of the base learner prediction, which is set up within <code>base.learners</code>, is
</p>

<ul>
<li> <p><code>"prob"</code><br> then <code>predict.type = 'prob'</code> will use the average of all
base learner predictions and <code>predict.type = 'response'</code> will use the
class with highest probability as final prediction.
</p>
</li>
<li> <p><code>"response"</code><br> then, for classification tasks with <code>predict.type =    'prob'</code>, the final prediction will be the relative frequency based on the
predicted base learner classes and classification tasks with <code>predict.type    = 'response'</code> will use majority vote of the base learner predictions to
determine the final prediction. For regression tasks, the final prediction
will be the average of the base learner predictions.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>(<code>character(1)</code>)<br>
“average” for averaging the predictions of the base learners,
“stack.nocv” for building a super learner using the predictions of
the base learners,
“stack.cv” for building a super learner using cross-validated
predictions of the base learners.
“hill.climb” for averaging the predictions of the base learners,
with the weights learned from hill climbing algorithm and
“compress” for compressing the model to mimic the predictions of a
collection of base learners while speeding up the predictions and reducing
the size of the model. Default is “stack.nocv”,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.feat</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Whether the original features should also be passed to the super learner.
Not used for <code>method = 'average'</code>.
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resampling</code></td>
<td>
<p>(ResampleDesc)<br>
Resampling strategy for <code>method = 'stack.cv'</code>.
Currently only CV is allowed for resampling.
The default <code>NULL</code> uses 5-fold CV.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parset</code></td>
<td>
<p>the parameters for <code>hill.climb</code> method, including
</p>

<ul>
<li> <p><code>replace</code><br> Whether a base learner can be selected more than once.
</p>
</li>
<li> <p><code>init</code><br> Number of best models being included before the selection algorithm.
</p>
</li>
<li> <p><code>bagprob</code><br> The proportion of models being considered in one round of selection.
</p>
</li>
<li> <p><code>bagtime</code><br> The number of rounds of the bagging selection.
</p>
</li>
<li> <p><code>metric</code><br> The result evaluation metric function taking two parameters
<code>pred</code> and <code>true</code>, the smaller the score the better.
</p>
</li>
</ul>
<p>the parameters for <code>compress</code> method, including
</p>

<ul>
<li>
<p> k<br> the size multiplier of the generated data
</p>
</li>
<li>
<p> prob<br> the probability to exchange values
</p>
</li>
<li>
<p> s<br> the standard deviation of each numerical feature
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">




# Classification
data(iris)
tsk = makeClassifTask(data = iris, target = "Species")
base = c("classif.rpart", "classif.lda", "classif.svm")
lrns = lapply(base, makeLearner)
lrns = lapply(lrns, setPredictType, "prob")
m = makeStackedLearner(base.learners = lrns,
  predict.type = "prob", method = "hill.climb")
tmp = train(m, tsk)
res = predict(tmp, tsk)

# Regression
data(BostonHousing, package = "mlbench")
tsk = makeRegrTask(data = BostonHousing, target = "medv")
base = c("regr.rpart", "regr.svm")
lrns = lapply(base, makeLearner)
m = makeStackedLearner(base.learners = lrns,
  predict.type = "response", method = "compress")
tmp = train(m, tsk)
res = predict(tmp, tsk)





</code></pre>


</div>