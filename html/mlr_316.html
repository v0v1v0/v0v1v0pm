<div class="container">

<table style="width: 100%;"><tr>
<td>makeTuneWrapper</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fuse learner with tuning.</h2>

<h3>Description</h3>

<p>Fuses a base learner with a search strategy to select its hyperparameters.
Creates a learner object, which can be used like any other learner object,
but which internally uses tuneParams.
If the train function is called on it,
the search strategy and resampling are invoked
to select an optimal set of hyperparameter values. Finally, a model is fitted on the
complete training data with these optimal hyperparameters and returned.
See tuneParams for more details.
</p>
<p>After training, the optimal hyperparameters (and other related information) can be retrieved with
getTuneResult.
</p>


<h3>Usage</h3>

<pre><code class="language-R">makeTuneWrapper(
  learner,
  resampling,
  measures,
  par.set,
  control,
  show.info = getMlrOption("show.info")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>(Learner | <code>character(1)</code>)<br>
The learner.
If you pass a string the learner will be created via makeLearner.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resampling</code></td>
<td>
<p>(ResampleInstance | ResampleDesc)<br>
Resampling strategy to evaluate points in hyperparameter space. If you pass a description,
it is instantiated once at the beginning by default, so all points are
evaluated on the same training/test sets.
If you want to change that behavior, look at TuneControl.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measures</code></td>
<td>
<p>(list of Measure | Measure)<br>
Performance measures to evaluate. The first measure, aggregated by the first aggregation function
is optimized, others are simply evaluated.
Default is the default measure for the task, see here getDefaultMeasure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.set</code></td>
<td>
<p>(ParamHelpers::ParamSet)<br>
Collection of parameters and their constraints for optimization.
Dependent parameters with a <code>requires</code> field must use <code>quote</code> and not
<code>expression</code> to define it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>(TuneControl)<br>
Control object for search method. Also selects the optimization algorithm for tuning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.info</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Print verbose output on console?
Default is set via configureMlr.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Learner.
</p>


<h3>See Also</h3>

<p>Other tune: 
<code>TuneControl</code>,
<code>getNestedTuneResultsOptPathDf()</code>,
<code>getNestedTuneResultsX()</code>,
<code>getResamplingIndices()</code>,
<code>getTuneResult()</code>,
<code>makeModelMultiplexer()</code>,
<code>makeModelMultiplexerParamSet()</code>,
<code>makeTuneControlCMAES()</code>,
<code>makeTuneControlDesign()</code>,
<code>makeTuneControlGenSA()</code>,
<code>makeTuneControlGrid()</code>,
<code>makeTuneControlIrace()</code>,
<code>makeTuneControlMBO()</code>,
<code>makeTuneControlRandom()</code>,
<code>tuneParams()</code>,
<code>tuneThreshold()</code>
</p>
<p>Other wrapper: 
<code>makeBaggingWrapper()</code>,
<code>makeClassificationViaRegressionWrapper()</code>,
<code>makeConstantClassWrapper()</code>,
<code>makeCostSensClassifWrapper()</code>,
<code>makeCostSensRegrWrapper()</code>,
<code>makeDownsampleWrapper()</code>,
<code>makeDummyFeaturesWrapper()</code>,
<code>makeExtractFDAFeatsWrapper()</code>,
<code>makeFeatSelWrapper()</code>,
<code>makeFilterWrapper()</code>,
<code>makeImputeWrapper()</code>,
<code>makeMulticlassWrapper()</code>,
<code>makeMultilabelBinaryRelevanceWrapper()</code>,
<code>makeMultilabelClassifierChainsWrapper()</code>,
<code>makeMultilabelDBRWrapper()</code>,
<code>makeMultilabelNestedStackingWrapper()</code>,
<code>makeMultilabelStackingWrapper()</code>,
<code>makeOverBaggingWrapper()</code>,
<code>makePreprocWrapper()</code>,
<code>makePreprocWrapperCaret()</code>,
<code>makeRemoveConstantFeaturesWrapper()</code>,
<code>makeSMOTEWrapper()</code>,
<code>makeUndersampleWrapper()</code>,
<code>makeWeightedClassesWrapper()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

task = makeClassifTask(data = iris, target = "Species")
lrn = makeLearner("classif.rpart")
# stupid mini grid
ps = makeParamSet(
  makeDiscreteParam("cp", values = c(0.05, 0.1)),
  makeDiscreteParam("minsplit", values = c(10, 20))
)
ctrl = makeTuneControlGrid()
inner = makeResampleDesc("Holdout")
outer = makeResampleDesc("CV", iters = 2)
lrn = makeTuneWrapper(lrn, resampling = inner, par.set = ps, control = ctrl)
mod = train(lrn, task)
print(getTuneResult(mod))
# nested resampling for evaluation
# we also extract tuned hyper pars in each iteration
r = resample(lrn, task, outer, extract = getTuneResult)
print(r$extract)
getNestedTuneResultsOptPathDf(r)
getNestedTuneResultsX(r)


</code></pre>


</div>