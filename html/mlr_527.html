<div class="container">

<table style="width: 100%;"><tr>
<td>tuneParams</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hyperparameter tuning.</h2>

<h3>Description</h3>

<p>Optimizes the hyperparameters of a learner.
Allows for different optimization methods, such as grid search, evolutionary strategies,
iterated F-race, etc. You can select such an algorithm (and its settings)
by passing a corresponding control object. For a complete list of implemented algorithms look at
TuneControl.
</p>
<p>Multi-criteria tuning can be done with tuneParamsMultiCrit.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tuneParams(
  learner,
  task,
  resampling,
  measures,
  par.set,
  control,
  show.info = getMlrOption("show.info"),
  resample.fun = resample
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>learner</code></td>
<td>
<p>(Learner | <code>character(1)</code>)<br>
The learner.
If you pass a string the learner will be created via makeLearner.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>task</code></td>
<td>
<p>(Task)<br>
The task.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resampling</code></td>
<td>
<p>(ResampleInstance | ResampleDesc)<br>
Resampling strategy to evaluate points in hyperparameter space. If you pass a description,
it is instantiated once at the beginning by default, so all points are
evaluated on the same training/test sets.
If you want to change that behavior, look at TuneControl.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measures</code></td>
<td>
<p>(list of Measure | Measure)<br>
Performance measures to evaluate. The first measure, aggregated by the first aggregation function
is optimized, others are simply evaluated.
Default is the default measure for the task, see here getDefaultMeasure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.set</code></td>
<td>
<p>(ParamHelpers::ParamSet)<br>
Collection of parameters and their constraints for optimization.
Dependent parameters with a <code>requires</code> field must use <code>quote</code> and not
<code>expression</code> to define it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>(TuneControl)<br>
Control object for search method. Also selects the optimization algorithm for tuning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.info</code></td>
<td>
<p>(<code>logical(1)</code>)<br>
Print verbose output on console?
Default is set via configureMlr.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resample.fun</code></td>
<td>
<p>(closure)<br>
The function to use for resampling. Defaults to resample. If a user-given function
is to be used instead, it should take the arguments “learner”, “task”, “resampling”,
“measures”, and “show.info”; see resample. Within this function,
it is easiest to call resample and possibly modify the result.
However, it is possible to return a list with only the following essential slots:
the “aggr” slot for general tuning, additionally the “pred” slot if threshold tuning is performed
(see TuneControl), and the “err.msgs” and “err.dumps” slots for error reporting.
This parameter must be the default when <code>mbo</code> tuning is performed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>(TuneResult).
</p>


<h3>Note</h3>

<p>If you would like to include results from the training data set, make
sure to appropriately adjust the resampling strategy and the aggregation for
the measure. See example code below.
</p>


<h3>See Also</h3>

<p>generateHyperParsEffectData
</p>
<p>Other tune: 
<code>TuneControl</code>,
<code>getNestedTuneResultsOptPathDf()</code>,
<code>getNestedTuneResultsX()</code>,
<code>getResamplingIndices()</code>,
<code>getTuneResult()</code>,
<code>makeModelMultiplexer()</code>,
<code>makeModelMultiplexerParamSet()</code>,
<code>makeTuneControlCMAES()</code>,
<code>makeTuneControlDesign()</code>,
<code>makeTuneControlGenSA()</code>,
<code>makeTuneControlGrid()</code>,
<code>makeTuneControlIrace()</code>,
<code>makeTuneControlMBO()</code>,
<code>makeTuneControlRandom()</code>,
<code>makeTuneWrapper()</code>,
<code>tuneThreshold()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">


set.seed(123)
# a grid search for an SVM (with a tiny number of points...)
# note how easily we can optimize on a log-scale
ps = makeParamSet(
  makeNumericParam("C", lower = -12, upper = 12, trafo = function(x) 2^x),
  makeNumericParam("sigma", lower = -12, upper = 12, trafo = function(x) 2^x)
)
ctrl = makeTuneControlGrid(resolution = 2L)
rdesc = makeResampleDesc("CV", iters = 2L)
res = tuneParams("classif.ksvm", iris.task, rdesc, par.set = ps, control = ctrl)
print(res)
# access data for all evaluated points
df = as.data.frame(res$opt.path)
df1 = as.data.frame(res$opt.path, trafo = TRUE)
print(head(df[, -ncol(df)]))
print(head(df1[, -ncol(df)]))
# access data for all evaluated points - alternative
df2 = generateHyperParsEffectData(res)
df3 = generateHyperParsEffectData(res, trafo = TRUE)
print(head(df2$data[, -ncol(df2$data)]))
print(head(df3$data[, -ncol(df3$data)]))
## Not run: 
# we optimize the SVM over 3 kernels simultanously
# note how we use dependent params (requires = ...) and iterated F-racing here
ps = makeParamSet(
  makeNumericParam("C", lower = -12, upper = 12, trafo = function(x) 2^x),
  makeDiscreteParam("kernel", values = c("vanilladot", "polydot", "rbfdot")),
  makeNumericParam("sigma", lower = -12, upper = 12, trafo = function(x) 2^x,
    requires = quote(kernel == "rbfdot")),
  makeIntegerParam("degree", lower = 2L, upper = 5L,
    requires = quote(kernel == "polydot"))
)
print(ps)
ctrl = makeTuneControlIrace(maxExperiments = 5, nbIterations = 1, minNbSurvival = 1)
rdesc = makeResampleDesc("Holdout")
res = tuneParams("classif.ksvm", iris.task, rdesc, par.set = ps, control = ctrl)
print(res)
df = as.data.frame(res$opt.path)
print(head(df[, -ncol(df)]))

# include the training set performance as well
rdesc = makeResampleDesc("Holdout", predict = "both")
res = tuneParams("classif.ksvm", iris.task, rdesc, par.set = ps,
  control = ctrl, measures = list(mmce, setAggregation(mmce, train.mean)))
print(res)
df2 = as.data.frame(res$opt.path)
print(head(df2[, -ncol(df2)]))

## End(Not run)



</code></pre>


</div>