<div class="container">

<table style="width: 100%;"><tr>
<td>filterFeatures</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter features by thresholding filter values.</h2>

<h3>Description</h3>

<p>First, calls generateFilterValuesData.
Features are then selected via <code>select</code> and <code>val</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">filterFeatures(
  task,
  method = "FSelectorRcpp_information.gain",
  fval = NULL,
  perc = NULL,
  abs = NULL,
  threshold = NULL,
  fun = NULL,
  fun.args = NULL,
  mandatory.feat = NULL,
  select.method = NULL,
  base.methods = NULL,
  cache = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>task</code></td>
<td>
<p>(Task)<br>
The task.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>(<code>character(1)</code>)<br>
See listFilterMethods.
Default is “FSelectorRcpp_information.gain”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fval</code></td>
<td>
<p>(FilterValues)<br>
Result of generateFilterValuesData.
If you pass this, the filter values in the object are used for feature
filtering.
<code>method</code> and <code>...</code> are ignored then.
Default is <code>NULL</code> and not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perc</code></td>
<td>
<p>(<code>numeric(1)</code>)<br>
If set, select <code>perc</code>*100 top scoring features.
<code>perc = 1</code> means to select all features.<code style="white-space: pre;">⁠Mutually exclusive with arguments⁠</code>abs<code style="white-space: pre;">⁠, ⁠</code>threshold<code>and</code>fun'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abs</code></td>
<td>
<p>(<code>numeric(1)</code>)<br>
If set, select <code>abs</code> top scoring features.
Mutually exclusive with arguments <code>perc</code>, <code>threshold</code> and <code>fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>(<code>numeric(1)</code>)<br>
If set, select features whose score exceeds <code>threshold</code>.
Mutually exclusive with arguments <code>perc</code>, <code>abs</code> and <code>fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>(<code>function</code>)<br>
If set, select features via a custom thresholding function, which must
return the number of top scoring features to select. Mutually exclusive
with arguments <code>perc</code>, <code>abs</code> and <code>threshold</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.args</code></td>
<td>
<p>(any)<br>
Arguments passed to the custom thresholding function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mandatory.feat</code></td>
<td>
<p>(character)<br>
Mandatory features which are always included regardless of their scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select.method</code></td>
<td>
<p>If multiple methods are supplied in argument <code>method</code>,
specify the method that is used for the final subsetting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base.methods</code></td>
<td>
<p>If <code>method</code> is an ensemble filter, specify the base
filter methods which the ensemble method will use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache</code></td>
<td>
<p>(<code>character(1)</code> | logical)<br>
Whether to use caching during filter value creation. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(any)<br>
Passed down to selected filter method.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Task.
</p>


<h3>Caching</h3>

<p>If <code>cache = TRUE</code>, the default mlr cache directory is used to cache
filter values. The directory is operating system dependent and can be
checked with <code>getCacheDir()</code>.<br>
The default cache can be cleared with <code>deleteCacheDir()</code>.
Alternatively, a custom directory can be passed to store the cache.
</p>
<p>Note that caching is not thread safe. It will work for parallel
computation on many systems, but there is no guarantee.
</p>


<h3>Simple and ensemble filters</h3>

<p>Besides passing (multiple) simple filter methods you can also pass an
ensemble filter method (in a list). The ensemble method will use the simple
methods to calculate its ranking. See <code>listFilterEnsembleMethods()</code> for
available ensemble methods.
</p>


<h3>See Also</h3>

<p>Other filter: 
<code>generateFilterValuesData()</code>,
<code>getFilteredFeatures()</code>,
<code>listFilterEnsembleMethods()</code>,
<code>listFilterMethods()</code>,
<code>makeFilter()</code>,
<code>makeFilterEnsemble()</code>,
<code>makeFilterWrapper()</code>,
<code>plotFilterValues()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

# simple filter
filterFeatures(iris.task, method = "FSelectorRcpp_gain.ratio", abs = 2)
# ensemble filter
filterFeatures(iris.task, method = "E-min",
  base.methods = c("FSelectorRcpp_gain.ratio",
    "FSelectorRcpp_information.gain"), abs = 2)


</code></pre>


</div>