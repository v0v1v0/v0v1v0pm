<div class="container">

<table style="width: 100%;"><tr>
<td>mlt-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Methods for mlt Objects
</h2>

<h3>Description</h3>

<p>Methods for objects of class mlt
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mlt'
coef(object, fixed = TRUE, ...)
coef(object) &lt;- value
## S3 method for class 'mlt'
weights(object, ...)
## S3 method for class 'mlt'
logLik(object, parm = coef(object, fixed = FALSE), w = NULL, newdata, ...)
## S3 method for class 'mlt'
vcov(object, parm = coef(object, fixed = FALSE), complete = FALSE, ...)
Hessian(object, ...)
## S3 method for class 'mlt'
Hessian(object, parm = coef(object, fixed = FALSE), ...)
Gradient(object, ...)
## S3 method for class 'mlt'
Gradient(object, parm = coef(object, fixed = FALSE), ...)
## S3 method for class 'mlt'
estfun(x, parm = coef(x, fixed = FALSE),
       w = NULL, newdata, ...)
## S3 method for class 'mlt'
residuals(object, parm = coef(object, fixed = FALSE), 
       w = NULL, newdata, what = c("shifting", "scaling"), ...)
## S3 method for class 'mlt'
mkgrid(object, n, ...)
## S3 method for class 'mlt'
bounds(object)
## S3 method for class 'mlt'
variable.names(object, ...)
## S3 method for class 'mlt_fit'
update(object, weights = stats::weights(object), 
       subset = NULL, offset = object$offset, theta = coef(object, fixed = FALSE), 
       fixed = NULL, ...)
## S3 method for class 'mlt'
as.mlt(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object, x</code></td>
<td>
<p>a fitted conditional transformation model as returned by <code>mlt</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>a logical indicating if only estimated coefficients (<code>fixed = FALSE</code>) 
should be returned OR (for <code>update</code>)
a named vector of fixed regression coefficients; the names
need to correspond to column names of the design matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>coefficients to be assigned to the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>model parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>model weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>type of residual: <code>shifting</code> means score with respect to
a constant intercept for the shift term and <code>scaling</code> means 
score with respect to a constant intercept in the scaling term. 
This works whether or not such terms are actually present in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>model weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>an optional data frame of new observations. Allows
evaluation of the log-likelihood for a given
model <code>object</code> on these new observations. The
parameters <code>parm</code> and <code>w</code> are ignored in this situation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of grid points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional integer vector indicating the subset of
observations to be used for fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>an optional vector of offset values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>optional starting values for the model parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete</code></td>
<td>
<p>currently ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>coef</code> can be used to get and set model parameters, <code>weights</code> and 
<code>logLik</code> extract weights and evaluate the log-likelihood (also for
parameters other than the maximum likelihood estimate). <code>Hessian</code>
returns the Hessian (of the <em>negative</em> log-likelihood) and <code>vcov</code> the inverse thereof. <code>Gradient</code>
gives the negative gradient (minus sum of the score contributions) 
and <code>estfun</code> the <em>negative</em> score contribution by each observation. <code>mkgrid</code>
generates a grid of all variables (as returned by <code>variable.names</code>) in the model.
<code>update</code> allows refitting the model with alternative weights and potentially
different starting values. <code>bounds</code> gets bounds for bounded variables in the model.
</p>


</div>