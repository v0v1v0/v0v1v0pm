<div class="container">

<table style="width: 100%;"><tr>
<td>plot-predict-simulate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plots, Predictions and Samples from mlt Objects
</h2>

<h3>Description</h3>

<p>Plot, predict and sample from objects of class mlt
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'ctm'
plot(x, newdata, type = c(
         "distribution", "logdistribution", 
         "survivor", "logsurvivor", 
         "density", "logdensity", 
         "hazard", "loghazard", 
         "cumhazard", "logcumhazard", 
         "odds", "logodds", 
         "quantile", "trafo"),
     q = NULL, prob = 1:(K - 1) / K, K = 50, col = rgb(.1, .1, .1, .1), lty = 1, 
     add = FALSE, ...)
## S3 method for class 'mlt'
plot(x, ...)
## S3 method for class 'ctm'
predict(object, newdata, type = c("trafo", 
         "distribution", "logdistribution", 
         "survivor", "logsurvivor", 
         "density", "logdensity", 
         "hazard", "loghazard", 
         "cumhazard", "logcumhazard", 
         "odds", "logodds", 
         "quantile"), 
         terms = c("bresponse", "binteracting", "bshifting"), 
         q = NULL, prob = NULL, K = 50, interpolate = FALSE, ...)
## S3 method for class 'mlt'
predict(object, newdata = object$data, ...)
## S3 method for class 'ctm'
simulate(object, nsim = 1, seed = NULL, newdata, K = 50, q = NULL,
         interpolate = FALSE, bysim = TRUE, ...)
## S3 method for class 'mlt'
simulate(object, nsim = 1, seed = NULL, newdata = object$data, bysim = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted conditional transformation model as returned by <code>mlt</code>
or an unfitted conditional transformation model as returned by <code>ctm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a fitted conditional transformation model as returned by <code>mlt</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>an optional data frame of observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of prediction or plot to generate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>quantiles at which to evaluate the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>probabilities for the evaluation of the quantile function (<code>type = "quantile"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>terms to evaluate for the predictions, corresponds to the argument
<code>response</code>, <code>interacting</code> and <code>shifting</code> in <code>ctm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of grid points to generate (in the absence of <code>q</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>color for the lines to plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p>line type for the lines to plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>logical indicating if a new plot shall be generated (the default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate</code></td>
<td>
<p>logical indicating if quantiles shall be interpolated
linearily. This unnecessary option is no longer implemented (starting with 1.2-1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>number of samples to generate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>optional seed for the random number generator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bysim</code></td>
<td>
<p>logical, if <code>TRUE</code> a list with <code>nsim</code> elements is returned,
each element is of length <code>nrow(newdata)</code> and 
contains one sample from the conditional distribution for each
row of <code>newdata</code>. If <code>FALSE</code>, a list of length <code>nrow(newdata)</code>
is returned, its ith element of length <code>nsim</code> contains <code>nsim</code> samples
from the conditional distribution given <code>newdata[i,]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>plot</code> evaluates the transformation function over a grid of <code>q</code> values
for all observations in <code>newdata</code> and plots these functions (according to 
<code>type</code>). <code>predict</code> evaluates the transformation function over a grid
of <code>q</code> values for all observations in <code>newdata</code> and returns the
result as a matrix (where _columns_ correspond to _rows_ in
<code>newdata</code>, see examples). Lack of <code>type = "mean"</code> is a feature
and not a bug.
</p>
<p>Argument <code>type</code> defines the scale of the plots or predictions:
<code>type = "distribution"</code> means the cumulative distribution function, 
<code>type = "survivor"</code> is the survivor function (one minus distribution
function), <code>type = "density"</code> the absolute continuous or discrete
density (depending on the response), <code>type = "hazard"</code>, <code>type =
  "cumhazard"</code>, and <code>type = "odds"</code> refers to the hazard (absolute
continuous or discrete), cumulative hazard (defined as minus log-survivor
function in both the absolute continuous and discrete cases), and odds
(distribution divided by survivor) functions. The quantile function can be
evaluated for probabilities <code>prob</code> by <code>type = "quantile"</code>.
</p>
<p>Note that the <code>predict</code> method for <code>ctm</code> objects requires all
model coefficients to be specified in this unfitted model.
<code>simulate</code> draws samples from <code>object</code> by numerical inversion of the
quantile function.
</p>
<p>Note that offsets are ALWAYS IGNORED when computing predictions. If you
want the methods to pay attention to offsets, specify them as a variable
in the model with fixed regression coefficient using the <code>fixed</code>
argument in <code>mlt</code>.
</p>
<p>More examples can be found in Hothorn (2018).
</p>


<h3>References</h3>

<p>Torsten Hothorn (2020), Most Likely Transformations: The mlt Package,
<em>Journal of Statistical Software</em>, <b>92</b>(1), 1â€“68,
<a href="https://doi.org/10.18637/jss.v092.i01">doi:10.18637/jss.v092.i01</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  library("survival")
  op &lt;- options(digits = 2)

  ### GBSG2 dataset
  data("GBSG2", package = "TH.data")

  ### right-censored response
  GBSG2$y &lt;- with(GBSG2, Surv(time, cens))

  ### define Bernstein(log(time)) parameterisation
  ### of transformation function. The response
  ### is bounded (log(0) doesn't work, so we use log(1))
  ### support defines the support of the Bernstein polynomial
  ### and add can be used to make the grid wider (see below)
  rvar &lt;- numeric_var("y", bounds = c(0, Inf), 
                      support = c(100, 2000))
  rb &lt;- Bernstein_basis(rvar, order = 6, ui = "increasing")
  ### dummy coding of menopausal status
  hb &lt;- as.basis(~ 0 + menostat, data = GBSG2)
  ### treatment contrast of hormonal treatment
  xb &lt;- as.basis(~ horTh, data = GBSG2, remove_intercept = TRUE)

  ### set-up and fit Cox model, stratified by menopausal status
  m &lt;- ctm(rb, interacting = hb, shifting = xb, todistr = "MinExtrVal")
  fm &lt;- mlt(m, data = GBSG2)

  ### generate grid for all three variables
  ### note that the response grid ranges between 1 (bounds[1])
  ### and 2000 (support[2])
  (d &lt;- mkgrid(m, n = 10))
  ### data.frame of menopausal status and treatment
  nd &lt;- do.call("expand.grid", d[-1])

  ### plot model on different scales, for all four combinations
  ### of menopausal status and hormonal treatment
  typ &lt;- c("distribution", "survivor", "density", "hazard", 
           "cumhazard", "odds")
  layout(matrix(1:6, nrow = 2))
  nl &lt;- sapply(typ, function(tp) 
      ### K = 500 makes densities and hazards smooth
      plot(fm, newdata = nd, type = tp, col = 1:nrow(nd), K = 500))
  legend("topleft", lty = 1, col = 1:nrow(nd), 
         legend = do.call("paste", nd), bty = "n")

  ### plot calls predict, which generates a grid with K = 50
  ### response values
  ### note that a K x nrow(newdata) matrix is returned
  ### (for reasons explained in the next example)
  predict(fm, newdata = nd, type = "survivor")

  ### newdata can take a list, and evaluates the survivor
  ### function on the grid defined by newdata 
  ### using a linear array model formulation and is 
  ### extremely efficient (wrt computing time and memory)
  ### d[1] (the response grid) varies fastest
  ### =&gt; the first dimension of predict() is always the response,
  ### not the dimension of the predictor variables (like one 
  ### might expect)
  predict(fm, newdata = d, type = "survivor")

  ### owing to this structure, the result can be quickly stored in 
  ### a data frame as follows
  cd &lt;- do.call("expand.grid", d)
  cd$surv &lt;- c(S &lt;- predict(fm, newdata = d, type = "survivor"))

  ### works for distribution functions
  all.equal(1 - S, predict(fm, newdata = d, type = "distribution"))
  ### cumulative hazard functions
  all.equal(-log(S), predict(fm, newdata = d, type = "cumhazard"))
  ### log-cumulative hazard functions (= trafo, for Cox models)
  all.equal(log(-log(S)), predict(fm, newdata = d, type = "logcumhazard"))
  all.equal(log(-log(S)), predict(fm, newdata = d, type = "trafo"))
  ### densities, hazards, or odds functions
  predict(fm, newdata = d, type = "density")
  predict(fm, newdata = d, type = "hazard")
  predict(fm, newdata = d, type = "odds")
  ### and quantiles (10 and 20%)
  predict(fm, newdata = d[-1], type = "quantile", prob = 1:2 / 10)

  ### note that some quantiles are only defined as intervals
  ### (&gt; 2000, in this case). Intervals are returned as an "response" 
  ### object, see ?R. Unfortunately, these can't be stored as array, so
  ### a data.frame is returned where the quantile varies first
  p &lt;- c(list(prob = 1:9/10), d[-1])
  np &lt;- do.call("expand.grid", p)
  (Q &lt;- predict(fm, newdata = d[-1], type = "quantile", prob = 1:9 / 10))
  np$Q &lt;- Q
  np

  ### simulating from the model works by inverting the distribution 
  ### function; some obs are right-censored at 2000
  (s &lt;- simulate(fm, newdata = nd, nsim = 3))
  ### convert to Surv
  sapply(s, as.Surv)

  ### generate 3 parametric bootstrap samples from the model
  tmp &lt;- GBSG2[, c("menostat", "horTh")]
  s &lt;- simulate(fm, newdata = tmp, nsim = 3)
  ### refit the model using the simulated response
  lapply(s, function(y) {
    tmp$y &lt;- y
    coef(mlt(m, data = tmp))
  })

  options(op)

</code></pre>


</div>