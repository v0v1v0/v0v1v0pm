<div class="container">

<table style="width: 100%;"><tr>
<td>distanceTransform</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distance transforms</h2>

<h3>Description</h3>

<p>The Euclidean distance transform produces an array like its argument, but
with element values representing the Euclidean distance to the nearest
nonzero element. The input is treated as logically binary, with all nonzero
values treated as "on", and all zeroes as "off".
</p>


<h3>Usage</h3>

<pre><code class="language-R">distanceTransform(x, ...)

## Default S3 method:
distanceTransform(x, pixdim = TRUE, signed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Any object. For the default method, this must be coercible to an
array.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pixdim</code></td>
<td>
<p>An optional numeric vector or logical value. In the former
case it will be taken as giving the physical size of the array elements of
<code>x</code> along each dimension, and these will be incorporated into the
distance calculation. If <code>TRUE</code>, the default, the <code>"pixdim"</code>
attribute of <code>x</code> will be used for this purpose, if it is present. If
<code>FALSE</code>, any such attribute will be ignored, and distances will
always be counted in array elements, with all dimensions treated equally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signed</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, the signed distance transform
is returned, such that distances from the region boundary are negative
within the region and positive outside. Otherwise, distances are zero
within the region.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An array of the same dimension as the original, whose elements give
the Euclidean distance from that element to the nearest "on" element in
the original.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>References</h3>

<p>This implementation is based on the "marching parabolas"
algorithm described by Felzenszwalb and Huttenlocher in the paper below.
</p>
<p>P.F. Felzenszwalb &amp; D.P. Huttenlocher (2012). Distance transforms of
sampled functions. Theory of Computing 8(19):415-428.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- c(0,0,1,0,0,0,1,1,1,0,0)
distanceTransform(x)
distanceTransform(x, pixdim=2)
</code></pre>


</div>