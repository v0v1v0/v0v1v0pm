<div class="container">

<table style="width: 100%;"><tr>
<td>gameOfLife</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Conway's Game of Life</h2>

<h3>Description</h3>

<p>An implementation of Conway's Game of Life, a classical cellular automaton,
using the <code>morph</code> function. The <code>gosperGliderGun</code>
function provides an interesting starting configuration.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gameOfLife(init, size, density = 0.3, steps = 200, viz = FALSE,
  tick = 0.5)

gosperGliderGun()
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>The initial state of the automaton, a binary matrix. If missing,
the initial state will be randomly generated, with a population density
given by <code>density</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>The dimensions of the board. Defaults to the size of
<code>init</code>, but must be given if that parameter is missing. If both are
specified and <code>size</code> is larger than the dimensions of <code>init</code>,
then the latter will be padded with zeroes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density</code></td>
<td>
<p>The approximate population density of the starting state.
Ignored if <code>init</code> is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>The number of generations of the automaton to simulate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>viz</code></td>
<td>
<p>If <code>TRUE</code>, the state of the system at each generation is
plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tick</code></td>
<td>
<p>The amount of time, in seconds, to pause before plotting each
successive generation. Ignored if <code>viz</code> is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Conway's Game of Life is a simple cellular automaton, based on a 2D matrix
of “cells”. It shows complex behaviour based on four simple rules. These
are:
</p>

<ol>
<li>
<p> Any live cell with fewer than two live neighbours dies, as if caused
by under-population.
</p>
</li>
<li>
<p> Any live cell with two or three live neighbours lives on to the next
generation.
</p>
</li>
<li>
<p> Any live cell with more than three live neighbours dies, as if by
overcrowding.
</p>
</li>
<li>
<p> Any dead cell with exactly three live neighbours becomes a live
cell, as if by reproduction.
</p>
</li>
</ol>
<p>Live and dead cells are represented by 1s and 0s in the matrix,
respectively.
</p>
<p>The initial state and the rules above completely determine the behaviour of
the system. The Gosper glider gun is an interesting starting configuration
that generates so-called “gliders”, which propagate across the board.
</p>
<p>In principle the size of the board in a cellular automaton is infinite. Of
course this is not easy to simulate, but this implementation adds a border
of two extra cells around the board on all sides to approximate an infinite
board slightly better. These are not visualised, nor returned in the final
state.
</p>


<h3>Value</h3>

<p>A binary matrix representing the final state of the system after
<code>steps</code> generations.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p>The <code>morph</code> function, which powers this simulation.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: gameOfLife(init=gosperGliderGun(), size=c(40,40), steps=50, viz=TRUE)
</code></pre>


</div>