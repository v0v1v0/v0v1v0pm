<div class="container">

<table style="width: 100%;"><tr>
<td>bayesRegressAssign</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regression for one or more samples, given some training data.</h2>

<h3>Description</h3>

<p>This method uses full-dependency (<code>simple=F</code>) Bayesian
inferencing to to a regression for the target features for all of the
samples given in <code>dfValid</code>. Assigns a regression value using either
</p>


<h3>Usage</h3>

<pre><code class="language-R">bayesRegressAssign(
  dfTrain,
  dfValid,
  targetCol,
  selectedFeatureNames = c(),
  shiftAmount = 0.1,
  retainMinValues = 2,
  doEcdf = FALSE,
  online = 0,
  simple = FALSE,
  useParallel = NULL,
  numBuckets = ceiling(log2(nrow(df))),
  sampleFromAllBuckets = TRUE,
  regressor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dfTrain</code></td>
<td>
<p>data.frame that holds the training data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfValid</code></td>
<td>
<p>data.frame that holds the validation samples, for each of which
a probability is sought. The convention is, that if you attempt to assign a
probability to a numeric value, it ought to be found in the target column of
this data frame (otherwise, the target column is not required in it).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targetCol</code></td>
<td>
<p>character the name of targeted feature, i.e., the feature to
assign a probability to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectedFeatureNames</code></td>
<td>
<p>character defaults to empty vector which defaults
to using all available features. Use this to select subsets of features and to
order features.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shiftAmount</code></td>
<td>
<p>numeric an offset value used to increase any one
probability (factor) in the full built equation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retainMinValues</code></td>
<td>
<p>integer to require a minimum amount of data points
when segmenting the data feature by feature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doEcdf</code></td>
<td>
<p>default FALSE a boolean to indicate whether to use the
empirical CDF to return a probability when inferencing a continuous
feature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>online</code></td>
<td>
<p>default 0 integer to indicate how many rows should be used to
do inferencing. If zero, then only the initially given data.frame dfTrain is
used. If &gt; 0, then each inferenced sample will be attached to it and the
resulting data.frame is truncated to this number. Use an integer large enough
(i.e., sum of training and validation rows) to keep all samples during
inferencing. A smaller amount as, e.g., in dfTrain, will keep the amount of data
restricted, discarding older rows. A larger amount than, e.g., in dfTrain is
also fine; dfTrain will grow to it and then discard rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simple</code></td>
<td>
<p>default FALSE boolean to indicate whether or not to use simple
Bayesian inferencing instead of full. This is faster but the results are less
good. If true, uses <code>mmb::bayesRegressSimple()</code>. Otherwise, uses
<code>mmb::bayesRegress()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useParallel</code></td>
<td>
<p>boolean DEFAULT NULL this is forwarded to the underlying
function <code>mmb::bayesRegress()</code> (only in simple=FALSE mode).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numBuckets</code></td>
<td>
<p>integer the amount of buckets to for discretization.
Buckets are built in an equidistant manner, not as quantiles (i.e., one
bucket has likely a different amount of values than another).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampleFromAllBuckets</code></td>
<td>
<p>default TRUE boolean to indicate how to
obtain values for regression from the buckets. If true, than takes
values from those buckets with a non-zero probability, and according
to their probability. If false, selects all values from the bucket
with the highest probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regressor</code></td>
<td>
<p>Function that is given the collected values for
regression and thus finally used to select a most likely value. Defaults
to the built-in estimator for the empirical PDF and returns its argmax.
However, any other function can be used, too, such as min, max, median,
average etc. You may also use this function to obtain the raw values
for further processing.#'</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Sebastian HÃ¶nel <a href="mailto:sebastian.honel@lnu.se">sebastian.honel@lnu.se</a>
</p>


<h3>See Also</h3>

<p><code>mmb::bayesRegress()</code> (full) or @seealso <code>mmb::bayesRegressSimple()</code>
if <code>simple=T</code>. It mostly forwards the given arguments to these functions,
and you will find good documentation there.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
df &lt;- iris[, ]
set.seed(84735)
rn &lt;- base::sample(rownames(df), 150)
dfTrain &lt;- df[1:120, ]
dfValid &lt;- df[121:150, ]
res &lt;- mmb::bayesRegressAssign(
  dfTrain, dfValid[, !(colnames(dfValid) %in% "Sepal.Length")],
  "Sepal.Length", sampleFromAllBuckets = TRUE, doEcdf = TRUE)
cov(res, iris[121:150,]$Sepal.Length)^2

</code></pre>


</div>