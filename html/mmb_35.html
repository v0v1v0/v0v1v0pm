<div class="container">

<table style="width: 100%;"><tr>
<td>vicinities</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Segment a dataset by each row once, then compute vicinities of
samples in the neighborhood.</h2>

<h3>Description</h3>

<p>Given an entire dataset, uses each instance in it to demarcate
a neighborhood using the selected features. Then, for each neighborhood,
the vicinity of all samples to it is computed. The result of this is an
N x N matrix, where the entry <code class="reqn">m_{i,j}</code> corresponds to the vicinity of
sample <code class="reqn">s_j</code> in neighborhood <code class="reqn">N_i</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">vicinities(
  df,
  selectedFeatureNames = c(),
  shiftAmount = 0.1,
  doEcdf = FALSE,
  ecdfMinusOne = FALSE,
  retainMinValues = 0,
  useParallel = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>data.frame to compute the matrix of vicinites for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectedFeatureNames</code></td>
<td>
<p>vector of names of features to use for computing
the vicinity/centrality of each sample to each neighborhood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shiftAmount</code></td>
<td>
<p>numeric DEFAULT 0.1 optional amount to shift each features
probability by. This is useful for when the centrality not necessarily must be
an actual probability and too many features are selected. To obtain actual
probabilities, this needs to be 0, and you must use the ECDF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doEcdf</code></td>
<td>
<p>boolean DEFAULT FALSE whether to use the ECDF instead of the EPDF
to find the likelihood of continuous values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ecdfMinusOne</code></td>
<td>
<p>boolean DEFAULT FALSE only has an effect if the ECDF is
used. If true, uses 1 minus the ECDF to find the probability of a continuous
value. Depending on the interpretation of what you try to do, this may be of use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retainMinValues</code></td>
<td>
<p>DEFAULT 0 the amount of samples to retain during
segmentation. For separating a neighborhood, this value typically should
be 0, so that no samples are included that are not within it. However,
for very sparse data or a great amount of variables, it might still make
sense to retain samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useParallel</code></td>
<td>
<p>boolean DEFAULT NULL whether to use parallelism or not. Setting this to
true requires also having previously registered a parallel backend. If parallel
computing is enabled, then each neighborhood is computed separately.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>matrix of length <code class="reqn">N^2</code> (N being the length of the data.frame). Each
row i demarcates the neighborhood as selected by sample i, and each column j then
is the vicinity of sample <code class="reqn">s_j</code> to that neighborhood. No value of the diagonal
is zero, because each neighborhood always contains the sample it was demarcated
by, and that sample has a similarity greater than zero to it.
</p>


<h3>Author(s)</h3>

<p>Sebastian HÃ¶nel <a href="mailto:sebastian.honel@lnu.se">sebastian.honel@lnu.se</a>
</p>


<h3>See Also</h3>

<p><code>vicinitiesForSample()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">w &lt;- mmb::getWarnings()
mmb::setWarnings(FALSE)
mmb::vicinities(df = iris[1:10,])

# Run the same, but use the ECDF and retain more values:
mmb::vicinities(df = iris[1:10,], doEcdf = TRUE, retainMinValues = 10)
mmb::setWarnings(w)
</code></pre>


</div>