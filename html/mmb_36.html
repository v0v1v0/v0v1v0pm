<div class="container">

<table style="width: 100%;"><tr>
<td>vicinitiesForSample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Segment a dataset by a single sample and compute vicinities for it and
the remaining samples in the neighborhood.</h2>

<h3>Description</h3>

<p>Given some data and one sample <code class="reqn">s_i</code> from it, constructs the
neighborhood <code class="reqn">N_i</code> of that sample and assigns centralities to all other
samples in that neighborhood to it. Samples that lie outside the neighborhood
are assigned a vicinity of zero. Uses <code>mmb::neighborhood()</code> and
<code>mmb::centralities()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">vicinitiesForSample(
  df,
  sampleFromDf,
  selectedFeatureNames = c(),
  shiftAmount = 0.1,
  doEcdf = FALSE,
  ecdfMinusOne = FALSE,
  retainMinValues = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>data.frame that holds the data (and also the sample to use to define
the neighborhood). Each sample in this data.frame is assigned a vicinity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampleFromDf</code></td>
<td>
<p>data.frame a single row from the given data.frame. This is
used to select a neighborhood from the given data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectedFeatureNames</code></td>
<td>
<p>vector of names of features to use to compute the
vicinity/centrality. This is passed to <code>mmb::neighborhood()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shiftAmount</code></td>
<td>
<p>numeric DEFAULT 0.1 optional amount to shift each features
probability by. This is useful for when the centrality not necessarily must be
an actual probability and too many features are selected. To obtain actual
probabilities, this needs to be 0, and you must use the ECDF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doEcdf</code></td>
<td>
<p>boolean DEFAULT FALSE whether to use the ECDF instead of the EPDF
to find the likelihood of continuous values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ecdfMinusOne</code></td>
<td>
<p>boolean DEFAULT FALSE only has an effect if the ECDF is
used. If true, uses 1 minus the ECDF to find the probability of a continuous
value. Depending on the interpretation of what you try to do, this may be of use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retainMinValues</code></td>
<td>
<p>DEFAULT 0 the amount of samples to retain during
segmentation. For separating a neighborhood, this value typically should
be 0, so that no samples are included that are not within it. However,
for very sparse data or a great amount of variables, it might still make
sense to retain samples.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>data.frame with a single column 'vicinity' and the same rownames as the
given data.frame. Each row then holds the vicinity for the corresponding row.
</p>


<h3>Author(s)</h3>

<p>Sebastian HÃ¶nel <a href="mailto:sebastian.honel@lnu.se">sebastian.honel@lnu.se</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">vic &lt;- mmb::vicinitiesForSample(
  df = iris, sampleFromDf = iris[1,], shiftAmount = 0.1)
vic$vicinity

# Plot the ordered samples to get an idea which ones have a vicinity &gt; 0
plot(x=rownames(vic), y=vic$vicinity)
</code></pre>


</div>