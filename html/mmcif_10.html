<div class="container">

<table style="width: 100%;"><tr>
<td>mmcif_sandwich</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computes the Sandwich Estimator</h2>

<h3>Description</h3>

<p>Computes the sandwich estimator of the covariance matrix. The parameter that
is passed is using the log Cholesky decomposition. The Hessian is computed
using numerical differentiation with Richardson extrapolation to refine the
estimate.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mmcif_sandwich(
  object,
  par,
  ghq_data = object$ghq_data,
  n_threads = 1L,
  eps = 0.01,
  scale = 2,
  tol = 1e-08,
  order = 3L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object from <code>mmcif_data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>numeric vector with the parameters to compute the sandwich
estimator at.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ghq_data</code></td>
<td>
<p>the Gauss-Hermite quadrature nodes and weights to
use. It should be a list with two elements called <code>"node"</code>
and <code>"weight"</code>. A default is provided if <code>NULL</code> is passed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_threads</code></td>
<td>
<p>the number of threads to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>determines the step size in the numerical differentiation using
<code>max(sqrt(.Machine$double.eps), |par[i]| * eps)</code>
for each parameter <code>i</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>scaling factor in the Richardson extrapolation. Each step is
smaller by a factor <code>scale</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>relative convergence criteria in the extrapolation given
by <code>max(tol, |g[i]| * tol)</code> with <code>g</code> being the gradient and for
each parameter <code>i</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>maximum number of iteration of the Richardson extrapolation.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The sandwich estimator along attributes called
</p>

<ul>
<li> <p><code>"meat"</code> for the "meat" of the sandwich estimator.
</p>
</li>
<li> <p><code>"hessian"</code> for the Hessian of the log composite likelihood.
</p>
</li>
<li> <p><code>"res vcov"</code> which is the sandwich estimator where the
last elements are the upper triangle of the covariance matrix of the random
effects rather than the log Cholesky decomposition of the matrix.
</p>
</li>
</ul>
<h3>References</h3>

<p>Cederkvist, L., Holst, K. K., Andersen, K. K., &amp;
Scheike, T. H. (2019).
<em>Modeling the cumulative incidence function of multivariate competing
risks data allowing for within-cluster dependence of risk and timing</em>.
Biostatistics, Apr 1, 20(2), 199-217.
</p>


<h3>See Also</h3>

<p><code>mmcif_fit</code> and <code>mmcif_data</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(require(mets)){
  # prepare the data
  data(prt)

  # truncate the time
  max_time &lt;- 90
  prt &lt;- within(prt, {
    status[time &gt;= max_time] &lt;- 0
    time &lt;- pmin(time, max_time)
  })

  # select the DZ twins and re-code the status
  prt_use &lt;- subset(prt, zyg == "DZ") |&gt;
    transform(status = ifelse(status == 0, 3L, status))

  # randomly sub-sample
  set.seed(1)
  prt_use &lt;- subset(
    prt_use, id %in% sample(unique(id), length(unique(id)) %/% 10L))

  n_threads &lt;- 2L
  mmcif_obj &lt;- mmcif_data(
    ~ country - 1, prt_use, status, time, id, max_time,
    2L, strata = country)

  # get the staring values
  start_vals &lt;- mmcif_start_values(mmcif_obj, n_threads = n_threads)

  # estimate the parameters
  ests &lt;- mmcif_fit(start_vals$upper, mmcif_obj, n_threads = n_threads)

  # get the sandwich estimator
  vcov_est &lt;- mmcif_sandwich(
    mmcif_obj, ests$par, n_threads = n_threads, order = 2L)

  # show the parameter estimates along with the standard errors
  rbind(Estimate = ests$par,
        SE = sqrt(diag(vcov_est))) |&gt;
    print()

  # show the upper triangle of the covariance matrix and the SEs
  rbind(`Estimate (vcov)` = tail(ests$par, 10) |&gt; log_chol_inv() |&gt;
          (\(x) x[upper.tri(x, TRUE)])() ,
        SE = attr(vcov_est, "res vcov") |&gt; diag() |&gt; sqrt() |&gt; tail(10)) |&gt;
    print()
}

</code></pre>


</div>