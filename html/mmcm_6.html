<div class="container">

<table style="width: 100%;"><tr>
<td>mmcm.resamp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The permuted modified maximum contrast method</h2>

<h3>Description</h3>

<p>This function gives <code class="reqn">P</code>-value for the permuted modified maximum
contrast method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mmcm.resamp(
  x,
  g,
  contrast,
  alternative = c("two.sided", "less", "greater"),
  nsample = 20000,
  abseps = 0.001,
  seed = NULL,
  nthread = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector of data values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>a integer vector giving the group for the corresponding elements of x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrast</code></td>
<td>
<p>a numeric contrast coefficient matrix for permuted modified
maximum contrast statistics</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of "two.sided" (default), "greater" or "less".
You can specify just the initial letter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsample</code></td>
<td>
<p>specifies the number of resamples (default: 20000)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abseps</code></td>
<td>
<p>specifies the absolute error tolerance (default: 0.001)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>a single value, interpreted as an integer;
see <code>set.seed()</code> function. (default: NULL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthread</code></td>
<td>
<p>sthe number of threads used in parallel computing, or FALSE 
that means single threading (default: 2)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>mmcm.resamp</code> performs the permuted modified maximum contrast
method that is detecting a true response pattern under the unequal sample size
situation.
</p>
<p><code class="reqn">Y_{ij} (i=1, 2, \ldots; j=1, 2, \ldots, n_i)</code> is an observed response for <code class="reqn">j</code>-th individual in
<code class="reqn">i</code>-th group.
</p>
<p><code class="reqn">\bm{C}</code> is coefficient matrix for permuted modified maximum contrast
statistics (<code class="reqn">i \times k</code> matrix, <code class="reqn">i</code>: No. of groups, <code class="reqn">k</code>:
No. of pattern).
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{C}=(\bm{c}_1, \bm{c}_2, \ldots, \bm{c}_k)^{\rm{T}}
</code>
</p>

<p><code class="reqn">\bm{c}_k</code> is coefficient vector of <code class="reqn">k</code>-th pattern.
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{c}_k=(c_{k1}, c_{k2}, \ldots, c_{ki})^{\rm{T}} \qquad (\textstyle \sum_i c_{ki}=0)
</code>
</p>

<p><code class="reqn">M_{\max}</code> is a permuted modified maximum contrast statistic.
</p>
<p style="text-align: center;"><code class="reqn">
  \bar{Y}_i=\frac{\sum_{j=1}^{n_i} Y_{ij}}{n_{i}},
  \bar{\bm{Y}}=(\bar{Y}_1, \bar{Y}_2, \ldots, \bar{Y}_i, \ldots, \bar{Y}_a)^{\rm{T}},
  M_{k}=\frac{\bm{c}^t_k \bar{\bm{Y}}}{\sqrt{\bm{c}^t_k \bm{c}_k}},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
  M_{\max}=\max(M_1, M_2, \ldots, M_k).
</code>
</p>

<p>Consider testing the overall null hypothesis <code class="reqn">H_0: \mu_1=\mu_2=\ldots=\mu_i</code>,
versus alternative hypotheses <code class="reqn">H_1</code> for response petterns 
(<code class="reqn">H_1: \mu_1&lt;\mu_2&lt;\ldots&lt;\mu_i, \mu_1=\mu_2&lt;\ldots&lt;\mu_i,
\mu_1&lt;\mu_2&lt;\ldots=\mu_i</code>).
The <code class="reqn">P</code>-value for the probability distribution of <code class="reqn">M_{\max}</code>
under the overall null hypothesis is
</p>
<p style="text-align: center;"><code class="reqn">
  P\mbox{-value}=\Pr(M_{\max}&gt;m_{\max} \mid H_0)
</code>
</p>

<p><code class="reqn">m_{\max}</code> is observed value of statistics.
This function gives distribution of <code class="reqn">M_{\max}</code> by using the
permutation method, follow algorithm:
</p>
<p>1. Initialize counting variable: <code class="reqn">COUNT = 0</code>.
Input parameters: <code class="reqn">NRESAMPMIN</code> (minimum resampling count,
we set 1000), <code class="reqn">NRESAMPMAX</code> (maximum resampling count), and
<code class="reqn">\epsilon</code> (absolute error tolerance).
</p>
<p>2. Calculate <code class="reqn">m_{\max}</code> that is the observed value of the test
statistic.
</p>
<p>3. Let <code class="reqn">y_{ij}^{(r)}</code> donate data, which are sampled without
replacement, and independently, form observed value <code class="reqn">y_{ij}</code>.
Where, <code class="reqn">(r)</code> is suffix of the resampling number
<code class="reqn">(r = 1,\, 2,\, \ldots)</code>.
</p>
<p>4. Calculate <code class="reqn">m^{(r)}_{\max}</code> from <code class="reqn">y_{ij}^{(r)}</code>.
If <code class="reqn">m^{(r)}_{\max} &gt; m_{\max}</code>, then increment the
counting variable: <code class="reqn">COUNT = COUNT + 1</code>. Calculate
approximate P-value <code class="reqn">\hat{p}^{(r)}=COUNT/r</code>, and
the simulation standard error <code class="reqn">SE(\hat{p}^{(r)})=\sqrt{\hat{p}^{(r)}(1-
\hat{p}^{(r)})/r}</code>.
</p>
<p>5. Repeat 3–4, while <code class="reqn">r &gt; 1000</code> and <code class="reqn">3.5SE(\hat{p}^{(r)})
&lt; \epsilon</code> (corresponding to 99% confidence
level), or <code class="reqn">NRESAMPMAX</code> times. Output the approximate P-value
<code class="reqn">\hat{p}^{(r)}</code>.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>the value of the test statistic with a name describing it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the type of test applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrast</code></td>
<td>
<p>a character string giving the names of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrast.index</code></td>
<td>
<p>a suffix of coefficient vector of the <code class="reqn">k</code>th pattern
that gives permuted modified maximum contrast statistics (row number of the
coefficient matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error</code></td>
<td>
<p>estimated absolute error and,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msg</code></td>
<td>
<p>status messages.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Nagashima, K., Sato, Y., Hamada, C. (2011).
A modified maximum contrast method for unequal sample sizes in
pharmacogenomic studies
<em>Stat Appl Genet Mol Biol.</em> <strong>10</strong>(1): Article 41.
<a href="http://dx.doi.org/10.2202/1544-6115.1560">http://dx.doi.org/10.2202/1544-6115.1560</a>
</p>
<p>Sato, Y., Laird, N.M., Nagashima, K., et al. (2009).
A new statistical screening approach for finding pharmacokinetics-related
genes in genome-wide studies.
<em>Pharmacogenomics J.</em> <strong>9</strong>(2): 137–146.
<a href="http://www.ncbi.nlm.nih.gov/pubmed/19104505">http://www.ncbi.nlm.nih.gov/pubmed/19104505</a>
</p>


<h3>See Also</h3>

<p><code>mmcm.mvt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example 1 ##
#  true response pattern: dominant model c=(1, 1, -2)
set.seed(136885)
x &lt;- c(
  rnorm(130, mean =  1 / 6, sd = 1),
  rnorm( 90, mean =  1 / 6, sd = 1),
  rnorm( 10, mean = -2 / 6, sd = 1)
)
g &lt;- rep(1:3, c(130, 90, 10))
boxplot(
  x ~ g,
  width = c(length(g[g==1]), length(g[g==2]), length(g[g==3])),
  main  = "Dominant model (sample data)",
  xlab  = "Genotype", ylab="PK parameter"
)

# coefficient matrix
# c_1: additive, c_2: recessive, c_3: dominant
contrast &lt;- rbind(
  c(-1, 0, 1), c(-2, 1, 1), c(-1, -1, 2)
)
y &lt;- mmcm.resamp(x, g, contrast, nsample = 20000,
                 abseps = 0.01, seed = 5784324)
y

## Example 2 ##
#  for dataframe
#  true response pattern:
#    pos = 1 dominant  model c=( 1,  1, -2)
#          2 additive  model c=(-1,  0,  1)
#          3 recessive model c=( 2, -1, -1)
set.seed(3872435)
x &lt;- c(
  rnorm(130, mean =  1 / 6, sd = 1),
  rnorm( 90, mean =  1 / 6, sd = 1),
  rnorm( 10, mean = -2 / 6, sd = 1),
  rnorm(130, mean = -1 / 4, sd = 1),
  rnorm( 90, mean =  0 / 4, sd = 1),
  rnorm( 10, mean =  1 / 4, sd = 1),
  rnorm(130, mean =  2 / 6, sd = 1),
  rnorm( 90, mean = -1 / 6, sd = 1),
  rnorm( 10, mean = -1 / 6, sd = 1)
)
g   &lt;- rep(rep(1:3, c(130, 90, 10)), 3)
pos &lt;- rep(c("rsXXXX", "rsYYYY", "rsZZZZ"), each = 230)
xx  &lt;- data.frame(pos = pos, x = x, g = g)

# coefficient matrix
# c_1: additive, c_2: recessive, c_3: dominant
contrast &lt;- rbind(
  c(-1, 0, 1), c(-2, 1, 1), c(-1, -1, 2)
)

y &lt;- by(xx, xx$pos, function(x) mmcm.resamp(x$x, x$g,
  contrast, abseps = 0.02, nsample = 10000))
y &lt;- do.call(rbind, y)[,c(3,7,9)]
y
</code></pre>


</div>