<div class="container">

<table style="width: 100%;"><tr>
<td>marginalPrediction</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>marginalizes prediction functions</h2>

<h3>Description</h3>

<p>monte-carlo integration of prediction functions
</p>


<h3>Usage</h3>

<pre><code class="language-R">marginalPrediction(data, vars, n, model, uniform = TRUE, points,
  int.points, aggregate.fun = function(x) sum(x)/length(x),
  predict.fun = function(object, newdata) predict(object, newdata =
  newdata), weight.fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a <code>data.frame</code> which contains the columns specified by <code>vars</code> and at least one additional column. should correspond to the set of columns used to train the <code>model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>a character vector corresponding to a strict subset of the columns in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>an integer vector of length two giving the resolution of the uniform or random grid on <code>vars</code> for the first element, and the number of the rows of the <code>data</code> to be sampled without replacement for the second element.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>an object which can be passed to <code>predict.fun</code> to compute predictions. presumably this object represents a model fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uniform</code></td>
<td>
<p>logical indicating whether to create the grid on <code>vars</code> uniformly or to sample without replacement from the empirical distribution of those <code>vars</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>
<p>a named list which gives specific points for <code>vars</code>. specifying this argument overrides <code>uniform</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.points</code></td>
<td>
<p>a integer vector giving indices of the points in <code>data</code> to marginalize over.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate.fun</code></td>
<td>
<p>what function to aggregate the predictions with. this function takes a single argument <code>x</code> and returns a vector. the default is <code>sum(x) / length(x)</code>. If <code>weight.fun</code> is used, this function must also take a numeric parameter <code>w</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict.fun</code></td>
<td>
<p>what function to generate predictions using <code>model</code>. default is the predict method for <code>model</code>. this function must have two arguments, <code>object</code> and <code>newdata</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.fun</code></td>
<td>
<p>a function to construct weights for <code>aggregate.fun</code>. this allows Monte-Carlo integration on a grid without assuming a uniform distribution for said grid. the function should take two arguments, <code>design</code> and <code>data</code>, both of which are <code>data.frame</code>s of the same column (but different row) dimension, and should return a numeric vector of the same length as the number of rows in <code>design</code>. If this argument is used <code>aggregate.fun</code> must also have an argument <code>w</code> which is the result of <code>weight.fun</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a <code>data.table</code> with columns for predictions and <code>vars</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">X = replicate(3, rnorm(100))
y = X %*% runif(3)
data = data.frame(X, y)
fit = lm(y ~ ., data)

marginalPrediction(data.frame(X), "X2", c(10, 25), fit,
  aggregate.fun = function(x) c("mean" = mean(x), "variance" = var(x)))
</code></pre>


</div>