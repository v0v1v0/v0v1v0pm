<div class="container">

<table style="width: 100%;"><tr>
<td>coocmetric</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Metrics for Point Process Realizations Based on Co-occurrence</h2>

<h3>Description</h3>

<p>For comparing two SPP realizations, it is natural to count the number of events which can be considered to be co-occurring. There are two metrics for SPP realizations based on the notion of co-occurrence.
The first one proposed by Quian Quiroga et al. (2002) directly counts near-by events. The second counting metric co-occurrence is proposed by Hunter and Milton (2003), which is based on a smoothing function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">coocmetric(S1, S2, measure = "sim", type = "count", tau = 1, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S1</code></td>
<td>
<p>marked point process data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S2</code></td>
<td>
<p>marked point process data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measure</code></td>
<td>
<p><code>"sim"</code> for similarity and "dist" for distance. Default <code>"sim"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>if <code>"count"</code>, counting near-by event measure by Quian is computed. If <code>"smooth"</code>, smoothed counting co-occurrence measure by Hunter and Milton is computed. Default <code>"count"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>a parameter for filtering function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>a precision matrix for filter of marks, i.e., exp( - r' M r) is used for filtering marks. It should be symmetric and positive semi-definite.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>coocmetric</code> computes co-occurrence base metrics for two point process realizations. This function counts the number of events in S1 which is coincided with those in S2, and vice versa.
</p>


<h3>Value</h3>

<p>Similarity or distance between two inputs (marked) point process S1 and S2.
</p>


<h3>Author(s)</h3>

<p>Hideitsu Hino <a href="mailto:hinohide@cs.tsukuba.ac.jp">hinohide@cs.tsukuba.ac.jp</a>, Ken Takano, Yuki Yoshikawa, and Noboru Murata
</p>


<h3>References</h3>

<p>R. Quian Quiroga, T. Kreuz, and P. Grassberger. Event synchronization: a simple and fast method to measure synchronicity and time delay patterns, Physical Review E, Vol. 66(4), 041904, 2002.
</p>
<p>J. D. Hunter and G. Milton. Amplitude and frequency dependence of spike timing: implications for dynamic regulation, Journal of Neurophysiology, Vol. 90, pp. 387-94, 2003.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## The aftershock data of 26th July 2003 earthquake of M6.2 at the northern Miyagi-Ken Japan.
data(Miyagi20030626)
## time longitude latitude depth magnitude
## split events by 7-hour
sMiyagi &lt;- splitMPP(Miyagi20030626,h=60*60*7,scaleMarks=TRUE)$S
N &lt;- 10
sMat &lt;- matrix(0,N,N)
tau&lt;-0.2
  cat("calculating coocmetric(smooth)...")
 for(i in 1:(N)){
   cat(i," ")
   for(j in i:N){
     S1 &lt;- sMiyagi[[i]]$time;S2 &lt;- sMiyagi[[j]]$time
    sMat[i,j] &lt;- coocmetric(S1,S2,type="smooth",tau=tau,M=diag(1,4))
   }
 }
 sMat &lt;- sMat+t(sMat)
 tmpd &lt;- diag(sMat) &lt;- diag(sMat)/2
 sMat &lt;- sMat/sqrt(outer(tmpd,tmpd))
image(sMat)
</code></pre>


</div>