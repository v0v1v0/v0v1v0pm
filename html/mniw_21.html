<div class="container">

<table style="width: 100%;"><tr>
<td>MNIW-dist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate samples from the Matrix-Normal Inverse-Wishart distribution.</h2>

<h3>Description</h3>

<p>Generate samples from the Matrix-Normal Inverse-Wishart distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rMNIW(n, Lambda, Sigma, Psi, nu, prec = FALSE)

rmniw(n, Lambda, Omega, Psi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda</code></td>
<td>
<p>A mean matrix of size <code style="white-space: pre;">⁠p x q⁠</code> or an array of size <code style="white-space: pre;">⁠p x q x n⁠</code>.  Defaults to matrix of zeros when missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>A row-wise variance or precision matrix of size <code style="white-space: pre;">⁠p x p⁠</code>, or an array of size <code style="white-space: pre;">⁠p x p x n⁠</code>.  Defaults to the identity matrix when missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Psi</code></td>
<td>
<p>A scale matrix of size <code style="white-space: pre;">⁠q x q⁠</code>, or an array of size <code style="white-space: pre;">⁠q x q x n⁠</code>.  Defaults to identity matrix when missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>Scalar degrees-of-freedom parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prec</code></td>
<td>
<p>Logical; whether or not <code>Sigma</code> is on the variance or precision scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Omega</code></td>
<td>
<p>A between-row precision matrix of size <code style="white-space: pre;">⁠p x p⁠</code>, or an array of size <code style="white-space: pre;">⁠p x p x n⁠</code>.  Defaults to the identity matrix when missing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Matrix-Normal Inverse-Wishart (MNIW) distribution <code class="reqn">(\boldsymbol{X}, \boldsymbol{V}) \sim \textrm{MNIW}(\boldsymbol{\Lambda}, \boldsymbol{\Sigma}, \boldsymbol{\Psi}, \nu)</code> on random matrices <code class="reqn">\boldsymbol{X}_{p \times q}</code> and symmetric positive-definite <code class="reqn">\boldsymbol{V}_{q\times q}</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
\begin{array}{rcl}
\boldsymbol{V} &amp; \sim &amp; \textrm{Inverse-Wishart}(\boldsymbol{\Psi}, \nu) \\
\boldsymbol{X} \mid \boldsymbol{V} &amp; \sim &amp; \textrm{Matrix-Normal}(\boldsymbol{\Lambda}, \boldsymbol{\Sigma}, \boldsymbol{V}),
\end{array}
</code>
</p>

<p>where the Matrix-Normal distribution is defined as the multivariate normal
</p>
<p style="text-align: center;"><code class="reqn">
\textrm{vec}(\boldsymbol{X}) \sim \mathcal{N}(\textrm{vec}(\boldsymbol{\Lambda}), \boldsymbol{V} \otimes \boldsymbol{\Sigma}),
</code>
</p>

<p>where <code class="reqn">\textrm{vec}(\boldsymbol{X})</code> is a vector stacking the columns of <code class="reqn">\boldsymbol{X}</code>, and <code class="reqn">\boldsymbol{V} \otimes \boldsymbol{\Sigma}</code> denotes the Kronecker product.
</p>
<p><code>rmniw()</code> is a convenience wrapper to <code>rMNIW(Sigma = Omega, prec = TRUE)</code>, for the common situation in Bayesian inference with conjugate priors when between-row variances are naturally parametrized on the precision scale.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<dl>
<dt><code>X</code></dt>
<dd>
<p>Array of size <code style="white-space: pre;">⁠p x q x n⁠</code> random samples from the Matrix-Normal component (see Details).</p>
</dd>
<dt><code>V</code></dt>
<dd>
<p>Array of size <code style="white-space: pre;">⁠q x q x n⁠</code> of random samples from the Inverse-Wishart component.</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R"># problem dimensions
p &lt;- 2
q &lt;- 3
n &lt;- 10 # number of samples
# parameter specification
Lambda &lt;- matrix(rnorm(p*q),p,q) # single argument
Sigma &lt;- rwish(n, Psi = diag(p), nu = p + rexp(1)) # vectorized argument
Psi &lt;- rwish(n = 1, Psi = diag(q), nu = q + rexp(1)) # single argument
nu &lt;- q + rexp(1)
# simulate n draws
rMNIW(n, Lambda = Lambda, Sigma = Sigma, Psi = Psi, nu = nu)
</code></pre>


</div>