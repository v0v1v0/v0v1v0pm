<div class="container">

<table style="width: 100%;"><tr>
<td>RxNormLM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian inference for a random-effects regression model.</h2>

<h3>Description</h3>

<p>Gibbs sampler for posterior distribution of parameters and hyperparameters of a multivariate normal random-effects linear regression model called RxNormLM (see Details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">RxNormLM(
  nsamples,
  Y,
  V,
  X,
  prior = NULL,
  init,
  burn,
  updateHyp = TRUE,
  storeHyp = TRUE,
  updateRX = TRUE,
  storeRX = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>nsamples</code></td>
<td>
<p>number of posterior samples to draw.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p><code style="white-space: pre;">⁠N x q⁠</code> matrix of responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>Either a <code style="white-space: pre;">⁠q x q⁠</code> variance matrix or an <code style="white-space: pre;">⁠q x q x N⁠</code> array of such matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code style="white-space: pre;">⁠N x p⁠</code> matrix of covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>parameters of the prior MNIW distribution on the hyperparameters (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>(optional) list with elements <code>Beta</code>, <code>Sigma</code>, and <code>Mu</code> providing the initial values for these.  Default values are <code>Beta = matrix(0, p, q)</code>, <code>Sigma = diag(q)</code>, and <code>Mu = Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>
<p>integer number of burn-in samples, or fraction of <code>nsamples</code> to prepend as burn-in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>updateHyp, storeHyp</code></td>
<td>
<p>logical. Whether or not to update/store the hyperparameter draws.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>updateRX, storeRX</code></td>
<td>
<p>logical. Whether or not to update/store the random-effects draws.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The RxNormLM model is given by
</p>
<p style="text-align: center;"><code class="reqn">
y_i \mid \mu_i \sim_iid N(\mu_i, V_i)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\mu_i \mid \beta, \Sigma ~sim_ind N(x_i' \beta, \Sigma)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\beta, \Sigma ~ MNIW(\Lambda, \Omega^{-1}, \Psi, \nu),
</code>
</p>

<p>where <code class="reqn">y_i</code> and <code class="reqn">\mu_i</code> are response and random-effects vectors of length <code class="reqn">q</code>, <code class="reqn">x_i</code> are covariate vectors of length <code class="reqn">p</code>, and <code class="reqn">(\beta, \Sigma)</code> are hyperparameter matrices of size <code class="reqn">p \times q</code> and <code class="reqn">q \times q</code>.
</p>
<p>The MNIW prior distribution is given by a list with elements <code>Lambda</code>, <code>Omega</code>, <code>Psi</code>, and <code>nu</code>.  If any of these is <code>NULL</code> or missing, the default value is 0.  Note that <code>Omega == 0</code> gives a Lebesgue prior to <code class="reqn">\beta</code>.
</p>


<h3>Value</h3>

<p>A list with (potential) elements:
</p>

<dl>
<dt><code>Beta</code></dt>
<dd>
<p>An <code style="white-space: pre;">⁠p x q x nsamples⁠</code> array of regression coefficient iterations (if <code>storeHyp == TRUE</code>)</p>
</dd>
<dt><code>Sigma</code></dt>
<dd>
<p>An <code style="white-space: pre;">⁠q x q x nsamples⁠</code> array of regression variance matrices (if <code>storeHyp == TRUE</code>)</p>
</dd>
<dt><code>Mu</code></dt>
<dd>
<p>An <code style="white-space: pre;">⁠n x q x nsamples⁠</code> array of random effects (if <code>storeRX == TRUE</code>)</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R"># problem dimensions
n &lt;- sample(10:20,1) # number of observations
p &lt;- sample(1:4,1) # number of covariates
q &lt;- sample(1:4,1) # number of responses

# hyperparameters
Lambda &lt;- rMNorm(1, Lambda = matrix(0, p, q))
Omega &lt;- crossprod(rMNorm(1, Lambda = matrix(0, p, p)))
Psi &lt;- crossprod(rMNorm(1, Lambda = matrix(0, q, q)))
nu &lt;- rexp(1) + (q+1)
prior &lt;- list(Lambda = Lambda, Omega = Omega, Psi = Psi, nu = nu)

# random-effects parameters
BSig &lt;- rmniw(1, Lambda = Lambda, Omega = Omega, Psi = Psi, nu = nu)
Beta &lt;- BSig$X
Sigma &lt;- BSig$V

# design matrix
X &lt;- rMNorm(1, matrix(0, n, p))

# random-effects themselves
Mu &lt;- rmNorm(n, X %*% Beta, Sigma)

# generate response data
V &lt;- rwish(n, Psi = diag(q), nu = q+1) # error variances
Y &lt;- rmNorm(n, mu = Mu, Sigma = V) # responses

# visual checks for each component of Gibbs sampler

# sample from p(Mu | Beta, Sigma, Y)
nsamples &lt;- 1e5
out &lt;- RxNormLM(nsamples,
                Y = Y, V = V, X = X,
                prior = prior,
                init = list(Beta = Beta, Sigma = Sigma, Mu = Mu),
                burn = floor(nsamples/10),
                updateHyp = FALSE,
                storeHyp = FALSE,
                updateRX = TRUE,
                storeRX = TRUE)

# conditional distribution is RxNorm:
iObs &lt;- sample(n, 1) # pick an observation at random
# calculate the RxNorm parameters
G &lt;- Sigma %*% solve(V[,,iObs] + Sigma)
xB &lt;- c(X[iObs,,drop=FALSE] %*% Beta)
muRx &lt;- G %*% (Y[iObs,] - xB) + xB
SigmaRx &lt;- G %*% V[,,iObs]

# a' * mu_i is univariate normal with known mean and variance:
a &lt;- rnorm(q) # arbitrary vector
amui &lt;- crossprod(a, out$Mu[iObs,,]) # a' * mu_i

hist(amui, breaks = 100, freq = FALSE,
     xlab = "", main = expression("Histogram of "*a^T*mu[i]))
curve(dnorm(x, mean = sum(a * muRx),
            sd = sqrt(crossprod(a, SigmaRx %*% a)[1])),
      add = TRUE, col = "red")
legend("topright",
       legend = c("Observed", "Expected"),
       lwd = c(NA, 2), pch = c(22, NA), seg.len = 1.5,
       col = c("black", "red"), bg = c("white", NA))



# sample from p(Beta, Sigma | Mu, Y)
nsamples &lt;- 1e5
out &lt;- RxNormLM(nsamples,
                Y = Y, V = V, X = X,
                prior = prior,
                init = list(Beta = Beta, Sigma = Sigma, Mu = Mu),
                burn = floor(nsamples/10),
                updateHyp = TRUE,
                storeHyp = TRUE,
                updateRX = FALSE,
                storeRX = FALSE)


# conditional distribution is MNIW:
# calculate the MNIW parameters
OmegaHat &lt;- crossprod(X) + Omega
LambdaHat &lt;- solve(OmegaHat, crossprod(X, Mu) + Omega %*% Lambda)
PsiHat &lt;- Psi + crossprod(Mu) + crossprod(Lambda, Omega %*% Lambda)
PsiHat &lt;- PsiHat - crossprod(LambdaHat, OmegaHat %*% LambdaHat)
nuHat &lt;- nu + n

# a' Sigma^{-1} a is chi^2 with known parameters:
a &lt;- rnorm(q)
aSiga &lt;- drop(crossprodV(a, V = out$Sigma, inverse = TRUE))
sigX &lt;- crossprod(a, solve(PsiHat, a))[1]
hist(aSiga, breaks = 100, freq = FALSE,
     xlab = "", main = expression("Histogram of "*a^T*Sigma^{-1}*a))
curve(dchisq(x/sigX, df = nuHat)/sigX, add = TRUE, col = "red")
legend("topright",
       legend = c("Observed", "Expected"),
       lwd = c(NA, 2), pch = c(22, NA), seg.len = 1.5,
       col = c("black", "red"), bg = c("white", NA))

# a' Beta b is student-t with known parameters:
a &lt;- rnorm(p)
b &lt;- rnorm(q)
# vectorized calculations
aBetab &lt;- crossprodV(X = aperm(out$Beta, c(2,1,3)),
                     Y = b, V = diag(q)) # Beta b
aBetab &lt;- drop(crossprodV(X = a, Y = aBetab, V = diag(p))) # a' Beta b
# student-t parameters
muT &lt;- crossprod(a, LambdaHat %*% b)[1]
nuT &lt;- nuHat-q+1
sigmaT &lt;- crossprodV(a, V = OmegaHat, inverse = TRUE)[1]
sigmaT &lt;- sigmaT * crossprodV(b, V = PsiHat)[1]
sigmaT &lt;- sqrt(sigmaT / nuT)

hist(aBetab, breaks = 100, freq = FALSE,
     xlab = "", main = expression("Histogram of "*a^T*Beta*a))
curve(dt((x-muT)/sigmaT, df = nuT)/sigmaT, add = TRUE, col = "red")
legend("topright",
       legend = c("Observed", "Expected"),
       lwd = c(NA, 2), pch = c(22, NA), seg.len = 1.5,
       col = c("black", "red"), bg = c("white", NA))

</code></pre>


</div>