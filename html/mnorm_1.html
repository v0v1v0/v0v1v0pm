<div class="container">

<table style="width: 100%;"><tr>
<td>cmnorm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parameters of conditional multivariate normal distribution</h2>

<h3>Description</h3>

<p>This function calculates mean (expectation) and covariance 
matrix of conditional multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cmnorm(
  mean,
  sigma,
  given_ind,
  given_x,
  dependent_ind = numeric(),
  is_validation = TRUE,
  is_names = TRUE,
  control = NULL,
  n_cores = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p>numeric vector representing expectation of multivariate
normal vector (distribution).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>positively defined numeric matrix representing covariance
matrix of multivariate normal vector (distribution).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>given_ind</code></td>
<td>
<p>numeric vector representing indexes of multivariate
normal vector which are conditioned at values given by 
<code>given_x</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>given_x</code></td>
<td>
<p>numeric vector which <code>i</code>-th element corresponds to
the given value of the <code>given_ind[i]</code>-th element (component) of 
multivariate normal vector. If <code>given_x</code> is numeric matrix then it's 
rows are such vectors of given values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dependent_ind</code></td>
<td>
<p>numeric vector representing indexes of unconditional
elements (components) of multivariate normal vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_validation</code></td>
<td>
<p>logical value indicating whether input 
arguments should be validated.  Set it to <code>FALSE</code> to get
performance boost (default value is <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_names</code></td>
<td>
<p>logical value indicating whether output 
values should have row and column names. Set it to <code>FALSE</code> to get
performance boost (default value is <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control parameters. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p>positive integer representing the number of CPU cores
used for parallel computing. Currently it is not recommended to set
<code>n_cores &gt; 1</code> if vectorized arguments include less then 100000 elements.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Consider <code class="reqn">m</code>-dimensional multivariate normal vector 
<code class="reqn">X=(X_{1},...,X_{m})^{T}~\sim N(\mu,\Sigma)</code>, where <code class="reqn">E(X)=\mu</code> and 
<code class="reqn">Cov(X)=\Sigma</code> are expectation (mean) and covariance matrix 
respectively.
</p>
<p>Let's denote vectors of indexes of conditioned and unconditioned elements of <code class="reqn">X</code>
by <code class="reqn">I_{g}</code> and <code class="reqn">I_{d}</code> respectively. By <code class="reqn">x^{(g)}</code> denote 
deterministic (column) vector of given values of <code class="reqn">X_{I_{g}}</code>. The 
function calculates expected value and covariance matrix of conditioned
multivariate normal vector <code class="reqn">X_{I_{d}} | X_{I_{g}} = x^{(g)}</code>. For example
if <code class="reqn">I_{g}=(1, 3)</code> and <code class="reqn">x^{(g)}=(-1, 1)</code> then <code class="reqn">I_{d}=(2, 4, 5)</code> 
so the function calculates:
</p>
<p style="text-align: center;"><code class="reqn">\mu_{c}=E\left(\left(X_{2}, X_{4}, X_{5}\right) | X_{1} = -1, X_{3} = 1\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma_{c}=Cov\left(\left(X_{2}, X_{4}, X_{5}\right) | 
      X_{1} = -1, X_{3} = 1\right)</code>
</p>

<p>In general case:
</p>
<p style="text-align: center;"><code class="reqn">\mu_{c} = E\left(X_{I_{d}} | X_{I_{g}} = x^{(g)}\right) = 
                \mu_{I_{d}} + 
                \left(x^{(g)} - \mu_{I_{g}}\right)
                \left(\Sigma_{(I_{d}, I_{g})}
                      \Sigma_{(I_{g}, I_{g})}^{-1}\right)^{T}</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma_{c} = Cov\left(X_{I_{d}} | X_{I_{g}} = x^{(g)}\right) = 
                   \Sigma_{(I_{d}, I_{d})} - 
                   \Sigma_{(I_{d}, I_{g})}
                   \Sigma_{(I_{g}, I_{g})}^{-1}
                   \Sigma_{(I_{g}, I_{d})}</code>
</p>

<p>Note that <code class="reqn">\Sigma_{(A, B)}</code>, where <code class="reqn">A,B\in\{d, g\}</code>, 
is a submatrix of <code class="reqn">\Sigma</code> generated by intersection of <code class="reqn">I_{A}</code> 
rows and <code class="reqn">I_{B}</code> columns of <code class="reqn">\Sigma</code>. 
</p>
<p>Below there is a correspondence between aforementioned theoretical
(mathematical) notations and function arguments:
</p>

<ul>
<li> <p><code>mean</code> - <code class="reqn">\mu</code>.
</p>
</li>
<li> <p><code>sigma</code> - <code class="reqn">\Sigma</code>.
</p>
</li>
<li> <p><code>given_ind</code> - <code class="reqn">I_{g}</code>.
</p>
</li>
<li> <p><code>given_x</code> - <code class="reqn">x^{(g)}</code>.
</p>
</li>
<li> <p><code>dependent_ind</code> - <code class="reqn">I_{d}</code></p>
</li>
</ul>
<p>Moreover <code class="reqn">\Sigma_{(I_{g}, I_{d})}</code> is a theoretical (mathematical)
notation for <code>sigma[given_ind, dependent_ind]</code>. Similarly <code class="reqn">\mu_{g}</code>
represents <code>mean[given_ind]</code>.
</p>
<p>By default <code>dependent_ind</code> contains all indexes that are not
in <code>given_ind</code>. It is possible to omit and duplicate indexes of 
<code>dependent_ind</code>. But at least single index should be provided for 
<code>given_ind</code> without any duplicates. Also <code>dependent_ind</code> and 
<code>given_ind</code> should not have the same elements. Moreover <code>given_ind</code>
should not be of the same length as <code>mean</code> so at least one component
should be unconditioned.
</p>
<p>If <code>given_x</code> is a vector then (if possible) it will be treated as 
a matrix with the number of columns equal to the length of <code>mean</code>.
</p>
<p>Currently <code>control</code> has no input arguments intended for
the users. This argument is used for some internal purposes
of the package.
</p>


<h3>Value</h3>

<p>This function returns an object of class "mnorm_cmnorm".<br><br>
An object of class "mnorm_cmnorm" is a list containing the 
following components:
</p>

<ul>
<li> <p><code>mean</code> - conditional mean.
</p>
</li>
<li> <p><code>sigma</code> - conditional covariance matrix.
</p>
</li>
<li> <p><code>sigma_d</code> - covariance matrix of unconditioned elements.
</p>
</li>
<li> <p><code>sigma_g</code> - covariance matrix of conditioned elements.
</p>
</li>
<li> <p><code>sigma_dg</code> - matrix of covariances between unconditioned
and conditioned elements.
</p>
</li>
<li> <p><code>s12s22</code> - equals to the matrix product of <code>sigma_dg</code>
and <code>solve(sigma_g)</code>.
</p>
</li>
</ul>
<p>Note that <code>mean</code> corresponds to <code class="reqn">\mu_{c}</code> while <code>sigma</code>
represents <code class="reqn">\Sigma_{c}</code>. Moreover <code>sigma_d</code> is 
<code class="reqn">\Sigma_{I_{d}, I_{d}}</code>, <code>sigma_g</code> is <code class="reqn">\Sigma_{I_{g}, I_{g}}</code> 
and <code>sigma_dg</code> is <code class="reqn">\Sigma_{I_{d}, I_{g}}</code>.
</p>
<p>Since <code class="reqn">\Sigma_{c}</code> do not depend on
<code class="reqn">X^{(g)}</code> the output <code>sigma</code> does not depend on <code>given_x</code>.
In particular output <code>sigma</code> remains the same independent of whether 
<code>given_x</code> is a matrix or vector. Oppositely if <code>given_x</code> is
a matrix then output <code>mean</code> is a matrix which rows correspond
to conditional means associated with given values provided by corresponding
rows of <code>given_x</code>.
</p>
<p>The order of elements of output <code>mean</code> and output <code>sigma</code> depends 
on the order of <code>dependet_ind</code> elements that is ascending by default.
The order of <code>given_ind</code> elements does not matter. But, please, check 
that the order of <code>given_ind</code> match the order of given values i.e. 
the order of <code>given_x</code> columns.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Consider multivariate normal vector:
# X = (X1, X2, X3, X4, X5) ~ N(mean, sigma)

# Prepare multivariate normal vector parameters
  # expected value
mean &lt;- c(-2, -1, 0, 1, 2)
n_dim &lt;- length(mean)
  # correlation matrix
cor &lt;- c(   1,  0.1,  0.2,   0.3,  0.4,
          0.1,    1, -0.1,  -0.2, -0.3,
          0.2, -0.1,    1,   0.3,  0.2,
          0.3, -0.2,  0.3,     1, -0.05,
          0.4, -0.3,  0.2, -0.05,     1)
cor &lt;- matrix(cor, ncol = n_dim, nrow = n_dim, byrow = TRUE)
  # covariance matrix
sd_mat &lt;- diag(c(1, 1.5, 2, 2.5, 3))
sigma &lt;- sd_mat %*% cor %*% t(sd_mat)

# Estimate parameters of conditional distribution i.e.
# when the first and the third components of X are conditioned:
# (X2, X4, X5 | X1 = -1, X3 = 1)
given_ind &lt;- c(1, 3)
given_x &lt;- c(-1, 1)
par &lt;- cmnorm(mean = mean, sigma = sigma,
              given_ind = given_ind,
              given_x = given_x)
  # E(X2, X4, X5 | X1 = -1, X3 = 1)
par$mean
  # Cov(X2, X4, X5 | X1 = -1, X3 = 1)
par$sigma

# Additionally calculate E(X2, X4, X5 | X1 = 2, X3 = 3)
given_x_mat &lt;- rbind(given_x, c(2, 3))
par1 &lt;- cmnorm(mean = mean, sigma = sigma,
               given_ind = given_ind,
               given_x = given_x_mat)
par1$mean

# Duplicates and omitted indexes are allowed for dependent_ind
# For given_ind duplicates are not allowed
# Let's calculate conditional parameters for (X5, X2, X5 | X1 = -1, X3 = 1):
dependent_ind &lt;- c(5, 2, 5)
par2 &lt;- cmnorm(mean = mean, sigma = sigma,
               given_ind = given_ind,
               given_x = given_x,
               dependent_ind = dependent_ind)
  # E(X5, X2, X5 | X1 = -1, X3 = 1)
par2$mean
  # Cov(X5, X2, X5 | X1 = -1, X3 = 1)
par2$sigma
</code></pre>


</div>