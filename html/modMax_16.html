<div class="container">

<table style="width: 100%;"><tr>
<td>simulatedAnnealing</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Simulated annealing algorithms
</h2>

<h3>Description</h3>

<p>The functions presented here are based on simulated annealing and identify the community structure and maximize the modularity.
<code>simulatedAnnealing</code> is only based on moving a single vertex from one community to another, while <code>saIndividualCollectiveMoves</code> considers movements of vertices, merging of communities and splitting of communities as alternatives to increase the modularity.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simulatedAnnealing(adjacency, numRandom = 0, 
                    initial = c("general", "random","greedy", "own"), 
                    beta = length(adjacency[1, ])/2, alpha = 1.005, fixed)
saIndividualCollectiveMoves(adjacency,numRandom=0,initial=c("general","own"),
                            beta=length(adjacency[1,])/2,alpha=1.005,
                            fixed=25,numIter=1.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>

<p>Specify the community structure to use as the initial partition in the algorithm. See details below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>

<p>Define the initial inverse temperature. <code>Default</code> is <code>(network size)/2</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>Define the cooling parameter. <code>Default</code> is <code>1.005</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>

<p>If the community structure has not changed for this specified number of steps, the algorithm is terminated.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numIter</code></td>
<td>

<p>Define the iteration factor. At each temperature, the algorithm performs <code class="reqn">fn^2</code> individual moves (movement of a single vertex) and <code class="reqn">fn</code> collective moves (merge or split of a community) where <code class="reqn">n</code> is the number of vertices in the network.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>
<p>The initial partition used in the simulated annealing algorithms can either be the generic one where all vertices are put in their own community (<code>initial=general</code>) or the initial partition can be identified by randomly identifying the initial number of communities and randomly assigning the vertices to one of these communities (<code>initial=random</code>) or the initial partition can be the community structure identified by the greedy algorithm (<code>initial=greedy</code>) or the initial partition can be given by the user (<code>initial=own</code>). In this case, the user needs to add a last column to the adjacency matrix indicating the initial partition. Hence, the adjacency matrix has to have one column more than the network has vertices.
</p>


<h3>Value</h3>

<p>The result of the simulated annealing algorithms is a list with the following components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br><code>numRandom&gt;0</code>
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Medus, A., Acua, G. and Dorso, C.O. Detection of community structures
in networks via global optimization. <em>Physica A: Statistical Mechanics and
its Applications</em>, 358(24):593-604, 2005.
</p>
<p>Massen, C. and Doye, J. Identifying communities within energy landscapes. <em>Phys. Rev. E</em>, 71:046101, Apr 2005.
</p>
<p>Guimera, R. and Amaral, L. A. N. Nunes amaral. Functional cartography
of complex metabolic networks. <em>Nature</em>, 2005.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#unweighted network
randomgraph &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices &lt;- which(clusters(randomgraph)$membership==1)  
graph &lt;- induced.subgraph(randomgraph,vertices)

adj &lt;- get.adjacency(graph)
result &lt;- simulatedAnnealing(adj, fixed=10)

</code></pre>


</div>