<div class="container">

<table style="width: 100%;"><tr>
<td>spectralOptimization</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Spectral optimization algorithms
</h2>

<h3>Description</h3>

<p><code>spectralOptimization</code> uses the leading eigenvector to recursively split the communities of a network into two until no further improvement of modularity is possible.
</p>
<p><code>multiWay</code>, <code>spectral1</code> and <code>spectral2</code> use <code class="reqn">k-1</code> leading eigenvectors to split the network into <code class="reqn">k</code> communities. The value for <code class="reqn">k</code> leading to the best community structure is chosen as the final number of communities and the resulting split of the network into <code class="reqn">k</code> communities as the final community structure. The 3 functions implement slightly different approaches leading to possibly different results.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spectralOptimization(adjacency, numRandom = 0, initial = c("general", "own"),
                      refine = FALSE)
multiWay(adjacency, numRandom=0, maxComm=length(adjacency[1,]))
spectral1(adjacency, numRandom=0, maxComm=(length(adjacency[1,])-1))
spectral2(adjacency, numRandom=0, maxComm=(length(adjacency[1,])-1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>

<p>Specify the community structure to use as initial partition in the algorithm. See details below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refine</code></td>
<td>

<p>If <code>TRUE</code>, Kernighan-Lin refinement is applied after splitting a community into two communities only on this part of the network.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxComm</code></td>
<td>

<p>THe maximum number of communities that the network allows
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>
<p>The initial partition used in the spectral optimization algorithm can either be the generic one where all vertices are put in their own community (<code>initial=general</code>) or the initial partition can be given by the user (<code>initial=own</code>). In this case, the user needs to add a last column to the adjacency matrix indicating the initial partition. Hence, the adjacency matrix has to have one column more than the network has vertices.
</p>


<h3>Value</h3>

<p>The result of the spectral optimization algorithms is a list with the following components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br><code>numRandom&gt;0</code>
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Newman, M. Finding community structure in networks using the eigenvectors
of matrices. <em>Phys. Rev. E</em>, 74:036104, Sep 2006.
</p>
<p>Newman, M. E. J. Modularity and community structure in networks.
<em>Proceedings of the National Academy of Sciences</em>, 103(23):8577-8582, 2006.
</p>
<p>Wang, G., Shen, Y., and Ouyang, M. A vector partitioning approach to detecting community structure in complex networks. <em>Computers and Mathematics with Applications</em>, 55(12):2746-2752, 2008.
</p>
<p>White, S. and Smyth, P. A spectral clustering approach to finding communities in graphs. In <em>In SIAM International Conference on Data Mining</em>, 2005.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#unweighted network
randomgraph1 &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices1 &lt;- which(clusters(randomgraph1)$membership==1)  
graph1 &lt;- induced.subgraph(randomgraph1,vertices1)

adj1 &lt;- get.adjacency(graph1)
result1 &lt;- spectralOptimization(adj1, refine = TRUE)

#weighted network
randomgraph2 &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices2 &lt;- which(clusters(randomgraph2)$membership==1)  
graph2 &lt;- induced.subgraph(randomgraph2,vertices2)
graph2 &lt;- set.edge.attribute(graph2, "weight", value=runif(ecount(graph2),0,1))

adj2 &lt;- get.adjacency(graph2, attr="weight")
result2 &lt;- multiWay(adj2, maxComm=3)
</code></pre>


</div>