<div class="container">

<table style="width: 100%;"><tr>
<td>extremalOptimization</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Extremal optimization (EO) algorithms
</h2>

<h3>Description</h3>

<p><code>extremalOptimization</code> is a function executing the extremal optimization approach and its modifications for calculating modularity and detecting communities (modules of nodes) of a network via modularity maximization
</p>
<p><code>pcseoss</code> is a function which uses extremal optimization, but also considers pairwise constraints when calculating the fitness function and the modularity. The violation of constraints is punished, leading to smaller fitness and modularity values for community structures that violate many pairwise constraints. The constraints are predefined as two matrices separately for must-links and cannot-links with punishment for violation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">extremalOptimization(adjacency, numRandom = 0, 
                      refine = c("none", "agents"), 
                      tau = FALSE, alpha_max = length(adjacency[1,]), steps = 3)
pcseoss(adjacency,constraints_ml,constraints_cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refine</code></td>
<td>

<p>Specify whether or not a refinement step is needed, the default option is <code>none</code>. See details below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>If <code>TRUE</code>, <code class="reqn">\tau</code>-EO is executed where the vertices are ranked according to their fitness values and chosen by a probability depending on this ranking.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_max</code></td>
<td>

<p>It gives the maximum number of iteration steps. If the community structure could not be improved for this number of steps, the algorithm terminates. It is <code>1</code> for the normal EO-algorithm and <code>n</code> for the <code class="reqn">\tau</code>-EO where <code>n</code> is the number of vertices in the network
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>

<p>The number of iteration steps for the random local search agent algorithm. The algorithm terminates, if the clusters have not changed for this number of steps. Ignored if <code>refine</code> is <code>none</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints_ml</code></td>
<td>

<p>The matrix where each column is a must-link constraint given by two vertices in the first two rows which have to be in the same community and a punishment for the violation of the constraint in the third row
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints_cl</code></td>
<td>

<p>The matrix where each column is a cannot-link constraint given by two vertices in the first two rows which cannot be in the same community and a punishment for the violation of the constraint in the third row
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>
<p>The EO algorithm can be run with a certain refinement step, the local random search agent algorithm, applied at the end of one round of extremal where all communities have been split once.
</p>
<p>This refinement algorithm is executed if <code>refine</code> equals <code>agent</code>, otherwise the generic EO algorithm is executed.
</p>


<h3>Value</h3>

<p>The result of the extremal optimization algorithms is a list with the following components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br><code>numRandom&gt;0</code>
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Duch, J. and Arenas, A. Community detection in complex networks using extremal optimization. <em>Phys. Rev. E</em>, 72:027104, Aug 2005.
</p>
<p>Azizifard, N., Mahdavi, M. and Nasersharif, B. Modularity optimization for clustering in social networks. 2011.
</p>
<p>Li, L., Du, M., Liu, G., Hu, X. and Wu, G. Extremal optimization-based semi-supervised algorithm with conflict pairwise constraints for community detection. In <em>Advances in Social Network Analysis and Mining (ASONAM), 2014 IEEE/ACM International Conference
on</em>, 2014.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#weighted network
randomgraph &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices &lt;- which(clusters(randomgraph)$membership==1)  
graph &lt;- induced.subgraph(randomgraph,vertices)
graph &lt;- set.edge.attribute(graph, "weight", value=runif(ecount(graph),0,1))

adj &lt;- get.adjacency(graph, attr="weight")
result &lt;- extremalOptimization(adj)
</code></pre>


</div>