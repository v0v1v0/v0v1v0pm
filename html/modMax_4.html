<div class="container">

<table style="width: 100%;"><tr>
<td>geneticAlgorithm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Genetic algorithm
</h2>

<h3>Description</h3>

<p><code>geneticAlgorithm</code> is a function executing the genetic algorithm and its modifications for identifying the community structure of a network via modularity maximization
</p>


<h3>Usage</h3>

<pre><code class="language-R">geneticAlgorithm(adjacency, numRandom = 0, 
                  initial = c("general", "cluster", "own"), p, g, 
                  mutRat = 0.5, crossOver = 0.2, beta = 0.1, alpha = 0.4, 
                  n_l = 4, local = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>

<p>Specify the community structure to use as initial partition in the algorithm. See details below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>Population size
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>

<p>Number of generations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutRat</code></td>
<td>

<p>Mutation rate. <code>Default</code> is <code>0.5</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crossOver</code></td>
<td>

<p>Crossing over rate. <code>Default</code> is <code>0.2</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>

<p>The fraction of chromosomes to save. The top <code class="reqn">\beta</code><code class="reqn">p</code> chromosomes are saved in each generation to ensure that the fitness scores of the top <code class="reqn">\beta</code><code class="reqn">p</code> chromosomes of the child generation are at least as good as the parent population. <code>Default</code> is <code>0.1</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>The fraction of repetitions for the identification of an initial partition according to <code>cluster</code>. <code>Default</code> is <code>0.4</code>. Ignored if <code>initial</code> is not <code>cluster</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_l</code></td>
<td>

<p>The number of copies of a chromosome made by the local search operator. <code>Default</code> is <code>4</code>. Ignored if <code>local</code> is <code>FALSE</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>local</code></td>
<td>

<p>If <code>TRUE</code>, local search operator is applied at the end of each iteration in the genetic algorithm.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>
<p>The initial partition used in the genetic algorithm can either be the generic one where all vertices are put in their own community (<code>initial=general</code>) or the initial partition can be identified by randomly picking a vertex <code class="reqn">\alpha</code><code class="reqn">n</code> times and assigning its cluster to all its neighbours (<code>initial=cluster</code>) or the initial partition can be given by the user (<code>initial=own</code>). In this case, the user needs to add a last column to the adjacency matrix indicating the initial partition. Hence, the adjacency matrix has to have one column more than the network has vertices.
</p>


<h3>Value</h3>

<p>The result of the genetic algorithm is a list with the following components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br><code>numRandom&gt;0</code>
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Tasgin, M., Herdagdelen, A., and Bingol, H. Community detection
in complex networks using genetic algorithms. <em>arXiv preprint
arXiv:0711.0491</em>, 2007.
</p>
<p>Li, S., Chen, Y., Du, H., and Feldman, M. W. A genetic algorithm with local search strategy for improved detection of community
structure. <em>Complexity</em>, 15(4):53-60, 2010.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#unweighted network
randomgraph &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices &lt;- which(clusters(randomgraph)$membership==1)  
graph &lt;- induced.subgraph(randomgraph,vertices)

adj &lt;- get.adjacency(graph)
result &lt;- geneticAlgorithm(adj, p=4, g=6)

</code></pre>


</div>