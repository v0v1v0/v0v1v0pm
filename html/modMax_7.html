<div class="container">

<table style="width: 100%;"><tr>
<td>localModularity</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Algorithms using local modularity
</h2>

<h3>Description</h3>

<p><code>localModularity</code> uses the local modularity to identify the local community structure around a certain vertex
</p>
<p><code>localModularityWang</code> uses the local modularity to identify the community structure of the entire network
</p>


<h3>Usage</h3>

<pre><code class="language-R">localModularity(adjacency, srcV, k)
localModularityWang(adjacency,numRandom=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>srcV</code></td>
<td>

<p>A given vertex whose local community structure should be determined by<br><code>localModularity</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>The maximum number of vertices to add to the local community of <code>srcV</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>


<h3>Value</h3>

<p>The result for <code>localModularity</code> is returned as a list with the following components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>local community<br> structure</code></td>
<td>

<p>Vertices assigned to the same community as the source vertex <code>srcV</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>local modularity</code></td>
<td>

<p>The local modularity value for the determined local community
</p>
</td>
</tr>
</table>
<p>The result for <code>localModularityWang</code> is returned as a list with the following components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br><code>numRandom&gt;0</code>
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Clauset, A. Finding local community structure in networks. <em>Phys. Rev.
E</em>, 72:026132, Aug 2005.
</p>
<p>Wang, X., Chen, G. and Lu, H. A very fast algorithm for detecting community structures in complex networks. <em>Physica A: Statistical Mechanics and its Applications</em>, 384(2):667-674, 2007.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#unweighted network
randomgraph1 &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices1 &lt;- which(clusters(randomgraph1)$membership==1)  
graph1 &lt;- induced.subgraph(randomgraph1,vertices1)

adj1 &lt;- get.adjacency(graph1)
result1 &lt;- localModularity(adj1, srcV=1, k=4)

#weighted network
randomgraph2 &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices2 &lt;- which(clusters(randomgraph2)$membership==1)  
graph2 &lt;- induced.subgraph(randomgraph2,vertices2)
graph2 &lt;- set.edge.attribute(graph2, "weight", value=runif(ecount(graph2),0,1))

adj2 &lt;- get.adjacency(graph2, attr="weight")
result2 &lt;- localModularityWang(adj2)
</code></pre>


</div>