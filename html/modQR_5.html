<div class="container">

<table style="width: 100%;"><tr>
<td>getCharSTM1u</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computing Some Overall Characteristics in <code>compContourM1u</code>
</h2>

<h3>Description</h3>

<p>The function computes some overall characteristics 
of directional regression quantiles in the output 
of <code>compContourM1u</code>, namely the list 
<code>COutST$CharST</code>.  It makes possible
to obtain some useful information without saving 
any file on the disk, and it can be easily modified 
by the users according to their wishes. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">getCharSTM1u(Tau, N, M, P, BriefDQMat, CharST, IsFirst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Tau</code></td>
<td>
<p>the quantile level in (0, 0.5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>the number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>the dimension of responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>the dimension of regressors including the intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BriefDQMat</code></td>
<td>
<p>the method-specific matrix containing 
the rows of a potential individual output 
file corresponding to 
<code>CTechST$BriefOutputI</code> = 1. See
the details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CharST</code></td>
<td>
<p>the output list, updated with each run 
of the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IsFirst</code></td>
<td>
<p>the indicator equal to one in the 
first run of <code>getCharSTM1u</code> 
(when <code>CharST</code> is initialized) 
and equal to zero otherwise.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is called inside <code>compContourM1u</code>.  
First, it is called with 
<code>BriefDQMat</code> = <code>NULL</code>, 
<code>CharST</code> = <code>NULL</code> and
<code>IsFirst</code> = 1 to initialize 
the output list <code>CharST</code>, and then 
it is called with <code>IsFirst</code> = 0 
successively for the content of each potential 
output file corresponding to 
<code>CTechST$BriefOutputI</code> = 1, i.e., even if
the output file(s) are not stored on the disk owing to 
<code>CTechST$OutSaveI</code> = 0.
</p>
<p>It still remains to describe in detail the content of possible 
output files, describing the optimal conic segmentation of 
the directional space that lies behind the optimization 
problem involved.  
</p>
<p>If <code>CTechST$BriefOutputI</code> = 1, then the rows of such
files are vectors of length <code>1+1+M+M+P+1</code> of the form 
<code>c(ConeID, Nu, UVec, BDVec, ADVec, LambdaD)</code> where 
</p>

<dl>
<dt>ConeID</dt>
<dd>
<p>is the number/order of the cone related to the 
line.  If <code>M</code> &gt; 2, then a cone can appear in 
the output repeatedly (under different numbers).</p>
</dd>
<dt>Nu</dt>
<dd>
<p>is the number of corresponding negative residuals.</p>
</dd>
<dt>UVec</dt>
<dd>
<p>is a normalized vector of the cone.  
It is usually its vertex direction but it may 
also be its interior vector pointing to a vertex 
of the artificial intersection of the cone with 
the bounding box <code>[-1,1]^M</code>.  The 
max normalization is used if the breadth-first 
search algorithm is employed and the L2 
normalization is used in the other case (when 
<code>M</code> = 2 and <code>CTechST$D2SpecI</code> = 1).</p>
</dd>
<dt>BDVec</dt>
<dd>
<p>is the vector <code>c(b_1,...,b_M)</code>, i.e., 
the constant vector denominator of <code>BVec</code>, 
where 
<code>BVec</code> = <code>BDVec/(t(BDVec)%*%UVec)</code>.</p>
</dd>
<dt>ADVec</dt>
<dd>
<p>is the vector <code>c(a_1,...,a_P)</code>, i.e., 
the constant vector denominator of <code>AVec</code>, 
where
<code>AVec</code> = <code>ADVec/(t(BDVec)%*%UVec)</code>.</p>
</dd>
<dt>LambdaD</dt>
<dd>
<p>is the constant scalar denominator of 
<code>Lambda</code> = <code>LambdaD/(t(BDVec)%*%UVec)</code>.</p>
</dd>
</dl>
<p>Recall that <code>c(BVec, AVec)</code> stands for the coefficients 
of the regression quantile hyperplane associated with 
<code>UVec</code> and that <code>Lambda</code> denotes the Lagrange 
multiplier equal to the optimal value <code>Psi</code> of the objective 
function for that direction.  
</p>
<p>If <code>CTechST$BriefOutputI</code> = 0, then the rows of the
potential output file(s) are longer 
(of length <code>1+1+M+M+P+1+(P+M-1)*M+(P+M-1)</code>) 
because they contain two more vectors appended at the end.  
The rows are of the form 
<code>c(ConeID, Nu, UVec, BDVec, ADVec, LambdaD, vec(VUMat), IZ)</code> 
where 
</p>

<dl>
<dt>VUMat</dt>
<dd>
<p>is the matrix for computing the multiplier vector 
<code>MuR0Vec</code> associated with zero residuals, 
<code>MuR0Vec</code> 
= <code>(VUMat%*%UVec)/(t(BDVec)%*%UVec)</code>.  
That is to say that all directions from the 
interior of the cone result in the regression 
<code>Tau</code>-quantile hyperplanes containing 
the same <code>P+M-1</code> observations because all 
such hyperplanes are the same up to a scaling 
factor multiplying their coefficients.</p>
</dd> 
<dt>IZ</dt>
<dd>
<p>is the vector containing original indices of the 
<code>M+P-1</code> observations with zero residuals 
for all directions from the interior of the cone.</p>
</dd>
</dl>
<h3>Value</h3>

<p><code>getCharSTM1u</code> returns a list with the following 
components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>NUESkip</code></td>
<td>
<p>the number of (skipped) directions (and 
corresponding hyperplanes) artificially 
induced by intersecting the cones with 
the <code>[-1,1]^M</code> bounding box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NAZSkip</code></td>
<td>
<p>the number of (skipped) hyperplanes (and 
corresponding directions) not counted in NUESkip 
and with at least one coordinate of 
<code>AVec</code> zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NBZSkip</code></td>
<td>
<p>the number of (skipped) hyperplanes (and 
corresponding directions) not counted in NUESkip 
and with at least one coordinate of 
<code>BVec</code> zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HypMat</code></td>
<td>
<p>(for <code>M &gt; 4</code>) the component is missing  <br>
(for <code>M &lt;= 4</code>) the matrix with <code>M + P</code>
columns containing (in rows) all the distinct 
regression Tau-quantile hyperplane 
coefficients <code>c(BVec, AVec)</code> normalized 
with <code>|BVec|</code>, rounded to the eighth 
decimal digit, and sorted lexicographically.  
This matrix can be used for the computation 
of the regression <code>Tau</code>-quantile contour.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CharMaxMat</code></td>
<td>
<p>the matrix with the (slightly rounded) maxima 
of certain directional regression Tau-quantile 
characteristics over all remaining vertex 
directions.  <br>
If <code>P</code> = 1, then <code>CharMaxMat</code> has 
only three rows: <br><code>c(UVec, max(|BVec|))</code>, <br><code>c(UVec, max(Lambda))</code>, and <br><code>c(UVec, max(Lambda/|BVec|))</code>, <br>
respectively.  <br>
If <code>P</code> &gt; 1, then the rows of 
<code>CharMaxMat</code> are as follows: <br><code>c(UVec, max(|BVec|))</code>, <br><code>c(UVec, max(Lambda))</code>, <br><code>c(UVec, max(Lambda/|BVec|))</code>, <br><code>c(UVec, max(|c(a_2,...,a_P)|))</code>, <br><code>c(UVec, max(|c(a_2,...,a_P)|/|BVec|))</code>, <br><code>c(UVec, max(|a_2|))</code>, <br><code>c(UVec, max(|a_2|/|BVec|))</code>, <br><code>...</code>, <br><code>c(UVec, max(|a_P|))</code>, and <br><code>c(UVec, max(|a_P|/|BVec|))</code>, <br>
respectively.  If <code>P</code> = 2, 
then the last two rows are missing for not 
being included twice.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CharMinMat</code></td>
<td>
<p>the matrix with the (slightly rounded) minima 
of certain directional regression Tau-quantile 
characteristics over all remaining vertex 
directions.  <br>
If <code>P</code> = 1, then <code>CharMinMat</code> has 
only three rows: <br><code>c(UVec, min(|BVec|))</code>, <br><code>c(UVec, min(Lambda))</code>, and <br><code>c(UVec, min(Lambda/|BVec|))</code>, <br>
respectively.  <br>
If <code>P</code> &gt; 1, then <code>CharMinMat</code> 
has five rows: <br><code>c(UVec, min(|BVec|))</code>, <br><code>c(UVec, min(Lambda))</code>, <br><code>c(UVec, min(Lambda/|BVec|))</code>, <br><code>c(UVec, min(|c(a_2,...,a_P)|))</code>, and <br><code>c(UVec, min(|c(a_2,...,a_P)|/|BVec|))</code>, <br>
respectively.</p>
</td>
</tr>
</table>
<p>Note that <code>||</code> symbolizes the Euclidean norm, 
and that the vertices (<code>UVec</code>) in the rows of 
<code>CharMaxMat</code> and <code>CharMinMat</code> are generally 
different and denote (one of) the direction(s) where 
the row maximum or minimum is attained.  
</p>


<h3>Examples</h3>

<pre><code class="language-R">##Run print(getCharSTM1u) to examine the default setting.
</code></pre>


</div>