<div class="container">

<table style="width: 100%;"><tr>
<td>modehunt-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiscale Analysis for Density Functions</h2>

<h3>Description</h3>

<p>Provides five methods and corresponding critical values to perform mode hunting, i.e. to 
compute multiscale test statistics based on local order statistics and spacings that provide simultaneous confidence 
statements for the existence and location of local increases and decreases of a density.</p>


<h3>Details</h3>


<table>
<tr>
<td style="text-align: left;">
Package: </td>
<td style="text-align: left;"> modehunt </td>
</tr>
<tr>
<td style="text-align: left;">
Type: </td>
<td style="text-align: left;"> Package </td>
</tr>
<tr>
<td style="text-align: left;">
Version: </td>
<td style="text-align: left;"> 1.0.7 </td>
</tr>
<tr>
<td style="text-align: left;">
Date: </td>
<td style="text-align: left;"> 2015-07-03 </td>
</tr>
<tr>
<td style="text-align: left;">
License: </td>
<td style="text-align: left;"> GPL (&gt;=2) </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>In Duembgen and Walther (2008) a multiscale test statistic based on spacings was introduced. This method provides 
simultaneous confidence statements for the existence and location of local increases and decreases of a density. 
The procedure guarantees finite–sample significance levels and possesses certain asymptotic optimality 
and adaptivity properties. However, since the local test statistics are computed on all <code class="reqn">O(n^2)</code> intervals in 
the set 
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{I}_{all} = \Bigl\{(j, \ k ) \ : \ 0 \le j &lt; k \le n+1, \ k - j &gt; 1\Bigr\},</code>
</p>

<p>this latter procedure is computationally very expensive. Furthermore, the correction term <code class="reqn">\Gamma</code> employed
by Duembgen and Walther (2008) to prevent the global test statistic to be dominated by the values of the local 
test statistics on small scales needs in principle to be re–derived for any new local test statistic, a non–trivial
task in general. In Rufibach and Walther (2010), two new procedures are proposed: One that within the original framework
of Duembgen and Walther (2008) approximates the set <code class="reqn">\mathcal{I}_{all}</code> by a specific subset of intervals 
<code class="reqn">\mathcal{I}_{app}</code> that only contains <code class="reqn">O(n \log n )</code> intervals. It is shown that considering 
<code class="reqn">\mathcal{I}_{app}</code> yields a procedure that is in terms of power asymptotically equivalent to that based 
on <code class="reqn">\mathcal{I}_{all}</code>, however, computationally much more efficient.
</p>
<p>Finally, Rufibach and Walther (2010) propose a <em>block procedure</em>. Here, all intervals under consideration are
grouped into blocks, where each interval in a block contains approximately the same number of original observations.
Critical values are then computed per block. Again, this procedure is basically asymptotically equivalent to the
standard approach proposed in Duembgen and Walther (2008), but again computationally much faster. It further offers
a (finite–sample) tradeoff between employing or omitting the additive correction <code class="reqn">\Gamma</code>.
</p>
<p>The initial procedure by Duembgen and Walther (2008) is implemented as the function
<code>modeHunting</code>. The help file to the latter function also contains some more description of the mathematical details.
<code>criticalValuesAll</code> can be used to compute critical values for this approach and 
<code>cvModeAll</code> contains a table of critical values (with and without correction term) for some 
<code class="reqn">n</code> and <code class="reqn">alpha</code>.
</p>
<p>The corresonding functions and <code class="reqn">p</code>-values for the approximation are made available as 
<code>modeHuntingApprox</code>, <code>criticalValuesApprox</code>, and <code>cvModeApprox</code>
and for the block method as <code>modeHuntingBlock</code>, <code>criticalValuesBlock</code>, and
<code>cvModeBlock</code>.
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer), <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a>, <br><a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a>
</p>
<p>Guenther Walther, <a href="mailto:gwalther@stanford.edu">gwalther@stanford.edu</a>, <br><a href="www-stat.stanford.edu/~gwalther">www-stat.stanford.edu/~gwalther</a>
</p>
<p>Kaspar Rufibach acknowledges support by the Swiss National Science Foundation SNF, <a href="http://www.snf.ch">http://www.snf.ch</a>.
</p>
<p>Guenther Walther acknowledges support by NSF grants DMS-9875598, DMS-0505682, and NIH grant 5R33HL068522.
</p>


<h3>References</h3>

<p>Duembgen, L. and Walther, G. (2008).
Multiscale Inference about a density.
<em>Ann. Statist.</em>, <b>36</b>, 1758–1785.
</p>
<p>Rufibach, K. and Walther, G. (2010).
A general criterion for multiscale inference. 
<em>J. Comput. Graph. Statist.</em>, <b>19</b>, 175–190.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate random sample
set.seed(1977)
n &lt;- 200; a &lt;- 0; b &lt;- 0.5; s &lt;- 2 / (b - a) 
X.raw &lt;- rlin(n, a, b, s)

## input critical values
alpha &lt;- 0.05
data(cvModeAll); data(cvModeApprox); data(cvModeBlock)
cv.all &lt;- cvModeAll[cvModeAll$alpha == alpha &amp; cvModeAll$n == n, 3:4]
cv.approx &lt;- cvModeApprox[cvModeApprox$alpha == alpha &amp; cvModeApprox$n == n, 3:4]
cv.block &lt;- cvModeBlock[cvModeBlock$alpha == alpha &amp; cvModeBlock$n == n, 3:11]

## standard procedure from Duembgen and Walther (2008)
mod1 &lt;- modeHunting(X.raw, lower = 0, upper = 1, cv.all, min.int = TRUE)

## procedure from Rufibach and Walther (2010) based on I_app
mod2 &lt;- modeHuntingApprox(X.raw, lower = 0, upper = 1, 
                          crit.vals = cv.approx, min.int = TRUE)

## block procedure from Rufibach and Walther (2010)
mod3 &lt;- modeHuntingBlock(X.raw, lower = 0, upper = 1, 
                         crit.vals = cv.block, min.int = TRUE)

## display
mod1; mod2; mod3
</code></pre>


</div>