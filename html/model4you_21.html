<div class="container">

<table style="width: 100%;"><tr>
<td>pmforest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute model-based forest from model.</h2>

<h3>Description</h3>

<p>Input a parametric model and get a forest.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pmforest(
  model,
  data = NULL,
  zformula = ~.,
  ntree = 500L,
  perturb = list(replace = FALSE, fraction = 0.632),
  mtry = NULL,
  applyfun = NULL,
  cores = NULL,
  control = ctree_control(teststat = "quad", testtype = "Univ", mincriterion = 0,
    saveinfo = FALSE, lookahead = TRUE, ...),
  trace = FALSE,
  ...
)

## S3 method for class 'pmforest'
gettree(object, tree = 1L, saveinfo = TRUE, coeffun = coef, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a model object. The model can be a parametric model with a single binary covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data. If <code>NULL</code> the data from the model object are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zformula</code></td>
<td>
<p>formula describing which variable should be used for partitioning.
Default is to use all variables in data that are not in the model (i.e. <code>~ .</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntree</code></td>
<td>
<p>number of trees.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perturb</code></td>
<td>
<p>a list with arguments replace and fraction determining which type of
resampling with <code>replace = TRUE</code> referring to the n-out-of-n bootstrap and
<code>replace = FALSE</code> to sample splitting. fraction is the number of observations
to draw without replacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtry</code></td>
<td>
<p>number of input variables randomly sampled as candidates at each
node (Default <code>NULL</code> corresponds to <code>ceiling(sqrt(nvar))</code>).
Bagging, as special case of a random forest without random input variable
sampling, can be performed by setting mtry either equal to Inf or
equal to the number of input variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>applyfun</code></td>
<td>
<p>see <code>cforest</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>see <code>cforest</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>control parameters, see <code>ctree_control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>a logical indicating if a progress bar shall be printed while
the forest grows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed on to model fit such as weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object returned by pmforest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p>an integer, the number of the tree to extract from the forest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveinfo</code></td>
<td>
<p>logical. Should the model info be stored in terminal nodes?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coeffun</code></td>
<td>
<p>function that takes the model object and returns the coefficients.
Useful when coef() does not return all coefficients (e.g. survreg).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>cforest object
</p>


<h3>See Also</h3>

<p><code>gettree</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("model4you")

if(require("mvtnorm") &amp; require("survival")) {
  
  ## function to simulate the data
  sim_data &lt;- function(n = 500, p = 10, beta = 3, sd = 1){
    
    ## treatment
    lev &lt;- c("C", "A")
    a &lt;- rep(factor(lev, labels = lev, levels = lev), length = n)
    
    ## correlated z variables
    sigma &lt;- diag(p) 
    sigma[sigma == 0] &lt;- 0.2
    ztemp &lt;- rmvnorm(n, sigma = sigma)
    z &lt;- (pnorm(ztemp) * 2 * pi) - pi  
    colnames(z) &lt;- paste0("z", 1:ncol(z))
    z1 &lt;- z[,1]
    
    ## outcome
    y &lt;- 7 + 0.2 * (a %in% "A") + beta * cos(z1) * (a %in% "A") + rnorm(n, 0, sd)
    
    data.frame(y = y, a = a, z)
  }
  
  ## simulate data
  set.seed(123)
  beta &lt;- 3
  ntrain &lt;- 500
  ntest &lt;- 50
  simdata &lt;- simdata_s &lt;- sim_data(p = 5, beta = beta, n = ntrain)
  tsimdata &lt;- tsimdata_s &lt;- sim_data(p = 5, beta = beta, n = ntest)
  simdata_s$cens &lt;- rep(1, ntrain)
  tsimdata_s$cens &lt;- rep(1, ntest)
  
  ## base model
  basemodel_lm &lt;- lm(y ~ a, data = simdata)
  
  ## forest
  frst_lm &lt;- pmforest(basemodel_lm, ntree = 20, 
                      perturb = list(replace = FALSE, fraction = 0.632),
                      control = ctree_control(mincriterion = 0))
  
  ## personalised models
  # (1) return the model objects
  pmodels_lm &lt;- pmodel(x = frst_lm, newdata = tsimdata, fun = identity)
  class(pmodels_lm)
  # (2) return coefficients only (default)
  coefs_lm &lt;- pmodel(x = frst_lm, newdata = tsimdata)
  
  # compare predictive objective functions of personalised models versus
  # base model
  sum(objfun(pmodels_lm)) # -RSS personalised models
  sum(objfun(basemodel_lm, newdata = tsimdata)) # -RSS base model
  
  
  if(require("ggplot2")) {
    ## dependence plot
    dp_lm &lt;- cbind(coefs_lm, tsimdata)
    ggplot(tsimdata) +
      stat_function(fun = function(z1) 0.2 + beta * cos(z1), 
                    aes(color = "true treatment\neffect")) +
      geom_point(data = dp_lm, 
                 aes(y = aA, x = z1, color = "estimates lm"), 
                 alpha = 0.5)  +
      ylab("treatment effect") + 
      xlab("patient characteristic z1")
  }
}

</code></pre>


</div>