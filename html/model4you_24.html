<div class="container">

<table style="width: 100%;"><tr>
<td>pmtree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute model-based tree from model.</h2>

<h3>Description</h3>

<p>Input a parametric model and get a model-based tree.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pmtree(
  model,
  data = NULL,
  zformula = ~.,
  control = ctree_control(),
  coeffun = coef,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a model object. The model can be a parametric model with a binary covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data. If NULL (default) the data from the model object are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zformula</code></td>
<td>
<p>formula describing which variable should be used for partitioning.
Default is to use all variables in data that are not in the model (i.e. <code>~ .</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>control parameters, see <code>ctree_control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coeffun</code></td>
<td>
<p>function that takes the model object and returns the coefficients.
Useful when <code>coef()</code> does not return all coefficients (e.g. <code>survreg</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed on to model fit such as weights.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Sometimes the number of participant in each treatment group needs to 
be of a certain size. This can be accomplished by setting <code>control$converged</code>.
See example below.
</p>


<h3>Value</h3>

<p>ctree object
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(require("TH.data") &amp; require("survival")) {
  ## base model
  bmod &lt;- survreg(Surv(time, cens) ~ horTh, data = GBSG2, model = TRUE)
  survreg_plot(bmod)
  
  ## partitioned model
  tr &lt;- pmtree(bmod)
  plot(tr, terminal_panel = node_pmterminal(tr, plotfun = survreg_plot, 
                                            confint = TRUE))
  summary(tr)
  summary(tr, node = 1:2)
  
  logLik(bmod)
  logLik(tr)
  
  
  ## Sometimes the number of participant in each treatment group needs to 
  ## be of a certain size. This can be accomplished using converged
  
  ## Each treatment group should have more than 33 observations
  ctrl &lt;- ctree_control(lookahead = TRUE)
  ctrl$converged &lt;- function(mod, data, subset) {
      all(table(data$horTh[subset]) &gt; 33)
  }
  
  tr2 &lt;- pmtree(bmod, control = ctrl)
  plot(tr2, terminal_panel = node_pmterminal(tr, plotfun = survreg_plot,
      confint = TRUE))
  
  summary(tr2[[5]]$data$horTh)
}


if(require("psychotools")) {
  data("MathExam14W", package = "psychotools")
  
  ## scale points achieved to [0, 100] percent
  MathExam14W$tests &lt;- 100 * MathExam14W$tests/26
  MathExam14W$pcorrect &lt;- 100 * MathExam14W$nsolved/13
  
  ## select variables to be used
  MathExam &lt;- MathExam14W[ , c("pcorrect", "group", "tests", "study",
                               "attempt", "semester", "gender")]
  
  ## compute base model
  bmod_math &lt;- lm(pcorrect ~ group, data = MathExam)
  lm_plot(bmod_math, densest = TRUE)
  
  ## compute tree
  (tr_math &lt;- pmtree(bmod_math, control = ctree_control(maxdepth = 2)))
  plot(tr_math, terminal_panel = node_pmterminal(tr_math, plotfun = lm_plot, 
                                                 confint = FALSE))
  plot(tr_math, terminal_panel = node_pmterminal(tr_math, plotfun = lm_plot, 
                                                 densest = TRUE,
                                                 confint = TRUE))
  
  ## predict
  newdat &lt;- MathExam[1:5, ]
  
  # terminal nodes
  (nodes &lt;- predict(tr_math, type = "node", newdata = newdat))
  
  # response
  (pr &lt;- predict(tr_math, type = "pass", newdata = newdat))
  
  # response including confidence intervals, see ?predict.lm
  (pr1 &lt;- predict(tr_math, type = "pass", newdata = newdat,
                  predict_args = list(interval = "confidence")))
}
</code></pre>


</div>