<div class="container">

<table style="width: 100%;"><tr>
<td>sim_classification</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate datasets</h2>

<h3>Description</h3>

<p>These functions can be used to generate simulated data for supervised
(classification and regression) and unsupervised modeling applications.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sim_classification(
  num_samples = 100,
  method = "caret",
  intercept = -5,
  num_linear = 10,
  keep_truth = FALSE
)

sim_regression(
  num_samples = 100,
  method = "sapp_2014_1",
  std_dev = NULL,
  factors = FALSE,
  keep_truth = FALSE
)

sim_noise(
  num_samples,
  num_vars,
  cov_type = "exchangeable",
  outcome = "none",
  num_classes = 2,
  cov_param = 0
)

sim_logistic(num_samples, eqn, correlation = 0, keep_truth = FALSE)

sim_multinomial(
  num_samples,
  eqn_1,
  eqn_2,
  eqn_3,
  correlation = 0,
  keep_truth = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>num_samples</code></td>
<td>
<p>Number of data points to simulate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A character string for the simulation method. For
classification, the single current option is "caret". For regression,
values can be "sapp_2014_1", "sapp_2014_2", "van_der_laan_2007_1", or
"van_der_laan_2007_2". See Details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>The intercept for the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_linear</code></td>
<td>
<p>Number of diminishing linear effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_truth</code></td>
<td>
<p>A logical: should the true outcome value be retained for
the data? If so, the column name is <code>.truth</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std_dev</code></td>
<td>
<p>Gaussian distribution standard deviation for residuals.
Default values are shown below in Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factors</code></td>
<td>
<p>A single logical for whether the binary indicators should be
encoded as factors or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_vars</code></td>
<td>
<p>Number of noise predictors to create.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_type</code></td>
<td>
<p>The multivariate normal correlation structure of the
predictors. Possible values are "exchangeable" and "toeplitz".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome</code></td>
<td>
<p>A single character string for what type of independent outcome
should be simulated (if any). The default value of "none" produces no extra
columns. Using "classification" will generate a <code>class</code> column with
<code>num_classes</code> values, equally distributed. A value of "regression" results
in an <code>outcome</code> column that contains independent standard normal values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_classes</code></td>
<td>
<p>When <code>outcome = "classification"</code>, the number of classes
to simulate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_param</code></td>
<td>
<p>A single numeric value for the exchangeable correlation
value or the base of the Toeplitz structure. See Details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eqn, eqn_1, eqn_2, eqn_3</code></td>
<td>
<p>An R expression or  (one sided) formula that
only involves variables <code>A</code> and <code>B</code> that is used to compute the linear
predictor. External objects should not be used as symbols; see the examples
below on how to use external objects in the equations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correlation</code></td>
<td>
<p>A single numeric value for the correlation between variables
<code>A</code> and <code>B</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Specific Regression and Classification methods</h4>

<p>These functions provide several supervised simulation methods (and one
unsupervised). Learn more by <code>method</code>:
</p>


<h5><code>method = "caret"</code></h5>

<p>This is a simulated classification problem with two classes, originally
implemented in <code>caret::twoClassSim()</code> with all numeric predictors. The
predictors are simulated in different sets. First, two multivariate normal
predictors (denoted here as <code>two_factor_1</code> and <code>two_factor_2</code>) are created
with a correlation of about 0.65. They change the log-odds using main
effects and an interaction:
</p>
<pre>  intercept - 4 * two_factor_1 + 4 * two_factor_2 + 2 * two_factor_1 * two_factor_2 </pre>
<p>The intercept is a parameter for the simulation and can be used to control
the amount of class imbalance.
</p>
<p>The second set of effects are linear with coefficients that alternate signs
and have a sequence of values between 2.5 and 0.25. For example, if there
were four predictors in this set, their contribution to the log-odds would
be
</p>
<pre>  -2.5 * linear_1 + 1.75 * linear_2 -1.00 * linear_3 + 0.25 * linear_4</pre>
<p>(Note that these column names may change based on the value of <code>num_linear</code>).
</p>
<p>The third set is a nonlinear function of a single predictor ranging between
<code style="white-space: pre;">⁠[0, 1]⁠</code> called <code>non_linear_1</code> here:
</p>
<pre>  (non_linear_1^3) + 2 * exp(-6 * (non_linear_1 - 0.3)^2) </pre>
<p>The fourth set of informative predictors are copied from one of Friedman's
systems and use two more predictors (<code>non_linear_2</code> and <code>non_linear_3</code>):
</p>
<pre>  2 * sin(non_linear_2 * non_linear_3) </pre>
<p>All of these effects are added up to model the log-odds.
</p>



<h5><code>method = "sapp_2014_1"</code></h5>

<p>This regression simulation is from Sapp et al. (2014). There are 20
independent Gaussian random predictors with mean zero and a variance of 9.
The prediction equation is:
</p>
<pre>
  predictor_01 + sin(predictor_02) + log(abs(predictor_03)) +
   predictor_04^2 + predictor_05 * predictor_06 +
   ifelse(predictor_07 * predictor_08 * predictor_09 &lt; 0, 1, 0) +
   ifelse(predictor_10 &gt; 0, 1, 0) + predictor_11 * ifelse(predictor_11 &gt; 0, 1, 0) +
   sqrt(abs(predictor_12)) + cos(predictor_13) + 2 * predictor_14 + abs(predictor_15) +
   ifelse(predictor_16 &lt; -1, 1, 0) + predictor_17 * ifelse(predictor_17 &lt; -1, 1, 0) -
   2 * predictor_18 - predictor_19 * predictor_20
</pre>
<p>The error is Gaussian with mean zero and variance 9.
</p>



<h5><code>method = "sapp_2014_2"</code></h5>

<p>This regression simulation is also from Sapp et al. (2014). There are 200
independent Gaussian predictors with mean zero and variance 16. The
prediction equation has an intercept of one and identical linear effects of
<code>log(abs(predictor))</code>.
</p>
<p>The error is Gaussian with mean zero and variance 25.
</p>



<h5><code>method = "van_der_laan_2007_1"</code></h5>

<p>This is a regression simulation from van der Laan et al. (2007) with ten
random Bernoulli variables that have a 40% probability of being a value of
one. The true regression equation is:
</p>
<pre>
  2 * predictor_01 * predictor_10 + 4 * predictor_02 * predictor_07 +
    3 * predictor_04 * predictor_05 - 5 * predictor_06 * predictor_10 +
    3 * predictor_08 * predictor_09 + predictor_01 * predictor_02 * predictor_04 -
    2 * predictor_07 * (1 - predictor_06) * predictor_02 * predictor_09 -
    4 * (1 - predictor_10) * predictor_01 * (1 - predictor_04)
</pre>
<p>The error term is standard normal.
</p>



<h5><code>method = "van_der_laan_2007_2"</code></h5>

<p>This is another regression simulation from van der Laan et al. (2007)  with
twenty Gaussians with mean zero and variance 16. The prediction equation is:
</p>
<pre>
  predictor_01 * predictor_02 + predictor_10^2 - predictor_03 * predictor_17 -
    predictor_15 * predictor_04 + predictor_09 * predictor_05 + predictor_19 -
    predictor_20^2 + predictor_09 * predictor_08
</pre>
<p>The error term is also Gaussian with mean zero and variance 16.
</p>



<h5><code>method = "hooker_2004"</code></h5>

<p>Hooker (2004) and Sorokina <em>at al</em> (2008) used the following:
</p>
<pre>
    pi ^ (predictor_01 * predictor_02) * sqrt( 2 * predictor_03 ) -
    asin(predictor_04) + log(predictor_03  + predictor_05) -
   (predictor_09 / predictor_10) * sqrt (predictor_07 / predictor_08) -
    predictor_02 * predictor_07
</pre>
<p>Predictors 1, 2, 3, 6, 7, and 9 are standard uniform while the others are
uniform on <code style="white-space: pre;">⁠[0.6, 1.0]⁠</code>. The errors are normal with mean zero and default
standard deviation of 0.25.
</p>




<h4><code>sim_noise()</code></h4>

<p>This function simulates a number of random normal variables with mean zero.
The values can be independent if <code>cov_param = 0</code>. Otherwise the values are
multivariate normal with non-diagonal covariance matrices. For
<code>cov_type = "exchangeable"</code>, the structure has unit variances and covariances
of <code>cov_param</code>. With <code>cov_type = "toeplitz"</code>, the covariances have an
exponential pattern (see example below).
</p>



<h4>Logistic simulation</h4>

<p><code>sim_logistic()</code> provides a flexible interface to simulating a logistic
regression model with two multivariate normal variables <code>A</code> and <code>B</code> (with
zero mean, unit variances and correlation determined by the <code>correlation</code>
argument).
</p>
<p>For example, using <code>eqn = A + B</code> would specify that the true probability of
the event was
</p>
<pre>
   prob = 1 / (1 + exp(A + B))
</pre>
<p>The class levels for the outcome column are <code>"one"</code> and <code>"two"</code>.
</p>



<h4>Multinomial simulation</h4>

<p><code>sim_multinomial()</code> can generate data with classes <code>"one"</code>, <code>"two"</code>, and
<code>"three"</code> based on the values in arguments <code>eqn_1</code>, <code>eqn_2</code>, and <code>eqn_3</code>,
respectfully. Like <code>sim_logistic()</code> these equations use predictors <code>A</code> and
<code>B</code>.
</p>
<p>The individual equations are evaluated and exponentiated. After this, their
values are, for each row of data, normalized to add up to one. These
probabilities are them passed to <code>stats::rmultinom()</code> to generate the outcome
values.
</p>



<h3>References</h3>

<p>Van der Laan, M. J., Polley, E. C., &amp; Hubbard, A. E. (2007). Super learner.
<em>Statistical applications in genetics and molecular biology</em>, 6(1).
DOI: 10.2202/1544-6115.1309.
</p>
<p>Sapp, S., van der Laan, M. J., &amp; Canny, J. (2014). Subsemble: an ensemble
method for combining subset-specific algorithm fits. <em>Journal of applied
statistics</em>, 41(6), 1247-1259. DOI: 10.1080/02664763.2013.864263
</p>
<p>Hooker, G. (2004, August). Discovering additive structure in black box
functions. In <em>Proceedings of the tenth ACM SIGKDD international conference
on Knowledge discovery and data mining</em> (pp. 575-580).
DOI: 10.1145/1014052.1014122
</p>
<p>Sorokina, D., Caruana, R., Riedewald, M., &amp; Fink, D. (2008, July). Detecting
statistical interactions with additive groves of trees. In <em>Proceedings of
the 25th international conference on Machine learning</em> (pp. 1000-1007).
DOI: 10.1145/1390156.1390282
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
sim_regression(100)
sim_classification(100)

# Flexible logistic regression simulation
if (rlang::is_installed("ggplot2")) {
  library(dplyr)
  library(ggplot2)

  sim_logistic(1000, ~ .1 + 2 * A - 3 * B + 1 * A *B, corr = .7) %&gt;%
    ggplot(aes(A, B, col = class)) +
    geom_point(alpha = 1/2) +
    coord_equal()

  f_xor &lt;- ~ 10 * xor(A &gt; 0, B &lt; 0)
  # or
  f_xor &lt;- rlang::expr(10 * xor(A &gt; 0, B &lt; 0))

  sim_logistic(1000, f_xor, keep_truth = TRUE) %&gt;%
    ggplot(aes(A, B, col = class)) +
    geom_point(alpha = 1/2) +
    coord_equal() +
    theme_bw()
}

## How to use external symbols:

a_coef &lt;- 2
# splice the value in using rlang's !! operator
lp_eqn &lt;- rlang::expr(!!a_coef * A+B)
lp_eqn
sim_logistic(5, lp_eqn)

# Flexible multinomial regression simulation
if (rlang::is_installed("ggplot2")) {

}
</code></pre>


</div>