<div class="container">

<table style="width: 100%;"><tr>
<td>bandwidth_bootstrap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bootstrap bandwidth for local polynomial estimator of a psychometric function</h2>

<h3>Description</h3>

<p>This function finds a bootstrap estimate of the optimal bandwidth h for a local polynomial
estimate of the psychometric function with specified guessing and lapsing rates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bandwidth_bootstrap( r, m, x, H, N, h0 = NULL, link = "logit",
                     guessing = 0, lapsing = 0, K = 2, p = 1,
                     ker = "dnorm", maxiter = 50, tol = 1e-6, method = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>number of successes at points x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>number of trials at points x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>stimulus levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>search interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of bootstrap replications</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h0</code></td>
<td>
<p>(optional) pilot bandwidth; if not specified, then the scaled plug-in bandwidth is used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>(optional) name of the link function to be used; default is "logit"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>guessing</code></td>
<td>
<p>(optional) guessing rate; default is 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lapsing</code></td>
<td>
<p>(optional) lapsing rate; default is 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>(optional) power parameter for Weibull and reverse Weibull link; default is 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>(optional) degree of the polynomial; default is 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ker</code></td>
<td>
<p>(optional) kernel function for weights; default is "dnorm"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>(optional) maximum number of iterations in Fisher scoring; default is 50</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>(optional) tolerance level at which to stop Fisher scoring; default is 1e-6</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>(optional) loss function to be used in bootstrap: choose from: "ISEeta", "ISE", "deviance"; by default all possible values are calculated</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code style="white-space: pre;">⁠h  ⁠</code> bootstrap bandwidth for the chosen "method"; if no "method" is specified, then it has three components: $pscale, $eta-scale and $deviance
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("Baker_etal")
x = Baker_etal$x
r = Baker_etal$r
m = Baker_etal$m
plot( x, r / m, xlim = c( 0.16, 7.83 ), ylim = c( -0.01, 1.01 ), type = "p", pch="*" )
val &lt;- binomfit_lims( r, m, x, link = "probit" )
numxfit &lt;- 199; # Number of new points to be generated minus 1
xfit &lt;- (max(x)-min(x)) * (0:numxfit) / numxfit + min(x)
# Plot the fitted curve
pfit&lt;-predict( val$fit, data.frame( x = xfit ), type = "response" )
lines(xfit, pfit )
## Not run: 
data("Miranda_Henson")
x = Miranda_Henson$x
r = Miranda_Henson$r
m = Miranda_Henson$m
numxfit &lt;- 199; # Number of new points to be generated minus 1
xfit &lt;- (max(x)-min(x)) * (0:numxfit) / numxfit + min(x)
# Find a cross-validation bandwidth
bwd_min &lt;- min( diff( x ) )
bwd_max &lt;- max( x ) - min( x )
# This might take a few minutes
niter &lt;- 500 # Note number of bootstrap iterations should be at least 500
bwd &lt;- bandwidth_bootstrap( r, m, x, c( bwd_min, bwd_max ),niter, method="deviance")
pfit &lt;- locglmfit( xfit, r, m, x, bwd )$pfit
# Plot the fitted curve
plot( x, r / m, xlim = c( 0.1, 1.302 ), ylim = c( 0.0165, 0.965 ), type = "p", pch="*" )
lines(xfit, pfit )

## End(Not run)
</code></pre>


</div>