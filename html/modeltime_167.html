<div class="container">

<table style="width: 100%;"><tr>
<td>temporal_hierarchy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>General Interface for Temporal Hierarchical Forecasting (THIEF) Models</h2>

<h3>Description</h3>

<p><code>temporal_hierarchy()</code> is a way to generate a <em>specification</em> of an Temporal Hierarchical Forecasting model
before fitting and allows the model to be created using
different packages. Currently the only package is <code>thief</code>. Note this
function requires the <code>thief</code> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">temporal_hierarchy(
  mode = "regression",
  seasonal_period = NULL,
  combination_method = NULL,
  use_model = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is "regression".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seasonal_period</code></td>
<td>
<p>A seasonal frequency. Uses "auto" by default.
A character phrase of "auto" or time-based phrase of "2 weeks"
can be used if a date or date-time variable is provided.
See Fit Details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>combination_method</code></td>
<td>
<p>Combination method of temporal hierarchies, taking one of the following values:
</p>

<ul>
<li>
<p> "struc" - Structural scaling: weights from temporal hierarchy
</p>
</li>
<li>
<p> "mse" - Variance scaling: weights from in-sample MSE
</p>
</li>
<li>
<p> "ols" - Unscaled OLS combination weights
</p>
</li>
<li>
<p> "bu" - Bottom-up combination â€“ i.e., all aggregate forecasts are ignored.
</p>
</li>
<li>
<p> "shr" - GLS using a shrinkage (to block diagonal) estimate of residuals
</p>
</li>
<li>
<p> "sam" - GLS using sample covariance matrix of residuals
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_model</code></td>
<td>
<p>Model used for forecasting each aggregation level:
</p>

<ul>
<li>
<p> "ets" - exponential smoothing
</p>
</li>
<li>
<p> "arima" - arima
</p>
</li>
<li>
<p> "theta" - theta
</p>
</li>
<li>
<p> "naive" - random walk forecasts
</p>
</li>
<li>
<p> "snaive" - seasonal naive forecasts, based on the last year of observed data
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Models can be created using the following <em>engines</em>:
</p>

<ul><li>
<p> "thief" (default) - Connects to <code>thief::thief()</code>
</p>
</li></ul>
<h3>Engine Details</h3>

<p>The standardized parameter names in <code>modeltime</code> can be mapped to their original
names in each engine:</p>

<table>
<tr>
<td style="text-align: left;">
   modeltime </td>
<td style="text-align: left;"> thief::thief() </td>
</tr>
<tr>
<td style="text-align: left;">
   combination_method </td>
<td style="text-align: left;"> comb </td>
</tr>
<tr>
<td style="text-align: left;">
   use_model </td>
<td style="text-align: left;"> usemodel </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Other options can be set using <code>set_engine()</code>.
</p>
<p><strong>thief (default engine)</strong>
</p>
<p>The engine uses <code>thief::thief()</code>.
</p>
<p>Function Parameters:
</p>
<div class="sourceCode"><pre>#&gt; function (y, m = frequency(y), h = m * 2, comb = c("struc", "mse", "ols", 
#&gt;     "bu", "shr", "sam"), usemodel = c("ets", "arima", "theta", "naive", 
#&gt;     "snaive"), forecastfunction = NULL, aggregatelist = NULL, ...)
</pre></div>
<p>Other options and argument can be set using <code>set_engine()</code>.
</p>
<p>Parameter Notes:
</p>

<ul><li> <p><code>xreg</code> - This model is not set up to use exogenous regressors. Only univariate
models will be fit.
</p>
</li></ul>
<h3>Fit Details</h3>

<p><strong>Date and Date-Time Variable</strong>
</p>
<p>It's a requirement to have a date or date-time variable as a predictor.
The <code>fit()</code> interface accepts date and date-time features and handles them internally.
</p>

<ul><li> <p><code>fit(y ~ date)</code>
</p>
</li></ul>
<p><strong>Univariate:</strong>
</p>
<p>For univariate analysis, you must include a date or date-time feature. Simply use:
</p>

<ul>
<li>
<p> Formula Interface (recommended): <code>fit(y ~ date)</code> will ignore xreg's.
</p>
</li>
<li>
<p> XY Interface: <code>fit_xy(x = data[,"date"], y = data$y)</code> will ignore xreg's.
</p>
</li>
</ul>
<p><strong>Multivariate (xregs, Exogenous Regressors)</strong>
</p>
<p>This model is not set up for use with exogenous regressors.
</p>


<h3>References</h3>


<ul>
<li>
<p>For forecasting with temporal hierarchies see: Athanasopoulos G., Hyndman R.J., Kourentzes N., Petropoulos F. (2017) Forecasting with Temporal Hierarchies. <em>European Journal of Operational research</em>, <b>262</b>(<b>1</b>), 60-74.
</p>
</li>
<li>
<p>For combination operators see: Kourentzes N., Barrow B.K., Crone S.F. (2014) Neural network ensemble operators for time series forecasting. <em>Expert Systems with Applications</em>, <b>41</b>(<b>9</b>), 4235-4244.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>fit.model_spec()</code>, <code>set_engine()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(thief)

# Data
m750 &lt;- m4_monthly %&gt;% filter(id == "M750")
m750

# Split Data 80/20
splits &lt;- initial_time_split(m750, prop = 0.8)

# ---- HIERARCHICAL ----

# Model Spec - The default parameters are all set
# to "auto" if none are provided
model_spec &lt;- temporal_hierarchy() %&gt;%
    set_engine("thief")

# Fit Spec
model_fit &lt;- model_spec %&gt;%
    fit(log(value) ~ date, data = training(splits))
model_fit




</code></pre>


</div>