<div class="container">

<table style="width: 100%;"><tr>
<td>mode_single</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The single mode</h2>

<h3>Description</h3>

<p><code>mode_single()</code> returns the only mode in a vector. If there are multiple
modes, it returns <code>NA</code> by default.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mode_single(x, na.rm = FALSE, accept = FALSE, multiple = "NA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector to search for its mode.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Boolean. Should missing values in <code>x</code> be removed before
computation proceeds? Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accept</code></td>
<td>
<p>Boolean. Should the minimum set of modes be accepted to check
for a single mode? If <code>FALSE</code> (the default), insists on the complete set
and returns <code>NA</code> if it can't be determined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple</code></td>
<td>
<p>String or integer (length 1), or a function. What to do if
<code>x</code> has multiple modes. The default returns <code>NA</code>. All other options rely on
the modal values: "<code style="white-space: pre;">⁠min"⁠</code>, <code>"max"</code>, <code>"mean"</code>, <code>"median"</code>, <code>"first"</code>,
<code>"last"</code>, and <code>"random"</code>. Alternatively, <code>multiple</code> can be an index number,
or a function that summarizes the modes. See details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>accept</code> is <code>FALSE</code> (the default), the set of modes is obtained
via <code>mode_all()</code> instead of <code>mode_possible_min()</code>. Set it to <code>TRUE</code> to
avoid returning <code>NA</code> when some, though not all modes are known. The purpose
of the default is to insist on a single mode.
</p>
<p>If <code>x</code> is a string vector and <code>multiple</code> is <code>"min"</code> or <code>"max"</code>, the mode is
selected lexically, just like <code>min(letters)</code> returns <code>"a"</code>. The <code>"mean"</code>
and <code>"median"</code> options return <code>NA</code> with a warning. For factors, <code>"min"</code>,
<code>"max"</code>, and <code>"median"</code> are errors, but <code>"mean"</code> returns <code>NA</code> with a
warning. These are inconsistencies in base R.
</p>
<p>The <code>multiple</code> options <code>"first"</code> and <code>"last"</code> always select the mode that
appears first or last in <code>x</code>. Index numbers, like <code>multiple = 2</code>, allow you
to select more flexibly. If <code>multiple</code> is a function, its output must be
length 1.
</p>


<h3>Value</h3>

<p>The only mode (most frequent value) in <code>x</code>. If it can't be determined
because of missing values, <code>NA</code> is returned instead. By default, <code>NA</code> is
also returned if there are multiple modes (<code>multiple = "NA"</code>).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>mode_first()</code> for the first-appearing mode.
</p>
</li>
<li> <p><code>mode_all()</code> for the complete set of modes.
</p>
</li>
<li> <p><code>mode_possible_min()</code> for the minimal set of modes.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># `8` is the only mode:
mode_single(c(8, 8, 9))

# With more than one mode, the function
# returns `NA`:
mode_single(c(1, 2, 3, 3, 4, 4))

# Can't determine the modes here --
# `9` might be another mode:
mode_single(c(8, 8, 9, NA))

# Accept `8` anyways if it's
# sufficient to just have any mode:
mode_single(c(8, 8, 9, NA), accept = TRUE)

# `1` is the most frequent value,
# no matter what `NA` stands for:
mode_single(c(1, 1, 1, 2, NA))

# Ignore `NA`s with `na.rm = TRUE`
# (there should be good reasons for this!):
mode_single(c(8, 8, 9, NA), na.rm = TRUE)
</code></pre>


</div>