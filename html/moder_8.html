<div class="container">

<table style="width: 100%;"><tr>
<td>mode_is_trivial</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Is the mode trivial?</h2>

<h3>Description</h3>

<p><code>mode_is_trivial()</code> checks whether all values in a given vector
are equally frequent. The mode is not too informative in such cases.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mode_is_trivial(x, na.rm = FALSE, max_unique = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector to search for its modes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Boolean. Should missing values in <code>x</code> be removed before
computation proceeds? Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_unique</code></td>
<td>
<p>Numeric or string. If the maximum number of unique values
in <code>x</code> is known, set <code>max_unique</code> to that number. This rules out that <code>NA</code>s
represent values beyond that number (see examples). Set it to <code>"known"</code>
instead if no values beyond those already known can occur. Default is
<code>NULL</code>, which assumes no maximum.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function returns <code>TRUE</code> whenever <code>x</code> has length &lt; 3 because no
value is more frequent than another one. Otherwise, it returns <code>NA</code> in
these cases:
</p>

<ul>
<li>
<p> Some <code>x</code> values are missing and all known values are equal. Thus, it is
unknown whether there is a value with a different frequency.
</p>
</li>
<li>
<p> All known values are modes if the <code>NA</code>s "fill up" the non-modal values
exactly, i.e., without any <code>NA</code>s remaining.
</p>
</li>
<li>
<p> Some <code>NA</code>s remain after "filling up" the non-modal values with <code>NA</code>s (so
that they are hypothetically modes), and the number of remaining <code>NA</code>s is
divisible by the number of unique known values.
</p>
</li>
<li>
<p> There are so many missing values that they might form mode-sized groups
of values that are not among the known values, and the number of <code>NA</code>s is
divisible by the modal frequency so that all (partly hypothetical) values
might be equally frequent. You can limit the number of such hypothetical
values by specifying <code>max_unique</code>. The function might then return <code>FALSE</code>
instead of <code>NA</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Boolean (length 1).
</p>


<h3>Examples</h3>

<pre><code class="language-R"># The mode is trivial if
# all values are equal...
mode_is_trivial(c(1, 1, 1))

# ...and even if all unique
# values are equally frequent:
mode_is_trivial(c(1, 1, 2, 2))

# It's also trivial if
# all values are different:
mode_is_trivial(c(1, 2, 3))

# Here, the mode is nontrivial
# because `1` is more frequent than `2`:
mode_is_trivial(c(1, 1, 2))

# Two of the `NA`s might be `8`s, and
# the other three might represent a value
# different from both `7` and `8`. Thus,
# it's possible that all three distinct
# values are equally frequent:
mode_is_trivial(c(7, 7, 7, 8, rep(NA, 5)))

# The same is not true if all values,
# even the missing ones, must represent
# one of the known values:
mode_is_trivial(c(7, 7, 7, 8, rep(NA, 5)), max_unique = "known")
</code></pre>


</div>