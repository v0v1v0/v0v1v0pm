<div class="container">

<table style="width: 100%;"><tr>
<td>mode-possible</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Possible sets of modes</h2>

<h3>Description</h3>

<p><code>mode_possible_min()</code> and <code>mode_possible_max()</code> determine the
minimal and maximal sets of modes from among known modes, given the number
of missing values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mode_possible_min(x, multiple = FALSE)

mode_possible_max(x, multiple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector to search for its possible modes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple</code></td>
<td>
<p>Boolean. If <code>multiple</code> is set to <code>TRUE</code>, the functions return
multiple modes with the same frequency, even if some values are missing.
Default is <code>FALSE</code> because <code>NA</code>s may tip the balance between values that
are equally frequent among the known values. Thus, if <code>multiple = TRUE</code>,
the functions don't necessarily return the minimal or maximal sets of
modes, but all values that <em>might</em> be part of those sets.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>By default, a vector with the minimal or maximal possible sets of
modes (values tied for most frequent) in <code>x</code>. If the functions can't
determine these possible modes because of missing values, they return
<code>NA</code> by default (<code>multiple = FALSE</code>).
</p>


<h3>See Also</h3>

<p><code>mode_count_range()</code> for the minimal and maximal <em>numbers</em> of
possible modes. They can always be determined, even if the present
functions return <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># "a" is guaranteed to be a mode,
# "b" might also be one, but
# "c" is impossible:
mode_possible_min(c("a", "a", "a", "b", "b", "c", NA))
mode_possible_max(c("a", "a", "a", "b", "b", "c", NA))

# Only `8` can possibly be the mode
# because, even if `NA` is `7`, it's
# still less frequent than `8`:
mode_possible_min(c(7, 7, 8, 8, 8, 8, NA))
mode_possible_max(c(7, 7, 8, 8, 8, 8, NA))

# No clear minimal or maximal set
# of modes because `NA` may tip
# the balance between `1` and `2`
# towards a single mode:
mode_possible_min(c(1, 1, 2, 2, 3, 4, 5, NA))
mode_possible_max(c(1, 1, 2, 2, 3, 4, 5, NA))

# With `multiple = TRUE`, the functions
# return all values that might be part of
# the min / max sets of modes; not these
# sets themselves:
mode_possible_min(c(1, 1, 2, 2, 3, 4, 5, NA), multiple = TRUE)
mode_possible_max(c(1, 1, 2, 2, 3, 4, 5, NA), multiple = TRUE)
</code></pre>


</div>