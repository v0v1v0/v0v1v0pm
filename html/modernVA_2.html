<div class="container">

<table style="width: 100%;"><tr>
<td>tdVA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R wrapper that accesses C code to fit temporal dependent value-added models for two cohorts</h2>

<h3>Description</h3>

<p><code>tdVA</code> is the main function used to fit the temporally dependent value-added model for two cohorts
</p>


<h3>Usage</h3>

<pre><code class="language-R">tdVA(y1, xmat1,
     y2, xmat2,
     school1, school2,
     groupID=NULL,
     model=0,
     priors=c(0, 100^2, 1, 1, 1, 1, 0, 100^2, -1, 1, 0, 100^2, 0, 100^2),
     var.global=TRUE,
     MHsd=c(0.2),
     nchains=1,
     draws=50000, burn=40000, thin=10,
     verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y1</code></td>
<td>
<p>numeric vector (response variable) of length N1 for cohort 1.  Must be in long format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y2</code></td>
<td>
<p>numeric vector (response variable) of Length N2 for cohort 2.  Must be in long format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmat1</code></td>
<td>
<p>N1 x p matrix of covariates for cohort 1 (column of 1's must NOT be included).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmat2</code></td>
<td>
<p>N2 x p matrix of covariates for cohort 2 (column of 1's must NOT be included).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>school1</code></td>
<td>
<p>numeric vector indicating to which school each student belongs for cohort 1.  These labels must be contiguous labels and start with 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>school2</code></td>
<td>
<p>numeric vector indicating to which school each student belongs for cohort 2.  These labels must be contiguous labels and start with 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupID</code></td>
<td>
<p>Optional vector that identifies to which group a school belongs.  If NULL there is no grouping</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Integer indicating which value-added model is to be fit
</p>
<p>0 - Independent school effects between the two cohorts.
</p>
<p>1 - Temporally dependent school effects between two cohorts based on a non-statinary AR(1) process,
</p>
<p>2 - Temporally dependent school effects based on previous cohorts post-test performance.
</p>
<p>3 - Full model that includes both an AR(1) type correlation and one based on previous cohorts post-test performance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>Vector of prior distribution parameter values.
</p>
<p>mb - prior mean for beta1 and beta2, default is 0.
</p>
<p>s2b - prior variance for beta1 and beta2, default is 100^2.
</p>
<p>at - prior shape for tau22 and tau21, default is 1.
</p>
<p>bt - prior rate for tau22 and tau21, default is 1.
</p>
<p>as - prior shape for sigma2, default is 1.
</p>
<p>bs - prior rate for sigma2, default is 1.
</p>
<p>mg - prior mean for gamma2, default is 0.  (only used if model = 2)
</p>
<p>s2g - prior variance for gamma2, default is 100^2.   (only used if model = 2)
</p>
<p>lp12 - prior lower bound for for phi12, default is -1.  (only used if model = 1)
</p>
<p>up12 - prior upper bound for for phi12, default is 1. (only used if model = 1)
</p>
<p>mp02 - prior mean for phi02, default is 0.
</p>
<p>s202 - prior variance for phi02, default is 100^2.
</p>
<p>mp01 - prior mean for phi01, default is 0.
</p>
<p>s201 - prior variance for phi01, default is 100^2.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.global</code></td>
<td>
<p>Logical argument. If true, then a model with common sigma21 and sigma22 among schools is fit.  If false, then a model with school-specific sigma21i and sigma22i is fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MHsd</code></td>
<td>
<p>Tuning parameter associated with M-H step of phi12.  Default is 0.2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nchains</code></td>
<td>
<p>number of MCMC chains to run. Default is 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>draws</code></td>
<td>
<p>number of MCMC iterates to be collected. default is 50,000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>
<p>number of MCMC iterates discared as burn-in. default is 40,000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>number by which the MCMC chain is thinne. default is 10</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical indicating if progress of MCMC algorithm should be printed to screen along with other data summaries</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>This function returns a list that contains MCMC iterates for all the model parameters in addition to the value-added estimates and intervals for each of the two cohorts
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate data from model 1 of San Martin el al.
m &lt;- 25 # number of schools
ni &lt;- 20 # number of students per school
N &lt;- m*ni

# specify parameter values to generate data
beta1 &lt;- 0.6
beta2 &lt;- 0.75;
sig21 &lt;- 100;
sig22 &lt;- 100;
tau2 &lt;- 100
phi02 &lt;- 0;
phi12 &lt;- 0.75;
phi01 &lt;- 0

X1 &lt;- rnorm(N, 0, sqrt(200))
X2 &lt;- rnorm(N, 0, sqrt(200))

alpha1 &lt;- rnorm(m, phi01, sqrt(tau2))
alpha2 &lt;- rnorm(m, phi02 + phi12*alpha1, sqrt(tau2*(1-phi12^2)))

Y1 &lt;- rep(alpha1, each=ni) + X1*beta1 + rnorm(N, 0, sqrt(sig21))
Y2 &lt;- rep(alpha2, each=ni) + X2*beta2 + rnorm(N, 0, sqrt(sig22))

# Create school vector indicating to which school each observation belongs
school1 &lt;- rep(1:m, each=ni)
school2 &lt;- rep(1:m, each=ni)


# design matrix only one covariate and no intercept
X1i &lt;- cbind(X1)
X2i &lt;- cbind(X2)


fit &lt;- tdVA(y1=Y1,xmat1=X1i,y2=Y2,xmat2=X2i,
              school1=school1,school2=school2, groupID=NULL, model=2,
              var.global=TRUE, nchains=1)

# Value-added estimates of cohort 1 and 2 with 95% credible intervals.  See paper for details
cbind(fit$VA1.estimate,t(fit$VA1.intervals))
cbind(fit$VA2.estimate,t(fit$VA2.intervals))


</code></pre>


</div>