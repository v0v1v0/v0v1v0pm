<div class="container">

<table style="width: 100%;"><tr>
<td>marg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimating predictive margins on a model</h2>

<h3>Description</h3>

<p>This function estimates the predictive effects and levels for variables within
a model using the delta method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">marg(
  mod,
  var_interest,
  data = NULL,
  weights = NULL,
  vcov_mat = NULL,
  dof = NULL,
  type = "levels",
  base_rn = 1,
  at_var_interest = NULL,
  at = NULL,
  cofint = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p>model object, currently only support those of class <code>glm</code>
or <code>ivreg</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_interest</code></td>
<td>
<p>name of the variable of interest, must correspond to a
covariate in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data.frame that margins should run over, defaults changes based
on class-specific method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>numeric, vector of weights used to generate predicted levels,
defaults changes based on class-specific method. Must be equal to the number
of rows in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov_mat</code></td>
<td>
<p>the variance-covariance matrix,
defaults changes based on class-specific method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dof</code></td>
<td>
<p>integer, the degrees of freedom used for the T statistic in an
OLS model, defaults changes based on class-specific method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>either <code>'levels'</code> (predicted outcomes) or <code>'effects'</code> <code class="reqn">dydx</code>,
defaults to <code>'levels'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base_rn</code></td>
<td>
<p>numeric, if <code>type == 'effects'</code>, the base level (taken as the
index of one of the ordered unique values in <code>var_interest</code>). if
<code>type == 'levels'</code>, this parameter is ignored. Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at_var_interest</code></td>
<td>
<p>vector, if type == 'levels', the values for the
variable of interest at which levels should be calculated.
If <code>NULL</code>, indicates all levels for a factor variable, defaults to <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p>list, should be in the format of <code>list('var_name' = c(values))</code>,
defaults to <code>NULL</code>. This calculates the margins of the variable at these
particular variables. If all values are needed, suggested syntax is
<code>at = list('var' = unique(df$var))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cofint</code></td>
<td>
<p>numeric, confidence interval (must be less than 1), defaults to 0.95</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters passed to class-specific methods</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The variable for the predictive margin is specified by <code>var_interest</code>. If
margins are only needed at particular values of <code>var_interest</code>,
<code>at_var_interest</code> should be used. If margins of <code>var_interest</code> are
needed at across the levels of a <em>different</em> variable in the model,
<code>at</code> should be used.
</p>
<p>If higher-order polynomial terms (e.g. <code class="reqn">y ~ x + x^2</code>) are added
using the R function <code>poly</code>, the <code>raw = TRUE</code>
argument should be used to include the basic polynomial terms
instead of orthogonal polynomial terms. If orthogonal polynomials are used,
<code>marg</code> will fail when the user specifies <code>at</code> for a small set
of values for the variable in question (e.g. <code>at = list(x = 10)</code>),
since <code>poly</code> needs more data to calculate orthogonal polynomials
(e.g. <code>poly(10, 2)</code> fails, but <code>poly(c(10, 8, 3), 2)</code> will run).
</p>
<p>P values are calculated with T tests for gaussian families, and Z tests
otherwise. If a new variance-covariance matrix is provided (e.g. for
clustering standard errors), the degrees of freedom for the T test / p-value
calculation may need to be specified using <code>dof</code>.
</p>
<p>This function currently only supports <code>glm</code> and
<code>ivreg</code> objects. If you would like to use <code>lm</code>
objects, consider running a <code>glm</code> with family <code>gaussian</code>.
</p>
<p>When calculating predicted levels and effects for models built using weights,
<code>marg</code> returns weighted averages for levels and effects by default.
Users can remove this option by setting <code>weights = NULL</code>.
</p>


<h3>Value</h3>

<p>list of dataframes with predicted margins/effects, standard errors, p-values,
and confidence interval bounds
</p>


</div>