<div class="container">

<table style="width: 100%;"><tr>
<td>resample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bootstrapping or multi-sample splits for variable selection</h2>

<h3>Description</h3>

<p>Multiple resampling procedures for selecting variables for a final network
model. There are three resampling methods that can be parameterized in a
variety of different ways. The ultimate goal is to fit models across iterated
resamples with variable selection procedures built in so as to home in on the
best predictors to include within a given model. The methods available
include: bootstrapped resampling, multi-sample splitting, and stability
selection.
</p>


<h3>Usage</h3>

<pre><code class="language-R">resample(
  data,
  m = NULL,
  niter = 10,
  sampMethod = "bootstrap",
  criterion = "AIC",
  method = "glmnet",
  rule = "OR",
  gamma = 0.5,
  nfolds = 10,
  nlam = 50,
  which.lam = "min",
  threshold = FALSE,
  bonf = FALSE,
  alpha = 0.05,
  exogenous = TRUE,
  split = 0.5,
  center = TRUE,
  scale = FALSE,
  varSeed = NULL,
  seed = NULL,
  verbose = TRUE,
  lags = NULL,
  binary = NULL,
  type = "g",
  saveMods = TRUE,
  saveData = FALSE,
  saveVars = FALSE,
  fitit = TRUE,
  nCores = 1,
  cluster = "mclapply",
  block = FALSE,
  beepno = NULL,
  dayno = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>n x k</code> dataframe. Cannot supply a matrix as input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Character vector or numeric vector indicating the moderator(s), if
any. Can also specify <code>"all"</code> to make every variable serve as a
moderator, or <code>0</code> to indicate that there are no moderators. If the
length of <code>m</code> is <code>k - 1</code> or longer, then it will not be possible
to have the moderators as exogenous variables. Thus, <code>exogenous</code> will
automatically become <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>Number of iterations for the resampling procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampMethod</code></td>
<td>
<p>Character string indicating which type of procedure to use.
<code>"bootstrap"</code> is a standard bootstrapping procedure. <code>"split"</code> is
the multi-sample split procedure where the data are split into disjoint
training and test sets, the variables to be modeled are selected based on
the training set, and then the final model is fit to the test set.
<code>"stability"</code> is stability selection, where models are fit to each of
two disjoint subsamples of the data, and it is calculated how frequently
each variable is selected in each subset, as well how frequently they are
simultaneously selected in both subsets at each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>The criterion for the variable selection procedure. Options
include: <code>"cv", "aic", "bic", "ebic", "cp", "rss", "adjr2", "rsq",
  "r2"</code>. <code>"CV"</code> refers to cross-validation, the information criteria are
<code>"AIC", "BIC", "EBIC"</code>, and <code>"Cp"</code>, which refers to Mallow's Cp.
<code>"RSS"</code> is the residual sum of squares, <code>"adjR2"</code> is adjusted
R-squared, and <code>"Rsq"</code> or <code>"R2"</code> is R-squared. Capitalization is
ignored. For methods based on the LASSO, only <code>"CV", "AIC", "BIC",
  "EBIC"</code> are available. For methods based on subset selection, only
<code>"Cp", "BIC", "RSS", "adjR2", "R2"</code> are available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character string to indicate which method to use for variable
selection. Options include <code>"lasso"</code> and <code>"glmnet"</code>, both of
which use the LASSO via the <code>glmnet</code> package (either with
<code>glmnet::glmnet</code> or
<code>glmnet::cv.glmnet</code>, depending upon the
criterion). <code>"subset", "backward", "forward", "seqrep"</code>, all call
different types of subset selection using the
<code>leaps::regsubsets</code> function. Finally
<code>"glinternet"</code> is used for applying the hierarchical lasso, and is the
only method available for moderated network estimation (either with
<code>glinternet::glinternet</code> or
<code>glinternet::glinternet.cv</code>,
depending upon the criterion). If one or more moderators are specified,
then <code>method</code> will automatically default to <code>"glinternet"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>Only applies to GGMs (including between-subjects networks) when a
threshold is supplied. The <code>"AND"</code> rule will only preserve edges when
both corresponding coefficients have p-values below the threshold, while
the <code>"OR"</code> rule will preserve an edge so long as one of the two
coefficients have a p-value below the supplied threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Numeric value of the hyperparameter for the <code>"EBIC"</code>
criterion. Only relevant if <code>criterion = "EBIC"</code>. Recommended to use a
value between 0 and .5, where larger values impose a larger penalty on the
criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>Only relevant if <code>criterion = "CV"</code>. Determines the number
of folds to use in cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlam</code></td>
<td>
<p>if <code>method = "glinternet"</code>, determines the number of lambda
values to evaluate in the selection path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.lam</code></td>
<td>
<p>Character string. Only applies if <code>criterion = "CV"</code>.
Options include <code>"min"</code>, which uses the lambda value that minimizes
the objective function, or <code>"1se"</code> which uses the lambda value at 1
standard error above the value that minimizes the objective function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>Logical or numeric. If <code>TRUE</code>, then a default value of
.05 will be set. Indicates whether a threshold should be placed on the
models at each iteration of the sampling. A significant choice by the
researcher.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bonf</code></td>
<td>
<p>Logical. Determines whether to apply a bonferroni adjustment on
the distribution of p-values for each coefficient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Type 1 error rate. Defaults to .05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exogenous</code></td>
<td>
<p>Logical. Indicates whether moderator variables should be
treated as exogenous or not. If they are exogenous, they will not be
modeled as outcomes/nodes in the network. If the number of moderators
reaches <code>k - 1</code> or <code>k</code>, then <code>exogenous</code> will automatically
be <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>If <code>sampMethod == "split"</code> or <code>sampMethod =
  "stability"</code> then this is a value between 0 and 1 that indicates the
proportion of the sample to be used for the training set. When
<code>sampMethod = "stability"</code> there isn't an important distinction
between the labels "training" and "test", although this value will still
cause the two samples to be taken of complementary size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>Logical. Determines whether to mean-center the variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Logical. Determines whether to standardize the variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varSeed</code></td>
<td>
<p>Numeric value providing a seed to be set at the beginning of
the selection procedure. Recommended for reproducible results. Importantly,
this seed will be used for the variable selection models at each iteration
of the resampler. Caution this means that while each model is run with a
different sample, it will always have the same seed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Can be a single value, to set a seed before drawing random seeds
of length <code>niter</code> to be used across iterations. Alternatively, one can
supply a vector of seeds of length <code>niter</code>. It is recommended to use
this argument for reproducibility over the <code>varSeed</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. Determines whether information about the modeling
progress should be displayed in the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lags</code></td>
<td>
<p>Numeric or logical. Can only be 0, 1 or <code>TRUE</code> or
<code>FALSE</code>. <code>NULL</code> is interpreted as <code>FALSE</code>. Indicates whether
to fit a time-lagged network or a GGM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binary</code></td>
<td>
<p>Numeric vector indicating which columns of the data contain
binary variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Determines whether to use gaussian models <code>"g"</code> or binomial
models <code>"c"</code>. Can also just use <code>"gaussian"</code> or
<code>"binomial"</code>. Moreover, a vector of length <code>k</code> can be provided
such that a value is given to every variable. Ultimately this is not
necessary, though, as such values are automatically detected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveMods</code></td>
<td>
<p>Logical. Indicates whether to save the models fit to the
samples at each iteration or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveData</code></td>
<td>
<p>Logical. Determines whether to save the data from each
subsample across iterations or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveVars</code></td>
<td>
<p>Logical. Determines whether to save the variable selection
models at each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitit</code></td>
<td>
<p>Logical. Determines whether to fit the final selected model on
the original sample. If <code>FALSE</code>, then this can still be done with
<code>fitNetwork</code> and <code>modSelect</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nCores</code></td>
<td>
<p>Numeric value indicating the number of CPU cores to use for the
resampling. If <code>TRUE</code>, then the
<code>parallel::detectCores</code> function will be
used to maximize the number of cores available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Character vector indicating which type of parallelization to
use, if <code>nCores &gt; 1</code>. Options include <code>"mclapply"</code> and
<code>"SOCK"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block</code></td>
<td>
<p>Logical or numeric. If specified, then this indicates that
<code>lags != 0</code> or <code>lags != NULL</code>. If numeric, then this indicates
that block bootstrapping will be used, and the value specifies the block
size. If <code>TRUE</code> then an appropriate block size will be estimated
automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beepno</code></td>
<td>
<p>Character string or numeric value to indicate which variable
(if any) encodes the survey number within a single day. Must be used in
conjunction with <code>dayno</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dayno</code></td>
<td>
<p>Character string or numeric value to indiciate which variable
(if any) encodes the survey number within a single day. Must be used in
conjunction with <code>beepno</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Sampling methods can be specified via the <code>sampMethod</code> argument.
</p>
 <dl>
<dt>Bootstrapped resampling</dt>
<dd>
<p>Standard bootstrapped resampling,
wherein a bootstrapped sample of size <code>n</code> is drawn with replacement at
each iteration. Then, a variable selection procedure is applied to the
sample, and the selected model is fit to obtain the parameter values.
P-values and confidence intervals for the parameter distributions are then
estimated.</p>
</dd> <dt>Multi-sample splitting</dt>
<dd>
<p>Involves taking two disjoint
samples from the original data – a training sample and a test sample. At
each iteration the variable selection procedure is applied to the training
sample, and then the resultant model is fit on the test sample. Parameters
are then aggregated based on the coefficients in the models fit to the test
samples.</p>
</dd> <dt>Stability selection</dt>
<dd>
<p>Stability selection begins the same as
multi-sample splitting, in that two disjoint samples are drawn from the data
at each iteration. However, the variable selection procedure is then applied
to each of the two subsamples at each iteration. The objective is to compute
the proportion of times that each predictor was selected in each subsample
across iterations, as well as the proportion of times that it was
simultaneously selected in both disjoint samples. At the end of the
resampling, the final model is selected by setting a frequency threshold
between 0 and 1, indicating the minimum proportion of samples that a variable
would have to have been selected to be retained in the final model.</p>
</dd> </dl>
<p>For the bootstrapping and multi-sample split methods, p-values are aggregated
for each parameter using a method developed by Meinshausen, Meier, &amp; Buhlmann
(2009) that employs error control based on the false-discovery rate. The same
procedure is employed for creating adjusted confidence intervals.
</p>
<p>A key distinguishing feature of the bootstrapping procedure implemented in
this function versus the <code>bootNet</code> function is that the latter is
designed to estimate the parameter distributions of a single model, whereas
the version here is aimed at using the bootstrapped resamples to select a
final model. In a practical sense, this boils down to using the bootstrapping
method in the <code>resample</code> function to perform variable selection
at each iteration of the resampling, rather than taking a single constrained
model and applying it equally at all iterations.
</p>


<h3>Value</h3>

<p><code>resample</code> output
</p>


<h3>References</h3>

<p>Meinshausen, N., Meier, L., &amp; Buhlmann, P. (2009). P-values for
high-dimensional regression. Journal of the American Statistical
Association. 104, 1671-1681.
</p>
<p>Meinshausen, N., &amp; Buhlmann, P. (2010). Stability selection. Journal of the
Royal Statistical Society: Series B (Statistical Methodology). 72, 417-423
</p>


<h3>See Also</h3>

<p><code>plot.resample, modSelect, fitNetwork,
  bootNet, mlGVAR, plotNet, plotCoefs,
  plotBoot, plotPvals, plotStability, net,
  netInts, glinternet::glinternet,
  glinternet::glinternet.cv,
  glmnet::glmnet,
  glmnet::cv.glmnet,
  leaps::regsubsets</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
fit1 &lt;- resample(ggmDat, m = 'M', niter = 10)

net(fit1)
netInts(fit1)

plot(fit1)
plot(fit1, what = 'coefs')
plot(fit1, what = 'bootstrap', multi = TRUE)
plot(fit1, what = 'pvals', outcome = 2, predictor = 4)

fit2 &lt;- resample(gvarDat, m = 'M', niter = 10, lags = 1, sampMethod = 'stability')

plot(fit2, what = 'stability', outcome = 3)

</code></pre>


</div>