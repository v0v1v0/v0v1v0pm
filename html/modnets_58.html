<div class="container">

<table style="width: 100%;"><tr>
<td>simNet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate network structure and data</h2>

<h3>Description</h3>

<p>Used for generating moderated and unmoderated adjacency matrices, along with
data based on those model structures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simNet(
  N = 100,
  p = 5,
  m = FALSE,
  m2 = 0.1,
  b1 = NULL,
  b2 = NULL,
  sparsity = 0.5,
  intercepts = NULL,
  nIter = 250,
  msym = FALSE,
  onlyDat = FALSE,
  pbar = TRUE,
  div = 10,
  gibbs = TRUE,
  ordinal = FALSE,
  nLevels = 5,
  mord = FALSE,
  time = TRUE,
  mbinary = FALSE,
  minOrd = 3,
  m1 = NULL,
  m1_range = NULL,
  m2_range = c(0.1, 0.3),
  modType = "none",
  lags = NULL,
  V = 2,
  skewErr = FALSE,
  onlyNets = FALSE,
  netArgs = NULL,
  nCores = 1,
  cluster = "SOCK",
  getChains = FALSE,
  const = 1.5,
  fixedPar = NULL,
  V2 = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Numeric value. Total number of subjects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Numeric value. Total number of nodes (excluding moderator).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>If a value is provided, a moderator is generated and named <code>M</code>
in the resultant data. If <code>TRUE</code>, then a normal distribution with a
mean of 0 will be used to generate the initial value of <code>m</code>, which
will serve as the population mean for <code>m</code> throughout the simulation.
If a numeric value is provided, then this will serve as the population
mean, and all subsequent draws will be taken from a normal distribution
with that mean. If <code>m = "binary"</code>, then this will simply set the
argument <code>mbinary = TRUE</code>. If <code>m = "ordinal"</code>, this will set
<code>mord = TRUE</code>. To simulate <code>m</code> from a skewed distribution, there
are two options: if <code>m = "skewed"</code>, then the <code>alpha</code> parameter of
the <code>sn::rmsn</code> will automatically be set to 3.
Alternatively, a vector of length two can be supplied, containing the
element <code>"skewed"</code> as well as the desired value of <code>alpha</code>.
Lastly, a function can be provided for <code>m</code> if the user wishes to
sample <code>m</code> from another distribution. The requirement is that the
function have only one argument, and only returns a single numeric value.
The input of the argument should be the location parameter of the desired
sampling distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m2</code></td>
<td>
<p>Numeric. If <code>m2 &gt;= 1</code>, then this will determine the number of
interaction effects between the moderator and some node in the network. If
a value between 0 and 1 is provided, then this determines the probability
of any given edge being moderated by the moderator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b1</code></td>
<td>
<p>Can provide an adjacency matrix to use for generating data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b2</code></td>
<td>
<p>Can provide an interaction matrix for generated moderated data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparsity</code></td>
<td>
<p>Numeric value between 0 and 1. Determines the sparsity of
sampled network matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercepts</code></td>
<td>
<p>A vector of means for sampling node values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIter</code></td>
<td>
<p>Number of iterations for generating each instance of a datapoint
with the Gibbs sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msym</code></td>
<td>
<p>If <code>TRUE</code> then will force the interaction matrix to be
symmetric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onlyDat</code></td>
<td>
<p>If <code>TRUE</code> then the function only returns the simulated
data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pbar</code></td>
<td>
<p>If <code>TRUE</code> then a progress bar will be shown as samples are
generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>div</code></td>
<td>
<p>A value to use as a sign that the sampler diverged. Can be
increased based on expected range of values. If a datapoint is larger than
<code>div</code>, then the sampler will stop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gibbs</code></td>
<td>
<p>If <code>TRUE</code>, then Gibbs sampling will be used. Otherwise,
data are generated from the <code>mvtnorm::rmvnorm</code>
function based on the partial correlation matrix that is created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordinal</code></td>
<td>
<p>Logical. Determines whether to generate ordinal values or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nLevels</code></td>
<td>
<p>Number of levels for the ordinal variables. Only relevant if
<code>ordinal</code> is not <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mord</code></td>
<td>
<p>Logical. Determines whether the moderator variable should be
simulated as ordinal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>If <code>TRUE</code> then the time it takes to simulate the data is
printed to screen at the end of the sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mbinary</code></td>
<td>
<p>Logical. Determines whether the moderator should be a binary
variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minOrd</code></td>
<td>
<p>The minimum number of unique values allowed for each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m1</code></td>
<td>
<p>Functions similarly to <code>m2</code>, except that this argument refers
to the number/probability of main effects of the moderator on any given
node.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m1_range</code></td>
<td>
<p>Numeric vector of length 2. The range of values for moderator
main effect coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m2_range</code></td>
<td>
<p>Numeric vector of length 2. The range of values for moderator
interaction effect coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modType</code></td>
<td>
<p>Determines the type of moderation to employ, such as
<code>"none", "full", "partial"</code>. If <code>modType = "full"</code>, then for any
interaction terms there will be full moderation, such that all pairwise
relationships for moderated paths will be set to zero. If <code>modType =
  "partial"</code>, then pairwise edges for moderated paths will always be nonzero.
If <code>modType = "none"</code>, no constraints will be applied (e.g., could
produce a mix between full and partial moderation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lags</code></td>
<td>
<p>If <code>TRUE</code> or 1, then arguments are rerouted to the
<code>mlGVARsim</code> function to simulate temporal data for a single
individual.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>Numeric, either 1 or 2. Determines whether to randomize the order of
simulating node values at each iteration of the Gibbs sampler. If <code>V =
  2</code>, then the order is randomized at each iteration. If <code>V = 1</code>, then
the sampler moves through the nodes from the first to the last in order at
each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skewErr</code></td>
<td>
<p>The skewness parameter for the <code>alpha</code> argument in the
<code>sn::rmsn</code> function. Only relevant when <code>gibbs =
  FALSE</code> and no moderator is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onlyNets</code></td>
<td>
<p>If <code>TRUE</code> then only the network models are returned,
without the data. Could be used to create random models and then simulate
data by another method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>netArgs</code></td>
<td>
<p>Only for use by the internal function
<code>modnets:::simNet2</code>, which serves as a wrapper for the current
function to prevent it from failing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nCores</code></td>
<td>
<p>Numeric value indicating the number of CPU cores to use for the
resampling. If <code>TRUE</code>, then the
<code>parallel::detectCores</code> function will be
used to maximize the number of cores available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Character vector indicating which type of parallelization to
use, if <code>nCores &gt; 1</code>. Options include <code>"mclapply"</code> and
<code>"SOCK"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getChains</code></td>
<td>
<p>Logical. Determines whether to return the data-generating
chains from the Gibbs sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>
<p>Numeric. The constant to be used by the internal
<code>modnets:::simPcor</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedPar</code></td>
<td>
<p>Numeric. If provided, then this will be set as the
coefficient value for all edges in the network. Provides a way to
standardize the parameter values while varying the sparsity of the network.
If <code>length(fixedPar) == 1</code>, then the same value will be used for all
parameters. If <code>length(fixedPar) == 2</code>, then the first value will be
for pairwise relationships, and the second value will be for interaction
terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V2</code></td>
<td>
<p>If <code>V2 = 1</code> and <code>m2</code> is between 0 and 1, the number of
interaction terms in the model will be determined by multiplying <code>m2</code>
with the number of elements in the interaction matrix and taking the
<code>ceiling</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If no moderator is specified then data can be generated directly from a
partial correlation matrix by setting <code>gibbs = FALSE</code>, which produces
fast simulation results. Alternatively, a Gibbs sampler is used to generate
data, which is the default option. For moderated networks, Gibbs sampling is
the only method available.
</p>


<h3>Value</h3>

<p>Simulated network models as well as data generated from those models.
For GGMs, model matrices are always symmetric. For temporal networks (when
<code>lags = 1</code>), columns predict rows.
</p>


<h3>Warning</h3>

<p>Importantly, the Gibbs sampler can easily diverge given certain model
parameters. Generating network data based on moderator variables can
produce data that quickly take on large values due to the presence of
multiplicative terms. If the simulation fails, first simply try re-running
the function with a different seed; this will often be sufficient to solve
the problem when default parameters are specified. Additionally, one can
increase the value of <code>div</code>, in case the sampler only diverges
slightly or simply produced an anomalous value. This raises the threshold
of tolerated values before the sampler stops. If supplying user-generated
model matrices (for the <code>b1</code> and/or <code>b2</code> arguments) and the
function continues to fail, you will likely need to change the parameter
values in those matrices, as it may not be possible to simulate data under
the given values. If simulating the model matrices inside the function (as
is the default) and the function continues to fail, try adjusting the
following parameters: </p>
 <ol>
<li>
<p>Try reducing the value of <code>m2</code>
to specify fewer interactions. </p>
</li>
<li>
<p>Try reducing a range with a smaller
maximum for <code>m2_range</code>, to adjust the range of interaction
coefficients. </p>
</li>
<li>
<p>Try adjusting the corresponding main effect parameters
for the moderator, <code>m1</code> and <code>m1_range</code>. </p>
</li>
<li>
<p>Try setting
<code>modType = "full"</code> to reduce the number of main effect parameters.
</p>
</li>
<li>
<p>Try setting a low value(s) for <code>fixedPar</code>, in order to provide
parameter values that are known to be lower </p>
</li>
</ol>
<p>An alternative approach could be to use the internal function
<code>simNet2</code>, which is a wrapper designed to re-run <code>simNet</code> when it
fails and automatically adjust simulation parameters such as <code>div</code> to
thoroughly test a given parameterization scheme. This function can be
accessed via <code>modnets:::simNet2</code>. There is not documentation for this
function, so it is recommended to look at the source code if one wishes to
use it This wrapper is also used inside the <code>mnetPowerSim</code> function.
</p>


<h3>See Also</h3>

<p><code>mlGVARsim, mnetPowerSim, plotNet,
  net, netInts, plotBoot, plotCoefs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Generate a moderated GGM along with data
set.seed(1)
x &lt;- simNet(N = 100, p = 3, m = TRUE)

net(x) # Get data-generating adjacency matrix
netInts(x) # Get data-generating interaction matrix

plot(x) # Plot the moderated network that generated the data

# Generate a single-subject GVAR model with data
set.seed(1)
x &lt;- simNet(N = 500, p = 3, m = TRUE, lags = 1)

net(x, n = 'temporal') # Get the data-generating time-lagged adjacency matrix
net(x, n = 'contemporaneous') # Get the data-generating standardized residual covariance matrix

plot(x, which.net = 'beta') # 'beta' is another way of referring to the temporal network
plot(x, which.net = 'pcc') # 'pcc' is another way of referring to the contemporaneous network
</code></pre>


</div>