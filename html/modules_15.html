<div class="container">

<table style="width: 100%;"><tr>
<td>import</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Import mechanism for modules</h2>

<h3>Description</h3>

<p>You can declare imports similar to what we would do in a R package: we list
complete packages or single function names from a package. These listed
imports are made available inside the module scope.
</p>


<h3>Usage</h3>

<pre><code class="language-R">import(from, ..., attach = TRUE, where = parent.frame())

importDefaultPackages(except = NULL, where = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>(character, or unquoted expression) a package name</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(character, or unquoted expression) names to import from package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attach</code></td>
<td>
<p>(logical) whether to attach the imports to the search path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>where</code></td>
<td>
<p>(environment) typically the calling environment. Should only be
relevant for testing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>except</code></td>
<td>
<p>(character | NULL) a character vactor excluding any packages
from being imported.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>import</code> and use can replace library and attach.
However they behave differently and are only designed to be used within
modules. Both will work when called in the <code>.GlobalEnv</code> but here they
should only be used for development and debugging of modules.
</p>
<p><code>import</code> adds a layer to a local search path. More precisely to the
calling environment, which is the environment supplied by <code>where</code>.
It will alter the state of the calling environment. This is very
similar to how the library function and the search path are
constructed in base R. Noticeable differences are that we can choose to
only import particular functions instead of complete packages. Further we
do not have to mutate the calling environment by setting attach to
<code>FALSE</code>. Regardless of the <code>attach</code> argument, <code>import</code> will
return an environment with the imports and can be bound to a name.
library will also load packages in the 'Depends' field of a package,
this is something <code>import</code> will not do.
</p>
<p>Only one <code>import</code> declaration per package is allowed. A second call to
import will remove the previous one from the search path. Then the new
import layer is added. If several smaller import declarations are
desirable, use <code>attach = FALSE</code> and bind the return value of
<code>import</code> to a name.
</p>


<h3>Value</h3>

<p>An environment is returned invisibly comprising the imports.
</p>


<h3>Examples</h3>

<pre><code class="language-R">m &lt;- module({
  # Single object from package
  import("stats", "median")
  # Complete package
  import("stats")
  # Without side-effects
  stats &lt;- import("stats", attach = FALSE)
  median &lt;- function(x) stats$median(x)
})
</code></pre>


</div>