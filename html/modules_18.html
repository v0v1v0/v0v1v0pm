<div class="container">

<table style="width: 100%;"><tr>
<td>use</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Use a module as dependency</h2>

<h3>Description</h3>

<p>Use and/or register a module as dependency. The behaviour of use is similar
to import but instead of importing from packages, we import from a
module. A module can be defined in a file, or be an object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">use(module, ..., attach = FALSE, reInit = TRUE, where = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>module</code></td>
<td>
<p>(character, module) a file or folder name, or an object that
can be interpreted as a module: any list-like object would do.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(character, or unquoted expression) names to use from module.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attach</code></td>
<td>
<p>(logical) whether to attach the module to the search path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reInit</code></td>
<td>
<p>(logical) we can use a module as is, or reinitialize it. The
default is to reinitialize. This is only relevant should the module be
state-full.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>where</code></td>
<td>
<p>(environment) typically the calling environment. Should only be
relevant for testing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>import and <code>use</code> can replace library and attach.
However they behave differently and are only designed to be used within
modules. Both will work when called in the <code>.GlobalEnv</code> but here they
should only be used for development and debugging of modules.
</p>
<p><code>use</code> adds a layer to a local search path if <code>attach</code> is
<code>TRUE</code>. More precisely to the calling environment, which is the
environment supplied by <code>where</code>. Regardless of the <code>attach</code>
argument, <code>use</code> will return the module invisibly.
</p>
<p><code>use</code> supplies a special mechanism to find the argument <code>module</code>:
generally you can supply a file name or folder name as character. You can
also reference objects/names which 'live' outside the module scope. If
names are not found within the scope of the module, they are searched for
in the environment in which the module has been defined. This happens
during initialization of the module, when the <code>use</code> function is
called.
</p>
<p>Modules can live in files. <code>use</code> should be used to load them. A module
definition in a file does not need to use the module constructor
explicitly. Any R script can be used as the body of a module.
</p>
<p>When a folder is referenced in <code>use</code> it is transformed into a list of
modules. This is represented as a nested list mimicking the folder
structure. Each file in that folder becomes a module.
</p>


<h3>Examples</h3>

<pre><code class="language-R">m1 &lt;- module({
  foo &lt;- function() "foo"
})
m2 &lt;- module({
  use(m1, attach = TRUE)
  bar &lt;- function() "bar"
  m1foo &lt;- function() foo()
})
m2$m1foo()
m2$bar()

## Not run: 
someFile &lt;- tempfile(fileext = ".R")
writeLines("foo &lt;- function() 'foo'", someFile)
m3 &lt;- use(someFile)
m3$foo()
otherFile &lt;- tempfile(fileext = ".R")
writeLines("bar &lt;- function() 'bar'", otherFile)
m4 &lt;- use(otherFile)
m4$bar()
m5 &lt;- use(tempdir())
m5

## End(Not run)
</code></pre>


</div>