<div class="container">

<table style="width: 100%;"><tr>
<td>export</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Export mechanism for modules</h2>

<h3>Description</h3>

<p>You can declare exports very much like the export mechanism in R packages:
you define which objects from the module you make available to a user. All
other objects are kept private, local, to the module.
</p>


<h3>Usage</h3>

<pre><code class="language-R">export(..., where = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(character, or unquoted expression) names to export from module. A
character of length 1 with a leading "^" is interpreted as regular
expression. Arguments can be named and used for renaming exports.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>where</code></td>
<td>
<p>(environment) typically the calling environment. Should only be
relevant for testing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A module can have several export declarations, e.g. directly in
front of each function definition. That means: exports stack up. When you
supply a regular expression, however, only one export pattern should be
declared. A regular expression is denoted, as a convention, as character
vector of length one with a leading "^".
</p>


<h3>Examples</h3>

<pre><code class="language-R">module({
  export("foo")
  foo &lt;- function() "foo"
  bar &lt;- function() "bar"
})

module({
  export("foo")
  foo &lt;- function() "foo"
  export("bar")
  bar &lt;- function() "bar"
})

module({
  export("foo", "bar")
  foo &lt;- function() "foo"
  bar &lt;- function() "bar"
})

module({
  export("^f.*$")
  foo &lt;- function() "foo"
  bar &lt;- function() "bar"
})

module({
  export(bar = foo)
  foo &lt;- function() "foo"
})
</code></pre>


</div>