<div class="container">

<table style="width: 100%;"><tr>
<td>flattenj_one</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Single JSON Object Flatten</h2>

<h3>Description</h3>

<p>Transform a JSON object into a flattened data frame in a serialization way.
</p>


<h3>Usage</h3>

<pre><code class="language-R">flattenj_one(dat, sep = "@", compact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p><code>list</code>. The list from a JSON object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p><code>character</code>. A character/string used to separate keys in the nesting path.
Defaults to @ to avoid the occasional overriding. Not recommended to use some risky characters like . and \.
When <code>compact = FALSE</code>, it is unnecessary to assign <code>sep</code> explicitly, unless @ has been used in the key fields.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compact</code></td>
<td>
<p>logical. Whether to generate the compact or completely expanded data frame. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function flattens a single JSON object into a data frame with two different schemas according to the <code>compact</code> value.
</p>

<ul>
<li>
<p>For <code>compact = TRUE</code>, the data frame contains two columns. One is <code>paths</code> which stores the absolute path of each record.
And the other is <code>values</code> which stores the corresponding values of each path.
</p>
</li>
<li>
<p>For <code>compact = FALSE</code>, the data frame has more columns based on the global nesting situation.
</p>
</li>
</ul>
<p><b>It actually applies the serialization way for flattening, which means the early values correspondingly appear in the heading rows of the data frame.</b>
And if the value is a list object in the original data or a non-named list/vector in the R environment,
the path will be correspondingly appended with an integer to specify each list element.
For example, in the raw JSON file, "{'a':[1, 2, 3]}" will be <code>data.frame(paths = c('a1', 'a2', 'a3'), values = c(1, 2, 3))</code>.
Great credits to the answer of <a href="https://stackoverflow.com/questions/8139677/how-to-flatten-a-list-to-a-list-without-coercion/8139959#8139959">Tommy</a>.
</p>


<h3>Value</h3>

<p><code>data frame</code>. The flattened result.
</p>


<h3>See Also</h3>

<p><code>expanddf</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(mojson)
j &lt;- list(a = list(x = 1, y = 2),
          b = c(3, 4, list(z = 5, s = 6, t = list(m = 7, n = 8))))
flattenj_one(j)
flattenj_one(j, compact = FALSE)

</code></pre>


</div>