<div class="container">

<table style="width: 100%;"><tr>
<td>postModeOrtho</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian model selection and averaging under block-diagonal X'X for linear models.</h2>

<h3>Description</h3>

<p>postModeOrtho is for diagonal X'X,
postModeBlockDiag for the more general block-diagonal X'X,
where X is the matrix with predictors.
</p>
<p>Both functions return the model of highest posterior probability of any given
size using an efficient search algorithm. This sequence of models includes
the highest posterior probability model (HPM).
Posterior model probabilities, marginal variable inclusion probabilities
and Bayesian model averaging estimates are also provided.
The unknown residual variance is integrated out using an exact deterministic
algorithm of low computational cost (see details in reference).
</p>


<h3>Usage</h3>

<pre><code class="language-R">postModeOrtho(y, x, priorCoef=momprior(tau=0.348), priorDelta=modelbbprior(1,1),
priorVar=igprior(0.01,0.01), bma=FALSE, includeModels, maxvars=100)

postModeBlockDiag(y, x, blocks, priorCoef=zellnerprior(tau=nrow(x)),
priorDelta=modelbinomprior(p=1/ncol(x)),priorVar=igprior(0.01,0.01), bma=FALSE,
maxvars=100, momcoef)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Outcome</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Matrix with predictors. If an intercept is desired x should include
a column of 1's.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blocks</code></td>
<td>
<p>Factor or integer vector of length ncol(x) indicating the block
that each column in x belongs to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorCoef</code></td>
<td>
<p>Prior distribution for the coefficients. Object created
with <code>momprior</code>, <code>imomprior</code>, <code>emomprior</code> or <code>zellnerprior</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorDelta</code></td>
<td>
<p>Prior on model space. Use <code>modelbbprior()</code> for Beta-Binomial prior,
<code>modelbinomprior(p)</code> for Binomial prior with prior inclusion
probability <code>p</code>,
<code>modelcomplexprior</code> for Complexity prior,
or <code>modelunifprior()</code> for Uniform prior</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorVar</code></td>
<td>
<p>Inverse gamma prior on residual variance, created with <code>igprior()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bma</code></td>
<td>
<p>Set to TRUE to obtain marginal inclusion probabilities and
Bayesian model averaging parameter estimates for each column of x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>includeModels</code></td>
<td>
<p>Models that should always be included when
computing posterior model probabilities. It must be a list, each
element in the list corresponds to a model and must be a logical or
numeric vector indicating the variables in that model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxvars</code></td>
<td>
<p>The search for the HPM is restricted to models with up to maxvars variables
(note: posterior model probabilities and BMA are valid regardless of maxvars)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>momcoef</code></td>
<td>
<p>optional argument containing pre-computed coefficients needed to obtain
the marginal likelihood under the pMOM prior.
A first call to postModeBlockDiag returns these coefficients,
thus this argument is useful to speed up successive calls.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The first step is to list a sequence of models with 0,...,maxvars variables which,
under fairly general conditions listed in Papaspiliopoulos &amp; Rossell (2016),
is guaranteed to include the HPM.
Then posterior model probabilities are computed for all these models to determine
the HPM, evaluate the marginal posterior of the residual variance on a grid,
and subsequently compute the marginal density p(y) via adaptive quadrature.
Finally this adaptive grid is used to compute marginal inclusion probabilities
and Bayesian model averaging estimates.
For more details see Papaspiliopoulos &amp; Rossell (2016).
</p>


<h3>Value</h3>

<p>List with elemants
</p>
<table>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p>data.frame indicating the variables included in the sequence of models found
during the search of the HPM, and their posterior probabilities. The model with highest
posterior probability in this list is guaranteed to be the HPM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>data.frame containing an adaptive grid of phi (residual variance) values and
their marginal posterior density p(phi|y).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logpy</code></td>
<td>
<p>log-marginal density p(y), i.e. normalization constant of p(phi|y).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bma</code></td>
<td>
<p>Marginal posterior inclusion probabilities and Bayesian model averaging estimates
for each column in x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>postmean.model</code></td>
<td>
<p>Coefficient estimates conditional on each of the models in <code>models</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>momcoef</code></td>
<td>
<p>If a MOM prior was specified in priorCoef, momcoef stores some coefficients needed
to compute its marginal likelihood</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> David Rossell </p>


<h3>References</h3>

<p>Papaspiliopoulos O., Rossell D. Scalable Bayesian variable selection
and model averaging under block-orthogonal design. 2016
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Simulate data
set.seed(1)
p &lt;- 400; n &lt;- 410
x &lt;- scale(matrix(rnorm(n*p),nrow=n,ncol=p),center=TRUE,scale=TRUE)
S &lt;- cov(x)
e &lt;- eigen(cov(x))
x &lt;- t(t(x %*% e$vectors)/sqrt(e$values))
th &lt;- c(rep(0,p-3),c(.5,.75,1)); phi &lt;- 1
y &lt;- x %*% matrix(th,ncol=1) + rnorm(n,sd=sqrt(phi))

#Fit
priorCoef=zellnerprior(tau=n); priorDelta=modelbinomprior(p=1/p); priorVar=igprior(0.01,0.01)
pm.zell &lt;- postModeOrtho(y,x=x,priorCoef=priorCoef,priorDelta=priorDelta,priorVar=priorVar,
bma=TRUE)

#Best models
head(pm.zell$models)

#Posterior probabilities for sequence of models
nvars &lt;- sapply(strsplit(as.character(pm.zell$models$modelid),split=','),length)
plot(nvars,pm.zell$models$pp,ylab='post prob',xlab='number of vars',ylim=0:1,xlim=c(0,50))

#Marginal posterior of phi
plot(pm.zell$phi,type='l',xlab='phi',ylab='p(phi|y)')

#Marginal inclusion prob &amp; BMA estimates
plot(pm.zell$bma$margpp,ylab='Marginal inclusion prob')
plot(pm.zell$bma$coef,ylab='BMA estimate')
</code></pre>


</div>