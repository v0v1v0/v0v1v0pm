<div class="container">

<table style="width: 100%;"><tr>
<td>modelSelectionGGM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Bayesian variable selection for linear models via non-local priors. </h2>

<h3>Description</h3>

<p>Bayesian model selection for linear, asymmetric linear,
median and quantile regression under
non-local or Zellner priors. p&gt;&gt;n can be handled.
</p>
<p>modelSelection enumerates all models when feasible
and uses a Gibbs scheme otherwise.
See <code>coef</code> and <code>coefByModel</code> for estimates and posterior
intervals of regression coefficients, and <code>rnlp</code> for posterior samples.
</p>
<p>modelsearchBlockDiag seeks the highest posterior
probability model using an iterative block search.
</p>


<h3>Usage</h3>

<pre><code class="language-R">

modelSelectionGGM(y, priorCoef=normalidprior(tau=1), 
priorModel=modelbinomprior(1/ncol(y)), 
priorDiag=exponentialprior(lambda=1), center=TRUE, scale=TRUE, 
almost_parallel= FALSE, sampler='Gibbs', niter=10^3, 
burnin= round(niter/10), pbirth=0.5, nbirth, 
Omegaini='glasso-ebic', verbose=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Data matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorCoef</code></td>
<td>
<p>Prior on off-diagonal entries of the precision
matrix, conditional on their not being zero (slab)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorModel</code></td>
<td>
<p>Prior probabilities on having non-zero diagonal
entries</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorDiag</code></td>
<td>
<p>Prior on diagonal entries of the precision matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>If <code>TRUE</code>, the columns of <code>y</code> will be centered
to zero mean</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>If <code>TRUE</code>, the columns of <code>y</code> will be scaled to
unit sample variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>almost_parallel</code></td>
<td>
<p>Use almost parallel algorithm sampling from each 
column independently and using an MH step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampler</code></td>
<td>
<p>Posterior sampler. Options are "Gibbs", "birthdeath"
and "zigzag"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>Number of posterior samples to be obtained</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pbirth</code></td>
<td>
<p>Probability of a birth move. Ignored unless
<code>sampler=="birthdeath"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbirth</code></td>
<td>
<p>Number of birth/death updates to perform for each row of
the precision matrix. Defaults to <code>ncol(y)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>The first burnin samples will be discarded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Omegaini</code></td>
<td>
<p>Initial value of the precision matrix Omega. "null"
sets all off-diagonal entries to 0. "glasso-bic" and "glasso-ebic" use
GLASSO with regularization parameter set via BIC/EBIC,
respectively. Alternatively, <code>Omegaini</code> can be a matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Set <code>verbose==TRUE</code> to print iteration progress</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let Omega be the inverse covariance matrix.
A spike-and-slab prior is used. Specifically,
independent priors are set on all Omega[j,k], and then a
positive-definiteness truncation is added.
</p>
<p>The prior on diagonal entries Omega[j,j] is given by <code>priorDiag</code>.
Off-diagonal Omega[j,k] are equal to zero with probability given by
<code>modelPrior</code> and, when non-zero, they are
</p>
<p>Independent spike-and-slab priors are set on the off-diagonal entries of Omega,
i.e. Omega[j,k]=0 with positive probability (spike) and otherwise
arises from the distribution indicated in <code>priorCoef</code> (slab).
</p>


<h3>Value</h3>

<p>Posterior inference on the inverse covariance of <code>y</code>.
Object of class <code>msfit_ggm</code>, which extends a list with elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>postSample</code></td>
<td>
<p>Posterior samples for the upper-diagonal entries of
the precision matrix. Stored as a sparse matrix, see package Matrix
to utilities to work with such matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Number of columns in <code>y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>List storing the priors specified when calling
<code>modelSelectionGGM</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> David Rossell </p>


<h3>See Also</h3>

<p><code>msfit_ggm-class</code> for further details on the output.
<code>icov</code> for the estimated precision (inverse covariance) matrix.
<code>coef.msfit_ggm</code> for Bayesian model averaging estimates and
intervals. 
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#Simulate data with p=3
Th= diag(3); Th[1,2]= Th[2,1]= 0.5
sigma= solve(Th)

z= matrix(rnorm(1000*3), ncol=3)
y= z 

#Obtain posterior samples
fit= modelSelectionGGM(y, scale=FALSE)

#Parameter estimates, intervals, prob of non-zero
coef(fit)

#Estimated inverse covariance
icov(fit)

#Estimated inverse covariance, entries set to 0
icov(fit, threshold=0.95)

#Shows first posterior samples
head(fit$postSample)

</code></pre>


</div>