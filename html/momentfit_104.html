<div class="container">

<table style="width: 100%;"><tr>
<td>gmmFit-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> ~~ Methods for Function <code>gmmFit</code> in Package <span class="pkg">momentfit</span> ~~</h2>

<h3>Description</h3>

<p>Method to fit a model using GMM, from an object of class
<code>"momentModel"</code> or <code>"sysModel"</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'momentModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, ...)

## S4 method for signature 'formulaModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, ...)

## S4 method for signature 'sysModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls", "EbyE"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, EbyE=FALSE, ...)

## S4 method for signature 'rnonlinearModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, ...)

## S4 method for signature 'rlinearModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, ...)

## S4 method for signature 'rformulaModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, ...)

## S4 method for signature 'rslinearModel'
gmmFit(model, type=c("twostep", "iter","cue",
              "onestep"), itertol=1e-7, initW=c("ident", "tsls", "EbyE"),
              weights="optimal", itermaxit=100,
              efficientWeights=FALSE, theta0=NULL, EbyE=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A model class object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>What GMM methods should we use? for
<code>type=="onestep"</code>, if <code>"weights"</code> is not a matrix, the
model will be estimated with the weights equals to the identity
matrix. For restricted </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itertol</code></td>
<td>
<p>Tolance for the stopping rule in iterative GMM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initW</code></td>
<td>
<p>How should be compute the initial coefficient vector in
the first. For single equation GMM, it only makes a difference for
linear models for which the choice is GMM with identity matrix or
two-stage least quares. For system of equations, <code>"tsls"</code>,
refers to equation by equation two-stage least squares. It is also
possible to start at the equation by equation estimate using the
same GMM type as specified by <code>"type"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>What weighting matrix to use? The choices are
<code>"optimal"</code>, in which case it is the inverse of the moment
vovariance matrix, <code>"ident"</code> for the identity matrix, or a
fixed matrix. It is also possible for weights to be an object of
class <code>gmmWeights</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermaxit</code></td>
<td>
<p>Maximum iterations for iterative GMM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EbyE</code></td>
<td>
<p>Should the system be estimated equation by equation?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>efficientWeights</code></td>
<td>
<p>If <code>weights</code> is a matrix or a
<code>gmmWeights</code> class object, setting <code>efficientWeights</code> to
<code>TRUE</code> implies that the resulting one-step GMM is
efficient. As a result, the default covariance matrix for the
coefficient estimates will not be a sandwich type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta0</code></td>
<td>
<p>An optional initial vector for <code>optim</code> when
the model is nonlinear. By default, the theta0 argument of the model
is used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to pass to other methods (mostly the
optimization algorithm)</p>
</td>
</tr>
</table>
<h3>Methods</h3>


<dl>
<dt><code>signature(model = "momentModel")</code></dt>
<dd>
<p>The main method for all moment-based models.
</p>
</dd>
<dt><code>signature(model = "rnonlinearModel")</code></dt>
<dd>
<p>It makes a difference only if the number of contraints is equal to the
number of coefficients, in which case, the method <code>evalGmm</code>
is called at the contrained vector. If not, the next method is called.
</p>
</dd>
<dt><code>signature(model = "rformulaModel")</code></dt>
<dd>
<p>It makes a difference only if the number of contraints is equal to the
number of coefficients, in which case, the method <code>evalGmm</code>
is called at the contrained vector. If not, the next method is called.
</p>
</dd>
<dt><code>signature(model = "rlinearModel")</code></dt>
<dd>
<p>It makes a difference only if the number of contraints is equal to the
number of coefficients, in which case, the method <code>evalGmm</code>
is called at the contrained vector. If not, the next method is called.
</p>
</dd>
<dt><code>signature(model = "sysModel")</code></dt>
<dd>
<p>Method to estimate system of equations using GMM methods.
</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">data(simData)

theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

## Efficient GMM with HAC vcov and tsls as first step.
res1 &lt;- gmmFit(model1, init="tsls")

## GMM with identity. Two ways.
res2 &lt;- gmmFit(model1, type="onestep")
res3 &lt;- gmmFit(model1, weights=diag(3))

## nonlinear regression with iterative GMM.
g &lt;- y~beta0+x1^beta1
h &lt;- ~z1+z2
model2 &lt;- momentModel(g, h, c(beta0=1, beta1=2), data=simData)
res4 &lt;- gmmFit(model2, type="iter")

## GMM for with no endogenous vaiables is
## OLS with Robust standard error

library(lmtest)
model3 &lt;- momentModel(y~x1, ~x1, data=simData, vcov="MDS")
resGmm &lt;- gmmFit(model3)
resLm &lt;- lm(y~x1, simData)
summary(resGmm)
coeftest(resLm, vcov=vcovHC(resLm, "HC0"))
summary(resGmm, df.adj=TRUE)
coeftest(resLm, vcov=vcovHC(resLm, "HC1"))

### All constrained
R &lt;- diag(2)
q &lt;- c(1,2)
rmodel1 &lt;- restModel(model1, R, q)
gmmFit(rmodel1)

## Only one constraint
R &lt;- matrix(c(0,1), ncol=2)
q &lt;- 2
rmodel1 &lt;- restModel(model1, R, q)
gmmFit(rmodel1)

</code></pre>


</div>