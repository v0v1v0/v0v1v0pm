<div class="container">

<table style="width: 100%;"><tr>
<td>hypothesisTest-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> ~~ Methods for Function <code>hypothesisTest</code> in Package <span class="pkg">momentfit</span> ~~</h2>

<h3>Description</h3>

<p>Performs hypothesis tests on the coefficients estimated by any GMM fit method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'gmmfit,missing'
hypothesisTest(object.u, object.r, R,
rhs=NULL, vcov=NULL, ...)

## S4 method for signature 'sgmmfit,missing'
hypothesisTest(object.u, object.r, R,
rhs=NULL, vcov=NULL, ...)

## S4 method for signature 'gmmfit,gmmfit'
hypothesisTest(object.u, object.r,
type=c("Wald", "LR", "LM"), sameVcov=TRUE, vcov=NULL,
firstStepWeight=FALSE, wObj=NULL, ...)

## S4 method for signature 'sgmmfit,sgmmfit'
hypothesisTest(object.u, object.r,
type=c("Wald", "LR", "LM"), sameVcov=TRUE, vcov=NULL,
firstStepWeight=FALSE, wObj=NULL, ...)

## S4 method for signature 'missing,gmmfit'
hypothesisTest(object.u, object.r, wObj=NULL)

## S4 method for signature 'missing,sgmmfit'
hypothesisTest(object.u, object.r, wObj=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object.u</code></td>
<td>
<p>An object of class <code>gmmfit</code> or <code>sgmmfit</code>
obtained using an unrestricted <code>"momentModel"</code> or
<code>"sysModel"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object.r</code></td>
<td>
<p>An object of class <code>gmmfit</code> obtained using a
restricted <code>"momentModel"</code> or <code>"sysModel"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>If it is an object of class <code>gmmfit</code>, one of the model
fit must be the restricted version of the other. The restrictions are
then tested. If <code>R</code> is a <code>character</code> type, it expresses
the restrictions using the coefficient names. If it <code>numeric</code>, it
must be a matrix and the restrictions are <code class="reqn">R\theta=0</code> for
<code>NULL</code> rhs, or <code class="reqn">R\theta=rhs</code> otherwise. If missing, the
<code>gmmfit</code> must be a fitted restricted model, in which case, a LM
test is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhs</code></td>
<td>
<p>A vector of right hand sides if <code>R</code> is <code>numeric</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Should we perform a Wald,  LR or LM test?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sameVcov</code></td>
<td>
<p>For the LR test, should we use the same estimate of
the covariance matrix of the moment conditions? See details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>For the Wald test, it is possible to provide the method
with the covariance matrix of the coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wObj</code></td>
<td>
<p>For the LR test, it is possible to provide the
<code>gmmWeights</code> object. In that case, the provided gmm weights
object if used for the restricted and unrestricted models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other argument to pass to <code>specTest</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>firstStepWeight</code></td>
<td>
<p>Should we use the first step weighting matrix
to compute the test (By default, the optimal weighting matrix is
recomputed using the final vector of coefficient estimates). See
details below.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The LR test is the difference between the J-tests of the restricted
and unrestricted models. It is therefore <code class="reqn">n\bar{g}_r'W_r\bar{g}_r
    - n\bar{g}_u'W_u\bar{g}_u</code>, where <code class="reqn">\bar{g}_r</code> and
<code class="reqn">\bar{g}_u</code> are respectively the restricted and unrestricted
sample mean of the moment conditions, and <code class="reqn">W_r</code> and <code class="reqn">W_u</code>
their respective optimal weigthing matrix. The test is therefore
invalid if either of the weighting matrices does not converge to the
inverse of the covariance matrix of the moment conditions. The
restricted and unrestricted models must therefore be estimated by
efficient GMM. This is not required for the Wald test.
</p>
<p>Asymptotically, it makes no difference which consistent estimate of
<code class="reqn">W_u</code> or <code class="reqn">W_r</code> is used. However, it will make a difference in
finite samples.
</p>
<p>If <code>sameVcov=TRUE</code>, both <code class="reqn">W_r</code> and <code class="reqn">W_u</code> are equal to the
the optimal weighting matrix from the unrestricted model if
<code>firstStepWeight=FALSE</code>, and they are equal to the first step
weighting matrix (or the last step for iteratice GMM) of the
unrestricted model if it is <code>TRUE</code>. For CUE, the value of
<code>firstStepWeight</code> makes no difference since the weighting matrix
and coefficients are computed simultaneously. Having <code class="reqn">W_r=W_u</code>
prevents the test to be negative in small samples.
</p>
<p>If <code>wObj</code> is provided, both <code class="reqn">W_r</code> and <code class="reqn">W_u</code> are equal to
it. Of cource, <code>wObj</code> must be a consistent estimate of the
optimal weighting matrix for the test to be valid.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object.u = "gmmfit", object.r = "gmmfit")</code></dt>
<dd>
<p>Used to test a restricted model against an unrestricted one.
</p>
</dd>
<dt><code>signature(object.u = "sgmmfit", object.r = "sgmmfit")</code></dt>
<dd>
<p>Used to test a restricted model against an unrestricted one (for systems
of equations).
</p>
</dd>
<dt><code>signature(object.u = "missing",  object.r= "gmmfit")</code></dt>
<dd>
<p>Used to test a restricted model using the LM test.
</p>
</dd>
<dt><code>signature(object.u = "missing",  object.r= "sgmmfit")</code></dt>
<dd>
<p>Used to test a restricted model using the LM test (for systems of
equations).
</p>
</dd>
<dt><code>signature(object.u = "gmmfit", object.r = "missing")</code></dt>
<dd>
<p>Perform a Wald test using an unrestricted model and a restriction matrix
or vector.
</p>
</dd>
<dt><code>signature(object.u = "sgmmfit", object.r = "missing")</code></dt>
<dd>
<p>Perform a Wald test using an unrestricted model and a restriction matrix
or vector in systems of linear equations.
</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">data(simData)

## Unrestricted model
model1 &lt;- momentModel(y~x1+x2+x3, ~x2+x3+z1+z2+z3, data=simData, vcov="MDS")
res1 &lt;- gmmFit(model1)

## Wald test 
R &lt;- c("x1=0.5","x2=x3")
hypothesisTest(object.u=res1, R=R)

## LR tests

rmodel1 &lt;- restModel(model1, R)
res2 &lt;- gmmFit(rmodel1)
hypothesisTest(object.u=res1, object.r=res2, type="LR")

### LR and Wald should be the same as long as the same weighting
### matrix if used for both GMM fits, for the LR and Wald as well

# Unrestricted model and save the weights
res1 &lt;- gmmFit(model1)
w &lt;- res1@wObj
# estimate models with the same weights
res2 &lt;- gmmFit(rmodel1, weights=w)

# LR test with the same weights
hypothesisTest(res1, res2, type="LR", wObj=w)

# Wald test with vcov based on the same weights (or the bread)
hypothesisTest(object.u=res1, R=R, breadOnly=TRUE)

### Another example with real data
data(Mroz)
model &lt;- momentModel(log(wage)~educ+exper+I(exper^2),
                  ~exper+I(exper^2)+fatheduc+motheduc, vcov="MDS",
                  data=Mroz, centeredVcov=FALSE)
R &lt;- c("educ=0","I(exper^2)=0")
rmodel &lt;- restModel(model, R)

res1 &lt;- gmmFit(model)
res2 &lt;- gmmFit(rmodel, weights=res1@wObj)

hypothesisTest(object.u=res1, object.r=res2, type="LR", wObj=res1@wObj)
hypothesisTest(object.u=res1, object.r=res2, type="Wald",
vcov=vcov(res1, breadOnly=TRUE))

## LM test (identical to the other two tests as well)

hypothesisTest(object.r=res2)
# or 
hypothesisTest(object.u=res1, object.r=res2, type="LM")

## Wald with the Delta Method:
## To impose nonlinear restrictions, we need to convert
## the linear model into a nonlinear one
NLmodel &lt;- as(model1, "nonlinearModel")
R1 &lt;- c("theta2=2", "theta3=theta4^2")
rNLmodel &lt;- restModel(NLmodel, R1)
res.u &lt;- gmmFit(NLmodel)
res.r &lt;- gmmFit(rNLmodel)
hypothesisTest(object.u=res.u, R=R1)

## LM

hypothesisTest(object.r=res.r)

## LR

hypothesisTest(object.r=res.r, object.u=res.u, type="LR")




</code></pre>


</div>