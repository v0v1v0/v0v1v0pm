<div class="container">

<table style="width: 100%;"><tr>
<td>momentModel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constructor for <code>"momentModel"</code> classes</h2>

<h3>Description</h3>

<p>It builds an object class <code>"momentModel"</code>, which is a
union class for <code>"linearModel"</code>,  <code>"nonlinearModel"</code>,
<code>"formulaModel"</code> and <code>"functionModel"</code> classes. These are
classes for moment based models. This is the first step before running
any estimation algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">momentModel(g, x=NULL, theta0=NULL,grad=NULL,
            vcov = c("iid", "HAC", "MDS", "CL"),
            vcovOptions=list(), centeredVcov = TRUE, data=parent.frame(),
            na.action="na.omit", survOptions=list(), smooth=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>A function of the form <code class="reqn">g(\theta,x)</code> and which returns a
<code class="reqn">n \times q</code> matrix with typical element <code class="reqn">g_i(\theta,x_t)</code> for
<code class="reqn">i=1,...q</code> and <code class="reqn">t=1,...,n</code>. This matrix is then used to build
the q sample moment conditions. It can also be a formula if the model
is linear (see detailsbelow).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The matrix or vector of data from which the function
<code class="reqn">g(\theta,x)</code> is computed. If "g" is a formula, it is an <code class="reqn">n
    \times Nh</code> matrix of instruments or a formula (see details below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta0</code></td>
<td>
<p>A <code class="reqn">k \times 1</code> vector of starting values. It is required
only when "g" is a function because only then a numerical algorithm is
used to minimize the objective function. If the dimension of
<code class="reqn">\theta</code> is one, see the argument "optfct".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grad</code></td>
<td>
<p>A function of the form <code class="reqn">G(\theta,x)</code> which returns a
<code class="reqn">q\times k</code> matrix of derivatives of <code class="reqn">\bar{g}(\theta)</code> with
respect to <code class="reqn">\theta</code>. By default, the numerical algorithm
<code>numericDeriv</code> is used. It is of course strongly suggested to
provide this function when it is possible. This gradient is used to
compute the asymptotic covariance matrix of <code class="reqn">\hat{\theta}</code> and to
obtain the analytical gradient of the objective function if the method
is set to "CG" or "BFGS" in <code>optim</code> and if "type" is not
set to "cue". If "g" is a formula, the gradiant is not required (see
the details below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>Assumption on the properties of the moment conditions. By
default, they are weakly dependant processes. For <code>MDS</code>, we
assume that the conditions are martingale difference sequences, which
implies they are serially uncorrelated, but may be
heteroscedastic. There is a difference between <code>iid</code> and
<code>MDS</code> only when <code>g</code> is a formula. In that case, residuals
are assumed homoscedastic as well as serially uncorrelated. For type
<code>CL</code>, clustered covariance matrix is computed. The options are
then included in <code>vcovOptions</code> (see <code>meatCL</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcovOptions</code></td>
<td>
<p>A list of options for the covariance matrix of the
moment conditions. See <code>vcovHAC</code> for the default values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centeredVcov</code></td>
<td>
<p>Should the moment function be centered when
computing its covariance matrix. Doing so may improve inference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame or a matrix with column names (Optional). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>Action to take for missing values. If missing values
are present and the option is set to <code>"na.pass"</code>, the model won't
be estimable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>survOptions</code></td>
<td>
<p>If needed, a list with the type of survey weights and
the weights as a numeric vector, data.frame or formula. The type is either
<code>"sampling"</code> or <code>"fequency"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p>If <code>TRUE</code>, the moment function is smoothed using a
kernel method.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>'momentModel' returns an object of one of the subclasses of <code>"momentModel"</code>.
</p>


<h3>References</h3>

<p>Andrews DWK (1991),
Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.
<em>Econometrica</em>, <b>59</b>,
817–858.
</p>
<p>Newey WK &amp; West KD (1987), A Simple, Positive Semi-Definite,
Heteroskedasticity and Autocorrelation Consistent Covariance
Matrix. <em>Econometrica</em>, <b>55</b>, 703–708.
</p>
<p>Newey WK &amp; West KD (1994), Automatic Lag Selection in Covariance
Matrix Estimation. <em>Review of Economic Studies</em>, <b>61</b>, 631-653.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(simData)
theta &lt;- c(beta0=1,beta1=2)

## A linearModel
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

## A nonlinearModel
g &lt;- y~beta0+x1^beta1
h &lt;- ~z1+z2
model2 &lt;- momentModel(g, h, c(beta0=1, beta1=2), data=simData)

## A functionModel
fct &lt;- function(tet, x)
    {
        m1 &lt;- (tet[1] - x)
        m2 &lt;- (tet[2]^2 - (x - tet[1])^2)
        m3 &lt;- x^3 - tet[1]*(tet[1]^2 + 3*tet[2]^2)
        f &lt;- cbind(m1, m2, m3)
        return(f)
    }
dfct &lt;- function(tet, x)
        {
        jacobian &lt;- matrix(c( 1, 2*(-tet[1]+mean(x)), -3*tet[1]^2-3*tet[2]^2,0, 2*tet[2],
			   -6*tet[1]*tet[2]), nrow=3,ncol=2)
        return(jacobian)
        }
model3 &lt;- momentModel(fct, simData$x3, theta0=c(beta0=1, beta1=2), grad=dfct)
</code></pre>


</div>