<div class="container">

<table style="width: 100%;"><tr>
<td>sysMomentModel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constructor for <code>"sysMomentModel"</code> classes</h2>

<h3>Description</h3>

<p>It builds the object of either class <code>"slinearModel"</code> or
<code>"snonlinearModel"</code>, which are system of equations based on moment
conditions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sysMomentModel(g, h=NULL, theta0=NULL, grad=NULL, 
            vcov = c("iid", "HAC", "MDS", "CL"),
            vcovOptions=list(), centeredVcov = TRUE,
            data=parent.frame(),na.action="na.omit",
            survOptions=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>A list of linear or nonlinear regression formulas for each
equation in the system.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>A list of linear formulas for the instruments in each
equation in the system.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta0</code></td>
<td>
<p>A list of vectors of starting values. It is required
only when the equations are nonlinear, in which case, it must be a
list of named vector, with the names corresponding to the coefficient
names in the regression formulas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grad</code></td>
<td>
<p>A list of functions that returns the derivative of the
moment functions. Only used if <code>g</code> is a list of functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>Assumption on the properties of the moment conditions. By
default, they are weakly dependant processes. For <code>MDS</code>, we
assume that the conditions are martingale difference sequences, which
implies they are serially uncorrelated, but may be
heteroscedastic. There is a difference between <code>iid</code> and
<code>MDS</code> only when <code>g</code> is a formula. In that case, residuals
are assumed homoscedastic as well as serially uncorrelated. For type
<code>CL</code>, clustered covariance matrix is computed. The options are
then included in <code>vcovOptions</code> (see <code>meatCL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcovOptions</code></td>
<td>
<p>A list of options for the covariance matrix of the
moment conditions. See <code>vcovHAC</code> for the default values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centeredVcov</code></td>
<td>
<p>Should the moment function be centered when
computing its covariance matrix. Doing so may improve inference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame or a matrix with column names (Optional). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>Action to take for missing values. If missing values
are present and the option is set to <code>"na.pass"</code>, the model won't
be estimable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>survOptions</code></td>
<td>
<p>If needed, a list with the type of survey weights and
the weights as a numeric vector, data.frame or formula. The type is either
<code>"sampling"</code> or <code>"fequency"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>'sysMomentModel' returns an object of one of the subclasses of
<code>"sysMomentModel"</code>.
</p>


<h3>References</h3>

<p>Hayashi, F. (2000). <em>Econometrics</em>, New Jersey: Princeton
University Press.
</p>
<p>Andrews DWK (1991),
Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.
<em>Econometrica</em>, <b>59</b>,
817–858.
</p>
<p>Newey WK &amp; West KD (1987), A Simple, Positive Semi-Definite,
Heteroskedasticity and Autocorrelation Consistent Covariance
Matrix. <em>Econometrica</em>, <b>55</b>, 703–708.
</p>
<p>Newey WK &amp; West KD (1994), Automatic Lag Selection in Covariance
Matrix Estimation. <em>Review of Economic Studies</em>, <b>61</b>, 631-653.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1122)
x1 &lt;- rchisq(50,5)
x2 &lt;- rchisq(50,5)
x3 &lt;- rnorm(50)
x4 &lt;- rnorm(50)
z1 &lt;- .2*x1+rnorm(50)
z2 &lt;- .2*x2+rnorm(50)
z3 &lt;- rnorm(50)
z4 &lt;- rnorm(50)
z5 &lt;- rnorm(50)
y1 &lt;- x1+rnorm(50)
y2 &lt;- 2*x1+rnorm(50)
y3 &lt;- 0.5*x2+rnorm(50)
dat &lt;- data.frame(y1=y1,y3=y3,y2=y2, z1=z1,x1=x1,z2=z2,x2=x2,z3=z3,x3=x3,
                  x4=x4,z4=z4,z5=z5)

g1 &lt;- y1~x1+x4; h1 &lt;- ~z1+z2+z3+z4+x4
g2 &lt;- y2~x1+x2+x3; h2 &lt;- ~z1+z2+z3+z4+x3
g3 &lt;- y3~x2+x3+x4; h3 &lt;- ~z2+z3+z4+x3+x4
g &lt;- list(g1,g2,g3)
h &lt;- list(h1,h2,h3)

smodel &lt;- sysMomentModel(g, h, data=dat)

## not really nonlinear
nlg &lt;- list(y1~theta0+theta1*x1+theta2*x4,
            y2~alpha0+alpha1*x1+alpha2*x2+alpha3*x3,
            y3~beta0+beta1*x2+beta2*x3+beta3*x4)
theta0 &lt;- list(c(theta0=1,theta1=2,theta2=3),
              c(alpha0=1,alpha1=2,alpha2=3, alpha3=4),
              c(beta0=1,beta1=2,beta2=3,beta3=4))
snmodel &lt;- sysMomentModel(nlg, h, theta0, data=dat)


</code></pre>


</div>