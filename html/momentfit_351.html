<div class="container">

<table style="width: 100%;"><tr>
<td>vcov-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> ~~ Methods for Function <code>vcov</code> in Package <span class="pkg">stats</span> ~~</h2>

<h3>Description</h3>

<p>Computes the covariance matrix of the coefficient estimated by GMM or GEL. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'gmmfit'
vcov(object, sandwich=NULL, df.adj=FALSE,
breadOnly=FALSE, modelVcov=NULL)

## S4 method for signature 'sgmmfit'
vcov(object, sandwich=NULL, df.adj=FALSE,
breadOnly=FALSE, modelVcov=NULL)

## S4 method for signature 'tsls'
vcov(object, sandwich=TRUE, df.adj=FALSE)

## S4 method for signature 'gelfit'
vcov(object, withImpProb=FALSE, tol=1e-10,
                        robToMiss=FALSE)

## S4 method for signature 'momentModel'
vcov(object, theta)

## S4 method for signature 'sysModel'
vcov(object, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A fitted model or a model, For fitted models, it
computes the covariance matrix of the estimators. For models, it
computes the covariance matrix of the moment conditions, in which
case, the coefficient vector must be provided. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>Coefficient vector to compute the covariance matrix of
the moment conditions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sandwich</code></td>
<td>
<p>Should we compute the sandwich covariance matrix. This is
only necessary if the weighting matrix is not the optimal one, or if
we think it is a bad estimate of it. If <code>NULL</code>, it will be set
to "TRUE" for One-Step GMM, which includes just-identified GMM like
IV, and "FALSE" otherwise. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.adj</code></td>
<td>
<p>Should we adjust for degrees of freedom. If <code>TRUE</code>
the covariance matrix is multiplied by <code>n/(n-k)</code>, where
<code>n</code> is the sample size and <code>k</code> is the number of
coefficients. For heteroscedastic robust covariance matrix,
adjusting is equivalent to computing HC1 while not adjusting is
HC0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breadOnly</code></td>
<td>
<p>If <code>TRUE</code>, the covariance matrix is set to the
bread (see details below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelVcov</code></td>
<td>
<p>Should be one of "iid", "MDS" or "HAC". It is meant
to change the way the variance of the moments is computed. If it is
set to a different specification included in the model,
<code>sandwich</code> is set to <code>TRUE</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withImpProb</code></td>
<td>
<p>Should we compute the moments with the implied
probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Any diagonal less than <code>"tol"</code> is set to tol</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robToMiss</code></td>
<td>
<p>Should we compute a covariance matrix that is robust
to misspecification?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>sandwich=FALSE</code>, then it returns <code class="reqn">(G'V^{-1}G)^{-1}/n</code>, where
<code class="reqn">G</code> and <code class="reqn">V</code> are respectively the matrix of average derivatives
and the covariance matrix of the moment conditions. If it is
<code>TRUE</code>, it returns <code class="reqn">(G'WG)^{-1}G'WVWG(G'WG)^{-1}/n</code>,
where <code class="reqn">W</code> is the weighting matrix used to obtain the vector of
estimates.
</p>
<p>If <code>breadOnly=TRUE</code>, it returns <code class="reqn">(G'WG)^{-1}/n</code>,
where the value of <code class="reqn">W</code> depends on the type of GMM. For two-step GMM,
it is the first step weighting matrix, for one-step GMM, it is either
the identity matrix or the fixed weighting matrix that was provided when
<code>gmmFit</code> was called, for iterative GMM, it is the weighting
matrix used in the last step. For CUE, the result is identical to
<code>sandwich=FALSE</code> and <code>beadOnly=FALSE</code>, because the
weighting and coefficient estimates are obtained simultaneously, which
makes <code class="reqn">W</code> identical to <code class="reqn">V</code>.
</p>
<p><code>breadOnly=TRUE</code> should therefore be used with caution because it
will produce valid standard errors only if the weighting matrix
converges to the the inverse of the covariance matrix of the moment
conditions.
</p>
<p>For <code>"tsls"</code> objects, <code>sandwich</code> is TRUE by default. If we
assume that the error term is iid, then setting it to FALSE to result in
the usual <code class="reqn">\sigma^2(\hat{X}'\hat{X})^{-1}</code> covariance matrix. If
<code>FALSE</code>, it returns a robust covariance matrix determined by the
value of <code>vcov</code> in the <code>momentModel</code>. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "gmmfit")</code></dt>
<dd>
<p>For any model estimated by any GMM methods.  
</p>
</dd>
<dt><code>signature(object = "gelfit")</code></dt>
<dd>
<p>For any model estimated by any GMM methods.  
</p>
</dd>
<dt><code>signature(object = "sgmmfit")</code></dt>
<dd>
<p>For any system of equations estimated by any GMM methods.  
</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">data(simData)
theta &lt;- c(beta0=1,beta1=2)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)

## optimal matrix
res &lt;- gmmFit(model1)
vcov(res)

## not the optimal matrix
res &lt;- gmmFit(model1, weights=diag(3))
vcov(res, TRUE)

## Model with heteroscedasticity
## MDS is for models with no autocorrelation.
## No restrictions are imposed on the structure of the
## variance of the moment conditions
model2 &lt;- momentModel(y~x1, ~z1+z2, data=simData, vcov="MDS")
res &lt;- tsls(model2)

## HC0 type of robust variance
vcov(res, sandwich=TRUE)
## HC1 type of robust variance
vcov(res, sandwich=TRUE, df.adj=TRUE)

## Fixed and True Weights matrix
## Consider the moment of a normal distribution:
## Using the first three non centered moments

g &lt;- function(theta, x)
{
mu &lt;- theta[1]
sig2 &lt;- theta[2]
m1 &lt;- x-mu
m2 &lt;- x^2-mu^2-sig2
m3 &lt;- x^3-mu^3-3*mu*sig2
cbind(m1,m2,m3)
}

dg &lt;- function(theta, x)
{
mu &lt;- theta[1]
sig2 &lt;- theta[2]
G &lt;- matrix(c(-1,-2*mu,-3*mu^2-3*sig2, 0, -1, -3*mu),3,2)
}

x &lt;- simData$x3

model &lt;- momentModel(g, x, c(mu=.1, sig2=1.5), vcov="iid")
res1 &lt;- gmmFit(model)
summary(res1)
## Same results (that's because the moment vcov is centered by default)
W &lt;- solve(var(cbind(x,x^2,x^3)))
res2 &lt;- gmmFit(model, weights=W)
res2
## If is therefore more efficient in this case to do the following:
## the option breadOnly of summary() is passed to vcov()
summary(res2, breadOnly=TRUE)
</code></pre>


</div>