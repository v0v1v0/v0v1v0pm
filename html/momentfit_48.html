<div class="container">

<table style="width: 100%;"><tr>
<td>evalDMoment-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> ~~ Methods for Function <code>evalDMoment</code> in Package <span class="pkg">momentfit</span> ~~</h2>

<h3>Description</h3>

<p>It computes the matrix of derivatives of the sample moments with respect
to the coefficients.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'functionModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'rfunctionModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'rnonlinearModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'formulaModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'rformulaModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'regModel'
evalDMoment(object, theta, impProb=NULL,
lambda=NULL)

## S4 method for signature 'sysModel'
evalDMoment(object, theta)

## S4 method for signature 'rslinearModel'
evalDMoment(object, theta)

## S4 method for signature 'rsnonlinearModel'
evalDMoment(object, theta, impProb=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An model object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>A numerical vector of coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>impProb</code></td>
<td>
<p>If a vector of implied probablities is provided, the
sample means are computed using them. If not provided, the means are
computed using the uniform weight</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A vector of Lagrange multipliers associated with the
moment conditions. Its length must therefore match the number of
conditions. See details below.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Without the argument <code>lambda</code>, the method returns a <code class="reqn">q \times
  k</code> matrix, where <code class="reqn">k</code> is the number of coefficients, and <code class="reqn">q</code> is
the number of moment conditions. That matrix is the derivative of the
sample mean of the moments with respect to the coefficient. 
</p>
<p>If <code>lambda</code> is provided, the method returns an <code class="reqn">n \times k</code>
matrix, where <code class="reqn">n</code> is the sample size. The ith row is
<code class="reqn">G_i'\lambda</code>, where $G_i$ is the derivative of the moment
function evaluated at the ith observation. For now, this option is
used to compute robust-to-misspecified standard errors of GEL
estimators.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "functionModel")</code></dt>
<dd>
</dd>
<dt><code>signature(object = "rfunctionModel")</code></dt>
<dd>
<p>The theta vector must match the number of coefficients in the restricted
model.
</p>
</dd>
<dt><code>signature(object = "formulaModel")</code></dt>
<dd>
</dd>
<dt><code>signature(object = "rformulaModel")</code></dt>
<dd>
<p>The theta vector must match the number of coefficients in the restricted
model.
</p>
</dd>
<dt><code>signature(object = "regModel")</code></dt>
<dd>
</dd>
<dt><code>signature(object = "sysModel")</code></dt>
<dd>
</dd>
<dt><code>signature(object = "rslinearModel")</code></dt>
<dd>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">data(simData)
theta &lt;- c(1,1)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)
G &lt;- evalDMoment(model1, theta)

## A nonlinearModel
g &lt;- y~beta0+x1^beta1
h &lt;- ~z1+z2
model2 &lt;- momentModel(g, h, c(beta0=1, beta1=2), data=simData)
G &lt;- evalDMoment(model2, c(beta0=1, beta1=2))

## A functionModel
fct &lt;- function(tet, x)
    {
        m1 &lt;- (tet[1] - x)
        m2 &lt;- (tet[2]^2 - (x - tet[1])^2)
        m3 &lt;- x^3 - tet[1]*(tet[1]^2 + 3*tet[2]^2)
        f &lt;- cbind(m1, m2, m3)
        return(f)
    }
dfct &lt;- function(tet, x)
        {
        jacobian &lt;- matrix(c( 1, 2*(-tet[1]+mean(x)), -3*tet[1]^2-3*tet[2]^2,0, 2*tet[2],
			   -6*tet[1]*tet[2]), nrow=3,ncol=2)
        return(jacobian)
        }
X &lt;- rnorm(200)
model3 &lt;- momentModel(fct, X, theta0=c(beta0=1, beta1=2), grad=dfct)
G &lt;- evalDMoment(model3, c(beta0=1, beta1=2))
</code></pre>


</div>