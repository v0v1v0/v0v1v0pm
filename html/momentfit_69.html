<div class="container">

<table style="width: 100%;"><tr>
<td>evalMoment-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> ~~ Methods for Function <code>evalMoment</code> in Package <span class="pkg">momentfit</span> ~~</h2>

<h3>Description</h3>

<p>Method to evaluate the moment matrix at a given coefficient vector.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "functionModel")</code></dt>
<dd>
</dd>
<dt><code>signature(object = "formulaModel")</code></dt>
<dd>
</dd>
<dt><code>signature(object = "regModel")</code></dt>
<dd>
</dd>
<dt><code>signature(object = "sysModel")</code></dt>
<dd>
</dd>
<dt><code>signature(object = "rsysModel")</code></dt>
<dd>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">data(simData)
theta &lt;- c(1,1)
model1 &lt;- momentModel(y~x1, ~z1+z2, data=simData)
gt &lt;- evalMoment(model1, theta)

## A nonlinearGmm
g &lt;- y~beta0+x1^beta1
h &lt;- ~z1+z2
model2 &lt;- momentModel(g, h, c(beta0=1, beta1=2), data=simData)
gt &lt;- evalMoment(model2, c(beta0=1, beta1=2))

## A functionGmm
fct &lt;- function(tet, x)
    {
        m1 &lt;- (tet[1] - x)
        m2 &lt;- (tet[2]^2 - (x - tet[1])^2)
        m3 &lt;- x^3 - tet[1]*(tet[1]^2 + 3*tet[2]^2)
        f &lt;- cbind(m1, m2, m3)
        return(f)
    }
dfct &lt;- function(tet, x)
        {
        jacobian &lt;- matrix(c( 1, 2*(-tet[1]+mean(x)), -3*tet[1]^2-3*tet[2]^2,0, 2*tet[2],
			   -6*tet[1]*tet[2]), nrow=3,ncol=2)
        return(jacobian)
        }
X &lt;- rnorm(200)
model3 &lt;- momentModel(fct, X, theta0=c(beta0=1, beta1=2), grad=dfct)
gt &lt;- evalMoment(model3, c(beta0=1, beta1=2))
</code></pre>


</div>