<div class="container">

<table style="width: 100%;"><tr>
<td>monmlp.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit one or more MLP or MONMLP models
</h2>

<h3>Description</h3>

<p>Fit an individual model or ensemble of MLP or MONMLP regression models
using <code>optimx</code> optimization routines to minimize a least
squares cost function. Optional stopped training and bootstrap
aggregation (bagging) can be used to help avoid overfitting.
</p>
<p>If invoked, the <code>monotone</code> argument enforces increasing behaviour
between specified columns of <code>x</code> and model outputs. In this case, the
<code>exp</code> function is applied to the relevant weights following
initialization and during optimization; manual adjustment of <code>init.weights</code>
may be needed.
</p>
<p>Note: <code>x</code> and <code>y</code> are automatically standardized prior to
fitting and predictions are automatically rescaled by
<code>monmlp.predict</code>. This behaviour can be suppressed for
<code>y</code> by the <code>scale.y</code> argument.
</p>


<h3>Usage</h3>

<pre><code class="language-R">monmlp.fit(x, y, hidden1, hidden2 = 0, iter.max = 5000,
           n.trials = 1, n.ensemble = 1, bag = FALSE,
           cases.specified = NULL, iter.stopped = NULL,
           scale.y = TRUE, Th = tansig, To = linear,
           Th.prime = tansig.prime, To.prime = linear.prime,
           monotone = NULL, init.weights = NULL,
           max.exceptions = 10, silent = FALSE, method = "BFGS",
           control = list(trace = 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>covariate matrix with number of rows equal to the number of samples and number of columns equal to the number of covariates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>response matrix with number of rows equal to the number of samples and number of columns equal to the number of response variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hidden1</code></td>
<td>

<p>number of hidden nodes in the first hidden layer.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hidden2</code></td>
<td>

<p>number of hidden nodes in the second hidden layer.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>

<p>maximum number of iterations of the optimization algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trials</code></td>
<td>

<p>number of repeated trials used to avoid local minima.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.ensemble</code></td>
<td>

<p>number of ensemble members to fit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bag</code></td>
<td>

<p>logical variable indicating whether or not bootstrap aggregation (bagging) should be used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cases.specified</code></td>
<td>

<p>if <code>bag = TRUE</code>, a list that specifies the bootstrapped cases to be used in each ensemble member.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.stopped</code></td>
<td>

<p>if <code>bag = TRUE</code>, specifies the number of stopped training iterations between calculation of the cost function on the out-of-bootstrap cases.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.y</code></td>
<td>

<p>logical determining if columns of the response matrix should be scaled to zero mean and unit variance prior to fitting. Set this to <code>FALSE</code> if using an output layer transfer function that limits the range of predictions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Th</code></td>
<td>

<p>hidden layer transfer function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>To</code></td>
<td>

<p>output layer transfer function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Th.prime</code></td>
<td>

<p>derivative of the hidden layer transfer function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>To.prime</code></td>
<td>

<p>derivative of the output layer transfer function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monotone</code></td>
<td>

<p>column indices of covariates for which the monotonicity constraint should hold.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.weights</code></td>
<td>

<p>either a vector giving the minimum and maximum allowable values of the random weights, an initial weight vector, or NULL to calculate based on fan-in.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.exceptions</code></td>
<td>

<p>maximum number of exceptions of the optimization routine before fitting is terminated with an error.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>

<p>logical determining if diagnostic messages should be suppressed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p><code>optimx</code> optimization method.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p><code>list of optimx</code> control parameters.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>list containing fitted weight matrices with attributes
including called values of <code>x</code>, <code>y</code>, <code>Th</code>, <code>To</code>,
<code>Th.prime</code>, <code>To.prime</code>, <code>monotone</code>, <code>bag</code>,
<code>iter.max</code>, and <code>iter.stopped</code>, along with values of
covariate/response column means and standard deviations
(<code>x.center</code>, <code>x.scale</code>, <code>y.center</code>,
<code>y.scale</code>), out-of-bootstrap cases <code>oob</code>,
predicted values <code>y.pred</code>, and, if stopped training is
switched on, the iteration <code>iter.best</code> and value of
the cost function <code>cost.best</code> that minimized the
out-of-bootstrap validation error.
</p>


<h3>See Also</h3>

<p><code>monmlp.predict</code>, <code>gam.style</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(123)
x &lt;- as.matrix(seq(-10, 10, length = 100))
y &lt;- logistic(x) + rnorm(100, sd = 0.2)

dev.new()
plot(x, y)
lines(x, logistic(x), lwd = 10, col = "gray")

## MLP w/ 2 hidden nodes
w.mlp &lt;- monmlp.fit(x = x, y = y, hidden1 = 2, iter.max = 500)
lines(x, attr(w.mlp, "y.pred"), col = "red", lwd = 3)

## MLP w/ 2 hidden nodes and stopped training
w.stp &lt;- monmlp.fit(x = x, y = y, hidden1 = 2, bag = TRUE,
                    iter.max = 500, iter.stopped = 10)
lines(x, attr(w.stp, "y.pred"), col = "orange", lwd = 3)

## MONMLP w/ 2 hidden nodes
w.mon &lt;- monmlp.fit(x = x, y = y, hidden1 = 2, monotone = 1,
                    iter.max = 500)
lines(x, attr(w.mon, "y.pred"), col = "blue", lwd = 3)
</code></pre>


</div>