<div class="container">

<table style="width: 100%;"><tr>
<td>ndr.bin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Four-stage monotonic binning procedure including regression with nested dummies</h2>

<h3>Description</h3>

<p><code>ndr.bin</code> implements extension of three-stage monotonic binning procedure (<code>iso.bin</code>)
with step of regression with nested dummies as fourth stage.
The first stage is isotonic regression used to achieve the monotonicity. The next two stages are possible corrections for
minimum percentage of observations and target rate, while the last regression stage is used to identify
statistically significant cut points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ndr.bin(
  x,
  y,
  sc = c(NA, NaN, Inf, -Inf),
  sc.method = "together",
  y.type = NA,
  min.pct.obs = 0.05,
  min.avg.rate = 0.01,
  p.val = 0.05,
  force.trend = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric vector to be binned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Numeric target vector (binary or continuous).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sc</code></td>
<td>
<p>Numeric vector with special case elements. Default values are <code>c(NA, NaN, Inf, -Inf)</code>.
Recommendation is to keep the default values always and add new ones if needed. Otherwise, if these values exist
in <code>x</code> and are not defined in the <code>sc</code> vector, function will report the error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sc.method</code></td>
<td>
<p>Define how special cases will be treated, all together or separately.
Possible values are <code>"together", "separately"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.type</code></td>
<td>
<p>Type of <code>y</code>, possible options are <code>"bina"</code> (binary) and <code>"cont"</code> (continuous).
If default value is passed, then algorithm will identify if y is 0/1 or continuous variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.pct.obs</code></td>
<td>
<p>Minimum percentage of observations per bin. Default is 0.05 or 30 observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.avg.rate</code></td>
<td>
<p>Minimum <code>y</code> average rate. Default is 0.05 or 30 observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.val</code></td>
<td>
<p>Threshold for p-value of regression coefficients. Default is 0.05.
For a binary target binary logistic regression is estimated, whereas for a continuous target, linear regression is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force.trend</code></td>
<td>
<p>If the expected trend should be forced. Possible values: <code>"i"</code> for
increasing trend (<code>y</code> increases with increase of <code>x</code>), <code>"d"</code> for decreasing trend
(<code>y</code> decreases with decrease of <code>x</code>). Default value is <code>NA</code>.
If the default value is passed, then trend will be identified based on the sign of the Spearman correlation
coefficient between <code>x</code> and <code>y</code> on complete cases.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The command <code>ndr.bin</code> generates a list of two objects. The first object, data frame <code>summary.tbl</code>
presents a summary table of final binning, while <code>x.trans</code> is a vector of discretized values.
In case of single unique value for <code>x</code> or <code>y</code> of complete cases (cases different than special cases),
it will return data frame with info.
</p>


<h3>See Also</h3>

<p><code>iso.bin</code> for three-stage monotonic binning procedure.
</p>


<h3>Examples</h3>

<pre><code class="language-R">suppressMessages(library(monobin))
data(gcd)
age.bin &lt;- ndr.bin(x = gcd$age, y = gcd$qual)
age.bin[[1]]
table(age.bin[[2]])
#linear regression example
amount.bin &lt;- ndr.bin(x = gcd$amount, y = gcd$qual, y.type = "cont", p.val = 0.05)
#create nested dummies
db.reg &lt;- gcd[, c("qual", "amount")]
db.reg$amount.bin &lt;- amount.bin[[2]]
amt.s &lt;- db.reg %&gt;% 
      group_by(amount.bin) %&gt;% 
      summarise(qual.mean = mean(qual),
		    amt.min = min(amount))
mins &lt;- amt.s$amt.min
for (i in 2:length(mins)) {
	 level.l &lt;- mins[i]
 nd &lt;- ifelse(db.reg$amount &lt; level.l, 0, 1)
 db.reg &lt;- cbind.data.frame(db.reg, nd)
 names(db.reg)[ncol(db.reg)] &lt;- paste0("dv_", i)
 }
reg.f &lt;- paste0("qual ~ dv_2 + dv_3")
lrm &lt;- lm(as.formula(reg.f), data = db.reg)
lr.coef &lt;- data.frame(summary(lrm)$coefficients)
lr.coef
cumsum(lr.coef$Estimate)
#check
as.data.frame(amt.s)
diff(amt.s$qual.mean)

</code></pre>


</div>