<div class="container">

<table style="width: 100%;"><tr>
<td>default.QP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Generating a default Quadratic Program for bmonomvn </h2>

<h3>Description</h3>

<p>This function generates a default “minimum variance”
Quadratic Program in order to obtain samples of the solution
under the posterior for parameters <code class="reqn">\mu</code> and <code class="reqn">\Sigma</code>
obtained via <code>bmonomvn</code>.  The list generated as output
has entries similar to the inputs of <code>solve.QP</code>
from the <span class="pkg">quadprog</span> package
</p>


<h3>Usage</h3>

<pre><code class="language-R">default.QP(m, dmu = FALSE, mu.constr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p> the dimension of the solution space; usually
<code>ncol(y)</code> or equivalently <code>length(mu)</code>, <code>ncol(S)</code>
and <code>nrow(S)</code> in the usage of <code>bmonomvn</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmu</code></td>
<td>
<p> a logical indicating whether <code>dvec</code> should
be replaced with samples of <code class="reqn">\mu</code>; see details below </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.constr</code></td>
<td>
<p> a vector indicating linear constraints on the
samples of <code class="reqn">\mu</code> to be included in the default constraint
set. See details below; the default of <code>NULL</code> indicates none </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>bmonomvn(y, QP=TRUE)</code> is called, this
function is used to generate a default Quadratic Program that
samples from the argument <code class="reqn">w</code> such that
</p>
<p style="text-align: center;"><code class="reqn">\min_w w^\top \Sigma w,</code>
</p>

<p>subject to the constraints that all
<code class="reqn">0\leq w_i \leq 1</code>, for
<code class="reqn">i=1,\dots,m</code>,
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^m w_i = 1,</code>
</p>

<p>and where <code class="reqn">\Sigma</code> is sampled from its posterior distribution
conditional on the data <code class="reqn">y</code>.
Alternatively, this function
can be used as a skeleton to for adaptation to more general 
Quadratic Programs by adjusting the <code>list</code> that is returned,
as described in the “value” section below.
</p>
<p>Non-default settings of the arguments <code>dmu</code> and <code>mu.constr</code>
augment the default Quadratic Program, described above, in two standard ways.
Specifying <code>dvec = TRUE</code> causes the program objective to change
to </p>
<p style="text-align: center;"><code class="reqn">\min_w - w^\top \mu + \frac{1}{2} w^\top \Sigma w,</code>
</p>

<p>with the same constraints as above.  Setting <code>mu.constr = 1</code>,
say, would augment the constraints to include
</p>
<p style="text-align: center;"><code class="reqn">\mu^\top w \geq 1,</code>
</p>
<p> for samples of <code class="reqn">\mu</code>
from the posterior.  Setting <code>mu.constr = c(1,2)</code> would
augment the constraints still further with
</p>
<p style="text-align: center;"><code class="reqn">-\mu^\top w \geq -2,</code>
</p>
<p> i.e., with
alternating sign on the linear part, so that each sample of
<code class="reqn">\mu^\top w</code> must lie in the interval [1,2].
So whereas <code>dmu = TRUE</code> allows the <code>mu</code> samples to
enter the objective in a standard way, <code>mu.constr</code>
(<code>!= NULL</code>) allows it to enter the constraints.
</p>
<p>The accompanying function <code>monomvn.solve.QP</code> can
act as an interface between the constructed (default) <code>QP</code>
object, and estimates of the covariance matrix <code class="reqn">\Sigma</code> and
mean vector <code class="reqn">\mu</code>, that is identical to the one used on
the posterior-sample version implemented in <code>bmonomvn</code>.
The example below, and those in the documentation for
<code>bmonomvn</code>, illustrate how this feature may be used
to extract mean and MLE solutions to the constructed
Quadratic Program
</p>


<h3>Value</h3>

<p>This function returns a <code>list</code> that can be interpreted as
specifying the following arguments to the
<code>solve.QP</code> function in the <span class="pkg">quadprog</span>
package.  See <code>solve.QP</code> for more information
of the general specification of these arguments.  In what follows
we simply document the defaults provided by <code>default.QP</code>.
Note that the <code>Dmat</code> argument is not, specified as
<code>bmonomvn</code> will use samples from <code>S</code> (from the
posterior) instead
</p>
<table>
<tr style="vertical-align: top;">
<td><code>m </code></td>
<td>
 <p><code>length(dvec)</code>, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dvec </code></td>
<td>
<p> a zero-vector <code>rep(0, m)</code>, or a one-vector
<code>rep(1, m)</code> when <code>dmu = TRUE</code> as the real <code>dvec</code>
that will be used by <code>solve.QP</code> will
then be <code>dvec * mu</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmu </code></td>
<td>
<p> a copy of the <code>dmu</code> input argument </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Amat </code></td>
<td>
<p> a <code>matrix</code> describing a linear transformation
which, together with <code>b0</code>  and <code>meq</code>, describe the
constraint that the components of the sampled solution(s),
<code>w</code>, must be positive and sum to one </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0 </code></td>
<td>
<p> a vector containing the (RHS of) in/equalities described by
the these constraints </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meq</code></td>
<td>
<p> an integer scalar indicating that the first <code>meq</code>
constraints described by <code>Amat</code> and <code>b0</code> are equality
constraints; the rest are <code>&gt;=</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.constr</code></td>
<td>
<p> a vector whose length is one greater than the
input argument of the same name, providing <code>bmonomvn</code> with
the number 
</p>
<p><code>mu.constr[1] = length(mu.constr[-1])</code>
</p>
<p>and location <code>mu.constr[-1]</code> of the columns of <code>Amat</code>
which require multiplication by samples of <code>mu</code> </p>
</td>
</tr>
</table>
<p>The <code>$QP</code> object that is returned from <code>bmonomvn</code>
will have the following additional field
</p>
<table><tr style="vertical-align: top;">
<td><code>o</code></td>
<td>
<p> an integer vector of length <code>m</code> indicating the ordering
of the rows of <code>$Amat</code>, and thus the rows of solutions
<code>$W</code> that was used in the monotone factorization of the
likelihood.  This field appears only after <code>bmonomvn</code>
returns a <code>QP</code> object checked by the internal function
<code>check.QP</code></p>
</td>
</tr></table>
<h3>Author(s)</h3>

<p> Robert B. Gramacy <a href="mailto:rbg@vt.edu">rbg@vt.edu</a> </p>


<h3>See Also</h3>

 <p><code>bmonomvn</code> and <code>solve.QP</code>
in the <span class="pkg">quadprog</span> package, <code>monomvn.solve.QP</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">## generate N=100 samples from a 10-d random MVN
## and randomly impose monotone missingness
xmuS &lt;- randmvn(100, 20)
xmiss &lt;- rmono(xmuS$x)

## set up the minimum-variance (default) Quadratic Program
## and sample from the posterior of the solution space
qp1 &lt;- default.QP(ncol(xmiss))
obl1 &lt;- bmonomvn(xmiss, QP=qp1)
bm1 &lt;- monomvn.solve.QP(obl1$S, qp1) ## calculate mean
bm1er &lt;- monomvn.solve.QP(obl1$S + obl1$mu.cov, qp1) ## use estimation risk
oml1 &lt;- monomvn(xmiss)
mm1 &lt;- monomvn.solve.QP(oml1$S, qp1) ## calculate MLE

## now obtain samples from the solution space of the
## mean-variance QP
qp2 &lt;- default.QP(ncol(xmiss), dmu=TRUE)
obl2 &lt;- bmonomvn(xmiss, QP=qp2)
bm2 &lt;- monomvn.solve.QP(obl2$S, qp2, obl2$mu) ## calculate mean
bm2er &lt;- monomvn.solve.QP(obl2$S + obl2$mu.cov, qp2, obl2$mu) ## use estimation risk
oml2 &lt;- monomvn(xmiss)
mm2 &lt;- monomvn.solve.QP(oml2$S, qp2, oml2$mu) ## calculate MLE

## now obtain samples from minimum variance solutions
## where the mean weighted (samples) are constrained to be
## greater one
qp3 &lt;- default.QP(ncol(xmiss), mu.constr=1)
obl3 &lt;- bmonomvn(xmiss, QP=qp3)
bm3 &lt;- monomvn.solve.QP(obl3$S, qp3, obl3$mu) ## calculate mean
bm3er &lt;- monomvn.solve.QP(obl3$S + obl3$mu.cov, qp3, obl3$mu) ## use estimation risk
oml3 &lt;- monomvn(xmiss)
mm3 &lt;- monomvn.solve.QP(oml3$S, qp3, oml2$mu) ## calculate MLE

## plot a comparison
par(mfrow=c(3,1))
plot(obl1, which="QP", xaxis="index", main="Minimum Variance")
points(bm1er, col=4, pch=17, cex=1.5) ## add estimation risk
points(bm1, col=3, pch=18, cex=1.5) ## add mean
points(mm1, col=5, pch=16, cex=1.5) ## add MLE
legend("topleft", c("MAP", "posterior mean", "ER", "MLE"), col=2:5,
       pch=c(21,18,17,16), cex=1.5)
plot(obl2, which="QP", xaxis="index", main="Mean Variance")
points(bm2er, col=4, pch=17, cex=1.5) ## add estimation risk
points(bm2, col=3, pch=18, cex=1.5) ## add mean
points(mm2, col=5, pch=16, cex=1.5) ## add MLE
plot(obl3, which="QP", xaxis="index", main="Minimum Variance, mean &gt;= 1")
points(bm3er, col=4, pch=17, cex=1.5) ## add estimation risk
points(bm3, col=3, pch=18, cex=1.5) ## add mean
points(mm3, col=5, pch=16, cex=1.5) ## add MLE

## for a further comparison of samples of the QP solution
## w under Bayesian and non-Bayesian monomvn, see the
## examples in the bmonomvn help file
</code></pre>


</div>