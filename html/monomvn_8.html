<div class="container">

<table style="width: 100%;"><tr>
<td>bmonomvn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian Estimation for Multivariate Normal Data with
Monotone Missingness</h2>

<h3>Description</h3>

<p>Bayesian estimation via sampling from the posterior distribution of the
of the mean and covariance matrix of multivariate normal (MVN)
distributed data with a monotone missingness pattern, via Gibbs Sampling.
Through the use of parsimonious/shrinkage regressions (lasso/NG &amp;
ridge),
where standard regressions fail, this function can handle an (almost)
arbitrary amount of missing data
</p>


<h3>Usage</h3>

<pre><code class="language-R">bmonomvn(y, pre = TRUE, p = 0.9, B = 100, T = 200, thin = 1,
         economy = FALSE, method = c("lasso", "ridge", "lsr", "factor",
         "hs", "ng"), RJ = c("p", "bpsn", "none"), capm = TRUE,
         start = NULL, mprior = 0, rd = NULL, theta = 0, rao.s2 = TRUE,
         QP = NULL, verb = 1, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p> data <code>matrix</code>  were each row is interpreted as a
random sample from a MVN distribution with missing
values indicated by <code>NA</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre</code></td>
<td>
<p> logical indicating whether pre-processing of the
<code>y</code> is to be performed.  This sorts the columns so that the
number of <code>NA</code>s is non-decreasing with the column index </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p> when performing regressions, <code>p</code> is the proportion of the
number of columns to rows in the design matrix before an
alternative regression (lasso, ridge, or RJ) is performed as if
least-squares regression has “failed”.
Least-squares regression is
known to fail when the number of columns equals the number of rows,
hence a default of <code>p = 0.9 &lt;= 1</code>. Alternatively, setting
<code>p = 0</code> forces a parsimonious method to be used for
<em>every</em> regression. Intermediate settings of <code>p</code> allow
the user to control when least-squares regressions stop and the
parsimonious ones start;  When <code>method = "factor"</code> the <code>p</code>
argument represents an integer (positive) number of initial columns
of <code>y</code> to treat as known factors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p> number of Burn-In MCMC sampling rounds,
during which samples are discarded </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>
<p> total number of MCMC sampling rounds to take
place after burn-in, during which samples are saved </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p> multiplicative thinning in the MCMC.  Each Bayesian
(lasso) regression will discard <code>thin*M</code> MCMC rounds,
where <code>M</code> is the number of columns in its design matrix,
before a sample is saved as a draw from the posterior distribution;
Likewise if <code>theta != 0</code> a further <code>thin*N</code>, for
<code>N</code> responses will be discarded </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>economy </code></td>
<td>
<p> indicates whether memory should be economized at
the expense of speed.  When <code>TRUE</code> the individual Bayesian
(lasso) regressions are cleaned between uses so that only one
of them has a large footprint at any time during sampling from
the Markov chain.  When <code>FALSE</code> (default) all regressions
are pre-allocated and the full memory footprint is realized at
the outset, saving dynamic allocations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> indicates the Bayesian parsimonious regression
specification to be used, choosing between the lasso (default)
of Park &amp; Casella, the NG extension, the horseshoe,
a ridge regression special case, and least-squares.
The <code>"factor"</code> method treats the first
<code>p</code> columns of <code>y</code> as known factors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RJ </code></td>
<td>
<p> indicates the Reversible Jump strategy to be employed.
The default argument of <code>"p"</code> method uses RJ whenever a
parsimonious regression is used;  <code>"bpsn"</code> only uses
RJ for regressions with <code>p &gt;= n</code>, and <code>"none"</code> never
uses RJ</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capm</code></td>
<td>
<p> when <code>TRUE</code> this argument indicates that the
number of components of <code class="reqn">\beta</code> should not exceed
<code class="reqn">n</code>, the number of response variables in a particular
regression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p> a list depicting starting values for the parameters
that are use to initialize the Markov chain.  Usually this will be
a <code>"monomvn"</code>-class object depicting maximum likelihood
estimates output from the <code>monomvn</code> function.
The relevant fields are the mean vector <code>$mu</code>, covariance
matrix <code>$S</code>, monotone ordering <code>$o</code> (for sanity checking
with input <code>y</code>), component vector <code>$ncomp</code> and
penalty parameter vector <code>$lambda</code>; see note below </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mprior</code></td>
<td>
<p> prior on the number of non-zero regression coefficients
(and therefore covariates) <code>m</code> in the model. The default
(<code>mprior = 0</code>) encodes the uniform prior on <code>0 &lt; m &lt; M</code>.
A scalar value <code>0 &lt;= mprior &lt;= 1</code> implies a Binomial prior
<code>Bin(m|n=M,p=mprior)</code>.  A 2-vector <code>mprior=c(g,h)</code>
of positive values <code>g</code> and <code>h</code> represents
gives <code>Bin(m|n=M,p)</code> prior where <code>p~Beta(g,h)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rd</code></td>
<td>
 <p><code>=c(r,delta)</code>; a 2-vector of prior parameters for
<code class="reqn">\lambda^2</code>
which depends on the regression method.  When <code>method =
      "lasso"</code> then the components are the <code class="reqn">\alpha</code>
(shape) and <code class="reqn">\beta</code> (rate) parameters to the a
gamma distribution <code>G(r,delta)</code>;
when <code>method = "ridge"</code> the components are the
<code class="reqn">\alpha</code> (shape) and <code class="reqn">\beta</code> (scale) parameters
to an inverse-gamma distribution <code>IG(r/2,delta/2)</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p> the rate parameter (<code>&gt; 0</code>) to the exponential prior
on the degrees of freedom paramter <code>nu</code> for each regression
model implementing Student-t errors (for each column of
<code>Y</code> marginally) by a scale-mixture prior.  See
<code>blasso</code> for more details.
The default setting of <code>theta = 0</code> turns off this prior,
defaulting to a normal errors prior.  A negative setting
triggers a pooling of the degrees of freedom parameter
across all columns of <code>Y</code>.  I.e., <code>Y</code> is modeled as
multivariate-t.  In this case <code>abs{theta}</code> is used as the
prior parameterization </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rao.s2 </code></td>
<td>
<p>indicates whether to  Rao-Blackwellized samples for
<code class="reqn">\sigma^2</code> should be used (default <code>TRUE</code>); see
the details section of <code>blasso</code> for more information </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>QP </code></td>
<td>
<p> if non-<code>NULL</code> this argument should either be
<code>TRUE</code>, a positive integer, or contain a <code>list</code>
specifying a Quadratic Program to solve as a function of the
samples of <code>mu = dvec</code> and
<code>Sigma = Dmat</code> in the notation of <code>solve.QP</code>;
see <code>default.QP</code> for a default specification that
is used when <code>QP = TRUE</code> or a positive integer is is given;
more details are below </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p> verbosity level; currently only <code>verb = 0</code> and
<code>verb = 1</code> are supported </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p> if <code>TRUE</code> then samples from all parameters are
saved to files in the CWD, and then read back into the
<code>"monomvn"</code>-class object upon return </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>pre = TRUE</code> then <code>bmonomvn</code> first re-arranges the columns
of <code>y</code> into nondecreasing order with respect to the number of
missing (<code>NA</code>)  entries. Then (at least) the first column should
be completely observed.
</p>
<p>Samples from the posterior distribution of the MVN mean vector and
covariance matrix are obtained sampling
from the posterior distribution of Bayesian regression models.
The methodology for converting these to samples from the mean vector
and covariance matrix is outlined in the <code>monomvn</code>
documentation, detailing a similarly structured maximum likelihood
approach.  Also see the references below.
</p>
<p>Whenever the regression model is ill–posed (i.e., when there are
more covariates than  responses, or a
“big <code>p</code> small <code>n</code>” problem) then
Bayesian lasso or ridge regressions – possibly augmented with Reversible
Jump (RJ) for model selection – are used instead.
See the Park &amp; Casella reference below, and the <code>blasso</code>
documentation.  To guarantee each regression is well posed the
combination setting of <code>method="lsr"</code> and <code>RJ="none"</code>
is not allowed.
As in <code>monomvn</code> the <code>p</code> argument can be used to
turn on lasso or ridge regressions (possibly with RJ) at other times.
The exception is the <code>"factor"</code> method which always involves
an OLS regression on (a subset of) the first <code>p</code>
columns of <code>y</code>.
</p>
<p>Samples from a function of samples of <code>mu</code> and <code>Sigma</code>
can be obtained by specifying a Quadratic program via the
argument <code>QP</code>.  The idea is to allow for the calculation of
the distribution of minimum variance and mean–variance portfolios,
although the interface is quite general.  See <code>default.QP</code>
for more details, as <code>default.QP(ncol(y))</code> is used
when the argument <code>QP = TRUE</code> is given.  When a positive integer
is given, then the first <code>QP</code> columns of <code>y</code> are treated
as factors by using
</p>
<p><code>default.QP(ncol(y) - QP)</code>
</p>
<p>instead. The result is that the corresponding components of (samples of)
<code>mu</code> and rows/cols of <code>S</code> are not factored into the
specification of the resulting Quadratic Program
</p>


<h3>Value</h3>

<p><code>bmonomvn</code> returns an object of class <code>"monomvn"</code>,
which is a <code>list</code> containing the inputs above and a
subset of the components below.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call </code></td>
<td>
<p>a copy of the function call as used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu </code></td>
<td>
<p>estimated mean vector with columns corresponding to the
columns of <code>y</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S </code></td>
<td>
<p>estimated covariance matrix with rows and columns
corresponding to the columns of <code>y</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.var </code></td>
<td>
<p>estimated variance of the mean vector with columns
corresponding to the columns of <code>y</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.cov </code></td>
<td>
<p>estimated covariance matrix of the mean vector
with columns corresponding to the columns of <code>y</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.var </code></td>
<td>
<p>estimated variance of the individual components of the
covariance matrix with columns and rows corresponding to the columns
of <code>y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.map </code></td>
<td>
<p>estimated maximum <em>a' posteriori</em> (MAP) of the
mean vector with columns corresponding to the columns of <code>y</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.map </code></td>
<td>
<p>estimated MAP of the individual
components of the covariance matrix with columns and rows
corresponding to the columns of <code>y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.nz </code></td>
<td>
<p> posterior probability that the individual entries of
the covariance matrix are non–zero </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Si.nz </code></td>
<td>
<p> posterior probability that the individual entries of
the inverse of the covariance matrix are non–zero </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu </code></td>
<td>
<p> when <code>theta &lt; 0</code> this field provides a trace of
the pooled <code>nu</code> parameter to the multivariate-t distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpost.map</code></td>
<td>
<p> log posterior probability of the MAP estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.map</code></td>
<td>
<p> gives the time index of the sample corresponding to
the MAP estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>llik</code></td>
<td>
<p> a trace of the log likelihood of the data </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>llik.norm</code></td>
<td>
<p> a trace of the log likelihood 
under the Normal errors model when sampling under the
Student-t model; i.e., it is not present unless <code>theta &gt; 0</code>.
Used for calculating Bayes Factors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na </code></td>
<td>
<p> when <code>pre = TRUE</code> this is a vector containing number of
<code>NA</code> entries in each column of <code>y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>o </code></td>
<td>
<p> when <code>pre = TRUE</code> this is a vector containing the
index of each column in the sorting of the columns of <code>y</code>
obtained by <code>o &lt;- order(na)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method </code></td>
<td>
<p>method of regression used on each column, or
<code>"bcomplete"</code> indicating that no regression was used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin </code></td>
<td>
<p> the (actual) number of thinning rounds used for the
regression (<code>method</code>) in each column</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2 </code></td>
<td>
<p> records the mean <code class="reqn">\lambda^2</code> value
found in the trace of the Bayesian Lasso regressions.  Zero-values
result when the column corresponds to a complete
case or an ordinary least squares regression (these would be
<code>NA</code> entries from <code>monomvn</code>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp </code></td>
<td>
<p> records the mean number of components
(columns of the design matrix) used in the regression model for
each column of <code>y</code>. If input <code>RJ = FALSE</code> then this simply
corresponds to the monotone ordering (these would correspond to
the <code>NA</code> entries from <code>monomvn</code>).
When <code>RJ = TRUE</code>
the monotone ordering is an upper bound (on each entry)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p> if input <code>trace = TRUE</code> then this field contains
traces of the samples of <code class="reqn">\mu</code> in the field <code>$mu</code> and
of <code class="reqn">\Sigma</code> in the field <code>$S</code>, and of all regression
parameters for each of the <code>m = length(mu)</code> columns in the field
<code>$reg</code>. This <code>$reg</code> field is a stripped-down
<code>"blasso"</code>-class object so that the methods of that object
may be used for analysis.  If data augmentation is required to
complete the monotone missingness pattern, then samples from these
entries of <code>Y</code> are contained in <code>$DA</code> where the column
names indicate the <code>i</code>-<code>j</code> entry of <code>Y</code> sampled;
see the <code>R</code> output below </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p> gives a <code>matrix</code> version of the missingness pattern
used: <code>0</code>-entries mean observed; <code>1</code>-entries indicate
missing values conforming to a monotone pattern; <code>2</code>-entries
indicate missing values that require data augmentation to complete
a monotone missingness pattern </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p> from inputs: number of Burn-In MCMC sampling rounds,
during which samples are discarded </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>
<p> from inputs: total number of MCMC sampling rounds to take
place after burn-in, during which samples are saved </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p> from inputs: alpha (shape) parameter to the gamma
distribution prior for the lasso parameter lambda </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p> from inputs: beta (rate) parameter to the gamma
distribution prior for the lasso parameter lambda </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>QP</code></td>
<td>
<p> if a valid (non–<code>FALSE</code> or <code>NULL</code>) <code>QP</code>
argument is given, then this field contains the specification of
a Quadratic Program in the form of a list with entries including
<code>$dvec</code>, <code>$Amat</code>, <code>$b0</code>, and <code>$meq</code>, similar
to the usage in <code>solve.QP</code>, and some
others; see <code>default.QP</code> for more details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p> when input <code>QP = TRUE</code> is given, then this field
contains a <code>T*ncol(y)</code> matrix of samples from the posterior
distribution of the solution to the Quadratic Program, which can
be visualized via <code>plot.monomvn</code> using the argument
<code>which = "QP"</code> </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Whenever the <code>bmonomvn</code> algorithm requires a regression
where <code>p &gt;= n</code>, i.e., if any of the columns in the <code>y</code>
matrix have fewer non–<code>NA</code> elements than the number of
columns with more non–<code>NA</code> elements, then it is helpful
to employ both lasso/ridge and the RJ method.
</p>
<p>It is important that any starting values provided in the
<code>start</code> be compatible with the regression model
specified by inputs <code>RJ</code> and <code>method</code>.  Any
incompatibilities will result with a warning that
(alternative) default action was taken and may result in
an undesired (possibly inferior) model being fit
</p>


<h3>Author(s)</h3>

<p> Robert B. Gramacy <a href="mailto:rbg@vt.edu">rbg@vt.edu</a> </p>


<h3>References</h3>

<p>R.B. Gramacy and E. Pantaleo (2010).
<em>Shrinkage regression for multivariate inference with missing
data, and an application to portfolio balancing.</em>  Bayesian Analysis.
5(1), 237-262.  <a href="https://doi.org/10.1214/10-BA602">doi:10.1214/10-BA602</a>
Preprint available on arXiv:0710.5837 <a href="https://arxiv.org/abs/0907.2135">https://arxiv.org/abs/0907.2135</a>
</p>
<p>Roderick J.A. Little and Donald B. Rubin (2002).
<em>Statistical Analysis with Missing Data</em>, Second Edition.
Wilely.
</p>
<p><a href="https://bobby.gramacy.com/r_packages/monomvn/">https://bobby.gramacy.com/r_packages/monomvn/</a>
</p>


<h3>See Also</h3>

 <p><code>blasso</code>, <code>monomvn</code>,
<code>default.QP</code>, <code>em.norm</code> in the now defunct
<code>norm</code> and <code>mvnmle</code> packages, and <code>returns</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## standard usage, duplicating the results in
## Little and Rubin, section 7.4.3
data(cement.miss)
out &lt;- bmonomvn(cement.miss)
out
out$mu
out$S

##
## A bigger example, comparing the various
## parsimonious methods
##

## generate N=100 samples from a 10-d random MVN
xmuS &lt;- randmvn(100, 20)

## randomly impose monotone missingness
xmiss &lt;- rmono(xmuS$x)

## using least squares only when necessary,
obl &lt;- bmonomvn(xmiss)
obl

## look at the posterior variability
par(mfrow=c(1,2))
plot(obl)
plot(obl, "S")

## compare to maximum likelihood
Ellik.norm(obl$mu, obl$S, xmuS$mu, xmuS$S)
oml &lt;- monomvn(xmiss, method="lasso")
Ellik.norm(oml$mu, oml$S, xmuS$mu, xmuS$S)


##
## a min-variance portfolio allocation example
##

## get the returns data, and use 20 random cols
data(returns)
train &lt;- returns[,sample(1:ncol(returns), 20)]

## missingness pattern requires DA; also gather
## samples from the solution to a QP
obl.da &lt;- bmonomvn(train, p=0, QP=TRUE)

## plot the QP weights distribution
plot(obl.da, "QP", xaxis="index")

## get ML solution: will warn about monotone violations
suppressWarnings(oml.da &lt;- monomvn(train, method="lasso"))

## add mean and MLE comparison, requires the
## quadprog library for the solve.QP function
add.pe.QP(obl.da, oml.da)

## now consider adding in the market as a factor
data(market)
mtrain &lt;- cbind(market, train)

## fit the model using only factor regressions
obl.daf &lt;- bmonomvn(mtrain, method="factor", p=1, QP=1)
plot(obl.daf, "QP", xaxis="index", main="using only factors")
suppressWarnings(oml.daf &lt;- monomvn(mtrain, method="factor"))
add.pe.QP(obl.daf, oml.daf)


##
## a Bayes/MLE comparison using least squares sparingly
##

## fit Bayesian and classical lasso
p &lt;- 0.25
obls &lt;- bmonomvn(xmiss, p=p)
Ellik.norm(obls$mu, obls$S, xmuS$mu, xmuS$S)
omls &lt;- monomvn(xmiss, p=p, method="lasso")
Ellik.norm(omls$mu, omls$S, xmuS$mu, xmuS$S)

## compare to ridge regression
obrs &lt;- bmonomvn(xmiss, p=p, method="ridge")
Ellik.norm(obrs$mu, obrs$S, xmuS$mu, xmuS$S)
omrs &lt;- monomvn(xmiss, p=p, method="ridge")
Ellik.norm(omrs$mu, omrs$S, xmuS$mu, xmuS$S)
</code></pre>


</div>