<div class="container">

<table style="width: 100%;"><tr>
<td>is_nondominated</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Identify, remove and rank dominated points according to Pareto optimality</h2>

<h3>Description</h3>

<p>Identify nondominated points with <code>is_nondominated()</code> and remove dominated
ones with <code>filter_dominated()</code>.
</p>
<p><code>pareto_rank()</code> ranks points according to Pareto-optimality,
which is also called nondominated sorting (Deb et al. 2002).
</p>


<h3>Usage</h3>

<pre><code class="language-R">is_nondominated(x, maximise = FALSE, keep_weakly = FALSE)

filter_dominated(x, maximise = FALSE, keep_weakly = FALSE)

pareto_rank(x, maximise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br> Matrix or data frame of numerical
values, where each row gives the coordinates of a point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximise</code></td>
<td>
<p><code>logical()</code><br> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_weakly</code></td>
<td>
<p>If <code>FALSE</code>, return <code>FALSE</code> for any duplicates
of nondominated points.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>pareto_rank()</code> is meant to be used like <code>rank()</code>, but it
assigns ranks according to Pareto dominance. Duplicated points are kept on
the same front. When <code>ncol(data) == 2</code>, the code uses the <code class="reqn">O(n
  \log n)</code> algorithm by Jensen (2003).
</p>


<h3>Value</h3>

<p><code>is_nondominated()</code> returns a logical vector of the same length
as the number of rows of <code>data</code>, where <code>TRUE</code> means that the
point is not dominated by any other point.
</p>
<p><code>filter_dominated</code> returns a matrix or data.frame with only mutually nondominated points.
</p>
<p><code>pareto_rank()</code> returns an integer vector of the same length as
the number of rows of <code>data</code>, where each value gives the rank of each
point.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>Kalyanmoy Deb, A Pratap, S Agarwal, T Meyarivan (2002).
“A fast and elitist multi-objective genetic algorithm: NSGA-II.”
<em>IEEE Transactions on Evolutionary Computation</em>, <b>6</b>(2), 182–197.
doi: <a href="https://doi.org/10.1109/4235.996017">10.1109/4235.996017</a>.<br><br> M
T Jensen (2003).
“Reducing the run-time complexity of multiobjective EAs: The NSGA-II and other algorithms.”
<em>IEEE Transactions on Evolutionary Computation</em>, <b>7</b>(5), 503–515.
</p>


<h3>Examples</h3>

<pre><code class="language-R">S = matrix(c(1,1,0,1,1,0,1,0), ncol = 2, byrow = TRUE)
is_nondominated(S)

is_nondominated(S, maximise = TRUE)

filter_dominated(S)

filter_dominated(S, keep_weakly = TRUE)

path_A1 &lt;- file.path(system.file(package="moocore"),"extdata","ALG_1_dat.xz")
set &lt;- read_datasets(path_A1)[,1:2]
is_nondom &lt;- is_nondominated(set)
cat("There are ", sum(is_nondom), " nondominated points\n")

if (requireNamespace("graphics", quietly = TRUE)) {
   plot(set, col = "blue", type = "p", pch = 20)
   ndset &lt;- filter_dominated(set)
   points(ndset[order(ndset[,1]),], col = "red", pch = 21)
}

ranks &lt;- pareto_rank(set)
str(ranks)
if (requireNamespace("graphics", quietly = TRUE)) {
   colors &lt;- colorRampPalette(c("red","yellow","springgreen","royalblue"))(max(ranks))
   plot(set, col = colors[ranks], type = "p", pch = 20)
}
</code></pre>


</div>