<div class="container">

<table style="width: 100%;"><tr>
<td>D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Derivative and Anti-derivative operators</h2>

<h3>Description</h3>

<p>Operators for computing derivatives and anti-derivatives as
functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">D(tilde, ...)

antiD(tilde, ..., lower.bound = 0, force.numeric = FALSE, .tol = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tilde</code></td>
<td>
<p>A tilde expression. The right side of a formula specifies
the variable(s) with which to
carry out the integration or differentiation.  On the left side should be
an expression or a function that returns a numerical vector
of the same length as its argument.
The expression can contain unbound variables.  Functions
will be differentiated as if the formula <code>f(x) ~ x</code> were specified
but with <code>x</code> replaced by the first argument of <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Default values to be given to unbound variables in the expression <code>expr</code>.
See examples.#'  Note that in creating anti-derivative functions,
default values of "from" and "to" can be assigned.  They are to be written with
the name of the variable as a prefix, e.g. <code>y.from</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.bound</code></td>
<td>
<p>for numerical integration only, the lower bound used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force.numeric</code></td>
<td>
<p>If <code>TRUE</code>, a numerical integral is performed even when a
symbolic integral is available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.tol</code></td>
<td>
<p>Tolerance for numerical integration. Most users do not need this.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>D()</code> attempts to find a symbolic derivative for simple expressions, but
will provide a function that is a numerical derivative if the attempt at
symbolic differentiation is unsuccessful.  The symbolic derivative can be of
any order (although the expression may become unmanageably complex).  The
numerical derivative is limited to first or second-order partial derivatives
(including mixed partials).
<code>antiD()</code> will attempt simple symbolic integration but if it fails
it will return a numerically-based anti-derivative.
</p>
<p><code>antiD()</code> returns a function with the same arguments as the
expression passed to it.  The returned function is the anti-derivative
of the expression, e.g., <code>antiD(f(x)~x) -&gt; F(x)</code>.
To calculate the integral of <code>f(x)</code>, use <code>F(to) - F(from)</code>.
</p>


<h3>Value</h3>

<p>For derivatives, the return value is a function of the variable(s)
of differentiation, as well as any other symbols used in the expression.  Thus,
<code>D(A*x^2 + B*y ~ x + y)</code> will compute the mixed partial with respect to x
then y (that is, <code class="reqn">\frac{d^2 f}{dy\;dx}</code>).  The returned value will be a function of x and y,
as well as A and B.  In evaluating the returned function, it's best to use the
named form of arguments, to ensure the order is correct.
</p>
<p>a function of the same arguments as the original expression with a
constant of integration set to zero by default, named "C", "D", ... depending on the first
such letter not otherwise in the argument list.
</p>


<h3>Examples</h3>

<pre><code class="language-R">D(sin(t) ~ t)
D(A*sin(t) ~ t )
D(A*sin(2*pi*t/P) ~ t, A=2, P=10) # default values for parameters.
f &lt;- D(A*x^3 ~ x + x, A=1) # 2nd order partial -- note, it's a function of x
f(x=2)
f(x=2,A=10) # override default value of parameter A
g &lt;- D(f(x=t, A=1)^2 ~ t)  # note: it's a function of t
g(t=1)
gg &lt;- D(f(x=t, A=B)^2 ~ t, B=10)  # note: it's a function of t and B
gg(t=1)
gg(t=1, B=100)
f &lt;- makeFun(x^2~x)
D(f(cos(z))~z) #will look in user functions also
antiD( a*x^2 ~ x, a = 3)
G &lt;- antiD( A/x~x ) # there will be an unbound parameter in G()
G(2, A=1) # Need to bound parameter. G(2) will produce an error.
F &lt;- antiD( A*exp(-k*t^2 ) ~ t, A=1, k=0.1)
F(t=Inf)
one = makeFun(1 ~ x)
by.x = antiD(one(x) ~ x)
by.xy = antiD(by.x(sqrt(1-y^2)) ~ y)
4 * by.xy(y = 1) # area of quarter circle
</code></pre>


</div>