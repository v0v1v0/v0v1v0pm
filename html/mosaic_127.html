<div class="container">

<table style="width: 100%;"><tr>
<td>maggregate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate for mosaic</h2>

<h3>Description</h3>

<p>Compute function on subsets of a variable in a data frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">maggregate(
  formula,
  data = parent.frame(),
  FUN,
  groups = NULL,
  subset,
  drop = FALSE,
  ...,
  .format = c("default", "table", "flat"),
  .overall = mosaic.par.get("aggregate.overall"),
  .multiple = FALSE,
  .name = deparse(substitute(FUN)),
  .envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula.  Left side provides variable to be summarized.  Right side and condition
describe subsets.  If the left side is empty, right side and condition are
shifted over as a convenience.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame.
Note that the default is <code>data = parent.frame()</code>.  This makes it convenient to
use this function interactively by treating the working environment as if it were
a data frame.  But this may not be appropriate for programming uses.
When programming, it is best to use an explicit <code>data</code> argument
â€“ ideally supplying a data frame that contains the variables mentioned
in <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>a function to apply to each subset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>grouping variable that will be folded into the formula (if there is room for it).
This offers some additional flexibility in how formulas can be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>a logical indicating a subset of <code>data</code> to be processed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>a logical indicating whether unused levels should be dropped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>FUN</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.format</code></td>
<td>
<p>format used for aggregation. <code>"default"</code> and <code>"flat"</code> are equivalent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.overall</code></td>
<td>
<p>currently unused</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.multiple</code></td>
<td>
<p>a logical indicating whether FUN returns multiple values
Ignored if <code>.multiple</code> is not <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.name</code></td>
<td>
<p>a name used for the resulting object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.envir</code></td>
<td>
<p>an environment in which to evaluate expressions</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a vector
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (require(mosaicData)) {
maggregate( cesd ~ sex, HELPrct, FUN = mean )
# using groups instead
maggregate( ~ cesd, groups = sex, HELPrct, FUN = sd )
# the next four all do the same thing
maggregate( cesd ~ sex + homeless, HELPrct, FUN = mean )
maggregate( cesd ~ sex | homeless, HELPrct, FUN = sd )
maggregate( ~ cesd | sex , groups= homeless, HELPrct, FUN = sd )
maggregate( cesd ~ sex, groups = homeless, HELPrct, FUN = sd )
# this is unusual, but also works.
maggregate( cesd ~ NULL , groups = sex, HELPrct, FUN = sd )
}

</code></pre>


</div>