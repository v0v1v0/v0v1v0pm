<div class="container">

<table style="width: 100%;"><tr>
<td>plotFun</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plotting mathematical expressions</h2>

<h3>Description</h3>

<p>Plots mathematical expressions in one and two variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotFun(
  object,
  ...,
  plot = trellis.last.object(),
  add = NULL,
  under = FALSE,
  xlim = NULL,
  ylim = NULL,
  npts = NULL,
  ylab = NULL,
  xlab = NULL,
  zlab = NULL,
  filled = TRUE,
  levels = NULL,
  nlevels = 10,
  labels = TRUE,
  surface = FALSE,
  groups = NULL,
  col = trellis.par.get("superpose.line")$col,
  col.regions = topo.colors,
  type = "l",
  lwd = trellis.par.get("superpose.line")$lwd,
  lty = trellis.par.get("superpose.line")$lty,
  alpha = NULL,
  discontinuities = NULL,
  discontinuity = 1,
  interactive = rstudio_is_available()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a mathematical expression or a function "of one variable" which will
converted to something intuitively equivalent to <code>object(x) ~ x</code>. (See examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters, typically processed by <code>lattice</code> functions such as
<code>lattice::xyplot()</code>, <code>lattice::levelplot()</code> or their panel functions.
Frequently used parameters include
</p>

<dl>
<dt><code>main</code></dt>
<dd>
<p>main title for plot </p>
</dd>
<dt><code>sub</code></dt>
<dd>
<p>subtitle for plot </p>
</dd>
<dt><code>lwd</code></dt>
<dd>
<p>line width </p>
</dd>
<dt><code>lty</code></dt>
<dd>
<p>line type </p>
</dd>
<dt><code>col</code></dt>
<dd>
<p>a color or a (small) integer indicating which color in the current
color scheme is desired.</p>
</dd>
</dl>
<p>Additionally, these arguments can be used to specify parameters for the function being
plotted and to specify the plotting window with natural names.  See the examples for such usage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>a trellis object; by default, the most recently created trellis plot.
When <code>add</code> is <code>TRUE</code>, the new function will
be plotted into a layer added to this object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>if <code>TRUE</code>, then add a layer to an existing plot rather than creating a new plot.
If <code>NULL</code>, this will be determined by the value of <code>under</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>under</code></td>
<td>
<p>if <code>TRUE</code>, then new layer is added beneath existing layers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>limits for x axis (or use variable names, see examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>limits for y axis (or use variable names, see examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npts</code></td>
<td>
<p>number of points for plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>label for y axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>label for x axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlab</code></td>
<td>
<p>label for z axis (when in surface-plot mode)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filled</code></td>
<td>
<p>fill with color between the contours (<code>TRUE</code> by default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>levels at which to draw contours</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlevels</code></td>
<td>
<p>number of contours to draw (if <code>levels</code> not specified)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>if <code>FALSE</code>, don't label contours</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>surface</code></td>
<td>
<p>draw a surface plot rather than a contour plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>grouping argument ala lattice graphics</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>vector of colors for line graphs and contours</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.regions</code></td>
<td>
<p>a vector of colors or a function (<code>topo.colors</code> by default) for generating such</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of plot (<code>"l"</code> by default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>vector of line widths for line graphs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p>vector of line types for line graphs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>number from 0 (transparent) to 1 (opaque) for the fill colors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discontinuities</code></td>
<td>
<p>a vector of input values at which a function is
discontinuous or <code>NULL</code> to use
a heuristic to auto-detect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discontinuity</code></td>
<td>
<p>a positive number determining how sensitive the plot is to
potential discontinuity.  Larger values result in less sensitivity.  The default is 1.
Use <code>discontinuity = Inf</code> to disable discontinuity detection.  Discontinuity detection
uses a crude numerical heuristic and may not give the desired results in all cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interactive</code></td>
<td>
<p>a logical indicating whether the surface plot should be
interactive.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>makes plots of mathematical expressions using the formula syntax.  Will
draw both line plots and contour/surface plots (for functions of two variables).
In RStudio, the surface plot comes with sliders to set orientation.
If the colors in filled surface plots are too blocky, increase <code>npts</code>
beyond the default of 50, though <code>npts=300</code> is as much as you're likely to ever need.
See examples for overplotting a constraint function on an objective function.
</p>


<h3>Value</h3>

<p>a <code>trellis</code> object
</p>


<h3>Examples</h3>

<pre><code class="language-R">plotFun( a*sin(x^2)~x, xlim=range(-5,5), a=2 )  # setting parameter value
plotFun( u^2 ~ u, ulim=c(-4,4) )                # limits in terms of u
# Note roles of ylim and y.lim in this example
plotFun( y^2 ~ y, ylim=c(-2,20), y.lim=c(-4,4) )    
# Combining plot elements to show the solution to an inequality
plotFun( x^2 -3 ~ x, xlim=c(-4,4), grid=TRUE )
ladd( panel.abline(h=0,v=0,col='gray50') )
plotFun( (x^2 -3) * (x^2 &gt; 3) ~ x, type='h', alpha=.1, lwd=4, col='lightblue', add=TRUE )
plotFun( sin(x) ~ x, 
   groups=cut(x, findZeros(sin(x) ~ x, within=10)$x), 
   col=c('blue','green'), lty=2, lwd=3, xlim=c(-10,10) )
plotFun( sin(x) ~ x, 
   groups=cut(x, findZeros(sin(x) ~ x, within=10)$x), 
   col=c(1,2), lty=2, lwd=3, xlim=c(-10,10) )
## plotFun( sin(2*pi*x/P)*exp(-k*t)~x+t, k=2, P=.3)
f &lt;- rfun( ~ u &amp; v )
plotFun( f(u=u,v=v) ~ u &amp; v, u.lim=range(-3,3), v.lim=range(-3,3) )
plotFun( u^2 + v &lt; 3 ~ u &amp; v, add=TRUE, npts=200 )
if (require(mosaicData)) {
# display a linear model using a formula interface
model &lt;- lm(wage ~ poly(exper,degree=2), data=CPS85)
fit &lt;- makeFun(model)
xyplot(wage ~ exper, data=CPS85)
plotFun(fit(exper) ~ exper, add=TRUE, lwd=3, col="red")
# Can also just give fit since it is a "function of one variable"
plotFun(fit, add=TRUE, lwd=2, col='white')
}
# Attempts to find sensible axis limits by default
plotFun( sin(k*x)~x, k=0.01 )
# Plotting a linear model with multiple predictors.
mod &lt;- lm(length ~ width * sex, data=KidsFeet)
fitted.length &lt;- makeFun(mod)
xyplot(length ~ width, groups=sex, data=KidsFeet, auto.key=TRUE)
plotFun(fitted.length(width, sex="B") ~ width, add=TRUE, col=1)
plotFun(fitted.length(width, sex="G") ~ width, add=TRUE, col=2)
</code></pre>


</div>