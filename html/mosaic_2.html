<div class="container">

<table style="width: 100%;"><tr>
<td>do</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Do Things Repeatedly</h2>

<h3>Description</h3>

<p><code>do()</code> provides a natural syntax for repetition tuned to assist
with replication and resampling methods.
</p>


<h3>Usage</h3>

<pre><code class="language-R">do(object, ...)

## S3 method for class 'numeric'
do(object, ...)

## Default S3 method:
do(object, ...)

Do(n = 1L, cull = NULL, mode = "default", algorithm = 1, parallel = TRUE)

## S3 method for class 'repeater'
print(x, ...)

## S4 method for signature 'repeater,ANY'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of times to repeat</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cull</code></td>
<td>
<p>function for culling output of objects being repeated.  If NULL,
a default culling function is used.  The default culling function is
currently aware of objects of types
<code>lme</code>,
<code>lm</code>,
<code>htest</code>,
<code>table</code>,
<code>cointoss</code>, and
<code>matrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>target mode for value returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>a number used to select the algorithm used.  Currently numbers below 1
use an older algorithm and numbers &gt;=1 use a newer algorithm which is faster in some
situations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>a logical indicating whether parallel computation should be attempted
using the <span class="pkg">parallel</span> package (if it is installed and loaded).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object created by <code>do</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e1</code></td>
<td>
<p>an object (in cases documented here, the result of running <code>do</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e2</code></td>
<td>
<p>an object (in cases documented here, an expression to be repeated)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>do</code> returns an object of class <code>repeater</code> which is only useful in
the context of the operator <code>*</code>.  See the examples.
</p>


<h3>Naming</h3>

<p>The names used in the object returned from <code>do()</code> are inferred from the
objects created in each replication.  Roughly, this the strategy employed.
</p>

<ul>
<li>
<p> If the objects have names, those names are inherited, if possible.
</p>
</li>
<li>
<p> If the objects do not have names, but <code>do()</code> is used with a simple
function call, the name of that function is used.
Example: <code>do(3) * mean(~height, data = Galton)</code> produces a data frame with
a variable named <code>mean</code>.
</p>
</li>
<li>
<p> In cases where names are not easily inferred and a single result is produced,
it is named <code>result</code>.
</p>
</li>
</ul>
<p>To get different names, one can rename the objects as they are created, or
rename the result returned from <code>do()</code>.  Example of the former:
<code>do(3) * c(mean_height = mean(~height, data = resample(Galton)))</code>.
</p>


<h3>Note</h3>

<p><code>do</code> is a thin wrapper around <code>Do</code> to avoid collision with
<code>dplyr::do()</code> from the <span class="pkg">dplyr</span> package.
</p>


<h3>Author(s)</h3>

<p>Daniel Kaplan (<a href="mailto:kaplan@macalaster.edu">kaplan@macalaster.edu</a>)
and Randall Pruim (<a href="mailto:rpruim@calvin.edu">rpruim@calvin.edu</a>)
</p>


<h3>See Also</h3>

<p><code>replicate()</code>, <code>set.rseed()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">do(3) * rnorm(1)
do(3) * "hello"
do(3) * 1:4
do(3) * mean(rnorm(25))
do(3) * lm(shuffle(height) ~ sex + mother, Galton)
do(3) * anova(lm(shuffle(height) ~ sex + mother, Galton))
do(3) * c(sample.mean = mean(rnorm(25)))
# change the names on the fly
do(3) * mean(~height, data = resample(Galton))
do(3) * c(mean_height = mean(~height, data = resample(Galton)))
set.rseed(1234)
do(3) * tally( ~sex|treat, data=resample(HELPrct))
set.rseed(1234)  # re-using seed gives same results again
do(3) * tally( ~sex|treat, data=resample(HELPrct))
</code></pre>


</div>