<div class="container">

<table style="width: 100%;"><tr>
<td>rlatlon</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sample longitude and latitude on a sphere</h2>

<h3>Description</h3>

<p>Randomly samples longitude and latitude on earth so that equal areas are
(approximately) equally likely to be sampled.
(Approximation assumes earth as a perfect sphere.)
</p>


<h3>Usage</h3>

<pre><code class="language-R">rlatlon(...)

rlonlat(...)

rgeo(n = 1, latlim = c(-90, 90), lonlim = c(-180, 180), verbose = FALSE)

rgeo2(n = 1, latlim = c(-90, 90), lonlim = c(-180, 180), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed through to other functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of random locations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>latlim, lonlim</code></td>
<td>
<p>range of latitudes and longitudes to sample within, only implemented for <code>rgeo</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>return verbose output that includes Euclidean coordinates on unit sphere as well as
longitude and latitude.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>rgeo</code> and <code>rgeo2</code> differ in the algorithms used to generate random positions.
Each assumes a spherical globe.  <code>rgeo</code> uses that fact that each of the x, y and z
coordinates is uniformly distributed (but not independent of each other).  Furthermore, the
angle about the z-axis is uniformly distributed and independent of z.  This provides
a straightforward way to generate Euclidean coordinates using <code>runif</code>.  These are then
translated into latitude and longitude.
</p>
<p><code>rlatlon</code> is an alias for <code>rgeo</code> and
<code>rlonlat</code> is too, expect that it reverses the
order in which the latitude and longitude values are
returned.
</p>
<p><code>rgeo2</code> samples points in a cube by independently sampling each coordinate.  It then
discards any point outside the sphere contained in the cube and projects the non-discarded points
to the sphere.  This method must oversample to allow for the discarded points.
</p>


<h3>Value</h3>

<p>a data frame with variables <code>long</code> and <code>lat</code>.  If <code>verbose</code> is
TRUE, then x, y, and z coordinates are also included in the data frame.
</p>


<h3>See Also</h3>

<p><code>deg2rad()</code>, <code>googleMap()</code> and <code>latlon2xyz()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">rgeo(4)
# sample from a region that contains the continental US
rgeo(4, latlim = c(25,50), lonlim = c(-65, -125))
rgeo2(4)
</code></pre>


</div>