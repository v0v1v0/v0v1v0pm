<div class="container">

<table style="width: 100%;"><tr>
<td>findZeros</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find zeros of functions</h2>

<h3>Description</h3>

<p>Compute numerically zeros of a function or simultaneous zeros of multiple functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">findZeros(
  expr,
  ...,
  xlim = c(near - within, near + within),
  near = 0,
  within = Inf,
  nearest = 10,
  npts = 1000,
  iterate = 1,
  sortBy = c("byx", "byy", "radial")
)

## S3 method for class 'formula'
solve(
  form,
  ...,
  near = 0,
  within = Inf,
  nearest = 10,
  npts = 1000,
  iterate = 1,
  sortBy = c("byx", "byy", "radial")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>A formula.  The right side names the variable with respect to which the zeros should be found.
The left side is an expression, e.g. <code>sin(x) ~ x</code>.
All free variables (all but the variable on the right side) named in the expression must be assigned
a value via <code style="white-space: pre;">⁠\ldots⁠</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Formulas corresponding to additional functions to use in simultaneous zero finding
and/or specific numerical values for the free variables in the expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>The range of the dependent variable to search for zeros. <code>Inf</code> is a legitimate value,
but is interpreted in the numerical sense as the non-Inf largest floating point number.  This can also
be specified replacing <code>x</code> with the name of the variable.  See the examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>near</code></td>
<td>
<p>a value near which zeros are desired</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>within</code></td>
<td>
<p>only look for zeros at least this close to near.  <code>near</code> and <code>within</code> provide an
alternative to using <code>xlim</code> to specify the search space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nearest</code></td>
<td>
<p>the number of nearest zeros to return.  Fewer are returned if fewer are found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npts</code></td>
<td>
<p>How many sub-intervals to divide the <code>xlim</code> into when looking for candidates for zeros.
The default is usually good enough.
If <code>Inf</code> is involved, the intervals are logarithmically spaced up to the largest finite floating point number.
There is no guarantee that all the roots will be found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterate</code></td>
<td>
<p>maximum number of times to iterate the search. Subsequent searches take place with the range
of previously found zeros.  Choosing a large number here is likely to kill performance without
improving results, but a value of 1 (the default) or 2 works well when searching in <code>c(-Inf,Inf)</code> for
a modest number of zeros near <code>near</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortBy</code></td>
<td>
<p>specifies how the zeros found will be sorted. Options are 'byx', 'byy', or 'radial'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>form</code></td>
<td>
<p>Expression to be solved</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Searches numerically using <code>uniroot</code>.
</p>
<p>Uses findZerosMult of findZeros to solve the given expression
</p>


<h3>Value</h3>

<p>A dataframe of zero or more numerical values.  Plugging these into the
expression on the left side of the formula should result in values near zero.
</p>
<p>a dataframe with solutions to the expression.
</p>


<h3>Author(s)</h3>

<p>Daniel Kaplan (<a href="mailto:kaplan@macalester.edu">kaplan@macalester.edu</a>)
</p>
<p>Cecylia Bocovich
</p>


<h3>Examples</h3>

<pre><code class="language-R">findZeros( sin(t) ~ t, xlim=c(-10,10) )
# Can use tlim or t.lim instead of xlim if we prefer
findZeros( sin(t) ~ t, tlim=c(-10,10) )
findZeros( sin(theta) ~ theta, near=0, nearest=20)
findZeros( A*sin(2*pi*t/P) ~ t, xlim=c(0,100), P=50, A=2)
# Interval of a normal at half its maximum height.
findZeros( dnorm(x,mean=0,sd=10) - 0.5*dnorm(0,mean=0,sd=10) ~ x )
# A pathological example
# There are no "neareset" zeros for this function.  Each iteration finds new zeros.
f &lt;- function(x) { if (x==0) 0 else sin(1/x) }
findZeros( f(x) ~ x, near=0 )
# Better to look nearer to 0
findZeros( f(x) ~ x, near=0, within=100 )
findZeros( f(x) ~ x, near=0, within=100, iterate=0 )
findZeros( f(x) ~ x, near=0, within=100, iterate=3 )
# Zeros in multiple dimensions (not run: these take a long time)
# findZeros(x^2+y^2+z^2-5~x&amp;y&amp;z, nearest=3000, within = 5)
# findZeros(x*y+z^2~z&amp;y&amp;z, z+y~x&amp;y&amp;z, npts=10)
solve(3*x==3~x)

# plot out sphere (not run)
# sphere = solve(x^2+y^2+z^2==5~x&amp;y&amp;z, within=5, nearest=1000)
# cloud(z~x+y, data=sphere)
</code></pre>


</div>