<div class="container">

<table style="width: 100%;"><tr>
<td>lsp_compare</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Comparison between spatial patterns</h2>

<h3>Description</h3>

<p>Compares two spatial datasets containing categorical raster data.
It accepts a categorical raster dataset with one or more attributes, and compares it to the second dataset with the same attributes and dimensions.
The both dataset are either compared to as whole areas, areas divided into regular windows, or areas divided into irregular windows.
This function allows for several types of comparisons using different representations of spatial patterns, including "coma" (co-occurrence matrix), "cove" (co-occurrence vector), "cocoma" (co-located co-occurrence matrix), "cocove" (co-located co-occurrence vector), "wecoma" (weighted co-occurrence matrix), "wecove" (weighted co-occurrence vector), "incoma" (integrated co-occurrence matrix), "incove" (integrated co-occurrence vector). These representations are created for both datasets, and next a distance between them is calculated using a selected measure from the <code>philentropy::distance</code> function.
Additional parameters, such as neighbourhood or normalization types, are also available.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lsp_compare(
  x,
  y,
  type,
  dist_fun,
  window = NULL,
  output = "stars",
  neighbourhood = 4,
  threshold = 0.5,
  ordered = FALSE,
  repeated = FALSE,
  normalization = "pdf",
  wecoma_fun = "mean",
  wecoma_na_action = "replace",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>. It should have one attribute (for <code>"coma"</code>, <code>"cove"</code>), two attributes (<code>"cocoma"</code>, <code>"cocove"</code>, <code>"wecoma"</code>, <code>"wecove"</code>), two or more attributes (<code>"incoma"</code>, <code>"incove"</code>), or any number of attributes suitable for user-defined functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>. It should have one attribute (for <code>"coma"</code>, <code>"cove"</code>), two attributes (<code>"cocoma"</code>, <code>"cocove"</code>, <code>"wecoma"</code>, <code>"wecove"</code>), two or more attributes (<code>"incoma"</code>, <code>"incove"</code>), or any number of attributes suitable for user-defined functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of the calculated signature. It can be <code>"coma"</code> (co-occurrence matrix), <code>"cove"</code> (co-occurrence vector), <code>"cocoma"</code> (co-located co-occurrence matrix), <code>"cocove"</code> (co-located co-occurrence vector), <code>"wecoma"</code> (weighted co-occurrence matrix), <code>"wecove"</code> (weighted co-occurrence vector), <code>"incoma"</code> (integrated co-occurrence matrix), <code>"incove"</code> (integrated co-occurrence vector), <code>"composition"</code> or any function that can summarize <code>stars</code> objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist_fun</code></td>
<td>
<p>Distance measure used. This function uses the <code>philentropy::distance</code> function in the background. Run <code>philentropy::getDistMethods()</code> to find possible distance measures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code>, a numeric value, or an <code>sf</code> object. If <code>window=NULL</code> calculations are performed for a whole area. If the <code>window</code> argument is numeric, it is a length of the side of a square-shaped block of cells. Expressed in the numbers of cells, it defines the extent of a local pattern. If an <code>sf</code> object is provided, each feature (row) defines the extent of a local pattern. The <code>sf</code> object should have one attribute (otherwise, the first attribute is used as an id).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>The class of the output. Either <code>"stars"</code>, <code>"sf"</code>, or <code>"terra"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>The share of NA cells to allow metrics calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>For <code>"cove"</code>, <code>"cocove"</code>, <code>"wecove"</code> and <code>"incove"</code> only. The type of pairs considered.
Either "ordered" (TRUE) or "unordered" (FALSE).
The default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeated</code></td>
<td>
<p>For <code>"incove"</code> only. Should the repeated co-located co-occurrence matrices be used?
Either "ordered" (TRUE) or "unordered" (FALSE).
The default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalization</code></td>
<td>
<p>For <code>"cove"</code>, <code>"cocove"</code>, <code>"wecove"</code>, <code>"incove"</code>, <code>"composition"</code>, or user-provided functions only.
Should the output vector be normalized?
Either "none" or "pdf".
The "pdf" option normalizes a vector to sum to one.
The default is "pdf".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wecoma_fun</code></td>
<td>
<p>For <code>"wecoma"</code> and <code>"wecove"</code> only. Function to calculate values from adjacent cells to contribute to exposure matrix, <code>"mean"</code> - calculate average values of local population densities from adjacent cells, <code>"geometric_mean"</code> - calculate geometric mean values of local population densities from adjacent cells, or <code>"focal"</code> assign a value from the focal cell</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wecoma_na_action</code></td>
<td>
<p>For <code>"wecoma"</code> and <code>"wecove"</code> only. Decides on how to behave in the presence of missing values in <code>w</code>. Possible options are <code>"replace"</code>, <code>"omit"</code>, <code>"keep"</code>. The default, <code>"replace"</code>, replaces missing values with 0, <code>"omit"</code> does not use cells with missing values, and <code>"keep"</code> keeps missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for the <code>philentropy::distance</code> function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Object of class <code>stars</code> (or <code>sf</code> or terra's <code>SpatRaster</code>, depending on the <code>output</code> argument).
It has four attributes:
(1) <code>id</code> - an id of each window.
For irregular windows, it is the values provided in the <code>window</code> argument,
(2) <code>na_prop_x</code> - share (0-1) of <code>NA</code> cells for each window in the <code>x</code> object,
(3) <code>na_prop_y</code> - share (0-1) of <code>NA</code> cells for each window in the <code>y</code> object,
(4) <code>dist</code>- calculated distance between signatures for each window
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(stars)

lc15 = read_stars(system.file("raster/landcover2015s.tif", package = "motif"))
lc01 = read_stars(system.file("raster/landcover2001s.tif", package = "motif"))
ecoregions = read_sf(system.file("vector/ecoregionss.gpkg", package = "motif"))

ecoregions = st_transform(ecoregions, st_crs(lc15))

c1 = lsp_compare(lc01, lc15, type = "cove",
    dist_fun = "jensen-shannon", window = ecoregions["id"])
plot(c1["dist"])


# larger data example
library(stars)

lc15 = read_stars(system.file("raster/landcover2015.tif", package = "motif"))
lc01 = read_stars(system.file("raster/landcover2001.tif", package = "motif"))
ecoregions = read_sf(system.file("vector/ecoregions.gpkg", package = "motif"))

ecoregions = st_transform(ecoregions, st_crs(lc15))

c1 = lsp_compare(lc01, lc15, type = "cove",
    dist_fun = "jensen-shannon", window = ecoregions["id"])
plot(c1["dist"])

</code></pre>


</div>