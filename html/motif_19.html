<div class="container">

<table style="width: 100%;"><tr>
<td>lsp_search</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Search for similar spatial pattern</h2>

<h3>Description</h3>

<p>Searches for areas with similar spatial patterns in categorical data.
It accepts a categorical raster dataset with one or more attributes, and compares it to the second (usually larger) dataset with the same attributes.
The first dataset is either compared to a whole area, areas divided into regular windows, or areas divided into irregular windows from the second dataset.
This function allows for several types of comparisons using different representations of spatial patterns, including "coma" (co-occurrence matrix), "cove" (co-occurrence vector), "cocoma" (co-located co-occurrence matrix), "cocove" (co-located co-occurrence vector), "wecoma" (weighted co-occurrence matrix), "wecove" (weighted co-occurrence vector), "incoma" (integrated co-occurrence matrix), "incove" (integrated co-occurrence vector). These representations are created for both datasets, and next a distance between them is calculated using a selected measure from the <code>philentropy::distance</code> function.
Additional parameters, such as neighbourhood or normalization types, are also available.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lsp_search(
  x,
  y,
  type,
  dist_fun,
  window = NULL,
  output = "stars",
  neighbourhood = 4,
  threshold = 0.5,
  ordered = FALSE,
  repeated = FALSE,
  normalization = "pdf",
  wecoma_fun = "mean",
  wecoma_na_action = "replace",
  classes = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>. It should have one attribute (for <code>"coma"</code>, <code>"cove"</code>), two attributes (<code>"cocoma"</code>, <code>"cocove"</code>, <code>"wecoma"</code>, <code>"wecove"</code>), two or more attributes (<code>"incoma"</code>, <code>"incove"</code>), or any number of attributes suitable for user-defined functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Object of class <code>stars</code>, <code>stars_proxy</code>, or terra's <code>SpatRaster</code>. It should have one attribute (for <code>"coma"</code>, <code>"cove"</code>), two attributes (<code>"cocoma"</code>, <code>"cocove"</code>, <code>"wecoma"</code>, <code>"wecove"</code>), two or more attributes (<code>"incoma"</code>, <code>"incove"</code>), or any number of attributes suitable for user-defined functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of the calculated signature. It can be <code>"coma"</code> (co-occurrence matrix), <code>"cove"</code> (co-occurrence vector), <code>"cocoma"</code> (co-located co-occurrence matrix), <code>"cocove"</code> (co-located co-occurrence vector), <code>"wecoma"</code> (weighted co-occurrence matrix), <code>"wecove"</code> (weighted co-occurrence vector), <code>"incoma"</code> (integrated co-occurrence matrix), <code>"incove"</code> (integrated co-occurrence vector), <code>"composition"</code> or any function that can summarize <code>stars</code> objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist_fun</code></td>
<td>
<p>Distance measure used. This function uses the <code>philentropy::distance</code> function in the background. Run <code>philentropy::getDistMethods()</code> to find possible distance measures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>Specifies areas for analysis. It can be either: <code>NULL</code>, a numeric value, or an <code>sf</code> object. If <code>window=NULL</code> calculations are performed for a whole area. If the <code>window</code> argument is numeric, it is a length of the side of a square-shaped block of cells. Expressed in the numbers of cells, it defines the extent of a local pattern. If an <code>sf</code> object is provided, each feature (row) defines the extent of a local pattern. The <code>sf</code> object should have one attribute (otherwise, the first attribute is used as an id).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>The class of the output. Either <code>"stars"</code>, <code>"sf"</code>, or <code>"terra"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>The share of NA cells to allow metrics calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>For <code>"cove"</code>, <code>"cocove"</code>, <code>"wecove"</code> and <code>"incove"</code> only. The type of pairs considered.
Either "ordered" (TRUE) or "unordered" (FALSE).
The default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeated</code></td>
<td>
<p>For <code>"incove"</code> only. Should the repeated co-located co-occurrence matrices be used?
Either "ordered" (TRUE) or "unordered" (FALSE).
The default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalization</code></td>
<td>
<p>For <code>"cove"</code>, <code>"cocove"</code>, <code>"wecove"</code>, <code>"incove"</code>, <code>"composition"</code>, or user-provided functions only.
Should the output vector be normalized?
Either "none" or "pdf".
The "pdf" option normalizes a vector to sum to one.
The default is "pdf".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wecoma_fun</code></td>
<td>
<p>For <code>"wecoma"</code> and <code>"wecove"</code> only. Function to calculate values from adjacent cells to contribute to exposure matrix, <code>"mean"</code> - calculate average values of local population densities from adjacent cells, <code>"geometric_mean"</code> - calculate geometric mean values of local population densities from adjacent cells, or <code>"focal"</code> assign a value from the focal cell</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wecoma_na_action</code></td>
<td>
<p>For <code>"wecoma"</code> and <code>"wecove"</code> only. Decides on how to behave in the presence of missing values in <code>w</code>. Possible options are <code>"replace"</code>, <code>"omit"</code>, <code>"keep"</code>. The default, <code>"replace"</code>, replaces missing values with 0, <code>"omit"</code> does not use cells with missing values, and <code>"keep"</code> keeps missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>
<p>Which classes (categories) should be analyzed? This parameter expects a list of the same length as the number of attributes in <code>x</code>, where each element of the list contains integer vector. The default is <code>NULL</code>, which means that the classes are calculated directly from the input data and all of them are used in the calculations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for the <code>philentropy::distance</code> function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Object of class <code>stars</code> (or <code>sf</code> or terra's <code>SpatRaster</code>, depending on the <code>output</code> argument).
It has three attributes:
(1) <code>id</code> - an id of each window.
For irregular windows, it is the values provided in the <code>window</code> argument,
(2) <code>na_prop</code> - share (0-1) of <code>NA</code> cells for each window in the <code>y</code> object,
(3) <code>dist</code>- calculated distance between the <code>x</code> object and each window in the <code>y</code> object
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(stars)

landcover = read_stars(system.file("raster/landcover2015s.tif", package = "motif"))
plot(landcover)

ext = st_bbox(c(xmin = -249797.344531127, xmax = -211162.693944285,
                ymin = -597280.143035389, ymax = -558645.492448547),
                crs = st_crs(landcover))

landcover_ext = landcover[ext]
plot(landcover_ext)

ecoregions = read_sf(system.file("vector/ecoregionss.gpkg", package = "motif"))
plot(ecoregions["id"])

s1 = lsp_search(landcover_ext, landcover, type = "cove",
  dist_fun = "jensen-shannon", threshold = 0.9, window = 100)
plot(s1["dist"])

ecoregions = st_transform(ecoregions, st_crs(landcover))
s2 = lsp_search(landcover_ext, landcover, type = "cove",
  dist_fun = "jensen-shannon", threshold = 0.5, window = ecoregions["id"])
plot(s2["dist"])


# larger data example
library(stars)

landcover = read_stars(system.file("raster/landcover2015.tif", package = "motif"))
plot(landcover)

ext = st_bbox(c(xmin = -249797.344531127, xmax = -211162.693944285,
                ymin = -597280.143035389, ymax = -558645.492448547),
                crs = st_crs(landcover))

landcover_ext = landcover[ext]
plot(landcover_ext)

ecoregions = read_sf(system.file("vector/ecoregions.gpkg", package = "motif"))
plot(ecoregions["id"])

s1 = lsp_search(landcover_ext, landcover, type = "cove",
  dist_fun = "jensen-shannon", threshold = 0.9, window = 1000)
plot(s1["dist"])

ecoregions = st_transform(ecoregions, st_crs(landcover))
s2 = lsp_search(landcover_ext, landcover, type = "cove",
  dist_fun = "jensen-shannon", threshold = 0.5, window = ecoregions["id"])
plot(s2["dist"])

</code></pre>


</div>