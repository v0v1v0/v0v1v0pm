<div class="container">

<table style="width: 100%;"><tr>
<td>FLXMCvMF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Flexmix Driver for Mixtures of von Mises-Fisher Distributions</h2>

<h3>Description</h3>

<p>This driver for <code>flexmix</code> implements
estimation of mixtures of von Mises-Fisher distributions where the
data can be stored in a dense or a simple triplet
matrix (package <span class="pkg">slam</span>) format.
</p>


<h3>Usage</h3>

<pre><code class="language-R">FLXMCvMF(formula = . ~ ., kappa = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula which is interpreted relative to the formula
specified in the call to <code>flexmix</code> using
<code>update.formula</code>. Only the
left-hand side (response) of the formula is used. Default is to use
the original <code>flexmix</code> model
formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>see the <code>control</code> argument of <code>movMF</code></p>
</td>
</tr>
</table>
<p>.
</p>


<h3>Value</h3>

<p>An object of class <code>"FLXMCvMF"</code>.
</p>


<h3>Author(s)</h3>

<p>Bettina Gr√ºn
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (requireNamespace("flexmix", quietly = TRUE)) {
## Generate and fit a "small-mix" data set a la Banerjee et al.
mu &lt;- rbind(c(-0.251, -0.968),
            c(0.399, 0.917))
kappa &lt;- c(4, 4)
theta &lt;- kappa * mu
theta
alpha &lt;- c(0.48, 0.52)
## Generate a sample of size n = 50 from the von Mises-Fisher mixture
## with the above parameters.
set.seed(123)
x &lt;- rmovMF(50, theta, alpha)
## Fit a von Mises-Fisher mixture with the "right" number of components,
## using 10 EM runs.
set.seed(123)
y2 &lt;- flexmix::stepFlexmix(x ~ 1, k = 2, model = FLXMCvMF(), verbose = FALSE)
## Inspect the fitted parameters:
y2
## Compare the fitted classes to the true ones:
table(True = attr(x, "z"), Fitted = flexmix::clusters(y2))
## To use a common kappa:
y2cv &lt;- flexmix::stepFlexmix(x ~ 1, k = 2,
  model = FLXMCvMF(kappa = list(common = TRUE)), verbose = FALSE)
## To use a common kappa fixed to the true value of 4:
y2cf &lt;- flexmix::stepFlexmix(x ~ 1, k = 2,
  model = FLXMCvMF(kappa = 4), verbose = FALSE)
## Comparing solutions via BIC:
sapply(list(y2, y2cf, y2cv), BIC)
##  Use a different kappa solver:
set.seed(123)
y2a &lt;- flexmix::stepFlexmix(x ~ 1, k = 2,
  model = FLXMCvMF(kappa = "uniroot"), verbose = FALSE)
y2a
## Using a sparse matrix:
x &lt;- slam::as.simple_triplet_matrix(x)
y2 &lt;- flexmix::stepFlexmix(x ~ 1, k = 2,
  model = FLXMCvMF(), verbose = FALSE)
}
</code></pre>


</div>