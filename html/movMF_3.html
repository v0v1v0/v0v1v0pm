<div class="container">

<table style="width: 100%;"><tr>
<td>movMF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit Mixtures of von Mises-Fisher Distributions</h2>

<h3>Description</h3>

<p>Fit mixtures of von Mises-Fisher distributions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">movMF(x, k, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric data matrix, with rows corresponding to
observations.  Standardized to unit row lengths if necessary.
Can be a dense matrix, a
simple triplet matrix
(package <span class="pkg">slam</span>), or a
dgTMatrix
(package <span class="pkg">Matrix</span>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>an integer giving the desired number of mixture components
(classes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control parameters.  See <b>Details</b>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>a list of control parameters (overriding those specified
in <code>control</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>movMF</code> returns an object of class <code>"movMF"</code> representing
the fitted mixture of von Mises-Fisher distributions model.  Available
methods for such objects include <code>coef</code>,
<code>logLik</code>, <code>print</code> and <code>predict</code>.
<code>predict</code> has an extra <code>type</code> argument with possible
values <code>"class_ids"</code> (default) and <code>"memberships"</code> for
indicating hard or soft prediction, respectively.
</p>
<p>The mixture of von Mises-Fisher distributions is fitted using EM
variants as specified by control option <code>E</code> (specifying the
E-step employed), with possible values <code>"softmax"</code> (default),
<code>"hardmax"</code> or <code>"stochmax"</code> where the first two implement
algorithms soft-moVMF and hard-moVMF of Banerjee et al (2005).  For
<code>"stochmax"</code>, class assignments are drawn from the posteriors for
each observation in the E-step as outlined as SEM in Celeux and
Govaert (1992). The stopping criterion for this algorithm is by
default changed to not check for convergence (logical control option
<code>converge</code>), but to return the parameters with the maximum
likelihood encountered. <code>E</code> may be abbreviated.
</p>
<p>In the M-step, the parameters <code class="reqn">\theta</code> of the respective component
distributions are estimated via maximum likelihood, which is
accomplished by taking <code class="reqn">\theta</code> proportional to suitable weighted
sample means <code class="reqn">\bar{x}</code>, with length <code class="reqn">\kappa</code> solving the
equation <code class="reqn">A_d(\kappa) = \|\bar{x}\|</code>, where
<code class="reqn">A_d(\kappa) = I_{d/2}(\kappa) / I_{d/2-1}(\kappa)</code> with <code class="reqn">I</code>
the modified Bessel function of the first kind.  Via control argument
<code>kappa</code>, one can specify how to (approximately) solve these
equations, and whether a common (possibly given) length <code class="reqn">\kappa</code>
should be employed.  If <code>kappa</code> is a number, it gives a common
length to be employed.  If it is a character string, it specifies the
method to be used for solving the <code class="reqn">\kappa</code> equation. The possible
methods are:
</p>

<dl>
<dt><code>"Banerjee_et_al_2005"</code></dt>
<dd>
<p>uses the approximation of
Banerjee et al (2005).</p>
</dd>
<dt><code>"Tanabe_et_al_2007"</code></dt>
<dd>
<p>uses the fixed-point iteration of
Tanabe et al (2007) with starting point for <code class="reqn">\kappa</code> in the
interval established by Tanabe et al (2007) implied by a given
<code>c</code> with values in [0, 2]. The default is <code>c</code> = 1, the
mid-point of the interval.</p>
</dd>
<dt><code>"Sra_2012"</code></dt>
<dd>
<p>uses two Newton steps as suggested in
Sra (2012) starting in the approximation of Banerjee et al (2005).</p>
</dd>
<dt><code>"Song_et_al_2012"</code></dt>
<dd>
<p>uses two Halley steps as
suggested in Song et al (2012) starting in the approximation of
Banerjee et al (2005).</p>
</dd>
<dt><code>"uniroot"</code></dt>
<dd>
<p>uses a straightforward call to
<code>uniroot</code> with the bounds established in Hornik and
Grün (2014).</p>
</dd>
<dt><code>"Newton"</code></dt>
<dd>
<p>uses a full Newton algorithm started in the
approximation of Hornik and Grün (2014).</p>
</dd>
<dt><code>"Halley"</code></dt>
<dd>
<p>uses a full Halley algorithm started in the
approximation of Hornik and Grün (2014).</p>
</dd>
<dt><code>"hybrid"</code></dt>
<dd>
<p>implements a combination of a
derivative-based step (Newton or Halley) and a bisection step as
outlined in Press et al. (2002). The derivative-based step can be
specified via the argument <code>step</code> which expects a function
performing this step. Currently <code>step_Newton</code> and
<code>step_Halley</code> (default) are available.</p>
</dd>
<dt>
<code>"Newton_Fourier"</code> (default)</dt>
<dd>
<p>uses a variant of the
Newton-Fourier method for strictly increasing concave functions as
for example given in Atkinson (1989, pp. 62–64). Concavity can
be established using Hornik and Grün (2013).</p>
</dd>
</dl>
<p>The lower-cased version of the given <code>kappa</code> specification is
matched against the lower-cased names of the available methods using
<code>pmatch</code>.  Finally, to indicate using a common (but not
given) <code class="reqn">\kappa</code> for all component distributions, <code>kappa</code>
should be a list with element <code>common = TRUE</code> (and optionally a
character string giving the estimation method).
</p>
<p>Additional control parameters are as follows.
</p>

<dl>
<dt><code>maxiter</code></dt>
<dd>
<p>an integer giving the maximal number of EM
iterations to be performed.  Default: 100.
</p>
</dd>
<dt><code>reltol</code></dt>
<dd>
<p>the minimum relative improvement of the
objective function per iteration. If improvement is less, the EM
algorithm will stop under the assumption that no further
significant improvement can be made.  Defaults to
<code>sqrt(.Machine$double.eps)</code>.
</p>
</dd>
<dt><code>ids</code></dt>
<dd>
<p>either a vector of class memberships or
<code>TRUE</code> which implies that the class memberships are obtained
from the attribute named <code>"z"</code> of the input data; these class
memberships are used for initializing the EM algorithm and the
algorithm is stopped after the first iteration.</p>
</dd>
<dt><code>start</code></dt>
<dd>
<p>a specification of the starting values to be
employed.  Can be a list of matrices giving the memberships of
objects to components, or of vectors giving component ids
(numbers from 1 to the given <code>k</code>).  Can also be a character
vector with elements <code>"i"</code> (randomly pick component ids for
the observations), or one of <code>"p"</code>, <code>"S"</code> or <code>"s"</code>.
The latter first determine component “prototypes”, and then
determine an optimal “fuzzy” membership matrix from the
implied cosine dissimilarities between observations and
prototypes.  Prototypes are obtained as follows: for <code>"p"</code>,
observations are randomly picked.  For <code>"S"</code>, one takes the
first prototype to minimize total cosine dissimilarity to the
observations, and then successively picks observations farthest
away from the already picked prototypes.  For <code>"s"</code>, one
takes a randomly chosen observation as the first prototype, and
then proceeds as for <code>"S"</code>. 
</p>
<p>By default, initialization method <code>"p"</code> is used.
</p>
<p>If several starting values are specified, the EM algorithm is
performed individually to each starting value, and the best
solution found is returned.
</p>
</dd>
<dt><code>nruns</code></dt>
<dd>
<p>an integer giving the number of EM runs to be
performed.  Default: 1. 
Only used if <code>start</code> is not given.
</p>
</dd>
<dt><code>minalpha</code></dt>
<dd>
<p>a numeric indicating the minimum prior
probability.  Components falling below this threshold are removed
during the iteration.  If <code class="reqn">\ge 1</code>, this is taken as the
minimal number of observations in a component.
Default: 0.</p>
</dd>
<dt><code>converge</code></dt>
<dd>
<p>a logical, if <code>TRUE</code> the EM algorithm is
stopped if the <code>reltol</code> criterion is met and the current
parameter estimate is returned. If <code>FALSE</code> the EM algorithm
is run for <code>maxiter</code> iterations and the parametrizations
with the maximum likelihood encountered during the EM algorithm is
returned. Default: <code>TRUE</code>, changed to <code>FALSE</code> if
<code>E="stochmax"</code>.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>a logical indicating whether to provide
some output on algorithmic progress.
Defaults to <code>getOption("verbose")</code>.</p>
</dd>
</dl>
<p>One popular application context of mixtures of von Mises-Fisher
distributions is text mining, where the data matrices are typically
very large and sparse.  The provided implementation should be able to
handle such large corpora with reasonable efficiency by employing
suitable sparse matrix representations and computations.  In addition,
straightforward computations of the normalizing constants in the von
Mises-Fisher densities (see movMF_distribution) by
directly employing the modified Bessel functions of the first kind are
computationally infeasible for large <code class="reqn">d</code> (dimension of the
observations) and/or values of the parameter lengths <code class="reqn">\kappa</code>.
Instead, we use suitably scaled hypergeometric-type power series for
computing (the logarithms of) the normalizing constants.
</p>


<h3>Value</h3>

<p>An object of class <code>"movMF"</code> representing the fitted mixture of
von Mises-Fisher distributions, which is a list containing at least
the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>a matrix with rows giving the fitted parameters of the
mixture components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>a numeric vector with the fitted mixture probabilities.</p>
</td>
</tr>
</table>
<p>See vMF for the employed parametrization of the von
Mises-Fisher distribution.
</p>


<h3>References</h3>

<p>K. E. Atkinson (1989).
<em>An Introduction to Numerical Analysis.</em>
2nd edition. John Wiley &amp; Sons.
</p>
<p>A. Banerjee, I. S. Dhillon, J. Ghosh, and S. Sra (2005).
Clustering on the unit hypersphere using von Mises-Fisher
distributions.
<em>Journal of Machine Learning Research</em>, <b>6</b>, 1345–1382.
<a href="https://jmlr.csail.mit.edu/papers/v6/banerjee05a.html">https://jmlr.csail.mit.edu/papers/v6/banerjee05a.html</a>.
</p>
<p>G. Celeux, and G. Govaert (1992).
A classification EM algorithm for clustering and two stochastic
versions.
<em>Computational Statistics &amp; Data Analysis</em>, <b>14</b>, 315–332.
<a href="https://doi.org/10.1016/0167-9473%2892%2990042-E">doi:10.1016/0167-9473(92)90042-E</a>.
</p>
<p>K. Hornik, and B. Grün (2013).
Amos-type bounds for modified Bessel function ratios.
<em>Journal of Mathematical Analysis and Applications</em>,
<b>408</b>(1), 91–101.
<a href="https://doi.org/10.1016/j.jmaa.2013.05.070">doi:10.1016/j.jmaa.2013.05.070</a>.
</p>
<p>K. Hornik, and B. Grün (2014).
On maximum likelihood estimation of the concentration
parameter of von Mises-Fisher distributions.
<em>Computational Statistics</em>, <b>29</b>, 945–957.
<a href="https://doi.org/10.1007/s00180-013-0471-0">doi:10.1007/s00180-013-0471-0</a>.
</p>
<p>W. H. Press, S. A. Teukolsky, W. T. Vetterling and Brian P. Flannery
(2002).
<em>Numerical Recipes in C: The Art of Scientific Computing.</em>
2nd edition. Cambridge University Press.
</p>
<p>H. Song, J. Liu, and G. Wang.
High-order parameter approximation for von Mises-Fisher distributions.
<em>Applied Mathematics and Computation</em>, <b>218</b>, 11880–11890.
<a href="https://doi.org/10.1016/j.amc.2012.05.050">doi:10.1016/j.amc.2012.05.050</a>.
</p>
<p>S. Sra (2012).
A short note on parameter approximation for von Mises-Fisher
distributions: and a fast implementation of <code class="reqn">I_s(x)</code>.
<em>Computational Statistics</em>, <b>27</b>, 177–190.
<a href="https://doi.org/10.1007/s00180-011-0232-x">doi:10.1007/s00180-011-0232-x</a>.
</p>
<p>A. Tanabe, K. Fukumizu, S. Oba, T. Takenouchi, and S. Ishii.
Parameter estimation for von Mises-Fisher distributions.
<em>Computational Statistics</em>, <b>22</b>, 145–157.
<a href="https://doi.org/10.1007/s00180-007-0030-7">doi:10.1007/s00180-007-0030-7</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate and fit a "small-mix" data set a la Banerjee et al.
mu &lt;- rbind(c(-0.251, -0.968),
            c(0.399, 0.917))
kappa &lt;- c(4, 4)
theta &lt;- kappa * mu
theta
alpha &lt;- c(0.48, 0.52)
## Generate a sample of size n = 50 from the von Mises-Fisher mixture
## with the above parameters.
set.seed(123)
x &lt;- rmovMF(50, theta, alpha)
## Fit a von Mises-Fisher mixture with the "right" number of components,
## using 10 EM runs.
set.seed(123)
y2 &lt;- movMF(x, 2, nruns = 10)
## Inspect the fitted parameters:
y2
## Compare the fitted classes to the true ones:
table(True = attr(x, "z"), Fitted = predict(y2))
## To use a common kappa:
y2cv &lt;- movMF(x, 2, nruns = 10, kappa = list(common = TRUE))
## To use a common kappa fixed to the true value of 4:
y2cf &lt;- movMF(x, 2, nruns = 10, kappa = 4)
## Comparing solutions via BIC:
sapply(list(y2, y2cf, y2cv), BIC)
##  Use a different kappa solver:
set.seed(123)
y2a &lt;- movMF(x, 2, nruns = 10, kappa = "uniroot")
y2a
</code></pre>


</div>