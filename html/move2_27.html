<div class="container">

<table style="width: 100%;"><tr>
<td>mt_filter_unique</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter out duplicated records from a <code>move2</code> object</h2>

<h3>Description</h3>


<ul>
<li> <p><code>mt_filter_unique</code>: returns a <code>move2</code> from which duplicated records have been removed
</p>
</li>
<li> <p><code>mt_unique</code>: returns a logical vector indicating the unique records
By default columns that have a duplicated timestamps and track identifier are filtered
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">mt_filter_unique(x, ...)

mt_unique(
  x,
  criterion = c("subsets", "subsets_equal", "sample", "first", "last"),
  additional_columns = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The <code>move2</code> object to filter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed on to the <code>mt_unique</code> function like <code>criterion</code> and arguments to the equivalence function
when one of the <code>"subsets"</code> criteria is use, this allows for example controlling the <code>tolerance</code> (<code>base::all.equal()</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>The criterion to decide what records to filter out. For more information see <em>Details</em> below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>additional_columns</code></td>
<td>
<p>In some cases different sensors or tracking devices
might have the same combination of time and track identifier.
It might, for example, be desirable to retain records from an accelerometer
and gps recorded at the same time.
This argument can be used to indicate additional column to include in the grouping
within which the records should not be duplicated.
See the examples below for its usage.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To make an informed choice of how to remove duplicates, we recommend to first try to understand why the data set has duplicates.
</p>
<p>Several methods for filtering duplicates are available the options can be controlled through the <code>criterion</code>
argument:
</p>

<ul>
<li> <p><code>"subsets"</code>: Only records that are a subset of other records are omitted.
Some tracking devices first transmit an smaller dataset that does not contain all information, therefore some
records may be the same as others only containing additional <code>NA</code> values.
This strategy only omits those (duplicated) records. As a result duplicates that contain unique information are
retained, the dataset is thus not guaranteed to not have unique records afterwards.
</p>
</li>
<li> <p><code>"subsets_equal"</code>: The same as <code>"subsets"</code> however not exact equivalence is tested using <code>base::identical()</code> but
rather <code>base::all.equal()</code> is used. This makes it possible to allow for small numeric differences to be considered
equal. This can however reduce speed considerably.
</p>
</li>
<li> <p><code>"sample"</code>: In this case one record is randomly selected from the duplicated records.
</p>
</li>
<li> <p><code>"first"</code>: Select the first location from a set of duplicated locations. Note that reordering the data will affect
which record is selected. For movebank data no specific order is enforced, ensure that the order of the locations is like you expect (same goes for <code>"last"</code>).
</p>
</li>
<li> <p><code>"last"</code>: Select the last location from a set of duplicated locations.
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>mt_unique</code>returns a logical vector indicating the unique records.<br><code>mt_filter_unique</code> returns a filtered <code>move2</code> object
</p>


<h3>See Also</h3>

<p>Other filter: 
<code>mt_filter_movebank_visible()</code>,
<code>mt_filter_per_interval()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">m &lt;- mt_sim_brownian_motion(1:2)[rep(1:4, 4), ]
m$sensor_type &lt;- as.character(gl(2, 4))
m$sensor_type_2 &lt;- as.character(gl(2, 8))
table(mt_unique(m, "sample"))
mt_filter_unique(m[, c("time", "track", "geometry")])
mt_filter_unique(m[, c("time", "track", "geometry", "sensor_type")],
  additional_columns = sensor_type
)
if (requireNamespace("dplyr")) {
  mt_filter_unique(m, additional_columns = across(all_of(c("sensor_type", "sensor_type_2"))))
}
mt_filter_unique(m, "sample")
mt_filter_unique(m, "first")
m$sensor_type[1:12] &lt;- NA
mt_filter_unique(m[, c("time", "track", "geometry", "sensor_type")])


## Sometimes it is desirable to not consider specific columns for finding
## the unique records. For example the record identifier like `event_id`
## in movebank This can be done by reducing the data.frame used to identify
## the unique records e.g.:
m$event_id &lt;- seq_len(nrow(m))
m[mt_unique(m |&gt; dplyr::select(-event_id, -ends_with("type_2"))), ]
## Note that because we subset the full original data.frame the
## columns are not lost


## This example is to retain the duplicate entry which contains the least
## number of columns with NA values
mv &lt;- mt_read(mt_example())
mv &lt;- dplyr::bind_rows(mv, mv[1:10, ])
mv[, "eobs:used-time-to-get-fix"] &lt;- NA
mv_no_dup &lt;- mv |&gt;
  dplyr::mutate(n_na = rowSums(is.na(pick(everything())))) |&gt;
  dplyr::arrange(n_na) |&gt;
  mt_filter_unique(criterion = "first")

</code></pre>


</div>