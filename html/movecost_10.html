<div class="container">

<table style="width: 100%;"><tr>
<td>movecorr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R function for calculating least-cost corridor between point locations</h2>

<h3>Description</h3>

<p>The function provides the facility to calculate the least-cost corridor between point locations.
It just requires an input DTM and at least two point locations ('SpatialPointsDataFrame' class) representing the locations between which the corridor is calculated.
Under the hood, <code>movecorr()</code> relies on the <code>movecost</code> function and, needless to say, implements the same
cost functions. See the help documentation of 'movecost()' for further details.<br>
Visit this <a href="https://drive.google.com/file/d/1gLDrkZFh1b_glzCEqKdkPrer72JJ9Ffa/view?usp=sharing">LINK</a> to access the package's vignette.<br></p>


<h3>Usage</h3>

<pre><code class="language-R">movecorr(
  dtm = NULL,
  a,
  b,
  lab.a = "A",
  lab.b = "B",
  cex.labs = 0.8,
  studyplot = NULL,
  barrier = NULL,
  plot.barrier = FALSE,
  irregular.dtm = FALSE,
  funct = "t",
  time = "h",
  move = 16,
  field = 0,
  cogn.slp = FALSE,
  sl.crit = 10,
  W = 70,
  L = 0,
  N = 1,
  V = 1.2,
  z = 9,
  rescale = FALSE,
  transp = 0.5,
  graph.out = TRUE,
  export = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dtm</code></td>
<td>
<p>Digital Terrain Model (RasterLayer class); if not provided, elevation data will be acquired online for the area enclosed by the 'studyplot' parameter (see <code>movecost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>first location from which the least-cost corridor is calculated (SpatialPointsDataFrame class); if it contains more than two locations, see the 'Description' section above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>second location from which the least-cost corridor is calculated (SpatialPointsDataFrame class); if parameter 'a' stores more than two locations, this parameter is disregarded; see the 'Description' section above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lab.a</code></td>
<td>
<p>string to be used to label point a on the outplut plot (A is the default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lab.b</code></td>
<td>
<p>string to be used to label point a on the outplut plot (B is the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.labs</code></td>
<td>
<p>scaling factor for the size of the points' labels (0.8 by default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>studyplot</code></td>
<td>
<p>polygon (SpatialPolygonDataFrame class) representing the study area for which online elevation data are acquired (see <code>movecost</code>); NULL is default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>barrier</code></td>
<td>
<p>area where the movement is inhibited (SpatialLineDataFrame or SpatialPolygonDataFrame class) (see <code>movecost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.barrier</code></td>
<td>
<p>TRUE or FALSE (default) if the user wants or does not want the barrier to be plotted (see <code>movecost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>irregular.dtm</code></td>
<td>
<p>TRUE or FALSE (default) if the input DTM features irregular margins (see <code>movecost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>funct</code></td>
<td>
<p>cost function to be used (for details on each of the following, see <code>movecost</code>):<br></p>
<p><strong>-functions expressing cost as walking time-</strong><br><strong>t</strong> (default) uses the on-path Tobler's hiking function;<br><strong>tofp</strong> uses the off-path Tobler's hiking function;<br><strong>mp</strong> uses the Marquez-Perez et al.'s modified Tobler's function;<br><strong>icmonp</strong> uses the Irmischer-Clarke's hiking function (male, on-path);<br><strong>icmoffp</strong> uses the Irmischer-Clarke's hiking function (male, off-path);<br><strong>icfonp</strong> uses the Irmischer-Clarke's hiking function (female, on-path);<br><strong>icfoffp</strong> uses the Irmischer-Clarke's hiking function (female, off-path);<br><strong>ug</strong> uses the Uriarte Gonzalez's walking-time cost function;<br><strong>ma</strong> uses the Marin Arroyo's walking-time cost function;<br><strong>alb</strong> uses the Alberti's Tobler hiking function modified for pastoral foraging excursions;<br><strong>gkrs</strong> uses the Garmy, Kaddouri, Rozenblat, and Schneider's hiking function;<br><strong>r</strong> uses the Rees' hiking function;<br><strong>ks</strong> uses the Kondo-Seino's hiking function;<br><strong>trp</strong> uses the Tripcevich's hiking function;<br></p>
<p><strong>-functions for wheeled-vehicles-</strong><br><strong>wcs</strong> uses the wheeled-vehicle critical slope cost function;<br></p>
<p><strong>-functions expressing abstract cost-</strong><br><strong>ree</strong> uses the relative energetic expenditure cost function;<br><strong>b</strong> uses the Bellavia's cost function;<br><strong>e</strong> uses the Eastman's cost function;<br></p>
<p><strong>-functions expressing cost as metabolic energy expenditure-</strong><br><strong>p</strong> uses the Pandolf et al.'s metabolic energy expenditure cost function;<br><strong>pcf</strong> uses the Pandolf et al.'s cost function with correction factor for downhill movements;<br><strong>m</strong> uses the Minetti et al.'s metabolic energy expenditure cost function;<br><strong>hrz</strong> uses the Herzog's metabolic energy expenditure cost function;<br><strong>vl</strong> uses the Van Leusen's metabolic energy expenditure cost function;<br><strong>ls</strong> uses the Llobera-Sluckin's metabolic energy expenditure cost function;<br><strong>a</strong> uses the Ardigo et al.'s metabolic energy expenditure cost function;<br><strong>h</strong> uses the Hare's metabolic energy expenditure cost function (for all the mentioned cost functions, see <code>movecost</code>).<br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>time-unit expressed by the accumulated raster if Tobler's and other time-related cost functions are used; h' for hour, 'm' for minutes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>move</code></td>
<td>
<p>number of directions in which cells are connected: 4 (rook's case), 8 (queen's case), 16 (knight and one-cell queen moves; default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>field</code></td>
<td>
<p>value assigned to the cells coinciding with the barrier (0 by default) (see <code>movecost</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cogn.slp</code></td>
<td>
<p>TRUE or FALSE (default) if the user wants or does not want the 'cognitive slope' to be used in place of the real slope (see <code>movecost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sl.crit</code></td>
<td>
<p>critical slope (in percent), typically in the range 8-16 (10 by default) (used by the wheeled-vehicle cost function; see <code>movecost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>walker's body weight (in Kg; 70 by default; used by the Pandolf's and Van Leusen's cost function; see <code>movecost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>carried load weight (in Kg; 0 by default; used by the Pandolf's and Van Leusen's cost function; see <code>movecost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>coefficient representing ease of movement (1 by default) (see <code>movecost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>speed in m/s (1.2 by default) (used by the Pandolf et al.'s, Pandolf et al.s with correction factor, Van Leusen's, and Ardigo et al.'s cost function; if set to 0, it is internally worked out on the basis of Tobler on-path hiking function (see <code>movecost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>zoom level for the elevation data downloaded from online sources (from 0 to 15; 9 by default) (see <code>movecost</code> and <code>get_elev_raster</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>
<p>TRUE or FALSE (default) if the user wants or does not want the output least-coast corridor raster to be rescaled between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transp</code></td>
<td>
<p>set the transparency of the slopeshade raster that is plotted over the least-cost corridor raster (0.5 by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph.out</code></td>
<td>
<p>TRUE (default) or FALSE if the user wants or does not want a graphical output to be generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>export</code></td>
<td>
<p>TRUE or FALSE (default) if the user wants or does not want the output to be exported; if TRUE, the least-cost corridor, the dtm (if not provided by the user but acquired online),
and the accumulated cost surface around a and b are exported as a GeoTiff file, while the two LCPs (from a to b, and from b to a) as individual shapefiles. If multiple locations are analysed, only the
least-cost corridor (and the DTM if originally not provided) will be exported. All the exported files (excluding the DTM) will bear a suffix corresponding to the cost function selected by the user.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If only two locations are provided (one via parameter <code>a</code>, one via parameter <code>b</code>),
the function renders a raster representing the least cost corridor (which can be optionally exported as GeoTiff) with least-cost paths superimposed.
If more than 2 locations are fed into the function via the 'a' parameter, the function calculates the least-cost corridor between pairs of locations.
All the pair-wise corridor rasters are returned (but not individually plotted) in a list.
All those rasters will be summed, and the resulting raster will be plotted (and can be, optionally, exported as GeoTiff).<br></p>
<p>The function returns a list containing a number of components (see 'Value' below). For more details about exporting the function's outputs,  see 'Arguments' below. <br></p>
<p>If the user wants to calculate the least-cost corridor between two locations only, (s)he may want to use parameter <code>a</code> and <code>b</code> to indicate
the two locations of interest respectively. For example, using the datasets provided by this package: <br></p>
<p>result &lt;- movecorr(a=Etna_start_location, b=Etna_end_location[1,], studyplot=Etna_boundary, funct="tofp") <br></p>
<p>The above will produce the least-cost corridor between two locations close to Mt Etna (Sicily, Italy), using the
Tobler's cost function (for off-path hiking). Side note: the elevation data will be acquired online. <br></p>
<p>If the interest lies in using more than 2 locations, the user may want to feed the dataset storing all the locations
into parameter <code>a</code> (disregarding <code>b</code>). As explained above, in this case the function calculates the least-cost corridor between pairs of locations.
All the pair-wise corridor rasters are returned in a list. Those rasters will be summed, and the resulting raster will be plotted (and can be, optionally, exported as GeoTiff).
For example, to calculate the least-cost corridors between every individual unique pair of the 9 locations stored in the <code>destin.loc</code> dataset:<br></p>
<p>volc &lt;- raster::raster(system.file("external/maungawhau.grd", package="gdistance")) <br></p>
<p>result &lt;- movecorr(dtm=volc, a=destin.loc, funct="ree", rescale=TRUE) <br></p>
<p>Note that only parameter <code>a</code> has been used. The function returns and plots the sum of the 36 individual corridors; the latter are not plotted,
but are stored in a list. If the user wants to plot the least-cost corridor, say, n 4, and then add the two locations
between which the corridor has been calculated, (s)he can first plot the corridor raster n 4: <br></p>
<p>raster::plot(result$corridors[[4]]) <br></p>
<p>Then, identifying which locations are related to corridor n 4 can be easily accomplished by looking up the values stored in
the 4th column of the returned matrix: <br></p>
<p>result$locations.matrix <br></p>
<p>The locations are the n 1 and n 5, so the user can add them to the plot previosly produced using: <br></p>
<p>raster::plot(destin.loc[1,], pch=20, add=T)<br>
raster::plot(destin.loc[5,], pch=20, add=T)<br></p>
<p>Note that the resulting plot can be produced (with a nicer outlook) directly by 'movecorr()' by feeding those two locations in the
parameter 'a' and 'b' respectively: <br></p>
<p>result &lt;- movecorr(dtm=volc, a=destin.loc[1,], b=destin.loc[5,], funct="ree") <br></p>
<p>Overall, what <code>movecorr()</code> does is to calculate (via the <code>movecost</code> function) the accumulated cost surface around each location.
Those are eventually summed to produce the least-cost corridor between locations. On the produced corridor raster, the cost of a cell is the total cost to reach it
from all the analysed locations. About least-cost corridors between pairs of locations, see for instance: <br>
Mitchell A. (2012), "The ESRI Guide to GIS Analysis. Vol 3. Modelling Suitability, Movement, and Interaction", New York: Esri Press (257-259). <br></p>


<h3>Value</h3>

<p>The function returns a list storing the following components
</p>

<ul>
<li>
<p> dtm: Digital Terrain Model ('RasterLayer' class)
</p>
</li>
<li>
<p> lc.corridor: raster of the least-cost corridor ('RasterLayer' class); if more than two locations are analysed, this raster is the sum of all the corridors between all the pairs of locations
</p>
</li>
<li>
<p> lcp_a_to_b: least-cost past from a to b ('SpatialLinesDataFrame' class); returned only when the corridor is calculated between two locations
</p>
</li>
<li>
<p> lcp_b_to_a: least-cost past from b to a ('SpatialLinesDataFrame' class); returned only when the corridor is calculated between two locations
</p>
</li>
<li>
<p> accum_cost_surf_a: accumulated cost-surface around a ('RasterLayer' class); returned only when the corridor is calculated between two locations
</p>
</li>
<li>
<p> accum_cost_surf_b: accumulated cost-surface around b ('RasterLayer' class); returned only when the corridor is calculated between two locations
</p>
</li>
<li>
<p> corridors: list of rasters ('RasterLayer' class) representing the least-cost corridor between all the unique pairs of locations; returned only when more than two locations are analysed
</p>
</li>
<li>
<p> locations.matrix: matrix whose columns indicate the identifiers for all the unique pairs of locations for which each corridor is calculated; returned only when more than two locations are analysed
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>movecost</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load a sample Digital Terrain Model
data(volc)


# load the sample destination locations on the above DTM
data(destin.loc)


# calculate the least-cost corridor between two locations, using the
# relative energetic expenditure cost function, and store the results
# in the 'result' object

result &lt;- movecorr(dtm=volc, a=destin.loc[1,], b=destin.loc[3,], funct="ree", move=8)


#same as above, but using the 'cognitive slope'

# result &lt;- movecorr(dtm=volc, a=destin.loc[1,], b=destin.loc[3,],
# funct="ree", move=8, cogn.slp=TRUE)


</code></pre>


</div>