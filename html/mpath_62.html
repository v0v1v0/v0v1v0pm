<div class="container">

<table style="width: 100%;"><tr>
<td>glmregNB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>fit a negative binomial model with lasso (or elastic net), snet and mnet regularization</h2>

<h3>Description</h3>

<p>Fit a negative binomial linear model via penalized maximum likelihood. The regularization path is computed for the lasso (or elastic net penalty), snet and mnet penalty, at a grid of values for the regularization parameter lambda. </p>


<h3>Usage</h3>

<pre><code class="language-R">glmregNB(formula, data, weights, offset=NULL, nlambda = 100, lambda=NULL, 
         lambda.min.ratio = ifelse(nobs&lt;nvars,0.05,0.001), alpha=1, gamma=3, 
         rescale=TRUE, standardize = TRUE, penalty.factor = rep(1, nvars), 
         thresh = 0.001, maxit.theta = 10, maxit=1000, eps=.Machine$double.eps,
         trace=FALSE, start = NULL, etastart = NULL, mustart = NULL, 
         theta.fixed=FALSE, theta0=NULL, init.theta=NULL, link=log, 
         penalty=c("enet","mnet","snet"), method="glmreg_fit", model=TRUE, 
         x.keep=FALSE, y.keep=TRUE, contrasts=NULL, convex=FALSE, 
         parallel=TRUE, n.cores=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>formula used to describe a model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>argument controlling formula processing
via <code>model.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of ‘prior weights’ to be used in the fitting process. Should be <code>NULL</code> or a numeric vector. Default is a vector of 1s with equal weight for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero). The default depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is <code>0.001</code>,
close to zero.  If <code>nobs &lt; nvars</code>, the default is <code>0.05</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The L2 penalty mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>. <code>alpha=1</code> is lasso (mcp, scad) penalty; and <code>alpha=0</code> the ridge penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>
<p>logical value, if TRUE, adaptive rescaling of the penalty parameter for <code>penalty="mnet"</code> or <code>penalty="snet"</code> with <code>family</code> other than "gaussian". See reference</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical flag for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on
the original scale. Default is <code>standardize=TRUE</code>.
If variables are in the same units already, you might not wish to
standardize.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>This is a number that multiplies <code>lambda</code> to allow
differential shrinkage of coefficients. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the
model. Default is same shrinkage for all variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Defaults value is <code>1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit.theta</code></td>
<td>
<p>Maximum number of iterations for estimating <code>theta</code> scaling parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of coordinate descent iterations for each <code>lambda</code> value; default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>If a number is less than <code>eps</code> in magnitude, then this number is considered as 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>If <code>TRUE</code>, fitting progress is reported</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start, etastart, mustart, ...</code></td>
<td>
<p> arguments for the <code>link{glmreg}</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.theta</code></td>
<td>
<p> initial scaling parameter <code>theta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.fixed</code></td>
<td>
<p>Estimate scale parameter theta? Default is FALSE. Note, the algorithm may become slow. In this case, one may use <code>glmreg</code> function with <code>family="negbin"</code>, and a fixed <code>theta</code></p>
</td>
</tr>
</table>
<p>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>theta0</code></td>
<td>
<p>initial scale parameter vector theta, with length <code>nlambda</code> if <code>theta.fixed=TRUE</code>. Default is NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convex</code></td>
<td>
<p>Calculate index for which objective function ceases to
be locally convex? Default is FALSE and only useful if <code>penalty="mnet" or "snet"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>link function, default is <code>log</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>Type of regularization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>estimation method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model, x.keep, y.keep</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components
of the fit (model frame, response, model matrix) are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel, n.cores</code></td>
<td>
<p>a logical value, parallel computing or not for sequence of <code>lambda</code> with the number of CPU cores to use. The <code>lambda</code> loop will attempt to send different <code>lambda</code> off to different cores.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The sequence of models implied by <code>lambda</code> is fit by coordinate
descent. This is a lasso (mcp, scad) or elastic net (mnet, snet) regularization path
for fitting the negative binomial linear regression
paths, by maximizing the penalized log-likelihood.
Note that the objective function is 
</p>
<p style="text-align: center;"><code class="reqn">-\sum (weights * loglik) + \lambda*penalty</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">-\frac{weights}{\sum(weights)} * loglik + \lambda*penalty</code>
</p>
<p> if <code>standardize=TRUE</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"glmreg", "glmregNB"</code> for the various types of models.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that produced the model fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x
      length(lambda)</code> matrix of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resdev</code></td>
<td>
<p>The computed deviance. The deviance calculations incorporate weights if
present in the model. The deviance is defined to be 2*(loglike_sat -
loglike), where loglike_sat is the log-likelihood for the saturated
model (a model with a free parameter per observation). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to
be  2*(loglike_sat -loglike(Null)); The NULL model refers to the
intercept model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>                                                                          Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)      <em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>


<h3>See Also</h3>

<p><code>print</code>, <code>predict</code>, <code>coef</code> and <code>plot</code> methods, and the <code>cv.glmregNB</code> function.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data("bioChemists", package = "pscl")
system.time(fm_nb1 &lt;- glmregNB(art ~ ., data = bioChemists, parallel=FALSE))
system.time(fm_nb2 &lt;- glmregNB(art ~ ., data = bioChemists, parallel=TRUE, n.cores=2))
coef(fm_nb1)
### ridge regression
fm &lt;- glmregNB(art ~ ., alpha=0, data = bioChemists, lambda=seq(0.001, 1, by=0.01))
fm &lt;- cv.glmregNB(art ~ ., alpha=0, data = bioChemists, lambda=seq(0.001, 1, by=0.01))

## End(Not run)
</code></pre>


</div>