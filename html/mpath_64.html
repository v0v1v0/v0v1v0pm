<div class="container">

<table style="width: 100%;"><tr>
<td>glmreg_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal function to fit a GLM with lasso (or elastic net), snet and mnet regularization</h2>

<h3>Description</h3>

<p>Fit a generalized linear model via penalized maximum likelihood.  The
regularization path is computed for the lasso (or elastic net penalty), snet and mnet penalty, at a grid
of values for the regularization parameter lambda. Fits
linear, logistic, Poisson and negative binomial (fixed scale parameter) regression models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glmreg_fit(x, y, weights, start=NULL, etastart=NULL, mustart=NULL, offset = NULL, 
           nlambda=100, lambda=NULL, lambda.min.ratio=ifelse(nobs&lt;nvars,.05, .001), 
           alpha=1, gamma=3, rescale=TRUE, standardize=TRUE, intercept=TRUE, 
           penalty.factor = rep(1, nvars), thresh=1e-6, eps.bino=1e-5, maxit=1000, 
           eps=.Machine$double.eps, theta, 
           family=c("gaussian", "binomial", "poisson", "negbin"),
           penalty=c("enet","mnet","snet"), convex=FALSE, x.keep=FALSE, y.keep=TRUE,
           trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response variable. Quantitative for <code>family="gaussian"</code>.
Non-negative counts for <code>family="poisson"</code> or <code>family="negbin"</code>. For
<code>family="binomial"</code> should be either a factor with two levels or
a vector of proportions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>observation weights. Can be total counts if responses are proportion matrices. Default is 1 for each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100. The sequence may be truncated before <code>nlambda</code> is reached if a close to saturated model is fitted. See also <code>satu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p> by default, the algorithm provides a sequence of regularization values, or a user supplied <code>lambda</code> sequence. When <code>alpha=0</code>, the largest lambda value is not defined (infinity). Thus, the largest <code>lambda</code> for <code>alpha=0.001</code> is computed, and the sequence of <code>lambda</code> values is calculated afterwards. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero except the intercept). Note, there is no closed formula for <code>lambda.max</code> in general. If <code>rescale=TRUE</code>, <code>lambda.max</code> is the same for <code>penalty="mnet" or "snet"</code>. Otherwise, some modifications are required. For instance, for small <code>gamma</code> value, half of the square root (if <code>lambda.max</code> is too small) of the computed <code>lambda.max</code> can be used when <code>penalty="mnet" or "snet"</code>. The default of <code>lambda.min.ratio</code> depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is <code>0.001</code>,
close to zero.  If <code>nobs &lt; nvars</code>, the default is <code>0.05</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The <code class="reqn">L_2</code> penalty mixing parameter, with
<code class="reqn">0 \le alpha\le 1</code>. <code>alpha=1</code> is lasso (mcp, scad) penalty; and <code>alpha=0</code> the ridge penalty. However, if <code>alpha=0</code>, one must provide <code>lambda</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>
<p>logical value, if TRUE, adaptive rescaling of the penalty parameter for <code>penalty="mnet"</code> or <code>penalty="snet"</code> with <code>family</code> other than "gaussian". See reference</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>logical value for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on
the original scale. Default is <code>standardize=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>logical value: if TRUE (default), intercept(s) are fitted; otherwise, intercept(s) are set to zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>This is a number that multiplies <code>lambda</code> to allow
differential shrinkage of coefficients. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the
model. Default is same shrinkage for all variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Defaults value is <code>1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.bino</code></td>
<td>
<p>a lower bound of probabilities to be truncated, for computing weights and related values when <code>family="binomial"</code>. It is also used when <code>family="negbin"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of coordinate descent iterations for each <code>lambda</code> value; default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>If a coefficient is less than <code>eps</code> in magnitude, then it is reported to be 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convex</code></td>
<td>
<p>Calculate index for which objective function ceases to
be locally convex? Default is FALSE and only useful if <code>penalty="mnet" or "snet"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p> an overdispersion scaling parameter for <code>family="negbin"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Response type (see above)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>Type of regularization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.keep, y.keep</code></td>
<td>
<p> For glmreg: logical values indicating whether the response
vector and model matrix used in the fitting process should be
returned as components of the returned value.
For glmreg_fit: x is a design matrix of dimension n * p,
and x is a vector of observations of length n.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>If <code>TRUE</code>, fitting progress is reported</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The sequence of models implied by <code>lambda</code> is fit by coordinate
descent. For <code>family="gaussian"</code> this is the lasso, mcp or scad sequence if
<code>alpha=1</code>, else it is the enet, mnet or snet sequence.
For the other families, this is a lasso (mcp, scad) or elastic net (mnet, snet) regularization path
for fitting the generalized linear regression
paths, by maximizing the appropriate penalized log-likelihood.
Note that the objective function for <code>"gaussian"</code> is </p>
<p style="text-align: center;"><code class="reqn">1/2*
  weights*RSS + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">1/2*
  \frac{weights}{\sum(weights)}*RSS + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>. For the other models it is
</p>
<p style="text-align: center;"><code class="reqn">-\sum (weights * loglik) + \lambda*penalty</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">-\frac{weights}{\sum(weights)} * loglik + \lambda*penalty</code>
</p>
<p> if <code>standardize=TRUE</code>. 
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"glmreg"</code> for the various types of models.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that produced the model fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x length(lambda)</code> matrix of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>satu</code></td>
<td>
<p>satu=1 if a saturated model (deviance/null deviance &lt; 0.05) is fit. Otherwise satu=0. The number of <code>nlambda</code> sequence may be truncated before <code>nlambda</code> is reached if <code>satu=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev</code></td>
<td>
<p>The computed deviance (for <code>"gaussian"</code>, this
is the R-square). The deviance calculations incorporate weights if
present in the model. The deviance is defined to be 2*(loglike_sat -
loglike), where loglike_sat is the log-likelihood for the saturated
model (a model with a free parameter per observation). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to
be  2*(loglike_sat -loglike(Null)); The NULL model refers to the
intercept model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Breheny, P. and Huang, J. (2011) <em>Coordinate descent
algorithms for nonconvex penalized regression, with applications to
biological feature selection</em>. <em>Ann. Appl. Statist.</em>, <b>5</b>: 232-253.
</p>
<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014)
<em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>. 2014 Apr 17. [Epub ahead of print]
</p>


<h3>See Also</h3>

<p><code>glmreg</code></p>


</div>