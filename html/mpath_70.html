<div class="container">

<table style="width: 100%;"><tr>
<td>irglmreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a robust penalized generalized linear models</h2>

<h3>Description</h3>

<p>Fit a robust penalized GLM where the loss function is a composite function <code>cfun</code>o<code>dfun</code> + penalty. This is the wrapper function of <code>irglmreg_fit</code> 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'formula'
irglmreg(formula, data, weights, offset=NULL, contrasts=NULL, ...)
## S3 method for class 'matrix'
irglmreg(x, y, weights, offset=NULL, ...)
## Default S3 method:
irglmreg(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>argument controlling formula processing
via <code>model.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional numeric vector of weights. If <code>standardize=TRUE</code>, weights are renormalized to weights/sum(weights). If <code>standardize=FALSE</code>, weights are kept as original input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response variable. Quantitative for <code>rfamily="clossR"</code> and -1/1 for classification. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Not implemented yet</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passing to <code>irglmreg_fit</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The computing is done by the iteratively reweighted penalized GLM, an application of the iteratively reweighted convex optimization (IRCO). Here convex is the loss function induced by <code>dfun</code>, not the penalty function. The output <code>weights_update</code> is a useful diagnostic to the outlier status of     the observations.
The regularization path is computed for the lasso (or elastic net penalty), scad (or snet) and mcp (or mnet penalty), at a grid of values for the regularization parameter lambda. 
The sequence of robust models implied by <code>lambda</code> is fit by the IRCO along with coordinate
descent. Note that the objective function is </p>
<p style="text-align: center;"><code class="reqn">weights*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">
  \frac{weights}{\sum(weights)}*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>. 
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"irglmreg"</code> for the various types of models.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x
      length(lambda)</code> matrix of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p>if <code>type.path="nonactive"</code>, a matrix with number of rows <code>iter</code> and number of columns <code>nlambda</code>, loss values along the regularization path. If <code>type.path="fast"</code>, a vector of length <code>nlambda</code>, loss values along the regularization path</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pll</code></td>
<td>
<p>if <code>type.path="nonactive"</code>, a matrix with number of rows <code>iter</code> and number of columns <code>nlambda</code>, penalized loss values along the regularization path. If <code>type.path="fast"</code>, a vector of length <code>nlambda</code>, penalized loss values along the regularization path</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>predicted values depending on <code>standardize</code>, internal use only</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal of      Statistics</em>. 66(1):77-102.
</p>


<h3>See Also</h3>

<p><code>print</code>, <code>predict</code>, <code>coef</code> and <code>plot</code> methods, and the <code>cv.irglmreg</code> function.</p>


<h3>Examples</h3>

<pre><code class="language-R">#binomial
x=matrix(rnorm(100*20),100,20)
g2=sample(c(-1,1),100,replace=TRUE)
fit1=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="active",
              decreasing=TRUE,type.init="bst")
#fit1$risk
## Not run: 
### different solution paths via a combination of type.path, decreasing and type.init
fit1=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="active",
           decreasing=TRUE,type.init="bst")
fit2=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="active",
           decreasing=FALSE,type.init="bst")
fit3=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="nonactive",
           decreasing=TRUE,type.init="bst")
fit4=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="nonactive",
           decreasing=FALSE,type.init="bst")
fit5=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="active",
           decreasing=TRUE,type.init="co")
fit6=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="active",
           decreasing=FALSE,type.init="co")
fit7=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="nonactive",
           decreasing=TRUE,type.init="co")
fit8=irglmreg(x,g2,s=1,cfun="ccave",dfun="gaussian",type.path="nonactive",
           decreasing=FALSE,type.init="co")

## End(Not run)
</code></pre>


</div>