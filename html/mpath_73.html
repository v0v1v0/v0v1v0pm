<div class="container">

<table style="width: 100%;"><tr>
<td>irglmreg_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal function for robust penalized generalized linear models</h2>

<h3>Description</h3>

<p>Fit a robust penalized GLM where the loss function is a composite function <code>cfun</code>o<code>dfun</code> + penalty. This does computing for <code>irglmreg</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">irglmreg_fit(x, y, weights, offset, cfun="ccave", dfun="gaussian", s=NULL, 
             delta=0.1, fk=NULL, iter=10, reltol=1e-5, 
             penalty=c("enet","mnet","snet"), nlambda=100, lambda=NULL, 
             type.path=c("active", "nonactive"), decreasing=TRUE, 
             lambda.min.ratio=ifelse(nobs&lt;nvars,.05, .001), alpha=1, gamma=3,
             rescale=TRUE, standardize=TRUE, intercept=TRUE, 
             penalty.factor= NULL, maxit=1000, type.init=c("bst", "co", "heu"), 
             init.family=NULL, mstop.init=10, nu.init=0.1, 
             eps=.Machine$double.eps, epscycle=10, thresh=1e-6, parallel=FALSE,
             n.cores=2, theta, trace=FALSE, tracelevel=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response variable. Quantitative for <code>dfun=1</code> and -1/1 otherwise for classifications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>observation weights. Can be total counts if responses are proportion matrices. Default is 1 for each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cfun</code></td>
<td>
<p> character, type of convex cap (concave) function.<br>
Valid options are:
</p>

<ul>
<li> <p><code>"hcave"</code>
</p>
</li>
<li> <p><code>"acave"</code>
</p>
</li>
<li> <p><code>"bcave"</code>
</p>
</li>
<li> <p><code>"ccave"</code>
</p>
</li>
<li> <p><code>"dcave"</code>
</p>
</li>
<li> <p><code>"ecave"</code>
</p>
</li>
<li> <p><code>"gcave"</code>
</p>
</li>
<li> <p><code>"tcave"</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfun</code></td>
<td>
<p> character, type of convex downward function. <br>
Valid options are:
</p>

<ul>
<li> <p><code>"gaussian"</code>
</p>
</li>
<li> <p><code>"gaussianC"</code>
</p>
</li>
<li> <p><code>"binomial"</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p> tuning parameter of <code>cfun</code>. <code>s &gt; 0</code> and can be equal    to 0 for <code>cfun="tcave"</code>. If <code>s</code> is too close to 0 for               <code>cfun="acave", "bcave", "ccave"</code>, the calculated weights can become 0    for all observations, thus crash the program.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>a small positive number provided by user only if                <code>cfun="gcave"</code> and <code>0 &lt; s &lt;1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fk</code></td>
<td>
<p> predicted values at an iteration in the IRCO algorithm </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100. The sequence may be truncated before <code>nlambda</code> is reached if a close to saturated model is fitted. See also <code>satu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p> by default, the algorithm provides a sequence of regularization values, or a user supplied <code>lambda</code> sequence </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.path</code></td>
<td>
<p>solution path for <code>parallel=FALSE</code>. If <code>type.path="active"</code>, then cycle through only the active set in the next increasing <code>lambda</code> sequence. If <code>type.path="nonactive"</code>, no active set for each element of the lambda sequence and cycle through all the predictor variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero except the intercept). Note, there is no closed formula for <code>lambda.max</code>. The default of <code>lambda.min.ratio</code> depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is <code>0.001</code>,
close to zero.  If <code>nobs &lt; nvars</code>, the default is <code>0.05</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The <code class="reqn">L_2</code> penalty mixing parameter, with
<code class="reqn">0 \le alpha\le 1</code>. <code>alpha=1</code> is lasso (mcp, scad) penalty; and <code>alpha=0</code> the ridge penalty. However, if <code>alpha=0</code>, one must provide <code>lambda</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>
<p>logical value, if TRUE, adaptive rescaling of the penalty       parameter for <code>penalty="mnet"</code> or <code>penalty="snet"</code> with               <code>dfun="binomial"</code>. See <code>glmreg_fit</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>logical value for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on
the original scale. Default is <code>standardize=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>logical value: if TRUE (default), intercept(s) are fitted; otherwise, intercept(s)  are set to zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>This is a number that multiplies <code>lambda</code> to allow
differential shrinkage of coefficients. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the
model. Default is same shrinkage for all variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.init</code></td>
<td>
<p>a method to determine the initial values. If <code>type.init="ncl"</code>, an intercept-only model as initial parameter and run <code>irglmreg</code> regularization path forward from lambda_max to lambda_min. If <code>type.init="heu"</code>, heuristic initial parameters and run <code>irglmreg</code> path backward or forward depending on <code>decreasing</code>, between lambda_min and lambda_max. If <code>type.init="bst"</code>, run a boosting model with <code>bst</code> in package bst, depending on <code>mstop.init, nu.init</code> and run <code>irglmreg</code> backward or forward depending on <code>decreasing</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.family</code></td>
<td>
<p> character value for initial family, one of "clossR",     "closs","gloss","qloss", which can be used to derive an initial estimator, if   the selection is different from the default value </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstop.init</code></td>
<td>
<p> an integer giving the number of boosting iterations when <code>type.init="bst"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.init</code></td>
<td>
<p> a small number (between 0 and 1) defining the step size or shrinkage parameter when <code>type.init="bst"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p> only used if <code>lambda=NULL</code>, a logical value used to determine regularization path direction either from lambda_max to a potentially modified lambda_min or vice versa if <code>type.init="bst", "heu"</code>. Since this is a nonconvex optimization, it is possible to generate different estimates for the same <code>lambda</code> depending on <code>decreasing</code>. The choice of <code>decreasing</code> picks different starting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of iteration in the IRCO algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Within each IRCO algorithm iteration, maximum number of coordinate descent iterations for each <code>lambda</code> value; default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>convergency criteria in the IRCO algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>If a coefficient is less than <code>eps</code> in magnitude, then it is reported to be 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epscycle</code></td>
<td>
<p> If <code>nlambda</code> &gt; 1 and the relative loss values from two consecutive <code>lambda</code> values change &gt; <code>epscycle</code>, then re-estimate parameters in an effort to avoid trap of local optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Defaults value is <code>1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>Type of regularization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p> an overdispersion scaling parameter for <code>family="negbin"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel, n.cores</code></td>
<td>
<p>If <code>TRUE</code>, to compute solution of <code>lambda</code> with parallel computing in number of <code>n.cores</code>. If <code>FALSE</code>, sequential computing. If <code>NULL</code>, still sequential computing with a different convergence criteria based on penalized loss values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace, tracelevel</code></td>
<td>
<p>If <code>TRUE</code>, fitting progress is reported. If <code>tracelevel=2</code>, deeper level of fitting progress is reported.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A case weighted penalized least squares or GLM is fit by the iteratively reweighted convex optimization (IRCO), where the loss function is a composite function <code>cfun</code>o<code>dfun</code> + penalty. Here convex is the loss function     induced by <code>dfun</code>, not the penalty function.
The sequence of robust models implied by <code>lambda</code> is fit by IRCO along with coordinate
descent. Note that the objective function is </p>
<p style="text-align: center;"><code class="reqn">weights*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">
  \frac{weights}{\sum(weights)}*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>. 
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"irglmreg"</code> for the various types of models.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that produced the model fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x length(lambda)</code> matrix of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights_update</code></td>
<td>
<p>A <code>nobs x length(lambda)</code> matrix of weights computed by the IRCO algorithm. The entry of i-th row and j-th column is the weight for the i-th observation and j-th <code>lambda</code> value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p> if <code>lambda</code> is an increasing sequence or not, used to determine regularization path direction either from lambda_max to a potentially modified lambda_min or vice versa if <code>type.init="bst", "heu"</code>. </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2024)
<em>Unified Robust Estimation</em>, <em>Australian &amp; New Zealand Journal of      Statistics</em>. 66(1):77-102.  
</p>


<h3>See Also</h3>

<p><code>irglmreg</code></p>


</div>