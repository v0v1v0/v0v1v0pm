<div class="container">

<table style="width: 100%;"><tr>
<td>glmreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>fit a GLM with lasso (or elastic net), snet or mnet regularization</h2>

<h3>Description</h3>

<p>Fit a generalized linear model via penalized maximum likelihood.  The
regularization path is computed for the lasso (or elastic net penalty), scad (or snet) and mcp (or mnet penalty), at a grid
of values for the regularization parameter lambda. Fits
linear, logistic, Poisson and negative binomial (fixed scale parameter) regression models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'formula'
glmreg(formula, data, weights, offset=NULL, contrasts=NULL, 
x.keep=FALSE, y.keep=TRUE, ...)
## S3 method for class 'matrix'
glmreg(x, y, weights, offset=NULL, ...)
## Default S3 method:
glmreg(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>argument controlling formula processing
via <code>model.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional numeric vector of weights. If <code>standardize=TRUE</code>, weights are renormalized to weights/sum(weights). If <code>standardize=FALSE</code>, weights are kept as original input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response variable. Quantitative for <code>family="gaussian"</code>.
Non-negative counts for <code>family="poisson"</code> or <code>family="negbin"</code>. For
<code>family="binomial"</code> should be either a factor with two levels or
a vector of proportions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.keep, y.keep</code></td>
<td>
<p>logical values: keep response variables or keep response variable?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passing to <code>glmreg_fit</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The sequence of models implied by <code>lambda</code> is fit by coordinate
descent. For <code>family="gaussian"</code> this is the lasso, mcp or scad sequence if
<code>alpha=1</code>, else it is the enet, mnet or snet sequence.
For the other families, this is a lasso (mcp, scad) or elastic net (mnet, snet) regularization path
for fitting the generalized linear regression
paths, by maximizing the appropriate penalized log-likelihood.
Note that the objective function for <code>"gaussian"</code> is </p>
<p style="text-align: center;"><code class="reqn">1/2*
  weights*RSS + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">1/2*
  \frac{weights}{\sum(weights)}*RSS + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>. For the other models it is
</p>
<p style="text-align: center;"><code class="reqn">-\sum (weights * loglik) + \lambda*penalty</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">-\frac{weights}{\sum(weights)} * loglik + \lambda*penalty</code>
</p>
<p> if <code>standardize=TRUE</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"glmreg"</code> for the various types of models.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x
      length(lambda)</code> matrix of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>the offset vector used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resdev</code></td>
<td>
<p>The computed deviance (for <code>"gaussian"</code>, this
is the R-square). The deviance calculations incorporate weights if
present in the model. The deviance is defined to be 2*(loglike_sat -
loglike), where loglike_sat is the log-likelihood for the saturated
model (a model with a free parameter per observation). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to
be  2*(loglike_sat -loglike(Null)); The NULL model refers to the
intercept model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pll</code></td>
<td>
<p>penalized log-likelihood values for standardized coefficients in the IRLS iterations. For <code>family="gaussian"</code>, not implemented yet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pllres</code></td>
<td>
<p>penalized log-likelihood value for the estimated model on the original scale of coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function. </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Breheny, P. and Huang, J. (2011) <em>Coordinate descent
algorithms for nonconvex penalized regression, with applications to
biological feature selection</em>. <em>Ann. Appl. Statist.</em>, <b>5</b>: 232-253.
</p>
<p>Zhu Wang, Shuangge Ma, Michael Zappitelli, Chirag Parikh, Ching-Yun Wang and Prasad Devarajan (2014) 
<em>Penalized Count Data Regression with Application to Hospital Stay after Pediatric Cardiac Surgery</em>, <em>Statistical Methods in Medical Research</em>.
2014 Apr 17. [Epub ahead of print]
</p>


<h3>See Also</h3>

<p><code>print</code>, <code>predict</code>, <code>coef</code> and <code>plot</code> methods, and the <code>cv.glmreg</code> function.</p>


<h3>Examples</h3>

<pre><code class="language-R">#binomial
x=matrix(rnorm(100*20),100,20)
g2=sample(0:1,100,replace=TRUE)
fit2=glmreg(x,g2,family="binomial")
#poisson and negative binomial
data("bioChemists", package = "pscl")
fm_pois &lt;- glmreg(art ~ ., data = bioChemists, family = "poisson")
coef(fm_pois)
fm_nb1 &lt;- glmreg(art ~ ., data = bioChemists, family = "negbin", theta=1)
coef(fm_nb1)
#offset
x &lt;- matrix(rnorm(100*20),100,20)
y &lt;- rpois(100, lambda=1)
exposure &lt;- rep(0.5, length(y))
fit2 &lt;- glmreg(x,y, lambda=NULL, nlambda=10, lambda.min.ratio=1e-4, 
	       offset=log(exposure), family="poisson")
predict(fit2, newx=x, newoffset=log(exposure))
## Not run: 
fm_nb2 &lt;- glmregNB(art ~ ., data = bioChemists)
coef(fm_nb2)

## End(Not run)
</code></pre>


</div>