<div class="container">

<table style="width: 100%;"><tr>
<td>nclreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimize a nonconvex loss with regularization</h2>

<h3>Description</h3>

<p>Fit a linear model via penalized nonconvex loss function.  The
regularization path is computed for the lasso (or elastic net penalty), scad (or snet) and mcp (or mnet penalty), at a grid
of values for the regularization parameter lambda. The name refers to <b>N</b>on<b>C</b>onvex <b>L</b>oss with <b>REG</b>ularization.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'formula'
nclreg(formula, data, weights, offset=NULL, contrasts=NULL, ...)
## S3 method for class 'matrix'
nclreg(x, y, weights, offset=NULL, ...)
## Default S3 method:
nclreg(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>argument controlling formula processing
via <code>model.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional numeric vector of weights. If <code>standardize=TRUE</code>, weights are renormalized to weights/sum(weights). If <code>standardize=FALSE</code>, weights are kept as original input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response variable. Quantitative for <code>rfamily="clossR"</code> and -1/1 for classification. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Not implemented yet</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code> from the
respective models</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passing to <code>nclreg_fit</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The sequence of robust models implied by <code>lambda</code> is fit by majorization-minimization along with coordinate
descent. Note that the objective function is </p>
<p style="text-align: center;"><code class="reqn">weights*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">\frac{weights}{\sum(weights)}*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>. 
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"nclreg"</code> for the various types of models.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x
      length(lambda)</code> matrix of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p>if <code>type.path="nonactive"</code>, a matrix with number of rows <code>iter</code> and number of columns <code>nlambda</code>, loss values along the regularization path. If <code>type.path="fast"</code>, a vector of length <code>nlambda</code>, loss values along the regularization path</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pll</code></td>
<td>
<p>if <code>type.path="nonactive"</code>, a matrix with number of rows <code>iter</code> and number of columns <code>nlambda</code>, penalized loss values along the regularization path. If <code>type.path="fast"</code>, a vector of length <code>nlambda</code>, penalized loss values along the regularization path</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>predicted values depending on <code>standardize</code>, internal use only</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2021),
<em>MM for Penalized Estimation</em>,
<em>TEST</em>,
doi: <a href="https://doi.org/10.1007/s11749-021-00770-2">10.1007/s11749-021-00770-2</a>
</p>


<h3>See Also</h3>

<p><code>print</code>, <code>predict</code>, <code>coef</code> and <code>plot</code> methods, and the <code>cv.nclreg</code> function.</p>


<h3>Examples</h3>

<pre><code class="language-R">#binomial
x=matrix(rnorm(100*20),100,20)
g2=sample(c(-1,1),100,replace=TRUE)
### different solution paths via a combination of type.path, decreasing and type.init
fit1=nclreg(x,g2,s=1,rfamily="closs",type.path="active",decreasing=TRUE,type.init="bst")
fit2=nclreg(x,g2,s=1,rfamily="closs",type.path="active",decreasing=FALSE,type.init="bst")
fit3=nclreg(x,g2,s=1,rfamily="closs",type.path="nonactive",decreasing=TRUE,type.init="bst")
fit4=nclreg(x,g2,s=1,rfamily="closs",type.path="nonactive",decreasing=FALSE,type.init="bst")
fit5=nclreg(x,g2,s=1,rfamily="closs",type.path="active",decreasing=TRUE,type.init="ncl")
fit6=nclreg(x,g2,s=1,rfamily="closs",type.path="active",decreasing=FALSE,type.init="ncl")
fit7=nclreg(x,g2,s=1,rfamily="closs",type.path="nonactive",decreasing=TRUE,type.init="ncl")
fit8=nclreg(x,g2,s=1,rfamily="closs",type.path="nonactive",decreasing=FALSE,type.init="ncl")
</code></pre>


</div>