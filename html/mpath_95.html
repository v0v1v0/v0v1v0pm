<div class="container">

<table style="width: 100%;"><tr>
<td>nclreg_fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal function to fitting a nonconvex loss based robust linear model with regularization</h2>

<h3>Description</h3>

<p>Fit a linear model via penalized nonconvex loss function.  The
regularization path is computed for the lasso (or elastic net penalty), scad (or snet) and mcp (or mnet penalty), at a grid
of values for the regularization parameter lambda.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nclreg_fit(x, y, weights, offset, rfamily=c("clossR", "closs", "gloss", "qloss"), 
           s=NULL, fk=NULL, iter=10, reltol=1e-5, 
           penalty=c("enet","mnet","snet"), nlambda=100,lambda=NULL, 
           type.path=c("active", "nonactive", "onestep"), decreasing=FALSE, 
           lambda.min.ratio=ifelse(nobs&lt;nvars,.05, .001), alpha=1, gamma=3, 
           standardize=TRUE, intercept=TRUE, penalty.factor=NULL, maxit=1000, 
           type.init=c("bst", "ncl", "heu"), mstop.init=10, nu.init=0.1, 
           eps=.Machine$double.eps, epscycle=10, thresh=1e-6, trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an
observation vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response variable. Quantitative for <code>rfamily="clossR"</code> and -1/1 for classifications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>observation weights. Can be total counts if responses are proportion matrices. Default is 1 for each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. Currently only one offset term can be included in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rfamily</code></td>
<td>
<p>Response type and relevant loss functions (see above)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p> nonconvex loss tuning parameter for robust regression and classification. The <code>s</code> value is for robust nonconvex loss where smaller <code>s</code> value is more robust to outliers with <code>rfamily="closs"</code>, and larger <code>s</code> value more robust with<br><code>rfamily="clossR", "gloss", "qloss"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fk</code></td>
<td>
<p> predicted values at an iteration in the MM algorithm </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100. The sequence may be truncated before <code>nlambda</code> is reached if a close to saturated model is fitted. See also <code>satu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p> by default, the algorithm provides a sequence of regularization values, or a user supplied <code>lambda</code> sequence </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.path</code></td>
<td>
<p>solution path. If <code>type.path="active"</code>, then cycle through only the active set in the next increasing <code>lambda</code> sequence. If <code>type.path="nonactive"</code>, no active set for each element of the lambda sequence and cycle through all the predictor variables. If <code>type.path="onestep"</code>, update for one element of lambda depending on <code>decreasing=FALSE</code> (last element of lambda) or <code>decreasing=TRUE</code> (then first element of lambda) in each MM iteration, and iterate until convergency of prediction. Then fit a solution path based on the sequence of lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero except the intercept). Note, there is no closed formula for <code>lambda.max</code>. The default of <code>lambda.min.ratio</code> depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is <code>0.001</code>,
close to zero.  If <code>nobs &lt; nvars</code>, the default is <code>0.05</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The <code class="reqn">L_2</code> penalty mixing parameter, with
<code class="reqn">0 \le alpha\le 1</code>. <code>alpha=1</code> is lasso (mcp, scad) penalty; and <code>alpha=0</code> the ridge penalty. However, if <code>alpha=0</code>, one must provide <code>lambda</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>The tuning parameter of the <code>snet</code> or <code>mnet</code> penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>logical value for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on
the original scale. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>logical value: if TRUE (default), intercept(s) are fitted; otherwise, intercept(s)  are set to zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>This is a number that multiplies <code>lambda</code> to allow
differential shrinkage of coefficients. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the
model. Default is same shrinkage for all variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.init</code></td>
<td>
<p>a method to determine the initial values. If <code>type.init="ncl"</code>, an intercept-only model as initial parameter and run <code>nclreg</code> regularization path forward from lambda_max to lambda_min. If <code>type.init="heu"</code>, heuristic initial parameters and run <code>nclreg</code> path backward or forward depending on <code>decreasing</code>, between lambda_min and lambda_max. If <code>type.init="bst"</code>, run a boosting model with <code>bst</code> in package bst, depending on <code>mstop.init, nu.init</code> and run <code>nclreg</code> backward or forward depending on <code>decreasing</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstop.init</code></td>
<td>
<p> an integer giving the number of boosting iterations when <code>type.init="bst"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.init</code></td>
<td>
<p> a small number (between 0 and 1) defining the step size or shrinkage parameter when <code>type.init="bst"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p> only used if <code>lambda=NULL</code>, a logical value used to    determine regularization path direction either from lambda_max to a potentially modified lambda_min or vice versa if <code>type.init="bst","heu"</code>. Since this is a nonconvex optimization, it is possible to generate different estimates for the same <code>lambda</code> depending on <code>decreasing</code>.  The choice of <code>decreasing</code> picks different starting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of iteration in the MM algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Within each MM algorithm iteration, maximum number of coordinate  descent iterations for each <code>lambda</code> value; default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>convergency criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>If a coefficient is less than <code>eps</code> in magnitude, then it is reported to be 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epscycle</code></td>
<td>
<p> If <code>nlambda</code> &gt; 1 and the relative loss values from two consecutive <code>lambda</code> values change &gt; <code>epscycle</code>, then re-estimate parameters in an effort to avoid trap of local optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Defaults value is <code>1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>Type of regularization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>If <code>TRUE</code>, fitting progress is reported</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The sequence of robust models implied by <code>lambda</code> is fit by majorization-minimization along with coordinate
descent. Note that the objective function is </p>
<p style="text-align: center;"><code class="reqn">weights*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=FALSE</code> and </p>
<p style="text-align: center;"><code class="reqn">\frac{weights}{\sum(weights)}*loss + \lambda*penalty,</code>
</p>
<p> if <code>standardize=TRUE</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"nclreg"</code> for the various types of models.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that produced the model fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x length(lambda)</code> matrix of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p> if <code>lambda</code> is an increasing sequence or not, used to determine regularization path direction either from lambda_max to a potentially modified lambda_min or vice versa if <code>type.init="bst", "heu"</code>. </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Zhu Wang &lt;zwang145@uthsc.edu&gt;</p>


<h3>References</h3>

<p>Zhu Wang (2021),
<em>MM for Penalized Estimation</em>,
<em>TEST</em>,
doi: <a href="https://doi.org/10.1007/s11749-021-00770-2">10.1007/s11749-021-00770-2</a>
</p>


<h3>See Also</h3>

<p><code>nclreg</code></p>


</div>