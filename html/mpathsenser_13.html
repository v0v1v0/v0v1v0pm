<div class="container">

<table style="width: 100%;"><tr>
<td>decrypt_gps</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Decrypt GPS data from a curve25519 public key</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
</p>
<p>By default, the latitude and longitude of the GPS data collected by m-Path Sense are encrypted
using an asymmetric curve25519 key to provide extra protection for these highly sensitive data.
This function takes a character vector and decrypts its longitude and latitude columns using the
provided <code>key</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">decrypt_gps(data, key, ignore = ":")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A character vector containing hexadecimal (i.e. encrypted) data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key</code></td>
<td>
<p>A curve25519 private key.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore</code></td>
<td>
<p>A string with characters to ignore from <code>data</code>. See <code>sodium::hex2bin()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of doubles of the decrypted GPS coordinates.
</p>


<h3>Parallel</h3>

<p>This function supports parallel processing in the sense that it is able to
distribute it's computation load among multiple workers. To make use of this functionality, run
<a href="https://rdrr.io/cran/future/man/plan.html"><code>future::plan("multisession")</code></a> before
calling this function.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(dplyr)
library(sodium)
# Create some GPS  coordinates.
data &lt;- data.frame(
  participant_id = "12345",
  time = as.POSIXct(c(
    "2022-12-02 12:00:00",
    "2022-12-02 12:00:01",
    "2022-12-02 12:00:02"
  )),
  longitude = c("50.12345", "50.23456", "50.34567"),
  latitude = c("4.12345", "4.23456", "4.345678")
)

# Generate keypair
key &lt;- sodium::keygen()
pub &lt;- sodium::pubkey(key)

# Encrypt coordinates with pubkey
# You do not need to do this for m-Path Sense
# as this is already encrypted
encrypt &lt;- function(data, pub) {
  data &lt;- lapply(data, charToRaw)
  data &lt;- lapply(data, function(x) sodium::simple_encrypt(x, pub))
  data &lt;- lapply(data, sodium::bin2hex)
  data &lt;- unlist(data)
  data
}
data$longitude &lt;- encrypt(data$longitude, pub)
data$latitude &lt;- encrypt(data$latitude, pub)

# Once the data has been collected, decrypt it using decrypt_gps().
data |&gt;
  mutate(longitude = decrypt_gps(longitude, key)) |&gt;
  mutate(latitude = decrypt_gps(latitude, key))

</code></pre>


</div>