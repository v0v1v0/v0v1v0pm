<div class="container">

<table style="width: 100%;"><tr>
<td>mpm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spectral Map Analysis</h2>

<h3>Description</h3>

<p>Produces an object of class <code>mpm</code> that allows for exploratory
multivariate analysis of large data matrices, such as gene expression data
from microarray experiments.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mpm(
  data,
  logtrans = TRUE,
  logrepl = 1e-09,
  center = c("double", "row", "column", "global", "none"),
  normal = c("global", "row", "column", "none"),
  closure = c("none", "row", "column", "global", "double"),
  row.weight = c("constant", "mean", "median", "max", "logmean", "RW"),
  col.weight = c("constant", "mean", "median", "max", "logmean", "CW"),
  CW = rep(1, ncol(data) - 1),
  RW = rep(1, nrow(data)),
  pos.row = rep(FALSE, nrow(data)),
  pos.column = rep(FALSE, ncol(data) - 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame with the row descriptors in the first column. For
microarray data rows indicate genes and columns biological samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logtrans</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, data are first
transformed to logarithms (base e) before the other operations.
Non-positive numbers are replaced by <code>logrepl</code>. If <code>FALSE</code>, data
are left unchanged. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logrepl</code></td>
<td>
<p>an optional numeric value that replaces non-positive numbers
in log-transformations. Defaults to <code>1e-9</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>optional character string specifying the centering operation
that is carried out on the optionally log-transformed, closed data matrix.
If <kbd>"double"</kbd> both row- and column-means are subtracted. If
<kbd>"row"</kbd> row-means are subtracted. If <kbd>"column"</kbd> column-means are
subtracted. If <kbd>"none"</kbd> the data are left uncentered. Defaults to
<kbd>"double"</kbd>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normal</code></td>
<td>
<p>optional character string specifying the normalization
operation that is carried out on the optionally log-transformed, closed,
and centered data matrix. If <kbd>"global"</kbd> the data are normalized using
the global standard deviation. If <kbd>"row"</kbd> data are divided by the
standard deviations of the respective row. If <kbd>"column"</kbd> data are
divided by their respective column standard deviation. If <kbd>"none"</kbd> no
normalization is carried out. Defaults to <kbd>"global"</kbd>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>closure</code></td>
<td>
<p>optional character string specifying the closure operation
that is carried out on the optionally log-transformed data matrix. If
<kbd>"double"</kbd>, data are divided by row- and column-totals. If <kbd>"row"</kbd>
data are divided by row-totals. If <kbd>"column"</kbd> data are divided by
column-totals. If <kbd>"none"</kbd> no closure is carried out. Defaults to
<kbd>"none"</kbd>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.weight</code></td>
<td>
<p>optional character string specifying the weights of the
different rows in the analysis. This can be <kbd>"constant"</kbd>,
<kbd>"mean"</kbd>, <kbd>"median"</kbd>, <kbd>"max"</kbd>, <kbd>"logmean"</kbd>, or <kbd>"RW"</kbd>.
If <kbd>"RW"</kbd> is specified, weights must be supplied in the vector
<kbd>RW</kbd>. In other cases weights are computed from the data. Defaults to
<kbd>"constant"</kbd>, i.e. constant weighting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.weight</code></td>
<td>
<p>optional character string specifying the weights of the
different columns in the analysis. This can be <kbd>"constant"</kbd>,
<kbd>"mean"</kbd>, <kbd>"median"</kbd>, <kbd>"max"</kbd>, <kbd>"logmean"</kbd>, or <kbd>"CW"</kbd>.
If <kbd>"CW"</kbd> is specified, weights must be supplied in the vector
<code>CW</code>. In other cases weights are computed from the data. Defaults to
<kbd>"constant"</kbd>, i.e. constant weighting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CW</code></td>
<td>
<p>optional numeric vector with external column weights. Defaults to
1 (constant weights).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RW</code></td>
<td>
<p>optional numeric vector with external row weights. Defaults to 1
(constant weights).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.row</code></td>
<td>
<p>logical vector indicating rows that are not to be included in
the analysis but must be positioned on the projection obtained with the
remaining rows. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.column</code></td>
<td>
<p>logical vector indicating columns that are not to be
included in the analysis but must be positioned on the projection obtained
with the remaining columns. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>mpm</code> presents a unified approach to exploratory
multivariate analysis encompassing principal component analysis,
correspondence factor analysis, and spectral map analysis. The algorithm
computes projections of high dimensional data in an orthogonal space. The
resulting object can subsequently be used in the construction of biplots
(i.e. <code>plot.mpm</code>).
</p>
<p>The projection of the pre-processed data matrix in the orthogonal space is
calculated using the <code>La.svd</code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>mpm</code> representing the projection of data
after the different operations of transformation, closure, centering, and
normalization in an orthogonal space. Generic functions <code>plot</code> and
<code>summary</code> have methods to show the results of the analysis in more
detail. The object consists of the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>TData</code></td>
<td>
<p>matrix with the data after optional log-transformation,
closure, centering and normalization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>character vector
with names of the row elements as supplied in the first column of the
original data matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.names</code></td>
<td>
<p>character vector with the names of
columns obtained from the column names from the original data matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>closure</code></td>
<td>
<p>closure operation as specified in the function call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>centering operation as specified in the function call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normal</code></td>
<td>
<p>normalization operation as specified in the function call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.weight</code></td>
<td>
<p>type of weighting used for rows as specified in the
function call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.weight</code></td>
<td>
<p>type of weighting used for columns as
specified in the function call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Wn</code></td>
<td>
<p>vector with calculated weights
for rows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Wp</code></td>
<td>
<p>vector with calculated weights for columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RM</code></td>
<td>
<p>vector with row means of original data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CM</code></td>
<td>
<p>vector with
column means of original data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.row</code></td>
<td>
<p>logical vector indicating
positioned rows as specified in the function call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.column</code></td>
<td>
<p>logical vector indicating positioned columns as
specified in the function call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SVD</code></td>
<td>
<p>list with components returned
by <code>La.svd</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigen</code></td>
<td>
<p>eigenvalues for each orthogonal factor from
obtained from the weighted singular value decomposition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrib</code></td>
<td>
<p>contributions of each factor to the total variance of the
pre-processed data, i.e. the eigenvalues as a fraction of the total
eigenvalue.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Principal component analysis is defined as the projection onto an
orthogonal space of the column-centered and column-normalized data. In
correspondence factor analysis the data are pre-processed by double
closure, double centering, and global normalization. Orthogonal projection
is carried out using the weighted singular value decomposition. Spectral
map analysis is in essence a principal component analysis on the
log-transformed, double centered and global normalized data. Weighted
spectral map analysis has been proven to be successful in the detection of
patterns in gene expression data (Wouters et al., 2003).
</p>


<h3>Author(s)</h3>

<p>Luc Wouters, Rudi Verbeeck, Tobias Verbeke
</p>


<h3>References</h3>

<p>Wouters, L., Goehlmann, H., Bijnens, L., Kass, S.U.,
Molenberghs, G., Lewi, P.J. (2003). Graphical exploration of gene
expression data: a comparative study of three multivariate methods.
<em>Biometrics</em> <b>59</b>, 1131-1140.
</p>


<h3>See Also</h3>

<p><code>plot.mpm</code>, <code>summary.mpm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  data(Golub)
  # Principal component analysis
  r.pca &lt;- mpm(Golub[,1:39], center = "column", normal = "column")
  # Correspondence factor analysis
  r.cfa &lt;- mpm(Golub[,1:39],logtrans = FALSE, row.weight = "mean",
             col.weight = "mean", closure = "double")
  # Weighted spectral map analysis
  r.sma &lt;- mpm(Golub[,1:39], row.weight = "mean", col.weight = "mean")
</code></pre>


</div>