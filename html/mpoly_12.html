<div class="container">

<table style="width: 100%;"><tr>
<td>as.function.mpolyList</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Change a vector of multivariate polynomials into a function.</h2>

<h3>Description</h3>

<p>Transforms an mpolyList object into a function which can be evaluated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mpolyList'
as.function(x, varorder = vars(x), vector = TRUE,
  silent = FALSE, ..., plus_pad = 1L, times_pad = 1L, squeeze = TRUE)

## S3 method for class 'bezier'
as.function(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class mpoly</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varorder</code></td>
<td>
<p>the order of the variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vector</code></td>
<td>
<p>whether the function should take a vector argument (TRUE) or a
series of arguments (FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>logical; if TRUE, suppresses output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>any additional arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plus_pad</code></td>
<td>
<p>number of spaces to the left and right of plus sign</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times_pad</code></td>
<td>
<p>number of spaces to the left and right of times sign</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>squeeze</code></td>
<td>
<p>minify code in the created function</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>plug()</code>, <code>as.function.mpolyList()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# basic examples
(mpolyList &lt;- mp(c("2 x + 1", "x - z^2")))
(f &lt;- as.function(mpolyList))
f(c(1,2)) # -&gt; (2*1 + 1, 1-2^2) = 3 -3

f &lt;- as.function(mpolyList, varorder = c("x","y","z"))
f(c(1,0,2)) # -&gt; 3 -3
f(c(1,4,2)) # -&gt; 3 -3

f &lt;- as.function(mpolyList, varorder = c("x","y","z"), vector = FALSE)
f(1, 0, 2) # -&gt; 3 -3
f(1, 4, 2) # -&gt; 3 -3



# making a gradient function (useful for optim)
mpoly &lt;- mp("x + y^2 + y z")
mpolyList &lt;- gradient(mpoly)
f &lt;- as.function(mpolyList, varorder = vars(mpoly))
f(c(0,2,3)) # -&gt; 1 7 2



# a univariate mpolyList creates a vectorized function
ps &lt;- mp(c("x", "x^2", "x^3"))
f &lt;- as.function(ps)
f
s &lt;- seq(-1, 1, length.out = 11)
f(s)

# another example
ps &lt;- chebyshev(1:3)
f &lt;- as.function(ps)
f(s)

# the binomial pmf as an algebraic (polynomial) map
# from [0,1] to [0,1]^size
# p |-&gt; {choose(size, x) p^x (1-p)^(size-x)}_{x = 0, ..., size}
abinom &lt;- function(size, indet = "p"){
  chars4mp &lt;- vapply(as.list(0:size), function(x){
    sprintf("%d %s^%d (1-%s)^%d", choose(size, x), indet, x, indet, size-x)
  }, character(1))
  mp(chars4mp)
}
(ps &lt;- abinom(2, "p")) # = mp(c("(1-p)^2", "2 p (1-p)", "p^2"))
f &lt;- as.function(ps)

f(.5) # P[X = 0], P[X = 1], and P[X = 2] for X ~ Bin(2, .5)
dbinom(0:2, 2, .5)

f(.75) # P[X = 0], P[X = 1], and P[X = 2] for X ~ Bin(2, .75)
dbinom(0:2, 2, .75)

# as the degree gets larger, you'll need to be careful when evaluating
# the polynomial.  as.function() is not currently optimized for
# stable numerical evaluation of polynomials; it evaluates them in
# the naive way
all.equal(
  as.function(abinom(10))(.5),
  dbinom(0:10, 10, .5)
)

all.equal(
  as.function(abinom(30))(.5),
  dbinom(0:30, 20, .5)
)


# the function produced is vectorized:
number_of_probs &lt;- 11
probs &lt;- seq(0, 1, length.out = number_of_probs)
(mat &lt;- f(probs))
colnames(mat) &lt;- sprintf("P[X = %d]", 0:2)
rownames(mat) &lt;- sprintf("p = %.2f", s)
mat

</code></pre>


</div>