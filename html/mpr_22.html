<div class="container">

<table style="width: 100%;"><tr>
<td>update.mpr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Update and Re-fit a Multi-Parameter Regression (MPR) Model Call
</h2>

<h3>Description</h3>

<p>Updates the right-hand side of the <code>formula</code> and re-fits the <code>mpr</code> model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mpr'
update(object, new, comp = 1:(object$ncomp), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>an object of class “<code>mpr</code>” which is the result of a call to <code>mpr</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new</code></td>
<td>

<p>either a one-sided <code>formula</code> (in which case the <code>comp</code> argument is also required) or a
<code>list</code> of one-sided <code>formula</code> objects whose length is equal
to the number of regression components in the <code>mpr</code> object, e.g., the Weibull model has two components. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp</code></td>
<td>

<p>a numeric vector indicating the regression component(s) to be updated (only needed when <code>new</code> is
a one-sided <code>formula</code>) where “<code>1</code>” <code class="reqn"> = \lambda</code>, “<code>2</code>”
<code class="reqn"> = \gamma</code> and “<code>3</code>” <code class="reqn"> = \rho</code>.  For more information on the various components,
see <code>mpr</code> and <code>distributions</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments to be passed to the updated <code>mpr</code> call.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There are two ways in whcih the <code>update.mpr</code> function can be used. The first specificies which
component(s) will be updated
(via the <code>comp</code> argument) along with the update to be applied via <code>new</code> which must then be a one-sided
<code>formula</code>. The second approach specifies both the components in question and the updates to be applied
through <code>new</code> which is a <code>list</code> of one-sided <code>formula</code> objects (in this case <code>comp</code>
is ignored). See “Examples” below.
</p>
<p>In the <code>new</code> formula (or list of formulae) . means “what is already there”.
</p>


<h3>Value</h3>

<p>The fitted, updated <code>mpr</code> object.
</p>


<h3>Author(s)</h3>

<p>Kevin Burke.
</p>


<h3>See Also</h3>

<p><code>mpr</code>, <code>addterm</code>, <code>dropterm</code>, <code>stepmpr</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Veterans' administration lung cancer data
veteran &lt;- survival::veteran
head(veteran)

# Weibull MPR treatment model
mod1 &lt;- mpr(Surv(time, status) ~ list(~ trt, ~ trt), data=veteran,
            family="Weibull")

# remove trt from first component
update(mod1, ~ . - trt, comp=1)
update(mod1, list(~ . - trt, ~ .))

# remove trt from both components
update(mod1, ~ . - trt, comp=1:2)
update(mod1, list(~ . - trt, ~ . - trt))

# add celltype to second component
update(mod1, ~ . + celltype, comp=2)
update(mod1, list(~ . , ~ . + celltype))

# simultaneously remove trt from first component and add celltype to second
# component. This is only possible using the approach where "new" is a list. 
update(mod1, list(~ . - trt, ~ . + celltype))

# can also update other things, e.g. "family"
update(mod1, ~ ., family="Gompertz")
update(mod1, ~ . + celltype, family="Loglogistic")

mod2 &lt;- update(mod1, ~ ., family="Burr") # change to Burr model
mod2
update(mod2, ~ . + celltype, comp=2:3) # add celltype to components 2 and 3
</code></pre>


</div>