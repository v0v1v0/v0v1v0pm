<div class="container">

<table style="width: 100%;"><tr>
<td>dctMatrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a n-by-n discrete cosine transform matrix.</h2>

<h3>Description</h3>

<p>The discrete cosine transform (DCT) matrix for a given dimension n is
calculated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dctMatrix(n)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Dimension for the DCT matrix.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The function can be used for 1D- or 2D-DCT transforms of data.
</p>

<ul>
<li> <p><strong>1D:</strong> Let <code>Q</code> be a m-by-n matrix with some data. <code>D</code> is a
m-by-m DCT matrix created by <code>dctMatrix(m)</code>. Then <code>D %*% Q</code> returns the
discrete cosine transform of the columns of Q. <code>t(D) %*% Q</code> returns the
inverse DCT of the columns of Q. As D is orthogonal, <code>solve(D) = t(D)</code>.
</p>
</li>
<li> <p><strong>2D:</strong> Let <code>Q</code> be a m-by-n matrix with some data. <code>D_m</code> is a
m-by-m DCT matrix created by <code>dctMatrix(m)</code>, <code>D_n</code> a n-by-n DCT matrix
created by <code>dctMatrix(n)</code>. <code>D_m %*% Q %*% t(D_n)</code> computes the 2D-DCT
of Q. The inverse 2D-DCT of Q can be computed via <br><code>t(D_mm) %*% DCT_Q %*% D_n</code>.
D_m transforms along columns, D_n along rows. Since D is orthogonal, <code>solve(D) = t(D)</code>.
</p>
</li>
</ul>
<p>It can be faster to use <code>dctMatrix</code> than using a direct transformation,
especially when calculating several DCT's.
</p>


<h3>Value</h3>

<p>The n-by-n DCT matrix.
</p>


<h3>Examples</h3>

<pre><code class="language-R">D &lt;- dctMatrix(5)
</code></pre>


</div>