<div class="container">

<table style="width: 100%;"><tr>
<td>MinLambda</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Numerical optimization for finding appropriate smoothing levels.</h2>

<h3>Description</h3>

<p>Numerical optimization of an objective function <code class="reqn">G</code> is carried out to find 
appropriate signal-dependent smoothing levels (<code class="reqn">\lambda</code>'s). This is easier 
than visual inspection via the signal-dependent tapering function in <code>TaperingPlot</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MinLambda(Xmu, mm, nn, nGrid, nLambda = 2, lambda, sphere = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Xmu</code></td>
<td>
<p>Posterior mean of the input object as a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mm</code></td>
<td>
<p>Number of rows of the original input object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn</code></td>
<td>
<p>Number of columns of the original input object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nGrid</code></td>
<td>
<p>Size of grid where objective function is evaluated (nGrid-by-nGrid).
This argument is ignorded if a sequence <code>lambda</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nLambda</code></td>
<td>
<p>Number of lambdas to minimize over. Possible arguments: 2 (default) or 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p><code class="reqn">\lambda</code>-sequence which is used for optimization. If nothing is provided, <br><code>lambda &lt;- 10^seq(-3, 10, len = nGrid)</code> is used for data on a grid and <br><code>lambda &lt;- 10^seq(-6, 1, len = nGrid)</code> is used for spherical data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sphere</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>: Is the input object defined on a sphere?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>As signal-dependent tapering functions are quiet irregular, it is hard to 
find appropriate smoothing values only by visual inspection of the tapering
function plot. A more formal approach is the numerical optimization of an 
objective function. 
</p>
<p>Optimization can be carried out with 2 or 3 smoothing parameters. As the 
smoothing parameters 0 and <code class="reqn">\infty</code> are always added, this results
in a mrbsizeR analysis with 4 or 5 smoothing parameters. 
</p>
<p>Sometimes, not all features of the input object can be extracted using the 
smoothing levels proposed by <code>MinLambda</code>. It might then be necessary to
include additional smoothing levels. 
</p>
<p><code>plot.minLambda</code> creates a plot of the objective function <code class="reqn">G</code> 
on a grid. The minimum is indicated with a white point. The minimum values of 
the <code class="reqn">\lambda</code>'s can be extracted from the output of <code>MinLambda</code>, 
see examples.
</p>


<h3>Value</h3>

<p>A list with 3 objects:
</p>
<p><code>G</code> Value of objective function <code class="reqn">G</code>.
</p>
<p><code>lambda</code> Evaluated smoothing parameters <code class="reqn">\lambda</code>.
</p>
<p><code>minind</code> Index of minimal <code class="reqn">\lambda</code>'s. <code>lambda</code>[<code>minind</code>] 
gives the minimal values.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Artificial sample data
set.seed(987)
sampleData &lt;- matrix(stats::rnorm(100), nrow = 10)
sampleData[4:6, 6:8] &lt;- sampleData[4:6, 6:8] + 5

# Minimization of two lambdas on a 20-by-20-grid
minlamOut &lt;- MinLambda(Xmu = c(sampleData), mm = 10, nn = 10, 
                       nGrid = 20, nLambda = 2)

# Minimal lambda values
minlamOut$lambda[minlamOut$minind]

</code></pre>


</div>