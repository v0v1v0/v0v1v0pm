<div class="container">

<table style="width: 100%;"><tr>
<td>innerProduct</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pairwise inner product for <code class="reqn">L^2</code> functions</h2>

<h3>Description</h3>

<p>Calculate all pairwise inner products between elements from <code class="reqn">L^2</code> supplied to this function. The integral is approximated by the Trapezoidal rule for uniform grids:
</p>
<p style="text-align: center;"><code class="reqn"> \int_a^b f(x) dx \approx \Delta x \left( \sum_{i=1}^{N-1} f(x_i) + \frac{f(x_N) - f(x_0)}{2} \right) </code>
</p>

<p>whereas <code class="reqn"> \{x_i \}</code> is an uniform grid on <code class="reqn">[a,b]</code> such that <code class="reqn">a = x_0 &lt; x_1 &lt; \ldots &lt; x_N = b</code> and <code class="reqn">\Delta x</code> the step size, i.e. <code class="reqn">\Delta x := x_2 - x_1</code>.
Therefore, it is assumed that the functions are evaluated at the same, equidistant grid.
</p>


<h3>Usage</h3>

<pre><code class="language-R">innerProduct(grid, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>A numeric vector of the uniform grid on which the functions are evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A numeric matrix. Each function has to be a vector stored in a column of <code>data</code> and evaluated at the points of <code>grid</code>.
Thus, the number of rows and columns of <code>data</code> correspond to <code>length(grid)</code> and the number of functions, respectively.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Numeric symmetric matrix containing the approximated pairwise inner products between the functions supplied by <code>data</code>. The entry <code class="reqn">(i,j)</code> of the result is the inner product
between the <code class="reqn">i</code>-th and <code class="reqn">j</code>-th column of <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create orthogonal fourier basis via `fdapace` package
library(fdapace)
basis &lt;- fdapace::CreateBasis(K = 10,
                              type = "fourier")
iP &lt;- innerProduct(grid = seq(0, 1, length.out = 50), # default grid in CreateBasis()
                   data = basis)
round(iP,3)
# Since the basis is orthogonal, the resulting matrix will be the identity matrix.
</code></pre>


</div>