<div class="container">

<table style="width: 100%;"><tr>
<td>mrct.sparse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse minimum regularized covariance trace estimator</h2>

<h3>Description</h3>

<p>Robust outlier detection for sparse functional data as a generalization of the <code>minimum</code> <code>regularized</code> <code>covariance</code> <code>trace</code> (MRCT) estimator (Oguamalam et al. 2023). At first the observations are smoothed
by a B-spline basis and afterwards the MRCT algorithm is performed with the matrix of basis coefficients.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mrct.sparse(
  data,
  nbasis = dim(data)[2],
  new.p = dim(data)[2],
  h = 0.75,
  alpha = 0.01,
  initializations = 5,
  seed = 123,
  scaling.iterations = 10,
  scaling.tolerance = 10^(-4),
  criterion = "sum",
  sum.percentage = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Numeric matrix of a functional data set for which the esimator has to be calculated. Each row contains an observation. They are assumed to be observed on the same (probably sparse) regular grid. The number of grid points must be at least <code>nbasis</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis</code></td>
<td>
<p>Integer. Number of B-spline basis functions for smoothing. The basis will be of order <code class="reqn">4</code> and therefore, cannot contain less than <code class="reqn">4</code> functions. The default value will be set to <code>dim(data)[2]</code>. i.e. the number of time points with a maximum of <code class="reqn">15</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.p</code></td>
<td>
<p>Integer. Length of the grid of the smoothed curves. The resulting grid will be an equidistant partition of <code style="white-space: pre;">⁠[rangeval[1],rangeval[length(rangeval)]]⁠</code>. Default value is <code>dim(data)[2]</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Numeric value between <code class="reqn">0.5</code> and <code class="reqn">1</code>. Ratio of the data which the estimator is based on. Default is set to <code class="reqn">0.75</code>, i.e. <code class="reqn">75\%</code> of the data will be used for the estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric (default is <code class="reqn">0.01</code>). Tikhonov regularization parameter <code class="reqn">\alpha</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initializations</code></td>
<td>
<p>Integer (default is <code class="reqn">5</code>). Number of random initial subsets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Integer (default is <code class="reqn">123</code>). Random seed for reproducibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling.iterations</code></td>
<td>
<p>Integer (default is <code class="reqn">5</code>). The maximum number of times <code class="reqn">k_1</code> is re-scaled if the error between subsequent
scalingparameters does not fall below <code>scaling.tolerance</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling.tolerance</code></td>
<td>
<p>Numeric (default is <code class="reqn">10^{-4}</code>). The error tolerance for re-scaling. If the error falls below this value, the re-scaling procedure stops.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>Character. Criterion based on which the optimal subset is chosen among the final subsets. Possible options are: "<code>cluster</code>" and the default "<code>sum</code>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sum.percentage</code></td>
<td>
<p>Numeric value between <code class="reqn">0.5</code> and <code class="reqn">1</code>. Corresponding to the "<code>sum</code>" criterion. Determines the fraction of observations up to which the sum over the sorted functional Mahalanobis distances is calculated (in ascending order). Default is set to <code class="reqn">0.75</code>, i.e. the sum of the smallest <code class="reqn">75\%</code> of Mahalanobis distances is calculated. If outliers are present, this value should not be to high, in order not to include any outlying curves.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with two entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mrct.output</code></td>
<td>
<p>List. The same output as the function <code>mrct()</code>. For more details, see there.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.smooth</code></td>
<td>
<p>Numeric matrix. Collection of the smoothed curves of <code>data</code> with <code>dim(data)[1]</code> rows and <code>new.p</code> columns. Each row corresponds to one observation.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Oguamalam J, Radojičić U, Filzmoser P (2023).
“Minimum regularized covariance trace estimator and outlier detection for functional data.”
<a href="https://doi.org/10.48550/arXiv.2307.13509">https://doi.org/10.48550/arXiv.2307.13509</a>..
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Fix seed for reproducibility
set.seed(123)

# Sample outlying indices
cont.ind &lt;- sample(1:50,size=10)

# Generate 50 sparse curves on the interval [0,1] at 10 timepoints with 20% outliers
y &lt;- mrct.rgauss(x.grid=seq(0,1,length.out=10), N=50, model=1,
                 outliers=cont.ind, method="linear")

# Visualize curves (regular curves grey, outliers black)
colormap &lt;- rep("grey",50); colormap[cont.ind] &lt;- "black"
matplot(x = seq(0,1,length.out=10), y = t(y), type="l", lty="solid",
        col=colormap, xlab="t",ylab="")

# Run sparse MRCT
sparse.mrct.y &lt;- mrct.sparse(data = y, nbasis = 10, h = 0.75, new.p = 50,
                             alpha = 0.1, initializations = 10, criterion = "sum" )

# Visualize smoothed functions
matplot(x=seq(0,1,length.out=50), y=t(sparse.mrct.y$data.smooth),
        type="l", lty="solid", col=colormap, xlab="t", ylab="")

# Visualize alpha-Mahalanobis distance with cutoff (horizontal black line)
# Colors correspond to simulated outliers, shapes to estimated (sparse MRCT) ones
# (circle regular and triangle irregular curves)
shapemap &lt;- rep(1,50); shapemap[sparse.mrct.y$mrct.output$theoretical.w] &lt;- 2
plot(x = 1:50, y = sparse.mrct.y$mrct.output$aMHD.w, col=colormap, pch = shapemap,
     xlab = "Index", ylab = expression(alpha*"-MHD"))
abline(h = sparse.mrct.y$mrct.output$quant.w)

# If you dont have any information on possible outliers,
# alternatively you could use the S3 method plot.mrctsparse()
mrct.sparse.plot(mrct.sparse.object = sparse.mrct.y)
</code></pre>


</div>