<div class="container">

<table style="width: 100%;"><tr>
<td>detfct.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit detection function using key-adjustment functions</h2>

<h3>Description</h3>

<p>Fit detection function to observed distances using the key-adjustment
function approach.  If adjustment functions are included it will alternate
between fitting parameters of key and adjustment functions and then all
parameters much like the approach in the CDS and MCDS Distance FORTRAN code.
To do so it calls <code>detfct.fit.opt</code> which uses the R optim function
which does not allow non-linear constraints so inclusion of adjustments does
allow the detection function to be non-monotone.
</p>


<h3>Usage</h3>

<pre><code class="language-R">detfct.fit(ddfobj, optim.options, bounds, misc.options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ddfobj</code></td>
<td>
<p>detection function object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.options</code></td>
<td>
<p>control options for optim</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>bounds for the parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>misc.options</code></td>
<td>
<p>miscellaneous options</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>fitted detection function model object with the following list
structure </p>
<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>final parameter vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>final negative
log likelihood value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p>number of function evaluations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>see codes in optim</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>string about
convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>hessian evaluated at final parameter values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aux</code></td>
<td>
<p> a list with 20 elements </p>
 <ul>
<li>
<p> maxit: maximum number
of iterations allowed for optimization </p>
</li>
<li>
<p> lower: lower bound values for
parameters </p>
</li>
<li>
<p> upper: upper bound values for parameters </p>
</li>
<li>
<p> setlower:
TRUE if they are user set bounds </p>
</li>
<li>
<p> setupper: TRUE if they are user set
bounds </p>
</li>
<li>
<p> point: TRUE if point counts and FALSE if line transect </p>
</li>
<li>
<p>int.range: integration range values </p>
</li>
<li>
<p> showit: integer value that
determines information printed during iteration </p>
</li>
<li>
<p> silent: option 
to silence errors from detfct.fit.opt </p>
</li>
<li>
<p> integral.numeric
if TRUE compute logistic integrals numerically </p>
</li>
<li>
<p>breaks: breaks in distance for defined fixed bins for analysis </p>
</li>
<li>
<p>maxiter: maximum iterations used </p>
</li>
<li>
<p> refit: if TRUE, detection function
will be fitted more than once if parameters are at a boundary or when
convergence is not achieved </p>
</li>
<li>
<p> nrefits: number of refittings
</p>
</li>
<li>
<p> mono: if TRUE monotonicity will be enforced </p>
</li>
<li>
<p>mono.strict: if TRUE, then strict monotonicity is enforced; otherwise weak
</p>
</li>
<li>
<p> width: radius of point count or half-width of strip </p>
</li>
<li>
<p>standardize: if TRUE, detection function is scaled so g(0)=1 </p>
</li>
<li>
<p> ddfobj:
distance detection function object; see <code>create.ddfobj</code> </p>
</li>
<li>
<p>bounded: TRUE if parameters ended up a boundary (I think) </p>
</li>
<li>
<p> model:
list of formulas for detection function model (probably can remove this)
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Dave Miller; Jeff Laake
</p>


</div>