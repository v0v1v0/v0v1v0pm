<div class="container">

<table style="width: 100%;"><tr>
<td>detfct.fit.opt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit detection function using key-adjustment functions</h2>

<h3>Description</h3>

<p>Fit detection function to observed distances using the key-adjustment
function approach. If adjustment functions are included it will alternate
between fitting parameters of key and adjustment functions and then all
parameters much like the approach in the CDS and MCDS Distance FORTRAN code.
This function is called by the driver function <code>detfct.fit</code>, then
calls <code>optimx</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">detfct.fit.opt(ddfobj, optim.options, bounds, misc.options, fitting = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ddfobj</code></td>
<td>
<p>detection function object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.options</code></td>
<td>
<p>control options for optim</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>bounds for the parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>misc.options</code></td>
<td>
<p>miscellaneous options</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitting</code></td>
<td>
<p>character string with values "all","key","adjust" to
determine which parameters are allowed to vary in the fitting</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>fitted detection function model object with the following list
structure </p>
<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>final parameter vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>final negative
log likelihood value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p>number of function evaluations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>see codes in optim</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>string about
convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>hessian evaluated at final parameter values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aux</code></td>
<td>
<p> a list with 20 elements </p>
 <ul>
<li>
<p> maxit: maximum number
of iterations allowed for optimization </p>
</li>
<li>
<p> lower: lower bound values for
parameters </p>
</li>
<li>
<p> upper: upper bound values for parameters </p>
</li>
<li>
<p> setlower:
TRUE if they are user set bounds </p>
</li>
<li>
<p> setupper: TRUE if they are user set
bounds </p>
</li>
<li>
<p> point: TRUE if point counts and FALSE if line transect </p>
</li>
<li>
<p>int.range: integration range values </p>
</li>
<li>
<p> showit: integer value that
determines information printed during iteration </p>
</li>
<li>
<p> integral.numeric
if TRUE compute logistic integrals numerically </p>
</li>
<li>
<p>breaks: breaks in distance for defined fixed bins for analysis </p>
</li>
<li>
<p>maxiter: maximum iterations used </p>
</li>
<li>
<p> refit: if TRUE, detection function
will be fitted more than once if parameters are at a boundary or when
convergence is not achieved </p>
</li>
<li>
<p> nrefits: number of refittings
</p>
</li>
<li>
<p> mono: if TRUE, monotonicity will be enforced </p>
</li>
<li>
<p>mono.strict: if TRUE, then strict monotonicity is enforced; otherwise weak
</p>
</li>
<li>
<p> width: radius of point count or half-width of strip </p>
</li>
<li>
<p>standardize: if TRUE, detection function is scaled so g(0)=1 </p>
</li>
<li>
<p> ddfobj:
distance detection function object; see <code>create.ddfobj</code> </p>
</li>
<li>
<p>bounded: TRUE if estimated parameters are at the bounds </p>
</li>
<li>
<p> model:
list of formulas for detection function model (probably can remove this)
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Dave Miller; Jeff Laake; Lorenzo Milazzo
</p>


</div>