<div class="container">

<table style="width: 100%;"><tr>
<td>distpdf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Detection functions</h2>

<h3>Description</h3>

<p>Various functions used to specify key and adjustment functions for
detection functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">detfct(distance, ddfobj, select=NULL, index=NULL, width=NULL,
              standardize = TRUE, stdint=FALSE, left=0)

adjfct.cos(distance, scaling = 1, adj.order, adj.parm = NULL, adj.exp=FALSE)

adjfct.poly(distance, scaling = 1, adj.order, adj.parm = NULL, adj.exp=FALSE)

adjfct.herm(distance, scaling = 1, adj.order, adj.parm = NULL, adj.exp=FALSE)

scalevalue(key.scale, z)

keyfct.hn(distance, key.scale)

keyfct.hz(distance, key.scale, key.shape)

keyfct.gamma(distance, key.scale, key.shape)

fx(distance,ddfobj,select=NULL,index=NULL,width=NULL,
   standardize=TRUE,stdint=FALSE, left=0)

fr(distance,ddfobj,select=NULL,index=NULL,width=NULL,
   standardize=TRUE,stdint=FALSE)

distpdf(distance,ddfobj,select=NULL,index=NULL,width=NULL,standardize=TRUE,
           stdint=FALSE,point=FALSE, left=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>vector of distances</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ddfobj</code></td>
<td>
<p>distance sampling object (see <code>create.ddfobj</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p>logical vector for selection of data values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>specific data row index</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>(right) truncation width</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>logical used to decide whether to divide through by the
function evaluated at 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stdint</code></td>
<td>
<p>logical used to decide whether integral is standardized</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>point</code></td>
<td>
<p>if TRUE, point counts; otherwise line transects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>left</code></td>
<td>
<p>(left) truncation distance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>design matrix for scale function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key.scale</code></td>
<td>
<p>vector of scale values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key.shape</code></td>
<td>
<p>vector of shape values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.order</code></td>
<td>
<p>vector of adjustment orders</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.parm</code></td>
<td>
<p>vector of adjustment parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>the scaling for the adjustment terms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.exp</code></td>
<td>
<p>if TRUE uses exp(adj) for adjustment to keep f(x)&gt;0</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Multi-covariate detection functions (MCDS) are represented by a function
<code class="reqn">g(x,w,\theta)</code> where x is distance, z is a set of covariates and
<code class="reqn">\theta</code> is the parameter vector.  The functions are defined such that
<code class="reqn">g(0,w,\theta)=1</code> and the covariates modify the scale <code class="reqn">(x/\sigma)</code>
where a log link is used to relate <code class="reqn">\sigma</code> to the covariates,
<code class="reqn">\sigma=exp(\theta*w)</code>. A CDS function is obtained with a constant
<code class="reqn">\sigma</code> which is equivalent to an intercept  design matrix, z.
</p>
<p><code>detfct</code> will call either a gamma, half-normal, hazard-rate or uniform
function only returning the probability of detection at that distance. In
addition to the simple model above, we may specify adjustment terms to fit
the data better. These adjustments are either Cosine, Hermite and simple
polynomials. These are specified as arguments to <code>detfct</code>, as detailed
below.
</p>
<p><code>detfct</code> function which calls the others and assembles the final result
using either key(x)[1+series(x)] or
(key(x)[1+series(x)])/(key(0)[1+series(0)]) (depending on the value of
<code>standardize</code>).
</p>
<p><code>keyfct.*</code> functions calculate key function values and <code>adjfct.*</code>
calculate adjustment term values.
</p>
<p><code>scalevalue</code> for either detection function it computes the scale with
the log link using the parameters and the covariate design matrix
</p>
<p><code>fx</code>, <code>fr</code> non-normalized probability density for line transects
and point counts respectively
</p>


<h3>Value</h3>

<p>For <code>detfct</code>, the value is a vector of detection probabilities
For <code>keyfct.*</code>, vector of key function evaluations
For <code>adjfct.*</code>, vector of adjustment series evaluations
For <code>scalevalue</code>, vector of the scale parameters.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake, David L Miller
</p>


<h3>References</h3>

<p>Marques, F. F. C., &amp; Buckland, S. T. (2003). Incorporating covariates into
standard line transect analyses. Biometrics, 59(4), 924-935.
</p>
<p>Buckland, S. T., Anderson, D. R., Burnham, K. P., Laake, J. L., Borchers, D.
L., &amp; Thomas, L. (2004). Advanced Distance Sampling. Oxford University
Press, Oxford, UK.
</p>
<p>Becker, E. F. and P. X. Quang. 2009. A gamma-shaped detection function for
line transect surveys with mark-recapture and covariate data. Journal of
Agricultural Biological and Environmental Statistics 14:207-223.
</p>


<h3>See Also</h3>

<p><code>mcds</code>,  <code>cds</code>
</p>


</div>