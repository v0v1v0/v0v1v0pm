<div class="container">

<table style="width: 100%;"><tr>
<td>rmrf2d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sampling of Markov Random Fields on 2d lattices</h2>

<h3>Description</h3>

<p>Performs pixelwise updates based on conditional distributions
to sample from a Markov random field.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rmrf2d(
  init_Z,
  mrfi,
  theta,
  cycles = 60,
  sub_region = NULL,
  fixed_region = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>init_Z</code></td>
<td>
<p>One of two options:
</p>

<ul>
<li>
<p> A <code>matrix</code> object with the initial field configuration. Its
valuesmust be integers in <code style="white-space: pre;">⁠{0,...,C}⁠</code>.
</p>
</li>
<li>
<p> A length 2 <code>numeric</code> vector with the lattice dimensions.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mrfi</code></td>
<td>
<p>A <code>mrfi</code> object representing the
interaction structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>A 3-dimensional array describing potentials. Slices represent
interacting positions, rows represent pixel values and columns represent
neighbor values. As an example: <code>theta[1,3,2]</code> has the potential for the
pair of values 0,2 observed in the second relative position of <code>mrfi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cycles</code></td>
<td>
<p>The number of updates to be done (for each each pixel).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub_region</code></td>
<td>
<p><code>NULL</code> if the whole lattice is considered or a <code>logical</code>
<code>matrix</code> with <code>TRUE</code> for pixels in the considered region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_region</code></td>
<td>
<p><code>NULL</code> if the whole lattice is to be sampled or a
<code>logical</code> <code>matrix</code> with <code>TRUE</code> for pixels to be considered fixed. Fixed
pixels are not updated in the Gibbs Sampler.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function implements a Gibbs Sampling scheme to sample from
a Markov random field by iteratively sampling pixel values from the
conditional distribution
</p>
<p style="text-align: center;"><code class="reqn">P(Z_i | Z_{{N}_i}, \theta).</code>
</p>

<p>A cycle means exactly one update to each pixel. The order pixels are
sampled is randomized within each cycle.
</p>
<p>If <code>init_Z</code> is passed as a length 2 vector with lattice dimensions, the
initial field is sampled from independent discrete uniform distributions in
<code style="white-space: pre;">⁠{0,...,C}⁠</code>. The value of C is obtained from the number of rows/columns of
<code>theta</code>.
</p>
<p>A MRF can be sampled in a non-rectangular region of the lattice with the use of
the <code>sub_region</code> argument or by setting pixels to <code>NA</code> in the initial
configuration <code>init_Z</code>. Pixels with <code>NA</code> values in <code>init_Z</code> are completely
disconsidered from the conditional probabilities and have the same effect as
setting <code>sub_region = is.na(init_Z)</code>. If <code>init_Z</code> has <code>NA</code> values,
<code>sub_region</code> is ignored and a warning is produced.
</p>
<p>A specific region can be kept constant during the Gibbs Sampler by using the
<code>fixed_region</code> argument. Keeping a subset of pixels constant is useful when
you want to sample in a specific region of the image conditional to the
rest, for example, in texture synthesis problems.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with the sampled field.
</p>


<h3>Note</h3>

<p>As in any Gibbs Sampling scheme, a large number of cycles may be
required to achieve the target distribution, specially for strong
interaction systems.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>
<p><code>rmrf2d_mc</code> for generating multiple points of a
Markov Chain to be used in Monte-Carlo methods.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Sample using specified lattice dimension
Z &lt;- rmrf2d(c(150,150), mrfi(1), theta_potts)

#Sample using itial configuration

Z2 &lt;- rmrf2d(Z, mrfi(1), theta_potts)

# View results
dplot(Z)
dplot(Z2)

# Using sub-regions
subreg &lt;- matrix(TRUE, 150, 150)
subreg &lt;- abs(row(subreg) - 75) + abs(col(subreg) - 75) &lt;= 80
# view the sub-region
dplot(subreg)

Z3 &lt;- rmrf2d(c(150,150), mrfi(1), theta_potts, sub_region = subreg)
dplot(Z3)

# Using fixed regions
fixreg &lt;- matrix(as.logical(diag(150)), 150, 150)
# Set initial configuration: diagonal values are 0.
init_Z4 &lt;- Z
init_Z4[fixreg] &lt;- 0

Z4 &lt;- rmrf2d(init_Z4, mrfi(1), theta_potts, fixed_region = fixreg)
dplot(Z4)

# Combine fixed regions and sub-regions
Z5 &lt;- rmrf2d(init_Z4, mrfi(1), theta_potts,
fixed_region = fixreg, sub_region = subreg)
dplot(Z5)


</code></pre>


</div>