<div class="container">

<table style="width: 100%;"><tr>
<td>bagdistance</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bagdistance of points relative to a dataset</h2>

<h3>Description</h3>

<p>Computes the bagdistance of <code class="reqn">p</code>-dimensional points <code>z</code> relative to a <code class="reqn">p</code>-dimensional dataset <code>x</code>. To compute the bagdistance of a point <code class="reqn">z_i</code> first the bag of <code>x</code> is computed as the depth region containing the 50% observations (of <code>x</code>) with largest halfspace depth. Next, the ray from the halfspace median <code class="reqn">\theta</code> through <code class="reqn">z_i</code> is considered and <code class="reqn">c_z</code> is defined as the intersection of this ray and the boundary of the bag. The bagdistance of <code class="reqn">z_i</code> to <code>x</code> is then given by the ratio between the Euclidean distance of <code class="reqn">z_i</code> to the halfspace median and the Euclidean distance of <code class="reqn">c_z</code> to the halfspace median.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bagdistance(x, z = NULL, options = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>An optional <code class="reqn">m</code> by <code class="reqn">p</code> matrix containing
rowwise the points <code class="reqn">z_i</code> for which to compute
the bagdistance. If <code>z</code> is not specified,
it is set equal to <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>A list of available options:
</p>

<ul>
<li> <p><code>approx</code> <br>
In two dimensions one may choose to use an approximate algorithm or the exact algorithm to find the bag. <br>
Defaults to <code>TRUE</code>.

</p>
</li>
<li> <p><code>max.iter</code> <br>
The maximum number of steps in the bisection algorithm to find the intersection point <code class="reqn">c_z</code> (see Details).<br>
Defaults to <code class="reqn">100</code>.

</p>
</li>
<li>
<p>All options may be specified that are passed to the <code>hdepth</code> function, see <code>hdepth</code> for details. Note that the option parameter <code>approx</code> is by default set to <code>TRUE</code> to save computation time.</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The bagdistance has been introduced in Hubert et al. (2015) and studied in Hubert et al. (2017). It does not assume symmetry and is affine invariant. Note that when the halfspace is not computed in an affine invariant way, the bagdistance cannot be affine invariant either. 
</p>
<p>The function first computes the halfspace depth and the halfspace median of <code>x</code>. Additional options may be passed to the <code>hdepth</code> routine by specifying them in the <code>option</code> list argument.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the subspace and a direction which is orthogonal to it.
</p>
<p>Depending on the dimensions different algorithms are used. For <code class="reqn">p=1</code> the bagdistance is computed exactly. For <code class="reqn">p=2</code> the default setting (<code>options$approx=TRUE</code>) uses an approximated algorithm. Exact computation, based on the exact algoritm to compute the contours of the bag (see the <code>depthContour</code> function), is obtained by setting <code>options$approx</code> to FALSE. Note that this may lead to an increase in computation time. 
</p>
<p>For the approximated algorithm, the intersection point <code class="reqn">c_z</code> is approximated by searching on each ray the point whose depth is equal to the median of the depth values of <code>x</code>. As the halfspace depth is monotone decreasing along the ray, a bisection algorithm is used. Starting limits are obtained by projecting the data on the direction and considering the data point with univariate depth corresponding to the median of the halfspace depths of <code>x</code>. By definition the multivariate depth of this point has to be lower or equal than its univariate depth. A second limit is obtained by considering the deepest location estimate. The maximum number of iterations bisecting the current search interval can be specified through the options argument <code>max.iter</code>. 
</p>
<p>An observation from <code>z</code> is flagged as an outlier if its bagdistance exceeds a cutoff value. This cutoff is equal to the squareroot of the 0.99 quantile of the chi-squared distribution with <code class="reqn">p</code> degrees of freedom.
</p>


<h3>Value</h3>

<p>A list with components: <br></p>
<table>
<tr style="vertical-align: top;">
<td><code>bagdistance</code></td>
<td>
<p>The bagdistance of the points of <code>z</code> with respect to the data matrix <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>Points of <code>z</code> whose bagdistance exceeds this cutoff can be considered as outliers with respect to <code>x</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flag</code></td>
<td>
<p>Points of <code>z</code> whose bagdistance exceeds the cutoff receive a flag equal to <code>FALSE</code>, otherwise they receive a flag <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>Vector of length <code>m</code> indicating for each point of <code>z</code> whether the bisection algorithm converged within the maximum number of steps specified by <code>max.iter</code> in the <code>options</code> list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimension</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, the dimension of this subspace.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hyperplane</code></td>
<td>
<p>When the data <code>x</code> are lying in a lower dimensional subspace, a direction orthogonal to this subspace.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>P. Segaert. </p>


<h3>References</h3>

<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection. <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177–202.
</p>
<p>Hubert M., Rousseeuw P.J., Segaert P. (2017). Multivariate and functional classification using depth and distance. <em>Advances in Data Analysis and Classification</em>, <b>11</b>, 445–466.
</p>


<h3>See Also</h3>

<p><code>depthContour</code>, <code>hdepth</code>, <code>bagplot</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate some bivariate data
set.seed(5)
nObs &lt;- 500
XS &lt;- matrix(rnorm(nObs * 2), nrow = nObs, ncol = 2)
A &lt;- matrix(c(1,1,.5,.1), ncol = 2, nrow = 2)
X &lt;- XS %*% A

# In two dimensions we may either use the approximate
# or the exact algorithm to compute the bag.
respons.exact &lt;- bagdistance(x = X, options = list(approx = FALSE))
respons.approx &lt;- bagdistance(x = X, options = list(approx = TRUE))
# Both algorithms yield fairly similar results.
plot(respons.exact$bagdistance, respons.approx$bagdistance)
abline(a = 0, b = 1)

# In Hubert et al. (2015) it was shown that for elliptical
# distributions the squared bagdistance relates to the 
# squared Mahalanobis distances. This may be easily illustrated.
mahDist &lt;- mahalanobis(x = X, colMeans(X), cov(X))
plot(respons.exact$bagdistance^2, mahDist)

# Computation of the bagdistance relies on the computation
# of halfspace depth using the hdepth function. Options for
# the hdepth routine can be passed down using the options
# arguments. Note that the bagdistance is only affine invariant
# if the halfspace depth is computed in an affine invariant way. 
options &lt;-list(type = "Rotation",
               ndir = 375,
               approx = TRUE,
               seed = 78341)
respons.approx.rot &lt;- bagdistance(x = X, options = options)
plot(respons.exact$bagdistance, respons.approx.rot$bagdistance)
abline(a = 0, b = 1)
</code></pre>


</div>