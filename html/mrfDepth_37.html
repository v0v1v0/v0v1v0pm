<div class="container">

<table style="width: 100%;"><tr>
<td>sprojmedian</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Location estimates based on skewness-adjusted projection depth</h2>

<h3>Description</h3>

<p>Computes a skewness-adjusted projection depth based location estimate of a 
<code class="reqn">p</code>-dimensional dataset <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sprojmedian(x, sprojection.depths = NULL, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix with observations
in the rows and variables in the columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sprojection.depths</code></td>
<td>
<p>Vector containing the skewness-adjusted projection
depth values of the observations in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p> A list of options to pass to the <code>sprojdepth</code> routine.
See <code>sprojdepth</code> for more details. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm depends on the function <code>sprojdepth</code> to compute the
skewness-adjusted projection depth values of the observations in <code>x</code>. 
If these depth have already been
computed they can be passed as an optional argument to save computing time.
If not, the skewness-adjusted projection depth values will be computed and the user 
can pass a list with options to the <code>sprojdepth</code> function.
</p>
<p>It is first checked whether the data lie in a subspace of dimension smaller 
than <code class="reqn">p</code>. If so, a warning is given, as well as the dimension of the 
subspace and a direction which is orthogonal to it.
</p>


<h3>Value</h3>

<p>A list with component: <br></p>
<table><tr style="vertical-align: top;">
<td><code>max</code></td>
<td>
<p>The point of <code>x</code> with maximal skewness-adjusted projection 
depth. If multiple points have maximum depth, their center
of gravity is returned.</p>
</td>
</tr></table>
<h3>Author(s)</h3>

<p>P. Segaert</p>


<h3>References</h3>

<p>Hubert M., Van der Veeken S. (2008). Outlier detection for skewed data. <em>Journal of Chemometrics</em>, <b>22</b>, 235–246.
</p>
<p>Hubert M., Rousseeuw P.J., Segaert P. (2015). Multivariate functional outlier detection. <em>Statistical Methods &amp; Applications</em>, <b>24</b>, 177–202.
</p>


<h3>See Also</h3>

<p><code>adjOutl</code>, <code>sprojdepth</code>, <code>dirOutl</code>, <code>outlyingness</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Compute a location estimate of a two-dimensional dataset.
data(bloodfat)

result &lt;- sprojmedian(x = bloodfat)
plot(bloodfat, pch = 16)
points(result$max, col = "red", pch = 18, cex = 1.5)

# Options for the underlying sprojdepth routine may be passed 
# using the options argument. 
result &lt;- sprojmedian(x = bloodfat,
                      options = list(type = "Rotation",
                                     ndir = 1000
                                     )
                     )
plot(bloodfat, pch = 16)
points(result$max, col = "red", pch = 18, cex = 1.5)

# One may also compute the depth values of the observations in the data
# separately. This avoids having to recompute them when computing the median. 
depth.result &lt;- sprojdepth(x = bloodfat)
result &lt;- sprojmedian(x = bloodfat, 
                      sprojection.depths = depth.result$depthX)
</code></pre>


</div>