<div class="container">

<table style="width: 100%;"><tr>
<td>mou.loglik</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Loglikelihood for multivariate Ornstein-Uhlenbeck process.</h2>

<h3>Description</h3>

<p>Computes the exact Euler loglikelihood for any amount of missing data using a Kalman filter.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mou.loglik(X, dt, nvar.obs, Gamma, Lambda, Phi, mu0, Sigma0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An <code style="white-space: pre;">⁠nobs x ndims⁠</code> matrix of complete data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p>A scalar or length <code>nobs-1</code> vector of interobservations times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvar.obs</code></td>
<td>
<p>A scalar or length <code>nobs</code> vector of integers between 0 and <code>ndims</code> denoting the number of observed SDE variables in each row of <code>data</code>.  Defaults to <code>ndims</code>.  See <code>sde.init()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gamma</code></td>
<td>
<p>A <code style="white-space: pre;">⁠ndims x ndims⁠</code> of linear-drift parameters.  See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda</code></td>
<td>
<p>A length-<code>ndims</code> vector of constant-drift parameters.  See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>A <code style="white-space: pre;">⁠ndims x ndims⁠</code> positive definite variance matrix.  See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu0, Sigma0</code></td>
<td>
<p>Mean and variance of marginal multivariate normal distribution of <code>X[1,]</code>.  Defaults to iid standard normals for each component.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code class="reqn">p</code>-dimensional multivariate Ornstein-Uhlenbeck (mOU) process <code class="reqn">Y_t = (Y_{1t}, \ldots, Y_{dt})</code> satisfies the SDE
</p>
<p style="text-align: center;"><code class="reqn">
dY_t = (\Gamma Y_t + \Lambda)dt + \Phi^{1/2} dB_t,
</code>
</p>

<p>where <code class="reqn">B_t = (B_{1t}, \ldots, B_{pt})</code> is <code class="reqn">p</code>-dimensional Brownian motion.  Its Euler discretization is of the form
</p>
<p style="text-align: center;"><code class="reqn">
Y_{n+1} = Y_n + (\Gamma Y_n + \Lambda) \Delta_n + \Phi^{1/2} \Delta B_n,
</code>
</p>

<p>where <code class="reqn">Y_n = Y(t_n)</code>, <code class="reqn">\Delta_n = t_{n+1} - t_n</code> and
</p>
<p style="text-align: center;"><code class="reqn">
\Delta B_n = B(t_{n+1}) - B(t_n) \stackrel{\textnormal{ind}}{\sim} \mathcal N(0, \Delta_n).
</code>
</p>

<p>Thus, <code class="reqn">Y_0, \ldots, Y_N</code> is multivariate normal Markov chain for which the marginal distribution of any subset of timepoints and/or components can be efficiently calculated using the Kalman filter.  This can be used to check the MCMC output of <code>sde.post()</code> as in the example.
</p>


<h3>Value</h3>

<p>Scalar value of the loglikelihood.  See Details.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# bivariate OU model
bmod &lt;- sde.examples("biou")

# simulate some data

# true parameter values
Gamma0 &lt;- .1 * crossprod(matrix(rnorm(4),2,2))
Lambda0 &lt;- rnorm(2)
Phi0 &lt;- crossprod(matrix(rnorm(4),2,2))
Psi0 &lt;- chol(Phi0) # precompiled model uses the Cholesky scale
theta0 &lt;- c(Gamma0, Lambda0, Psi0[c(1,3,4)])
names(theta0) &lt;- bmod$param.names
# initial value
Y0 &lt;- rnorm(2)
names(Y0) &lt;- bmod$data.names

# simulation
dT &lt;- runif(1, max = .1) # time step
nObs &lt;- 10
bsim &lt;- sde.sim(bmod, x0 = Y0, theta = theta0,
                dt = dT, dt.sim = dT, nobs = nObs)
YObs &lt;- bsim$data

# inference via MCMC
binit &lt;- sde.init(bmod, x = YObs, dt = dT, theta = theta0,
                  nvar.obs = 1) # second component is unobserved
# only Lambda1 is unknown
fixed.params &lt;- rep(TRUE, bmod$nparams)
names(fixed.params) &lt;- bmod$param.names
fixed.params["Lambda1"] &lt;- FALSE
# prior on (Lambda1, Y_0)
hyper &lt;- list(mu = c(0,0), Sigma = diag(2))
names(hyper$mu) &lt;- bmod$data.names
dimnames(hyper$Sigma) &lt;- rep(list(bmod$data.names), 2)

# posterior sampling
nsamples &lt;- 1e5
burn &lt;- 1e3
bpost &lt;- sde.post(bmod, binit, hyper = hyper,
                  fixed.params = fixed.params,
                  nsamples = nsamples, burn = burn)
L1.mcmc &lt;- bpost$params[,"Lambda1"]

# analytic posterior
L1.seq &lt;- seq(min(L1.mcmc), max(L1.mcmc), len = 500)
L1.loglik &lt;- sapply(L1.seq, function(l1) {
  lambda &lt;- Lambda0
  lambda[1] &lt;- l1
  mou.loglik(X = YObs, dt = dT, nvar.obs = 1,
             Gamma = Gamma0, Lambda = lambda, Phi = Phi0,
             mu0 = hyper$mu, Sigma0 = hyper$Sigma)
})
# normalize density
L1.Kalman &lt;- exp(L1.loglik - max(L1.loglik))
L1.Kalman &lt;- L1.Kalman/sum(L1.Kalman)/(L1.seq[2]-L1.seq[1])

# compare
hist(L1.mcmc, breaks = 100, freq = FALSE,
     main = expression(p(Lambda[1]*" | "*bold(Y)[1])),
     xlab = expression(Lambda[1]))
lines(L1.seq, L1.Kalman, col = "red")
legend("topright", legend = c("Analytic", "MCMC"),
       pch = c(NA, 22), lty = c(1, NA), col = c("red", "black"))

</code></pre>


</div>