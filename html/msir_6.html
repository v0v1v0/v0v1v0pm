<div class="container">

<table style="width: 100%;"><tr>
<td>msir</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model-based Sliced Inverse Regression (MSIR)</h2>

<h3>Description</h3>

<p>A dimension reduction method based on Gaussian finite mixture models which provides an extension to sliced inverse regression (SIR). The basis of the subspace is estimated by modeling the inverse distribution within slice using Gaussian finite mixtures with number of components and covariance matrix parameterization selected by BIC or defined by the user.</p>


<h3>Usage</h3>

<pre><code class="language-R">msir(x, y, nslices = msir.nslices, slice.function = msir.slices, 
     modelNames = NULL, G = NULL, cov = c("mle", "regularized"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code class="reqn">(n \times p)</code> design matrix containing the predictors data values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A <code class="reqn">(n \times 1)</code> vector of data values for the response variable. It can be a numeric vector (regression) but also a factor (classification). In the latter case, the levels of the factor define the slices used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nslices</code></td>
<td>
<p>The number of slices used, unless <code>y</code> is a factor. By default the value returned by <code>msir.nslices</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slice.function</code></td>
<td>
<p>The slice functions to be used, by default <code>msir.slices</code>, but the user can provide a different slicing function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelNames</code></td>
<td>
<p>A vector of character strings indicating the Gaussian mixture models to be fitted as described in <code>mclustModelNames</code>. If a  vector of strings is given they are used for all the slices. If a list of vectors is provided then each vector refers to a single slice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>An integer vector specifying the numbers of mixture components used in fitting Gaussian mixture models. If a list of vectors is provided then each vector refers to a single slice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>The predictors marginal covariance matrix. Possible choices are:
</p>

<ul>
<li> <p><code>"mle"</code>: for the maximum likelihood estimate
</p>
</li>
<li> <p><code>"regularized"</code>: for a regularized estimate of the covariance matrix (see <code>msir.regularizedSigma</code>)
</p>
</li>
<li> <p><code>R matrix</code>: a <code class="reqn">(p \times p)</code> user defined covariance matrix
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed to <code>msir.compute</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns an object of class <code>'msir'</code> with attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the design matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slice.info</code></td>
<td>
<p>output from slicing function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mixmod</code></td>
<td>
<p>a list of finite mixture model objects as described in  <code>mclustModel</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>the log-likelihood for the mixture models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>a vector of length equal to the total number of mixture components containing the fraction of observations in each fitted component within slices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a matrix of component within slices predictors means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>the marginal predictors covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>the msir kernel matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evalues</code></td>
<td>
<p>the eigenvalues from the generalized eigen-decomposition of <code>M</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evectors</code></td>
<td>
<p>the raw eigenvectors from the generalized eigen-decomposition of <code>M</code> ordered according to the eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis</code></td>
<td>
<p>the normalized eigenvectors from the generalized eigen-decomposition of <code>M</code> ordered according to the eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.basis</code></td>
<td>
<p>standardized basis vectors obtained by multiplying each coefficient of the eigenvectors by the standard deviation of the corresponding predictor. The resulting coefficients are scaled such that all predictors have unit standard deviation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numdir</code></td>
<td>
<p>the maximal number of directions estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dir</code></td>
<td>
<p>the estimated MSIR directions from mean-centered predictors.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Scrucca, L. (2011) Model-based SIR for dimension reduction. <em>Computational Statistics &amp; Data Analysis</em>, 55(11), 3010-3026.</p>


<h3>See Also</h3>

<p><code>summary.msir</code>, <code>plot.msir</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R"># 1-dimensional simple regression
n &lt;- 200
p &lt;- 5
b &lt;- as.matrix(c(1,-1,rep(0,p-2)))
x &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y &lt;- exp(0.5 * x%*%b) + 0.1*rnorm(n)
MSIR &lt;- msir(x, y)
summary(MSIR)
plot(MSIR, type = "2Dplot")

# 1-dimensional symmetric response curve
n &lt;- 200
p &lt;- 5
b &lt;- as.matrix(c(1,-1,rep(0,p-2)))
x &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y &lt;- (0.5 * x%*%b)^2 + 0.1*rnorm(n)
MSIR &lt;- msir(x, y)
summary(MSIR)
plot(MSIR, type = "2Dplot")
plot(MSIR, type = "coefficients")

# 2-dimensional response curve
n &lt;- 300
p &lt;- 5
b1 &lt;- c(1, 1, 1, rep(0, p-3))
b2 &lt;- c(1,-1,-1, rep(0, p-3))
b &lt;- cbind(b1,b2)
x &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
y &lt;- x %*% b1 + (x %*% b1)^3 + 4*(x %*% b2)^2 + rnorm(n)
MSIR &lt;- msir(x, y)
summary(MSIR)
plot(MSIR, which = 1:2)
## Not run: plot(MSIR, type = "spinplot")
plot(MSIR, which = 1, type = "2Dplot", span = 0.7)
plot(MSIR, which = 2, type = "2Dplot", span = 0.7)
</code></pre>


</div>