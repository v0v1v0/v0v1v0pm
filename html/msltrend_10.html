<div class="container">

<table style="width: 100%;"><tr>
<td>t</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>sample 'msl.forecast' object</h2>

<h3>Description</h3>

<p>Output of call to <code>msl.forecast</code> used extensively in examples throughout
this Manual.
</p>


<h3>Usage</h3>

<pre><code class="language-R">data(t)
</code></pre>


<h3>Format</h3>

<p>msl.forecast object</p>


<h3>Details</h3>

<p>This <code>msl.forecast</code> object is used extensively in the
examples throughout this manual in order to call the object direct rather than
producing the same via original code which can be computationally expensive. This
object results from a decomposition of the Baltimore record, filling gaps with
spline interpolation and using 500 iterations to generate error margins via
bootstrapping (see <code>s</code>). This 'msl.trend' object is then parsed to
<code>msl.forecast</code> with the addition of 1000 millimetres of sea level rise
between the end of the historical record and 2100.
</p>
<p><strong>Note: </strong>Ordinarily the user would call 'File.csv' direct from working
directory, creating the 'msl.trend' object first, then creating the above-mentioned
<code>msl.forecast</code> object using the following sample code:
</p>
<p>s &lt;- msl.trend('Balt.csv', fillgaps = 3, iter = 500, 'BALTIMORE, USA') # DON'T RUN
</p>
<p>t &lt;- msl.forecast(s, slr = 1000) # DON'T RUN
</p>


<h3>See Also</h3>

<p><code>msl.trend</code>, <code>msl.forecast</code>,
<code>msl.plot</code>, <code>msl.pdf</code>, <code>summary</code>,
<code>Balt</code>, <code>s</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(t)
str(t) # check structure of object
</code></pre>


</div>