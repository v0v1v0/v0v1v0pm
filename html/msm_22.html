<div class="container">

<table style="width: 100%;"><tr>
<td>efpt.msm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Expected first passage time</h2>

<h3>Description</h3>

<p>Expected time until first reaching a particular state or set of states in a
Markov model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">efpt.msm(
  x = NULL,
  qmatrix = NULL,
  tostate,
  start = "all",
  covariates = "mean",
  ci = c("none", "normal", "bootstrap"),
  cl = 0.95,
  B = 1000,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code>msm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qmatrix</code></td>
<td>
<p>Instead of <code>x</code>, you can simply supply a transition
intensity matrix in <code>qmatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tostate</code></td>
<td>
<p>State, or set of states supplied as a vector, for which to
estimate the first passage time into.  Can be integer, or character matched
to the row names of the Q matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Starting state (integer).  By default (<code>start="all"</code>),
this will return a vector of expected passage times from each state in turn.
</p>
<p>Alternatively, this can be used to obtain the expected first passage time
from a <em>set</em> of states, rather than single states.  To achieve this,
<code>state</code> is set to a vector of weights, with length equal to the number
of states in the model.  These weights should be proportional to the
probability of starting in each of the states in the desired set, so that
weights of zero are supplied for other states.  The function will calculate
the weighted average of the expected passage times from each of the
corresponding states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>Covariate values defining the intensity matrix for the
fitted model <code>x</code>, as supplied to <code>qmatrix.msm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>If <code>"normal"</code>, then calculate a confidence interval by
simulating <code>B</code> random vectors from the asymptotic multivariate normal
distribution implied by the maximum likelihood estimates (and covariance
matrix) of the log transition intensities and covariate effects.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code>boot.msm</code> for more details of bootstrapping in <span class="pkg">msm</span>.
</p>
<p>If <code>"none"</code> (the default) then no confidence interval is calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>Width of the symmetric confidence interval, relative to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Number of bootstrap replicates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code>boot.msm</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to pass to <code>MatrixExp</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The expected first passage times from each of a set of states
<code class="reqn">\mathbf{i}</code> to to the remaining set of states
<code class="reqn">\overline{\mathbf{i}}</code> in the state space, for a model with
transition intensity matrix <code class="reqn">Q</code>, are
</p>
<p style="text-align: center;"><code class="reqn">-Q_{\mathbf{i},\mathbf{i}}^{-1} \mathbf{1}</code>
</p>

<p>where <code class="reqn">\mathbf{1}</code> is a vector of ones, and
<code class="reqn">Q_{\mathbf{i},\mathbf{i}}</code> is the square subset of <code class="reqn">Q</code>
pertaining to states <code class="reqn">\mathbf{i}</code>.
</p>
<p>It is equal to the sum of mean sojourn times for all states between the
"from" and "to" states in a unidirectional model.  If there is non-zero
chance of reaching an absorbing state before reaching <code>tostate</code>, then
it is infinite.  It is trivially zero if the "from" state equals
<code>tostate</code>.
</p>
<p>This function currently only handles time-homogeneous Markov models.  For
time-inhomogeneous models it will assume that <code class="reqn">Q</code> equals the average
intensity matrix over all times and observed covariates.  Simulation might
be used to handle time dependence.
</p>
<p>Note this is the <em>expectation</em> of first passage time, and the
confidence intervals are CIs for this mean, not predictive intervals for the
first passage time.  The full distribution of the first passage time to a
set of states can be obtained by setting the rows of the intensity matrix
<code class="reqn">Q</code> corresponding to that set of states to zero to make a model where
those states are absorbing.  The corresponding transition probability matrix
<code class="reqn">Exp(Qt)</code> then gives the probabilities of having hit or passed that
state by a time <code class="reqn">t</code> (see the example below). This is implemented in
<code>ppass.msm</code>.
</p>


<h3>Value</h3>

<p>A vector of expected first passage times, or "hitting times", from
each state to the desired state.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Norris, J. R. (1997) Markov Chains. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code>sojourn.msm</code>, <code>totlos.msm</code>,
<code>boot.msm</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
twoway4.q &lt;- rbind(c(-0.5, 0.25, 0, 0.25), c(0.166, -0.498, 0.166, 0.166),
             c(0, 0.25, -0.5, 0.25), c(0, 0, 0, 0))
efpt.msm(qmatrix=twoway4.q, tostate=3)
# given in state 1, expected time to reaching state 3 is infinite
# since may die (state 4) before entering state 3

# If we remove the death state from the model, EFPTs become finite
Q &lt;- twoway4.q[1:3,1:3]; diag(Q) &lt;- 0; diag(Q) &lt;- -rowSums(Q)
efpt.msm(qmatrix=Q, tostate=3)

# Suppose we cannot die or regress while in state 2, can only go to state 3
Q &lt;- twoway4.q; Q[2,4] &lt;- Q[2,1] &lt;- 0; diag(Q) &lt;- 0; diag(Q) &lt;- -rowSums(Q)
efpt.msm(qmatrix=Q, tostate=3)
# The expected time from 2 to 3 now equals the mean sojourn time in 2.
-1/Q[2,2]

# Calculate cumulative distribution of the first passage time
# into state 3 for the following three-state model
Q &lt;- twoway4.q[1:3,1:3]; diag(Q) &lt;- 0; diag(Q) &lt;- -rowSums(Q)
# Firstly form a model where the desired hitting state is absorbing
Q[3,] &lt;- 0
MatrixExp(Q, t=10)[,3]
ppass.msm(qmatrix=Q, tot=10)
# Given in state 1 at time 0, P(hit 3 by time 10) = 0.479
MatrixExp(Q, t=50)[,3]  # P(hit 3 by time 50) = 0.98
ppass.msm(qmatrix=Q, tot=50)


</code></pre>


</div>