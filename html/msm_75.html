<div class="container">

<table style="width: 100%;"><tr>
<td>medists</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Measurement error distributions</h2>

<h3>Description</h3>

<p>Truncated Normal and Uniform distributions, where the response is also
subject to a Normally distributed measurement error.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dmenorm(
  x,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  sderr = 0,
  meanerr = 0,
  log = FALSE
)

pmenorm(
  q,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  sderr = 0,
  meanerr = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

qmenorm(
  p,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  sderr = 0,
  meanerr = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

rmenorm(n, mean = 0, sd = 1, lower = -Inf, upper = Inf, sderr = 0, meanerr = 0)

dmeunif(x, lower = 0, upper = 1, sderr = 0, meanerr = 0, log = FALSE)

pmeunif(
  q,
  lower = 0,
  upper = 1,
  sderr = 0,
  meanerr = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

qmeunif(
  p,
  lower = 0,
  upper = 1,
  sderr = 0,
  meanerr = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

rmeunif(n, lower = 0, upper = 1, sderr = 0, meanerr = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, q</code></td>
<td>
<p>vector of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p>vector of means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>lower truncation point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>upper truncation point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sderr</code></td>
<td>
<p>Standard deviation of measurement error distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanerr</code></td>
<td>
<p>Optional shift for the measurement error distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log, log.p</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as
<code class="reqn">\log(p)</code>, or log density is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;=
x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>vector of probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The normal distribution with measurement error has density
</p>
<p style="text-align: center;"><code class="reqn">
\frac{\Phi(u, \mu_2, \sigma_3) - \Phi(l, \mu_2, \sigma_3)}{\Phi(u, \mu_2, \sigma_3) -
\Phi(l, \mu_2, \sigma_3)} \phi(x, \mu_0 + \mu_\epsilon, \sigma_2)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\sigma_2^2 = \sigma_0^2 + \sigma_\epsilon^2,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_3 = \sigma_0 \sigma_\epsilon / \sigma_2,</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_2 = (x - \mu_\epsilon) \sigma_0^2 + \mu_0 \sigma_\epsilon^2,
</code>
</p>

<p><code class="reqn">\mu_0</code> is the mean of the original Normal distribution before
truncation, <br><code class="reqn">\sigma_0</code> is the corresponding standard deviation,
<br><code class="reqn">u</code> is the upper truncation point, <br><code class="reqn">l</code> is the lower
truncation point, <br><code class="reqn">\sigma_\epsilon</code> is the standard deviation
of the additional measurement error, <br><code class="reqn">\mu_\epsilon</code> is the
mean of the measurement error (usually 0). <br><code class="reqn">\phi(x)</code> is the
density of the corresponding normal distribution, and <br><code class="reqn">\Phi(x)</code> is the distribution function of the corresponding
normal distribution.
</p>
<p>The uniform distribution with measurement error has density
</p>
<p style="text-align: center;"><code class="reqn">(\Phi(x, \mu_\epsilon+l, \sigma_\epsilon) - \Phi(x, \mu_\epsilon+u,
\sigma_\epsilon)) </code>
</p>
<p style="text-align: center;"><code class="reqn"> / (u - l)</code>
</p>

<p>These are calculated from the original truncated Normal or Uniform density
functions <code class="reqn">f(. | \mu, \sigma, l, u)</code> as
</p>
<p style="text-align: center;"><code class="reqn"> \int f(y | \mu, \sigma, l, u) \phi(x, y + \mu_\epsilon, \sigma_\epsilon) dy </code>
</p>

<p>If <code>sderr</code> and <code>meanerr</code> are not specified they assume the default
values of 0, representing no measurement error variance, and no constant
shift in the measurement error, respectively.
</p>
<p>Therefore, for example with no other arguments, <code>dmenorm(x)</code>, is simply
equivalent to <code>dtnorm(x)</code>, which in turn is equivalent to
<code>dnorm(x)</code>.
</p>
<p>These distributions were used by Satten and Longini (1996) for CD4 cell
counts conditionally on hidden Markov states of HIV infection, and later by
Jackson and Sharples (2002) for FEV1 measurements conditionally on states of
chronic lung transplant rejection.
</p>
<p>These distribution functions are just provided for convenience, and are not
optimised for numerical accuracy or speed.  To fit a hidden Markov model
with these response distributions, use a <code>hmmMETNorm</code> or
<code>hmmMEUnif</code> constructor. See the <code>hmm-dists</code> help
page for further details.
</p>


<h3>Value</h3>

<p><code>dmenorm</code>, <code>dmeunif</code> give the density, <code>pmenorm</code>,
<code>pmeunif</code> give the distribution function, <code>qmenorm</code>,
<code>qmeunif</code> give the quantile function, and <code>rmenorm</code>,
<code>rmeunif</code> generate random deviates, for the Normal and Uniform versions
respectively.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Satten, G.A. and Longini, I.M.  Markov chains with measurement
error: estimating the 'true' course of a marker of the progression of human
immunodeficiency virus disease (with discussion) <em>Applied Statistics</em>
45(3): 275-309 (1996)
</p>
<p>Jackson, C.H. and Sharples, L.D. Hidden Markov models for the onset and
progression of bronchiolitis obliterans syndrome in lung transplant
recipients <em>Statistics in Medicine</em>, 21(1): 113â€“128 (2002).
</p>


<h3>See Also</h3>

<p><code>dnorm</code>, <code>dunif</code>, <code>dtnorm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## what does the distribution look like?
x &lt;- seq(50, 90, by=1)
plot(x, dnorm(x, 70, 10), type="l", ylim=c(0,0.06)) ## standard Normal
lines(x, dtnorm(x, 70, 10, 60, 80), type="l")       ## truncated Normal
## truncated Normal with small measurement error
lines(x, dmenorm(x, 70, 10, 60, 80, sderr=3), type="l")

</code></pre>


</div>