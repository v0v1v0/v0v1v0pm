<div class="container">

<table style="width: 100%;"><tr>
<td>msma</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiblock Sparse Partial Least Squares</h2>

<h3>Description</h3>

<p>This is a function for a matrix decomposition method incorporating sparse and supervised modeling for a multiblock multivariable data analysis
</p>


<h3>Usage</h3>

<pre><code class="language-R">msma(X, ...)

## Default S3 method:
msma(
  X,
  Y = NULL,
  Z = NULL,
  comp = 2,
  lambdaX = NULL,
  lambdaY = NULL,
  lambdaXsup = NULL,
  lambdaYsup = NULL,
  eta = 1,
  type = "lasso",
  inX = NULL,
  inY = NULL,
  inXsup = NULL,
  inYsup = NULL,
  muX = 0,
  muY = 0,
  defmethod = "canonical",
  scaling = TRUE,
  verbose = FALSE,
  intseed = 1,
  ceps = 1e-04,
  ...
)

## S3 method for class 'msma'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a matrix or list of matrices indicating the explanatory variable(s). This parameter is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>a matrix or list of matrices indicating objective variable(s). This is optional. If there is no input for Y, then PCA is implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>a vector, response variable(s) for implementing the supervised version of (multiblock) PCA or PLS. This is optional. The length of Z is the number of subjects. If there is no input for Z, then unsupervised PLS/PCA is implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp</code></td>
<td>
<p>numeric scalar for the maximum number of componets to be considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaX</code></td>
<td>
<p>numeric vector of regularized parameters for X, with a length equal to the number of blocks. If lambdaX is omitted, no regularization is conducted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaY</code></td>
<td>
<p>numeric vector of regularized parameters for Y, with a length equal to the number of blocks. If lambdaY is omitted, no regularization is conducted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaXsup</code></td>
<td>
<p>numeric vector of regularized parameters for the super weight of X with length equal to the number of blocks. If omitted, no regularization is conducted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaYsup</code></td>
<td>
<p>numeric vector of regularized parameters for the super weight of Y with length equal to the number of blocks. If omitted, no regularization is conducted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>numeric scalar indicating the parameter indexing the penalty family. This version contains only choice 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a character, indicating the penalty family. In this version, only one choice is available: "lasso."</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inX</code></td>
<td>
<p>a vector or list of numeric vectors specifying the variables in X, always included in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inY</code></td>
<td>
<p>a vector or list of numeric vectors specifying the variables in Y, always included in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inXsup</code></td>
<td>
<p>a (list of) numeric vector to specify the blocks of X which are always in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inYsup</code></td>
<td>
<p>a (list of) numeric vector to specify the blocks of Y which are always in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muX</code></td>
<td>
<p>a numeric scalar for the weight of X for the supervised case. 0 &lt;= muX &lt;= 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muY</code></td>
<td>
<p>a numeric scalar for the weight of Y for the supervised case. 0 &lt;= muY &lt;= 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>defmethod</code></td>
<td>
<p>a character representing the deflation method. This version has only the choice "canonical."</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>a logical, indicating whether or not data scaling is performed. The default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>information</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intseed</code></td>
<td>
<p>seed number for the random number in the parameter estimation algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ceps</code></td>
<td>
<p>a numeric scalar for the convergence condition of the algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class "<code>msma</code>", usually, a result of a call to <code>msma</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>msma</code> requires at least one input X (a matrix or list). In this case, (multiblock) PCA is conducted. If Y is also specified, then a PLS is conducted using X as explanatory variables and Y as objective variables. This function scales each data matrix to a mean of 0 and variance of 1 in the default. The block structure can be represented as a list. If Z is also specified, a supervised version is implemented, and the degree is controlled by muX or muY, where 0 &lt;= muX &lt;= 1, 0 &lt;= muY &lt;= 1, and 0 &lt;= muX + muY &lt; 1. If a positive lambdaX or lambdaY is specified, then a sparse estimation based on the L1 penalty is implemented.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dmode</code></td>
<td>
<p>Which modes "PLS" or "PCA"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Scaled X which has a list form.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Scaled Y which has a list form.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xscale</code></td>
<td>
<p>Scaling information for X. The means and standard deviations for each block of X are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Yscale</code></td>
<td>
<p>Scaling information for Y. The means and standard deviations for each block of Y are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp</code></td>
<td>
<p>the number of componets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wbX</code></td>
<td>
<p>block loading for X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sbX</code></td>
<td>
<p>block score for X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wbY</code></td>
<td>
<p>block loading for Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sbY</code></td>
<td>
<p>block score for Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssX</code></td>
<td>
<p>super score for X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wsX</code></td>
<td>
<p>super loading for X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssY</code></td>
<td>
<p>super score for Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wsY</code></td>
<td>
<p>super loading for Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nzwbX</code></td>
<td>
<p>number of nonzeros in block loading for X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nzwbY</code></td>
<td>
<p>number of nonzeros in block loading for Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nzwsX</code></td>
<td>
<p>number of nonzeros in super loading for X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nzwsY</code></td>
<td>
<p>number of nonzeros in super loading for Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectXnames</code></td>
<td>
<p>names of selected variables for X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectYnames</code></td>
<td>
<p>names of selected variables for Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avX</code></td>
<td>
<p>the adjusted variance of the score for X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avY</code></td>
<td>
<p>the adjusted variance of the score for Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpevX</code></td>
<td>
<p>the cumulative percentage of the explained variance for X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpevY</code></td>
<td>
<p>the cumulative percentage of the explained variance for Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reproduct</code></td>
<td>
<p>Predictivity. Correlation between Y and the predicted Y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictiv</code></td>
<td>
<p>Reproductivity. Correlation between the score for Y and the outcome Z</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">##### data #####
tmpdata = simdata(n = 50, rho = 0.8, Yps = c(10, 12, 15), Xps = 20, seed=1)
X = tmpdata$X; Y = tmpdata$Y 

##### One Component #####
fit1 = msma(X, Y, comp=1, lambdaX=2, lambdaY=1:3)
fit1

##### Two Component #####
fit2 = msma(X, Y, comp=2, lambdaX=2, lambdaY=1:3)
fit2

##### Sparse Principal Component Analysis #####
fit3 = msma(X, comp=5, lambdaX=2.5)
summary(fit3)

</code></pre>


</div>