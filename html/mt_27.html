<div class="container">

<table style="width: 100%;"><tr>
<td>feat.mfs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Multiple Feature Selection
</h2>

<h3>Description</h3>

<p> Multiple feature selection with or without resampling
procedures. </p>


<h3>Usage</h3>

<pre><code class="language-R">feat.mfs(x,y,method,pars = valipars(),is.resam = TRUE, ...)
         
feat.mfs.stab(fs.res,rank.cutoff = 20,freq.cutoff = 0.5)

feat.mfs.stats(fs.stats,cumu.plot=FALSE, main="Stats Plot", 
               ylab="Values", xlab="Index of variable", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> A matrix or data frame containing the explanatory variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p> A factor specifying the class for each observation. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> Multiple feature selection/ranking method to be used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p> A list of resampling scheme. See <code>valipars</code>
for details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.resam</code></td>
<td>
<p> A logical value indicating whether the resampling
should be applied. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs.res</code></td>
<td>
<p> A list obtained by running <code>feat.mfs</code> .</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank.cutoff</code></td>
<td>
<p>Cutoff of top features for frequency calculating.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq.cutoff</code></td>
<td>
<p> Cutoff of feature frequency. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs.stats</code></td>
<td>
<p>A matrix of feature statistics or values outputted by
<code>feat.mfs</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumu.plot</code></td>
<td>
<p> A logical value indicating the cumulative scores
should be plotted. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main,xlab,ylab</code></td>
<td>
<p>Plot parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>feat.mfs.stab</code> summarises multiple feature selection only when
resampling strategy is employed (i.e. <code>is.resam</code> is <code>TRUE</code>
when calling <code>feat.mfs</code>). It obtains these results based on
<code>feat.mfs</code>'s returned value called <code>all</code>.
</p>
<p><code>feat.mfs.stats</code> handles the statistical values or scores. Its
purpose is to provide a guidance in selecting the best number of
features by spotting the elbow point. This method should work in
conjunction with plotting of p-values and their corresponding adjusted
values such as FDR and Bonferroni in the multiple hypothesis test.
</p>


<h3>Value</h3>

<p><code>feat.mfs</code> returns a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fs.order</code></td>
<td>
<p>A data frame of feature order from best to worst.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs.rank</code></td>
<td>
<p>A matrix of feature ranking scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs.stats</code></td>
<td>
<p>A matrix of feature statistics or values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all</code></td>
<td>
<p>A list of output of <code>feat.rank.re</code> for each feature 
selection method.</p>
</td>
</tr>
</table>
<p><code>feat.mfs.stab</code> returns a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fs.freq</code></td>
<td>
<p>Feature frequencies larger than <code>freq.cutoff</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs.subs</code></td>
<td>
<p>Feature with frequencies larger than <code>freq.cutoff</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs.stab</code></td>
<td>
<p>Stability rate of feature ranking.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs.cons</code></td>
<td>
<p>A matrix of feature consensus table based on feature
frequency.</p>
</td>
</tr>
</table>
<p><code>feat.mfs.stats</code> returns a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>stats.tab</code></td>
<td>
<p>A statistical values with their corresponding names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stats.long</code></td>
<td>
<p>Long-format of statistical values for plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stats.p</code></td>
<td>
<p> An object of class "trellis".</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The feature order can be computed directly from the overall statistics
<code>fs.stats</code>. It is, however, slightly different from
<code>fs.order</code> obtained by rank aggregation when resampling is
employed.
</p>
<p>The <code>fs.cons</code> and <code>fs.freq</code> are computed based on
<code>fs.order</code>.
</p>


<h3>Author(s)</h3>

<p> Wanchang Lin  </p>


<h3>See Also</h3>

 <p><code>feat.rank.re</code>, <code>feat.freq</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(lattice)	
data(abr1)
dat &lt;- preproc(abr1$pos[,200:400], method="log10")  
cls &lt;- factor(abr1$fact$class)

tmp &lt;- dat.sel(dat, cls, choices=c("1","2"))
x   &lt;- tmp[[1]]$dat
y   &lt;- tmp[[1]]$cls

fs.method &lt;- c("fs.anova","fs.rf","fs.rfe")
fs.pars   &lt;- valipars(sampling="cv",niter=10,nreps=5)
fs &lt;- feat.mfs(x, y, fs.method, fs.pars)   ## with resampling
names(fs)

## frequency, consensus and stabilities of feature selection 
fs.stab &lt;- feat.mfs.stab(fs)
print(fs.stab$fs.cons,digits=2,na.print="")

## plot feature selection frequency
freq &lt;- fs.stab$fs.freq
dotplot(freq$fs.anova, type="o", main="Feature Selection Frequencies")
barchart(freq$fs.anova)

## rank aggregation 
fs.agg &lt;- feat.agg(fs$fs.rank)

## stats table and plotting
fs.stats &lt;- fs$fs.stats
tmp &lt;- feat.mfs.stats(fs.stats, cumu.plot = TRUE)
tmp$stats.p
fs.tab &lt;- tmp$stats.tab
## convert to matrix
fs.tab &lt;- list2df(un.list(fs.tab))

## without resampling
fs.1 &lt;- feat.mfs(x, y, method=fs.method, is.resam = FALSE)

## End(Not run)
</code></pre>


</div>