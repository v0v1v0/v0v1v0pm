<div class="container">

<table style="width: 100%;"><tr>
<td>mv.util</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Missing Value Utilities
</h2>

<h3>Description</h3>

<p>Functions to handle missing values of data set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mv.stats(dat,grp=NULL,...) 
  
mv.fill(dat,method="mean",ze_ne = FALSE)

mv.zene(dat)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>

<p>A data frame or matrix of data set. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grp</code></td>
<td>

<p>A factor or vector of class.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Univariate imputation method for missing value. For details, see 
examples below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ze_ne</code></td>
<td>
 
<p>A logical value indicating whether the zeros or negatives should be 
treated as missing values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional parameters to <code>mv.stats</code> for plotting using <span class="pkg">lattice</span>.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>mv.fill</code> returns an imputed data frame. 
</p>
<p><code>mv.zene</code> returns an NA-filled data frame.
</p>
<p><code>mv.stats</code> returns a list including the components:
</p>
 
<ul>
<li> <p><code>mv.overall</code>: Overall missng value rate.
</p>
</li>
<li> <p><code>mv.var</code>: Missing value rate per variable (column).
</p>
</li>
<li> <p><code>mv.grp</code>: A matrix of missing value rate for different groups
if argument <code>grp</code> is given.
</p>
</li>
<li> <p><code>mv.grp.plot</code>:  An object of class <code>trellis</code> for plotting  
of <code>mv.grp</code> if argument <code>grp</code> is given.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Wanchang Lin 
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(abr1)
dat &lt;- abr1$pos[,1970:1980]
cls &lt;- factor(abr1$fact$class)

## fill zeros with NAs
dat &lt;- mv.zene(dat)

## missing values summary
mv &lt;- mv.stats(dat, grp=cls) 
plot(mv$mv.grp.plot)

## fill NAs with mean
dat.mean &lt;- mv.fill(dat,method="mean")

## fill NAs with median
dat.median &lt;- mv.fill(dat,method="median")

## -----------------------------------------------------------------------
## fill NAs with user-defined methods: two examples given here.
## a.) Random imputation function:
rand &lt;- function(x,...) sample(x[!is.na(x)], sum(is.na(x)), replace=TRUE)

## test this function:
(tmp &lt;- dat[,1])        ## an vector with NAs
## get the randomised values for NAs
rand(tmp)

## fill NAs with method "rand"
dat.rand &lt;- mv.fill(dat,method="rand")

## b.) "Low" imputation function:
"low" &lt;- function(x, ...) {
  max(mean(x,...) - 3 * sd(x,...), min(x, ...)/2)
}
## fill NAs with method "low"
dat.low &lt;- mv.fill(dat, method="low") 

## summary of imputed data set
df.summ(dat.mean)

</code></pre>


</div>