<div class="container">

<table style="width: 100%;"><tr>
<td>tlgmm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit the binary Gaussian mixture model (GMM) on target data set by leveraging multiple source data sets under a transfer learning (TL) setting.</h2>

<h3>Description</h3>

<p>Fit the binary Gaussian mixture model (GMM) on target data set by leveraging multiple source data sets under a transfer learning (TL) setting. This function implements the modified EM algorithm (Altorithm 4) proposed in Tian, Y., Weng, H., &amp; Feng, Y. (2022).
</p>


<h3>Usage</h3>

<pre><code class="language-R">tlgmm(
  x,
  fitted_bar,
  step_size = c("lipschitz", "fixed"),
  eta_w = 0.1,
  eta_mu = 0.1,
  eta_beta = 0.1,
  lambda_choice = c("fixed", "cv"),
  cv_nfolds = 5,
  cv_upper = 2,
  cv_lower = 0.01,
  cv_length = 5,
  C1_w = 0.05,
  C1_mu = 0.2,
  C1_beta = 0.2,
  C2_w = 0.05,
  C2_mu = 0.2,
  C2_beta = 0.2,
  kappa0 = 1/3,
  tol = 1e-05,
  initial_method = c("kmeans", "EM"),
  iter_max = 1000,
  iter_max_prox = 100,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>design matrix of the target data set. Should be a <code>matrix</code> or <code>data.frame</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted_bar</code></td>
<td>
<p>the output from <code>mtlgmm</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step_size</code></td>
<td>
<p>step size choice in proximal gradient method to solve each optimization problem in the revised EM algorithm (Algorithm 1 in Tian, Y., Weng, H., &amp; Feng, Y. (2022)), which can be either "lipschitz" or "fixed". Default = "lipschitz".
</p>

<ul>
<li>
<p> lipschitz: <code>eta_w</code>, <code>eta_mu</code> and <code>eta_beta</code> will be chosen by the Lipschitz property of the gradient of objective function (without the penalty part). See Section 4.2 of Parikh, N., &amp; Boyd, S. (2014).
</p>
</li>
<li>
<p> fixed: <code>eta_w</code>, <code>eta_mu</code> and <code>eta_beta</code> need to be specified
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta_w</code></td>
<td>
<p>step size in the proximal gradient method to learn w (Step 3 of Algorithm 4 in Tian, Y., Weng, H., &amp; Feng, Y. (2022)). Default: 0.1. Only used when <code>step_size</code> = "fixed".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta_mu</code></td>
<td>
<p>step size in the proximal gradient method to learn mu (Steps 4 and 5 of Algorithm 4 in Tian, Y., Weng, H., &amp; Feng, Y. (2022)). Default: 0.1. Only used when <code>step_size</code> = "fixed".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta_beta</code></td>
<td>
<p>step size in the proximal gradient method to learn beta (Step 7 of Algorithm 4 in Tian, Y., Weng, H., &amp; Feng, Y. (2022)). Default: 0.1. Only used when <code>step_size</code> = "fixed".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_choice</code></td>
<td>
<p>the choice of constants in the penalty parameter used in the optimization problems. See Algorithm 4 of Tian, Y., Weng, H., &amp; Feng, Y. (2022), which can be either "fixed" or "cv". Default = "cv".
</p>

<ul>
<li>
<p> cv: <code>cv_nfolds</code>, <code>cv_upper</code>, and <code>cv_length</code> need to be specified. Then the C1 and C2 parameters will be chosen in all combinations in <code>exp(seq(log(cv_lower/10), log(cv_upper/10), length.out = cv_length))</code> via cross-validation. Note that this is a two-dimensional cv process, because we set <code>C1_w</code> = <code>C2_w</code>, <code>C1_mu</code> = <code>C1_beta</code> = <code>C2_mu</code> = <code>C2_beta</code> to reduce the computational cost.
</p>
</li>
<li>
<p> fixed: <code>C1_w</code>, <code>C1_mu</code>, <code>C1_beta</code>, <code>C2_w</code>, <code>C2_mu</code>, and <code>C2_beta</code> need to be specified. See equations (19)-(24) in Tian, Y., Weng, H., &amp; Feng, Y. (2022).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_nfolds</code></td>
<td>
<p>the number of cross-validation folds. Default: 5</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_upper</code></td>
<td>
<p>the upper bound of <code>lambda</code> values used in cross-validation. Default: 5</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_lower</code></td>
<td>
<p>the lower bound of <code>lambda</code> values used in cross-validation. Default: 0.01</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_length</code></td>
<td>
<p>the number of <code>lambda</code> values considered in cross-validation. Default: 5</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C1_w</code></td>
<td>
<p>the initial value of C1_w. See equations (19) in Tian, Y., Weng, H., &amp; Feng, Y. (2022). Default: 0.05</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C1_mu</code></td>
<td>
<p>the initial value of C1_mu. See equations (20) in Tian, Y., Weng, H., &amp; Feng, Y. (2022). Default: 0.2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C1_beta</code></td>
<td>
<p>the initial value of C1_beta. See equations (21) in Tian, Y., Weng, H., &amp; Feng, Y. (2022). Default: 0.2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C2_w</code></td>
<td>
<p>the initial value of C2_w. See equations (22) in Tian, Y., Weng, H., &amp; Feng, Y. (2022). Default: 0.05</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C2_mu</code></td>
<td>
<p>the initial value of C2_mu. See equations (23) in Tian, Y., Weng, H., &amp; Feng, Y. (2022). Default: 0.2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C2_beta</code></td>
<td>
<p>the initial value of C2_beta. See equations (24) in Tian, Y., Weng, H., &amp; Feng, Y. (2022). Default: 0.2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa0</code></td>
<td>
<p>the decaying rate used in equation (19)-(24) in Tian, Y., Weng, H., &amp; Feng, Y. (2022). Default: 1/3</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>maximum tolerance in all optimization problems. If the difference between last update and the current update is less than this value, the iterations of optimization will stop. Default: 1e-05</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_method</code></td>
<td>
<p>initialization method. This indicates the method to initialize the estimates of GMM parameters for each data set. Can be either "kmeans" or "EM".
</p>

<ul>
<li>
<p> kmeans: the initial estimates of GMM parameters will be generated from the single-task k-means algorithm. Will call <code>kmeans</code> function in <code>stats</code> package.
</p>
</li>
<li>
<p> EM: the initial estimates of GMM parameters will be generated from the single-task EM algorithm. Will call <code>Mclust</code> function in <code>mclust</code> package.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter_max</code></td>
<td>
<p>the maximum iteration number of the revised EM algorithm (i.e. the parameter T in Algorithm 1 in Tian, Y., Weng, H., &amp; Feng, Y. (2022)). Default: 1000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter_max_prox</code></td>
<td>
<p>the maximum iteration number of the proximal gradient method. Default: 100</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>the number of cores to use. Parallel computing is strongly suggested, specially when <code>lambda_choice</code> = "cv". Default: 1</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following components.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>the estimate of mixture proportion in GMMs for the target task. Will be a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu1</code></td>
<td>
<p>the estimate of Gaussian mean in the first cluster of GMMs for the target task. Will be a matrix, where each column represents the estimate for a task.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu2</code></td>
<td>
<p>the estimate of Gaussian mean in the second cluster of GMMs for the target task. Will be a matrix, where each column represents the estimate for a task.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>the estimate of the discriminant coefficient for the target task. Will be a matrix, where each column represents the estimate for a task.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>the estimate of the common covariance matrix for the target task. Will be a list, where each component represents the estimate for a task.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C1_w</code></td>
<td>
<p>the initial value of C1_w.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C1_mu</code></td>
<td>
<p>the initial value of C1_mu.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C1_beta</code></td>
<td>
<p>the initial value of C1_beta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C2_w</code></td>
<td>
<p>the initial value of C2_w.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C2_mu</code></td>
<td>
<p>the initial value of C2_mu.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C2_beta</code></td>
<td>
<p>the initial value of C2_beta.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Tian, Y., Weng, H., &amp; Feng, Y. (2022). Unsupervised Multi-task and Transfer Learning on Gaussian Mixture Models. arXiv preprint arXiv:2209.15224.
</p>
<p>Parikh, N., &amp; Boyd, S. (2014). Proximal algorithms. Foundations and trends in Optimization, 1(3), 127-239.
</p>


<h3>See Also</h3>

<p><code>mtlgmm</code>, <code>predict_gmm</code>, <code>data_generation</code>, <code>initialize</code>, <code>alignment</code>, <code>alignment_swap</code>, <code>estimation_error</code>, <code>misclustering_error</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(0, kind = "L'Ecuyer-CMRG")
## Consider a transfer learning problem with 3 source tasks and 1 target task in the setting "MTL-1"
data_list_source &lt;- data_generation(K = 3, outlier_K = 0, simulation_no = "MTL-1", h_w = 0,
h_mu = 0, n = 50)  # generate the source data
data_target &lt;- data_generation(K = 1, outlier_K = 0, simulation_no = "MTL-1", h_w = 0.1,
h_mu = 1, n = 50)  # generate the target data
fit_mtl &lt;- mtlgmm(x = data_list_source$data$x, C1_w = 0.05, C1_mu = 0.2, C1_beta = 0.2,
C2_w = 0.05, C2_mu = 0.2, C2_beta = 0.2, kappa = 1/3, initial_method = "EM",
trim = 0.1, lambda_choice = "fixed", step_size = "lipschitz")

fit_tl &lt;- tlgmm(x = data_target$data$x[[1]], fitted_bar = fit_mtl, C1_w = 0.05,
C1_mu = 0.2, C1_beta = 0.2, C2_w = 0.05, C2_mu = 0.2, C2_beta = 0.2, kappa0 = 1/3,
initial_method = "EM", ncores = 1, lambda_choice = "fixed", step_size = "lipschitz")


# use cross-validation to choose the tuning parameters
# warning: can be quite slow, large "ncores" input is suggested!!
fit_tl &lt;- tlgmm(x = data_target$data$x[[1]], fitted_bar = fit_mtl, kappa0 = 1/3,
initial_method = "EM", ncores = 2, lambda_choice = "cv", step_size = "lipschitz")

</code></pre>


</div>