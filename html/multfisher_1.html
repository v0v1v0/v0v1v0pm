<div class="container">

<table style="width: 100%;"><tr>
<td>mfisher.test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimal Exact Tests for Multiple Binary Endpoints</h2>

<h3>Description</h3>

<p>Calculates global tests and multiple testing procedures to compare two groups with respect to multiple binary endpoints based on optimal rejection regions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mfisher.test(x, y = NULL, method = c("alpha.greedy", "alpha", "number",
  "power", "bonferroni.greedy"), alpha = 0.025, p1 = NULL, p0 = NULL,
  max.iter = 10^5, limit = 0, show.region = FALSE, closed.test = FALSE,
  consonant = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a data frame of binary response vectors, or an array of numbers of failures and successes in the treatment group, or a list of marginal <em>2 by 2</em> tables, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a vector of group allocations, or an array of numbers of failures and successes in the reference group, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character variable indicating which optimization procedure to use.
This can be one of <code>"alpha.greedy"</code>, <code>"alpha"</code>, <code>"number"</code>, <code>"power"</code> or <code>"bonferroni.greedy"</code>, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>nominal significance level, the default is 0.025. Note that the test is one-sided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>an array of assumed probabilities for failure and success in the treatment group, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p0</code></td>
<td>
<p>an array of assumed probabilities for failure and success in the reference group, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>the maximal number of iterations in the branch and bound optimzation algorithm. Defaults to 10^5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limit</code></td>
<td>
<p>the value below which contributions to alpha are set to zero (and alpha is lowered accordingly) to speed up computation. Defaults to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.region</code></td>
<td>
<p>logical, if <code>TRUE</code> a data frame indicating which possible outcome is element of the rejection region of the global test is added to the output. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>closed.test</code></td>
<td>
<p>logical, if <code>TRUE</code> adjusted p-values for the elementary null hypotheses are calculated by applying the specified test to all intersection hypotheses in a closed testing scheme. This can be 
computer intensive, depending on the number of endpoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>consonant</code></td>
<td>
<p>logical indicating if the global test should be constrained such that the resulting closed test is consonant. This option is only available for two endpoints. Note that the
Bonferroni greedy method is always consonant by construction.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The null hypothesis for the global test is an identical multidimensional distribution of successes and failures in both groups.
The alternative hypothesis is a larger success proportion in the treatment group in at least one endpoint.
</p>
<p><code>x</code> can be a data frame with one row per subject and one column for each endpoint. Only values of 0 or 1 are allowed,
with 0 indicating failure and 1 indicating success of the subject for the particular endpoint. In that case <code>y</code> needs to be a vector of group assignemnts with values 0 and 1,
where 0 is the reference group and 1 the treatment group.
Alternatively, <code>x</code> and <code>y</code> can be contingency tables in terms of <em>2 by 2 by ... by 2</em> arrays. Each dimension of the array corresponds to one endpoint, the first coordinate position
in each dimension refers to failure in that endpoint, the second coordinate position refers to success. The array contains the number of subjects that were observed
for each possible combination of failures and successes. 
If <code>x</code> is a list of marginal <em>2 by 2</em> tables, the Bonferroni greedy method is used. Matching the other input
variants, the <em>2 by 2</em> tables are assumed to have the number of failures in the first row and the number of successes in the second row, and the first column to correspond to
the reference group, the second column to the treatment group.
</p>
<p>The methods <code>"alpha.greedy"</code>, <code>"alpha"</code>, <code>"number"</code> and <code>"power"</code> are based on the multivariate permutation distribution of the data conditional 
on the observed numbers of successes and failures across both groups. The method <code>"alpha.greedy"</code> uses a greedy algorithm aiming to exhaust the nominal significance level.
The methods <code>"alpha"</code>, <code>"number"</code> and <code>"power"</code> use a branch and bound algorithm to find rejection regions with, respectively,
maximal exhaustion of the nominal significance level, maximal number of elements or maximal power for the alternative given by <code>p1</code> and <code>p0</code>. 
The method <code>"bonferroni.greedy"</code> uses a greedy algorithm aiming to exhaust the nominal significance level of a weighted Bonferroni adjustment of multiple Fisher's exact tests.
See reference for further details.
</p>
<p><code>p1</code> and <code>p0</code> are <em>2 by 2 by ... by 2</em> arrays. Each dimension of the array corresponds to one endpoint, the first coordinate position
in each dimension refers to failure in that endpoint, the second coordinate position refers to success. 
The array contains the assumed true probabilities for each possible combination of failures and successes.
</p>


<h3>Value</h3>

<p>A list with class <code>multfisher</code> containing the following components:
</p>

<dl>
<dt><code>call</code></dt>
<dd>
<p>the function call.</p>
</dd>
<dt><code>data</code></dt>
<dd>
<p>a data frame showing the aggregated input data. If <code>p1</code> and <code>p0</code> are provided they are included in vectorized form.</p>
</dd>
<dt><code>alpha</code></dt>
<dd>
<p>the value of <code>alpha</code>.</p>
</dd>
<dt><code>method</code></dt>
<dd>
<p>the chosen method as found by argument match to <code>method</code>.</p>
</dd>
<dt><code>statistic</code></dt>
<dd>
<p>the vector of test statistics, these are the marginal numbers of successes in the treatment group.</p>
</dd>
<dt><code>p.value</code></dt>
<dd>
<p>the p-value of the global test. See reference for details on the calculation.</p>
</dd>
<dt><code>conditional.properties</code></dt>
<dd>
<p>a list of the actual significance level, the number of elements and the power of the global test. The values are calculated from the permutation 
distribution of the date and they are conditional on the observed total numbers of successes and failures. The power is calculated for the alternative defined through
<code>p1</code> and <code>p0</code>. If <code>p1</code> and <code>p0</code> are not specified, the value for power is <code>NA</code>.</p>
</dd>
<dt><code>rej.region</code></dt>
<dd>
<p>Provided if <code>show.region</code> is <code>TRUE</code> and method is in <code>c("alpha","number","power","alpha.greedy")</code>. A data frame showing in the column rejection.region
if a multidimensional test statistic, indicated by the previous columns, is element of the rejection region (value of 1) or not (value of 0) for the global level alpha test.
The column alpha gives the probability of  observing the particular vector of test statistics under the null hypothesis and conditional on the observed total numbers of
successes and failures. Values of 0 occur if a combination of test statistics is not possible in the conditional distribution. The column power shows the conditional probability
under the alternative defined through <code>p1</code> and <code>p0</code>. If <code>p1</code> and <code>p0</code> are not specified, the values for power are <code>NA</code>.</p>
</dd>
<dt><code>elementary.tests</code></dt>
<dd>
<p>a data frame showing for each endpoint the marginal odds ratio, the unadjusted one-sided p-value of Fisher's exact test and the adjusted 
p-value resulting from application of the optimal exact test in a closed testing procedure.</p>
</dd>
<dt><code>closed.test</code></dt>
<dd>
<p>a data frame indicating all intersection hypotheses in the closed test and giving their p-values.</p>
</dd>
<dt><code>consonant.constraint</code></dt>
<dd>
<p>logical indicating whether the consonance constraint was used.</p>
</dd>
<dt><code>OPT</code></dt>
<dd>
<p>a list summarizing the optimization success, if applicable. The number of iterations of the branch and bound algorithm is given, as well as the 
specified maximal iteration number and a logical variable indicating whether the optimization (in all steps of the closed test, if applicable) was finished.
The number of iterations may be 0, which indicates that the optimization problem was solved in a pre-processing step.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Robin Ristl, <a href="mailto:robin.ristl@meduniwien.ac.at">robin.ristl@meduniwien.ac.at</a>
</p>


<h3>References</h3>

<p>Robin Ristl, Dong Xi, Ekkehard Glimm, Martin Posch (2018), Optimal exact tests for multiple binary endpoints. 
<em>Computational Statistics and Data Analysis</em>, <strong>122</strong>, 1-17. doi: 10.1016/j.csda.2018.01.001 (open access)
</p>


<h3>See Also</h3>

<p><code>print.multfisher</code>, <code>plot.multfisher</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Examples with two endpoints
data&lt;-data.frame(endpoint1=c(0,0,1,1,1,0,0,0,0,1,1,1,1,1,1, 0,0,1,0,0,1,1,1,1,1,1,1,1,1,1),
		  endpoint2=c(0,0,0,0,0,1,1,1,1,1,1,1,1,1,1, 0,0,0,1,1,1,1,1,1,1,1,1,1,1,1),
		  group=rep(c(0,1),each=15))
## maximal power under a specified alternative
p1&lt;-matrix(c(0.1,0.2,0.2,0.5),2,2)
p0&lt;-matrix(c(0.75,0.1,0.1,0.05),2,2)
rownames(p1)&lt;-rownames(p0)&lt;-c("EP1_failure","EP1_success")
colnames(p1)&lt;-colnames(p0)&lt;-c("EP2_failure","EP2_success")
testpower&lt;-mfisher.test(x=data[,c(1:2)],y=data$group,method="power",
	p1=p1,p0=p0,closed.test=TRUE,show.region=TRUE)
print(testpower)
plot(testpower,cex=2)
str(testpower)

## maximal alpha with consonance constraint and using aggregated data as input
tab1&lt;-table(data$endpoint1[data$group==1],data$endpoint2[data$group==1])
tab0&lt;-table(data$endpoint1[data$group==0],data$endpoint2[data$group==0])
testalpha&lt;-mfisher.test(x=tab1,y=tab0,method="alpha",closed.test=TRUE,
	show.region=TRUE,consonant=TRUE)
print(testalpha)
plot(testalpha,cex=2)

## Examples with three endpoints
data3EP&lt;-data.frame(endpoint1=c(0,0,0,0,0,1,1,0,0,0, 0,0,0,0,1,1,1,1,1,1),
		     endpoint2=c(0,0,0,0,0,1,0,1,0,0, 0,0,1,1,1,1,1,1,1,1),
		     endpoint3=c(0,0,0,0,0,0,0,0,1,1, 0,0,0,1,1,1,1,1,1,1),
		     group=rep(c(0,1),each=10))

## greedy alpha exhaustion
testgreedy3EP&lt;-mfisher.test(x=data3EP[,1:3],y=data3EP$group,method="alpha.greedy",
	show.region=TRUE,closed.test=TRUE)
print(testgreedy3EP)
par(mfrow=c(3,3))
for(i in 1:9) {
plot(testgreedy3EP,dim=c(1,2),slice=list(T3=i),show.titles=FALSE,cex=2,xlim=c(0,8),ylim=c(0,10))
title(paste("T3 =",i))
}

## Bonferroni greedy
mfisher.test(x=data3EP[,1:3],y=data3EP$group,method="bonferroni.greedy",closed.test=TRUE)
## Bonferroni greedy with alternative input of marginal tables
mfisher.test(x=list(table(data3EP$endpoint1,data3EP$group),
	table(data3EP$endpoint2,data3EP$group),table(data3EP$endpoint3,data3EP$group)),
	method="bonferroni.greedy",closed.test=TRUE)

</code></pre>


</div>