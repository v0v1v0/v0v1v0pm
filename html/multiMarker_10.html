<div class="container">

<table style="width: 100%;"><tr>
<td>predict.multiMarker</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A latent variable model to infer food intake from multiple biomarker data alone.</h2>

<h3>Description</h3>

<p>Implements the multiMarker model via an MCMC algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'multiMarker'
predict( object, y,
         niter = 10000, burnIn = 3000,
         posteriors = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> An object of class inheriting from <code>'multiMarker'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p> A matrix of dimension <code class="reqn">(n^{*} \times P)</code> storing <code class="reqn">P</code> biomarker measurements on a set of <code class="reqn">n^{*}</code> observations. Missing values (<code>NA</code>) are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p> The number of MCMC iterations. The default value is <code>niter = 10000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnIn</code></td>
<td>
<p> A numerical value, the number of iterations of the chain to be discarded when computing the posterior estimates. The default value is <code>burnIn = 3000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posteriors</code></td>
<td>
<p> A logical value indicating if the full parameter chains should also be returned in output. The default value is <code>posteriors = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

 
<p>The function facilitates inference on food intake from multiple biomarkers alone via MCMC, according to the multiMarker model (D'Angelo et al., 2020).
</p>
<p>A Bayesian framework is employed for the modelling process, allowing quantification of the uncertainty associated with inferred intake. The framework is implemented through an MCMC algorithm.
</p>
<p>For more details, see D'Angelo et al. (2020).
</p>


<h3>Value</h3>

<p>A list with 2 components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>inferred_E</code></td>
<td>
<p> a list with 2 components, storing estimates of medians, standard deviations and <code class="reqn">95\%</code> credible interval lower and upper bounds for:
</p>

<ul>
<li>
<p><code>inferred_intakes</code> is a matrix of dimension <code class="reqn">(4\times n^*)</code>, storing the estimates of medians (1st row), standard deviations (2nd row) and <code class="reqn">95\%</code> credible interval lower (3rd row) and upper bounds (4th row) from the conditional distribution of the <code class="reqn">n^{*}</code> latent intakes, <code class="reqn">(z_1^{*}, \dots, z_{n^*})</code>.
</p>
</li>
<li>
<p><code>inferred_Prob</code> is an array of dimension <code class="reqn">(n^{*}\times D\times 4)</code>, storing estimated median (1st matrix), standard deviation (2nd matrix) and <code class="reqn">95\%</code> credible interval lower (3rd matrix) and upper bound (4th matrix) values for the food quantity probabilities, for each one of the new <code class="reqn"> {n^*}</code> observations.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chains</code></td>
<td>
<p> If <code>posteriors = TRUE</code>, it contains a list with conditional distributions for:
</p>

<ul>
<li>
<p><code>ZINF</code> is a matrix of dimension <code class="reqn">n^{*}\times niter</code> containing samples from the conditional distributions of the latent intakes, <code class="reqn">(z_1^{*}, \dots, z_{n^*})</code>.
</p>
</li>
<li>
<p><code>PROBS</code> is an array of <code class="reqn"> n^{*}\times D \times niter </code> dimensions containing samples from the conditional distribution for food quantity probabilities, for each observation and food quantity.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>References</h3>

<p>D'Angelo, S. and Brennan, L. and Gormley, I.C. (2020). Inferring food intake from multiple biomarkers using a latent variable model. <a href="https://arxiv.org/abs/2006.02995">arXiv</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(truncnorm)
oldpar &lt;- par(no.readonly =TRUE)

#-- Simulate intervention study biomarker and food quantity data --#

P &lt;- D &lt;- 3; n &lt;- 50
alpha &lt;- rtruncnorm(P, 0, Inf, 4, 1)
beta &lt;- rtruncnorm(P, 0, Inf, 0.001, 0.1)
x &lt;- c(50, 100, 150)
labels_z &lt;- sample(c(1,2,3), n, replace = TRUE)
quantities &lt;- x[labels_z]
sigma_d &lt;- 8
z &lt;- rtruncnorm(n, 0, Inf, x[labels_z], sigma_d)
Y &lt;- sapply( 1:P, function(p) sapply( 1:n, function(i)
  max(0, alpha[p] + beta[p]*z[i] + rnorm( 1, 0, 5) ) ) )

#-- Simulate Biomarker data only --#
nNew &lt;- 20
labels_zNew &lt;- sample(c(1,2,3), nNew, replace = TRUE)
zNew &lt;- rtruncnorm(nNew, 0, Inf, x[labels_zNew], sigma_d)
YNew &lt;- sapply( 1:P, function(p) sapply( 1:nNew, function(i)
  max(0, alpha[p] + beta[p]*zNew[i] + rnorm( 1, 0, 5) ) ) )

#-- Fit the multiMarker model to the intervention study data --#
# Number of iterations (and burnIn) set small for example.
modM &lt;- multiMarker(y = Y, quantities = quantities,
                    niter = 100, burnIn = 30,
                    posteriors = TRUE)
                    # niter and burnIn values are low only for example purposes

#-- Extract summary statistics for model parameters --#
modM$estimates$ALPHA_E[,3] #estimated median, standard deviation,
# 0.025 and 0.975 quantiles for the third intercept parameter (alpha_3)

modM$estimates$BETA_E[,2] #estimated median, standard deviation,
# 0.025 and 0.975 quantiles for the second scaling parameter (beta_2)

#-- Examine behaviour of MCMC chains --#
par(mfrow= c(2,1))
plot(modM$chains$ALPHA_c[,3], type = "l",
xlab = "Iteration (after burnin)", ylab = expression(alpha[3]) )
abline( h = mean(modM$chains$ALPHA_c[,3]), lwd = 2, col = "darkred")

plot(modM$chains$BETA_c[,2], type = "l",
xlab = "Iteration (after burnin)", ylab = expression(beta[2]) )
abline( h = mean(modM$chains$BETA_c[,2]), lwd = 2, col = "darkred")

# compute Effective Sample Size
# library(LaplacesDemon)
# ESS(modM$chains$ALPHA_c[,3]) # effective sample size for alpha_3 MCMC chain
# ESS(modM$chains$BETA_c[,2]) # effective sample size for beta_2 MCMC chain

#-- Infer intakes from biomarker only data --#
# Number of iterations (and burnIn) set small for example.
infM &lt;- predict(modM, y = YNew, niter = 100, burnIn = 30,
                 posteriors = TRUE)
# niter and burnIn values are low only for example purpose

#-- Extract summary statistics for a given intake --#
obs_j &lt;- 2 # choose which observation to look at
infM$inferred_E$inferred_intakes[, obs_j] #inferred median, standard deviation,
# 0.025 and 0.975 quantiles for the intake of observation obs_j

#-- Example of plot --#
par(mfrow = c(1,1))
hist(infM$chains$ZINF[obs_j, ], breaks = 50,
    ylab = "Density", xlab = "Intake",
    main = "Intake's conditional distribution",
    cex.main = 0.7,
    freq = FALSE) # Inferred condtional distribution of intake for observation obs_j
abline( v = infM$inferred_E$inferred_intakes[1,obs_j], col = "darkred",
lwd = 2 ) # median value
abline( v = infM$inferred_E$inferred_intakes[3,obs_j], col = "grey",
lwd = 2 )
abline( v = infM$inferred_E$inferred_intakes[4,obs_j], col = "grey",
lwd = 2 )
legend( x = "topleft", fill = c("grey", "darkred"), title = "quantiles:",
legend = c("(0.025, 0.975)", "0.5"), bty = "n", cex = 0.7)

mtext(paste("Observation", obs_j, sep = " "), outer = TRUE, cex = 1.5)
par(oldpar)

</code></pre>


</div>