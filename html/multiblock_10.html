<div class="container">

<table style="width: 100%;"><tr>
<td>preprocess</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Preprocessing of block data</h2>

<h3>Description</h3>

<p>This is an interface to simplify preprocessing of one, a subset or all
blocks in a multiblock object, e.g., a <code>data.frame</code> (see <code>block.data.frame</code>)
or <code>list</code>. Several standard preprocessing methods are supplied in addition to
letting the user supply it's own function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">block.preprocess(
  X,
  block = 1:length(X),
  fun = c("autoscale", "center", "scale", "SNV", "EMSC", "Fro", "FroSq", "SingVal"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code>data.frame</code> or <code>list</code> of data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block</code></td>
<td>
<p><code>vector</code> of block(s) to preprocess (<code>integer</code>s or <code>character</code>s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p><code>character</code> or <code>function</code> selecting which preprocessing to apply (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to underlying functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>fun</code> parameter controls the type of preprocessing to be performed:
</p>

<ul>
<li>
<p> autoscale: centre and scale each feature/variable.
</p>
</li>
<li>
<p> center: centre each feature/variable.
</p>
</li>
<li>
<p> scale: scale each feature/variable.
</p>
</li>
<li>
<p> SNV: Standard Normal Variate correction, i.e., centre and scale each sample across features/variables.
</p>
</li>
<li>
<p> EMSC: Extended Multiplicative Signal Correction defaulting to basic EMSC (2nd order polynomials). Further parameters are sent to <code>EMSC::EMSC</code>.
</p>
</li>
<li>
<p> Fro: Frobenius norm scaling of whole block.
</p>
</li>
<li>
<p> FroSq: Squared Frobenius norm scaling of whole block (sum of squared values).
</p>
</li>
<li>
<p> SingVal: Singular value scaling of whole block (first singular value).
</p>
</li>
<li>
<p> User defined: If a function is supplied, this will be applied to chosen blocks.
Preprocessing can be done for all blocks or a subset. It can also be done in a series of operations to combine preprocessing techniques.
</p>
</li>
</ul>
<h3>Value</h3>

<p>The input multiblock object is preprocessed and returned.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code>multiblock</code>, and methods organised by main structure: <code>basic</code>, <code>unsupervised</code>, <code>asca</code>, <code>supervised</code> and <code>complex</code>.
Common functions for computation and extraction of results and plotting are found in <code>multiblock_results</code> and <code>multiblock_plots</code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(potato)
# Autoscale Chemical block
potato &lt;- block.preprocess(potato, block = "Chemical", "autoscale")
# Apply SNV to NIR blocks
potato &lt;- block.preprocess(potato, block = 3:4, "SNV")
# Centre Sensory block
potato &lt;- block.preprocess(potato, block = "Sensory", "center")
# Scale all blocks to unit Frobenius norm
potato &lt;- block.preprocess(potato, fun = "Fro")

# Effect of SNV
NIR &lt;- (potato$NIRraw + rnorm(26)) * rnorm(26,1,0.2)
NIRc &lt;- block.preprocess(list(NIR), fun = "SNV")[[1]]
old.par &lt;- par(mfrow = c(2,1), mar = c(4,4,1,1))
matplot(t(NIR), type="l", main = "uncorrected", ylab = "")
matplot(t(NIRc), type="l", main = "corrected", ylab = "")
par(old.par)

</code></pre>


</div>