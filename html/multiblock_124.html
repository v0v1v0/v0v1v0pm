<div class="container">

<table style="width: 100%;"><tr>
<td>smbpls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse Multiblock Partial Least Squares - sMB-PLS</h2>

<h3>Description</h3>

<p>sMB-PLS is an adaptation of MB-PLS (<code>mbpls</code>) that enforces sparseness in loading weights
when computing PLS components in the global model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">smbpls(
  formula,
  data,
  subset,
  na.action,
  X = NULL,
  Y = NULL,
  ncomp = 1,
  scale = FALSE,
  shrink = NULL,
  truncation = NULL,
  trunc.width = 0.95,
  blockScale = c("sqrtnvar", "ssq", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Model formula accepting a single response (block) and predictor block names separated by + signs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data set to analyse.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>Expression for subsetting the data before modelling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>How to handle NAs (no action implemented).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code>list</code> of input blocks. If X is supplied, the formula interface is skipped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p><code>matrix</code> of responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p><code>integer</code> number of PLS components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p><code>logical</code> for autoscaling inputs (default = FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shrink</code></td>
<td>
<p><code>numeric</code> scalar indicating degree of L1-shrinkage/Soft-Thresholding (optional), 0 &lt;= shrink &lt; 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>truncation</code></td>
<td>
<p><code>character</code> indicating type of truncation (optional) "Lenth" uses
asymmetric confidence intervals to determine outlying loading weights. "quantile" uses
a quantile plot approach to determining outliers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trunc.width</code></td>
<td>
<p><code>numeric</code> indicating confidence of "Lenth type" confidence interval
or quantile in "quantile plot" approach. Default = 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blockScale</code></td>
<td>
<p>Either a <code>character</code> indicating type of block scaling or a <code>numeric</code> vector of block weights (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to pls::plsr.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Two versions of sparseness are supplied: Soft-Threshold PLS, also
known as Sparse PLS, and Truncation PLS. The former uses L1 shrinkage of loading weights, while the latter
comes in two flavours, both estimating inliers and outliers. The "Lenth" method uses asymmetric confidence
intervals around the median of a loading weigh vector to estimate inliers. The "quantile" method uses
a quantile plot approach to estimate outliers as deviations from the estimated quantile line. As with
ordinary MB-PLS scaled input blocks (1/sqrt(ncol)) are used.
</p>
<p>Block weighting is performed after scaling all variables and is by default
<code>"sqrtnvar"</code>: 1/sqrt(ncol(X[[i]])) in each block. Alternatives
are <code>"ssq"</code>: 1/norm(X[[i]], "F")^2 and <code>"none"</code>: 1/1. Finally, if
a <code>numeric</code> vector is supplied, it will be used to scale the blocks
after <code>"ssq"</code> scaling, i.e., Z[[i]] = X[[i]] / norm(X[[i]], "F")^2 * blockScale[i].
</p>


<h3>Value</h3>

<p><code>multiblock, mvr</code> object with super-scores, super-loadings, block-scores and block-loading, and the underlying
<code>mvr</code> (PLS) object for the super model, with all its result and plot possibilities. Relevant plotting functions: <code>multiblock_plots</code>
and result functions: <code>multiblock_results</code>.
</p>


<h3>References</h3>


<ul>
<li>
<p> Sæbø, S.; Almøy, T.; Aarøe, J. &amp; Aastveit, A. ST-PLS: a multi-directional nearest shrunken centroid type classifier via PLS Journal of Chemometrics: A Journal of the Chemometrics Society, Wiley Online Library, 2008, 22, 54-62.
</p>
</li>
<li>
<p> Lê Cao, K.; Rossouw, D.; Robert-Granié, C. &amp; Besse, P. A sparse PLS for variable selection when integrating omics data Statistical applications in genetics and molecular biology, 2008, 7.
</p>
</li>
<li>
<p> Liland, K.; Høy, M.; Martens, H. &amp; Sæbø, S. Distribution based truncation for variable selection in subspace methods for multivariate regression Chemometrics and Intelligent Laboratory Systems, 2013, 122, 103-111.
</p>
</li>
<li>
<p> Karaman, I.; Nørskov, N.; Yde, C.; Hedemann, M.; Knudsen, K. &amp; Kohler, A. Sparse multi-block PLSR for biomarker discovery when integrating data from LC–MS and NMR metabolomics Metabolomics, 2015, 11, 367-379.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Overviews of available methods, <code>multiblock</code>, and methods organised by main structure: <code>basic</code>, <code>unsupervised</code>, <code>asca</code>, <code>supervised</code> and <code>complex</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(potato)

# Truncation MB-PLS 
# Loading weights inside 60% confidence intervals around the median are set to 0.
tmb &lt;- smbpls(Sensory ~ Chemical+Compression, data=potato, ncomp = 5, 
              truncation = "Lenth", trunc.width = 0.6)
              
# Alternative XY-interface
tmb.XY &lt;- smbpls(X=potato[c('Chemical','Compression')], Y=potato[['Sensory']], ncomp = 5, 
              truncation = "Lenth", trunc.width = 0.6)
identical(tmb, tmb.XY)
scoreplot(tmb, labels="names") # Exploiting mvr object structure from pls package
loadingweightplot(tmb, labels="names")

# Soft-Threshold / Sparse MB-PLS 
# Loading weights are subtracted by 60% of maximum value.
smb &lt;- smbpls(X=potato[c('Chemical','Compression')], Y=potato[['Sensory']], 
              ncomp = 5, shrink = 0.6)
print(smb)
scoreplot(smb, labels="names") # Exploiting mvr object structure from pls package
loadingweightplot(smb, labels="names")

# Emphasis may be different for blocks
smb &lt;- smbpls(X=potato[c('Chemical','Compression')], Y=potato[['Sensory']], 
              ncomp = 5, shrink = 0.6, blockScale = c(1, 10))
</code></pre>


</div>