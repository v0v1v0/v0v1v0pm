<div class="container">

<table style="width: 100%;"><tr>
<td>mbpls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiblock Partial Least Squares - MB-PLS</h2>

<h3>Description</h3>

<p>A function computing MB-PLS scores, loadings, etc. on the super-level and
block-level.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mbpls(
  formula,
  data,
  subset,
  na.action,
  X = NULL,
  Y = NULL,
  ncomp = 1,
  scale = FALSE,
  blockScale = c("sqrtnvar", "ssq", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Model formula accepting a single response (block) and predictor block names separated by + signs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data set to analyse.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>Expression for subsetting the data before modelling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>How to handle NAs (no action implemented).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code>list</code> of input blocks. If X is supplied, the formula interface is skipped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p><code>matrix</code> of responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p><code>integer</code> number of PLS components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p><code>logical</code> for autoscaling inputs (default = FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blockScale</code></td>
<td>
<p>Either a <code>character</code> indicating type of block scaling or a <code>numeric</code> vector of block weights (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to pls::plsr.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>MB-PLS is the prototypical component based supervised multiblock method.
It was originally formulated as a two-level method with a block-level and a super-level,
but it was later discovered that it could be expressed as an ordinary PLS on concatenated
weighted X blocks followed by a simple loop for calculating block-level loading weights,
loadings and scores. This implementation uses the <code>plsr</code> function on the
scaled input blocks (1/sqrt(ncol)) enabling all summaries and plots from the <code>pls</code>
package.
</p>
<p>Block weighting is performed after scaling all variables and is by default
<code>"sqrtnvar"</code>: 1/sqrt(ncol(X[[i]])) in each block. Alternatives
are <code>"ssq"</code>: 1/norm(X[[i]], "F")^2 and <code>"none"</code>: 1/1. Finally, if
a <code>numeric</code> vector is supplied, it will be used to scale the blocks
after <code>"ssq"</code> scaling, i.e., Z[[i]] = X[[i]] / norm(X[[i]], "F")^2 * blockScale[i].
</p>


<h3>Value</h3>

<p><code>multiblock, mvr</code> object with super-scores, super-loadings, block-scores and block-loading, and the underlying
<code>mvr</code> (PLS) object for the super model, with all its result and plot possibilities. Relevant plotting functions: <code>multiblock_plots</code>
and result functions: <code>multiblock_results</code>.
</p>


<h3>References</h3>


<ul>
<li>
<p> Wangen, L.E. and Kowalski, B.R. (1988). A multiblock partial least squares algorithm for investigating complex chemical systems. Journal of Chemometrics, 3, 3–20.
</p>
</li>
<li>
<p> Westerhuis, J.A., Kourti, T., and MacGregor,J.F. (1998). Analysis of multiblock and hierarchical PCA and PLS models. Journal of Chemometrics, 12, 301–321.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Overviews of available methods, <code>multiblock</code>, and methods organised by main structure: <code>basic</code>, <code>unsupervised</code>, <code>asca</code>, <code>supervised</code> and <code>complex</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(potato)
# Formula interface
mb &lt;- mbpls(Sensory ~ Chemical+Compression, data=potato, ncomp = 5)

# ... or X and Y
mb.XY &lt;- mbpls(X=potato[c('Chemical','Compression')], Y=potato[['Sensory']], ncomp = 5)
identical(mb$scores, mb.XY$scores)
print(mb)
scoreplot(mb, labels="names") # Exploiting mvr object structure from pls package

# Block scaling with emphasis on first block
mbs &lt;- mbpls(Sensory ~ Chemical+Compression, data=potato, ncomp = 5, blockScale = c(10, 1))
scoreplot(mbs, labels="names") # Exploiting mvr object structure from pls package
</code></pre>


</div>