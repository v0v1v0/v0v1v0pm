<div class="container">

<table style="width: 100%;"><tr>
<td>pcagca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PCA-GCA</h2>

<h3>Description</h3>

<p>PCA-GCA is a methods which aims at estimating subspaces of common, local and
distinct variation from two or more blocks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pcagca(
  X,
  commons = 2,
  auto = TRUE,
  auto.par = list(explVarLim = 40, rLim = 0.8),
  manual.par = list(ncomp = 0, ncommon = 0),
  tol = 10^-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code>list</code> of input blocks</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>commons</code></td>
<td>
<p><code>numeric</code> giving the highest number of blocks to combine when calculating local or common scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto</code></td>
<td>
<p><code>logical</code> indicating if automatic choice of complexities should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto.par</code></td>
<td>
<p><code>named list</code> setting limits for automatic choice of complexities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>manual.par</code></td>
<td>
<p><code>named list</code> for manual choice of blocks. The list consists of <code>ncomp</code> which indicates the number of components to extract from each block and <code>ncommon</code> which is the corresponding for choosing the block combinations (local/common). For the latter, use unique_combos(n_blocks, commons) to see order of local/common blocks. Component numbers will be reduced if simpler models give better predictions. See example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p><code>numeric</code> tolerance for component inclusion (singular values).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The name PCA-GCA comes from the process of first applying
PCA to each block, then using GCA to estimate local and common components, and finally
orthogonalising the block-wise scores on the local/common ones and re-estimating these to
obtain distinct components. The procedure is highly similar to the supervised method
PO-PLS, where the PCA steps are exchanged with PLS.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code>multiblock_plots</code>
and result functions: <code>multiblock_results</code>. Distinct components are marked as 'D(x), Comp c' for block x and component c
while local and common components are marked as "C(x1, x2), Comp c", where x1 and x2 (and more) are block numbers.
</p>


<h3>References</h3>

<p>Smilde, A., MÃ¥ge, I., Naes, T., Hankemeier, T.,Lips, M., Kiers, H., Acar, E., and Bro, R.(2017). Common and distinct components in data fusion. Journal of Chemometrics, 31(7), e2900.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code>multiblock</code>, and methods organised by main structure: <code>basic</code>, <code>unsupervised</code>, <code>asca</code>, <code>supervised</code> and <code>complex</code>.
Common functions for computation and extraction of results and plotting are found in <code>multiblock_results</code> and <code>multiblock_plots</code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(potato)
potList &lt;- as.list(potato[c(1,2,9)])
pot.pcagca &lt;- pcagca(potList)

# Show origin and type of all components
lapply(pot.pcagca$blockScores,colnames)

# Basic multiblock plot
plot(scores(pot.pcagca, block=2), comps=1, labels="names")

</code></pre>


</div>