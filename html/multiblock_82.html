<div class="container">

<table style="width: 100%;"><tr>
<td>popls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parallel and Orthogonalised Partial Least Squares - PO-PLS</h2>

<h3>Description</h3>

<p>This is a basic implementation of PO-PLS with manual and automatic component selections.
</p>


<h3>Usage</h3>

<pre><code class="language-R">popls(
  X,
  Y,
  commons = 2,
  auto = TRUE,
  auto.par = list(explVarLim = 40, rLim = 0.8),
  manual.par = list(ncomp = rep(0, length(X)), ncommon = list())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code>list</code> of input blocks</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p><code>matrix</code> of response variable(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>commons</code></td>
<td>
<p><code>numeric</code> giving the highest number of blocks to combine when calculating local or common scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto</code></td>
<td>
<p><code>logical</code> indicating if automatic choice of complexities should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto.par</code></td>
<td>
<p><code>named list</code> setting limits for automatic choice of complexities. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>manual.par</code></td>
<td>
<p><code>named list</code> for manual choice of blocks. The list consists of <code>ncomp</code> which indicates the number of components to extract from each block and <code>ncommon</code> which is the corresponding for choosing the block combinations (local/common). For the latter, use unique_combos(n_blocks, commons) to see order of local/common blocks. Component numbers will be reduced if simpler models give better predictions. See example.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>PO-PLS decomposes a set of input data blocks into common, local and distinct components
through a process involving <code>pls</code> and <code>gca</code>. The <code>rLim</code> parameter is
a lower bound for the GCA correlation when building common components, while explVarLim is the minimum
explained variance for common components and unique components.
</p>


<h3>Value</h3>

<p>A <code>multiblock</code> object with block-wise, local and common loadings and scores. Relevant plotting functions: <code>multiblock_plots</code>
and result functions: <code>multiblock_results</code>.
</p>


<h3>References</h3>


<ul>
<li>
<p> I Måge, BH Mevik, T Næs. (2008). Regression models with process variables and parallel blocks of raw material measurements. Journal of Chemometrics: A Journal of the Chemometrics Society 22 (8), 443-456
</p>
</li>
<li>
<p> I Måge, E Menichelli, T Næs (2012). Preference mapping by PO-PLS: Separating common and unique information in several data blocks. Food quality and preference 24 (1), 8-16
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Overviews of available methods, <code>multiblock</code>, and methods organised by main structure: <code>basic</code>, <code>unsupervised</code>, <code>asca</code>, <code>supervised</code> and <code>complex</code>.
Common functions for computation and extraction of results and plotting are found in <code>multiblock_results</code> and <code>multiblock_plots</code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(potato)

# Automatic analysis
pot.po.auto &lt;- popls(potato[1:3], potato[['Sensory']][,1])
pot.po.auto$explVar

# Manual choice of up to 5 components for each block and 1, 0, and 2 blocks,
# respectively from the (1,2), (1,3) and (2,3) combinations of blocks.
pot.po.man &lt;- popls(potato[1:3], potato[['Sensory']][,1], auto=FALSE, 
                manual.par = list(ncomp=c(5,5,5), ncommon=c(1,0,2)))
pot.po.man$explVar

# Score plot for local (2,3) components
plot(scores(pot.po.man,3), comps=1:2, labels="names")

</code></pre>


</div>