<div class="container">

<table style="width: 100%;"><tr>
<td>multinom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate multinomial coefficients</h2>

<h3>Description</h3>

<p>This function calculates the number of permutations of a multiset, this
being the multinomial coefficient. If a set <code class="reqn">X</code> contains <code class="reqn">k</code> unique
elements <code class="reqn">x_1, x_2, \ldots, x_k</code> with associate counts (or
multiplicities) of <code class="reqn">n_1, n_2, \ldots, n_k</code>, then this function returns
</p>
<p style="text-align: center;"><code class="reqn">\frac{n!}{n_1!n_2!\ldots n_k!}</code>
</p>
<p> where <code class="reqn">n
= \sum_{i=1}{k}n_i</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multinom(x, counts = FALSE, useDouble = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either a multiset (with one or more potentially non-unique
elements), or if <code>counts</code> is <code>TRUE</code> a set of counts of the unique
elements of <code class="reqn">X</code>. If <code>counts</code> is <code>FALSE</code> and <code>x</code> is not
numeric, then x will be coerced into an integer vector internally. If
<code>counts</code> is <code>TRUE</code> then <code>x</code> must be a vector of integers that
are greater than, or equal to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p>if <code>counts</code> is TRUE, then this means x is the set of
counts <code class="reqn">n_1, n_2, \ldots, n_k</code> rather than the set itself</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useDouble</code></td>
<td>
<p>if <code>useDouble</code> is TRUE then the computation will be
done using double precision floating point arithmetic. This option was added
because the internal code cannot handle integer overflow. The double
precision code will may a result that is closer to the truth for large
values, but this is not guaranteed. Ideally something like the GMP library
should be used, but this is not a priority at this point in time.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>multinom depends on C++ code written by Dave Barber which can be found at
<a href="http://tamivox.org/dave/multinomial/code.html">http://tamivox.org/dave/multinomial/code.html</a>. The code may require
the STL algorithm library to be included in order to compile it.
</p>


<h3>Value</h3>

<p>A single integer representing the multinomial coefficient for the
given multiset, or given set of multiplicities.
</p>


<h3>Author(s)</h3>

<p>James M. Curran, Dave Barber
</p>


<h3>References</h3>

<p><a href="http://tamivox.org/dave/multinomial/code.html">http://tamivox.org/dave/multinomial/code.html</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## An example with a multiset X = (a,a,a,b,b,c)
## There are 3 a s, 2 b s and 1 c, so the answer should be
## (3+2+1)!/(3!2!1!) = 6!/3!2!1! = 60
x = rep(letters[1:3],3:1)
multinom(x)

## in this example x is a vector of counts
## the answer should be the same as above as x = c(3,2,1)
x = rep(letters[1:3],3:1)
x = as.vector(table(x)) #coerce x into a vector of counts
multinom(x, counts = TRUE)


## An example of integer overflow. x is a vector of counts
## c(12,11,8,8,6,5). The true answer from Maple is
## 11,324,718,121,789,252,764,532,876,767,840,000
## The error in the integer based answer is obvious.
## The error using floating point is not, but from Maple is
## 0.705057123232160000e+10
## Thanks to Lev Dashevskiy for calling my attention to this.
## Not run: x = c(12,11,8,8,6,5)
multinom(x, counts = TRUE, useDouble = FALSE)
multinom(x, counts = TRUE, useDouble = TRUE)

## End(Not run)

</code></pre>


</div>