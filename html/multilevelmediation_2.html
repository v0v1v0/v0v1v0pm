<div class="container">

<table style="width: 100%;"><tr>
<td>boot.modmed.mlm.custom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bootstrapping multilevel mediation model (without boot package)</h2>

<h3>Description</h3>

<p>Bootstrapping multilevel mediation model (without boot package)
</p>


<h3>Usage</h3>

<pre><code class="language-R">boot.modmed.mlm.custom(
  data,
  L2ID,
  ...,
  return.type = "all",
  modval1 = NULL,
  modval2 = NULL,
  nrep = 500,
  boot.type = c("caseboth", "case2", "case1", "resid"),
  parallel.type = c("lapply", "parallel", "furrr"),
  ncores = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame in long format. The function will do restructuring using <code>stack_bpg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2ID</code></td>
<td>
<p>Name of column that contains grouping variable in 'data' (e.g., "SubjectID")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to <code>modmed.mlm</code> or <code>lme</code> to define the mediation analysis model or do estimation, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.type</code></td>
<td>
<p>Character that defines what information to extract from the model. Default and options are in <code>extract.modmed.mlm</code>.
As examples, "indirect" will compute the indirect effect, "all" will save all random and fixed effects for possible additional
computations, "indirect.diff" will compute the difference in the indirect effect at two values of a possible moderating variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modval1</code></td>
<td>
<p>(Optional) Numeric. If the model has a moderator, this value will be passed to <code>extract.modmed.mlm</code>
to compute the indirect effect or other effects at that value. See <code>extract.modmed.mlm</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modval2</code></td>
<td>
<p>(Optional). If the model has a moderator, it is possible to compute the difference in the indirect
at two values of the moderator. If given and an appropriate option for such a difference is chosen for <code>type</code>,
this value and that of <code>modval1</code> will be passed to <code>extract.modmed.mlm</code> to compute and save the difference.
This is useful for obtaining a CI for the difference in the indirect effect at two different levels of the moderator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>
<p>Number of bootstrap replications to perform. Pick a small number just for testing purposes, something larger (e.g., 1000 or more) for analyses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot.type</code></td>
<td>
<p>Character indicating the type of bootstrapping to perform. Options are: "caseboth", "case2", "case1", or "resid".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.type</code></td>
<td>
<p>Character indicating type of parallel processing (if any) to use. Options are "lapply" (no parallel processing),"parallel"
(uses <code>parallel</code> package), or "furrr" (uses <code>furrr</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Integer indicating the number of processing cores to attempt to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Integer to set random number seed, for replication purposes. Note that replication may be somewhat R version or platform dependent.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function was written to do all four kinds of bootstrapping outlined in Falk, Vogel, Hammami &amp; Miočević (in press):
case resampling at both levels, at level 2 only, at level 1 only, and the residual-based bootstrap (e.g., see Hox and van de Schoot, 2013;
van der Leeden, Meijer, &amp; Busing, 2008). These functions also support moderated mediation. See also <code>modmed.mlm</code>.
Note that <code>nlm</code> was used as the optimizer for some of the examples below as it was found to be faster for the models/simulations
studied by Falk et al (in press). Note that Level 1 only bootstrapping is typically not recommended. See Falk et al. (in press) for details.
</p>
<p>This function is different from the original functions used for the publication and that as of this writing still appear here: <code>boot.modmed.mlm</code>
and here: <code>bootresid.modmed.mlm</code> . The present function seeks to unify case bootstrapping and residual-based bootstrapping in the same function. Furthermore,
this newer function is also aimed at attempting to bypass the need for using the <code>boot</code> package to do computations and parallel processing.
Some performance gains in terms of speed have been observed via use of this function instead of <code>boot</code> in conjunction with <code>boot.modmed.mlm</code>.
Although somewhat slower, <code>furrr</code> can also be used if one would like a progress bar.
</p>


<h3>Value</h3>

<p>A list with the following elements. Note that <code>t0</code> and <code>t</code> are intended to trick the <code>boot</code>
package into working with some if its functions.
</p>

<ul>
<li>
<p><code>call</code> Call/arguments used when invoking this function. Useful for later extracting things like indirect effect.
</p>
</li>
<li>
<p><code>t0</code> Parameter estimates based on the dataset.
</p>
</li>
<li>
<p><code>t</code> Bootstrap distribution of all parameter estimates.
</p>
</li>
<li>
<p><code>model</code> Fitted model to restructured data as one would obtain from <code>modmed.mlm</code>.
</p>
</li>
<li>
<p><code>conv</code> Whether model fit to restructured dataset converged.
</p>
</li>
<li>
<p><code>args</code> Arguments used when calling <code>modmed.mlm</code>. Useful for later extracting things like indirect effect.
</p>
</li>
</ul>
<h3>References</h3>

<p>Bauer, D. J., Preacher, K. J., &amp; Gil, K. M. (2006). Conceptualizing and testing random indirect effects and moderated mediation in multilevel models: New procedures and recommendations. Psychological Methods, 11(2), 142–163. <a href="https://doi.org/10.1037/1082-989X.11.2.142">doi:10.1037/1082-989X.11.2.142</a>
</p>
<p>Falk, C. F., Vogel, T., Hammami, S., &amp; Miočević, M. (in press). Multilevel mediation analysis in R: A comparison of bootstrap and Bayesian approaches. Behavior Research Methods. <a href="https://doi.org/10.3758/s13428-023-02079-4">doi:10.3758/s13428-023-02079-4</a>  Preprint: <a href="https://doi.org/10.31234/osf.io/ync34">doi:10.31234/osf.io/ync34</a>
</p>
<p>Hox, J., &amp; van de Schoot, R. (2013). Robust methods for multilevel analysis. In M. A. Scott, J. S. Simonoff &amp; B. D. Marx (Eds.), The SAGE Handbook of Multilevel Modeling (pp. 387-402). SAGE Publications Ltd. <a href="https://doi.org/10.4135/9781446247600.n22">doi:10.4135/9781446247600.n22</a>
</p>
<p>van der Leeden, R., Meijer, E., &amp; Busing, F. M. T. A. (2008). Resampling multilevel models. In J. de Leeuw &amp; E. Meijer (Eds.), Handbook of Multilevel Analysis (pp. 401-433). Springer.
</p>


<h3>Examples</h3>

<pre><code class="language-R">


data(BPG06dat)

# Note that for all examples below, nrep should be increased to something
#  MUCH larger (e.g., 1000). Small values here are used only so that the code
#  runs relatively quickly when tested.

# double bootstrap, no parallel processing
boot.result&lt;-boot.modmed.mlm.custom(BPG06dat, nrep=10, L2ID="id", X="x", Y="y", M="m",
  boot.type="caseboth",
  control=list(opt="nlm"), seed=1234)

extract.boot.modmed.mlm(boot.result, type="indirect", ci.conf=.95)

# residual bootstrap, parallel package
boot.result&lt;-boot.modmed.mlm.custom(BPG06dat, nrep=10, L2ID="id", X="x", Y="y", M="m",
  boot.type="resid", random.a=TRUE, random.b=TRUE,
  parallel.type="parallel",ncores=2,seed=2299,
  control=list(opt="nlm"))

extract.boot.modmed.mlm(boot.result, type="indirect", ci.conf=.95)



# Example with moderation
data(simdat)

# moderation
boot.result&lt;-boot.modmed.mlm.custom(simdat, nrep=5, L2ID = "L2id", X = "X", Y = "Y", M = "M",
   boot.type="caseboth",
   random.a=TRUE, random.b=TRUE, random.cprime=TRUE,
   moderator = "mod", mod.a=TRUE, mod.b=TRUE,
   random.mod.a = TRUE, random.mod.b = TRUE,
  parallel.type="parallel",ncores=2,seed=2299)

extract.boot.modmed.mlm(boot.result, type="indirect")

# indirect effect point estimate and 95% CI when moderator = 0
extract.boot.modmed.mlm(boot.result, type="indirect", modval1=0)

# indirect effect point estimate and 95% CI when moderator = 1
 extract.boot.modmed.mlm(boot.result, type="indirect", modval1=1)

# indirect effect difference point estimate and 95% CI
extract.boot.modmed.mlm(boot.result, type="indirect.diff",
  modval1=0, modval2=1)


</code></pre>


</div>