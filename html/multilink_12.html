<div class="container">

<table style="width: 100%;"><tr>
<td>specify_prior</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Specify the Prior Distributions</h2>

<h3>Description</h3>

<p>Specify the prior distributions for the <code class="reqn">m</code> and <code class="reqn">u</code> parameters of the
models for comparison data among matches and non-matches, and the partition.
</p>


<h3>Usage</h3>

<pre><code class="language-R">specify_prior(
  comparison_list,
  mus = NA,
  nus = NA,
  flat = 0,
  alphas = NA,
  dup_upper_bound = NA,
  dup_count_prior_family = NA,
  dup_count_prior_pars = NA,
  n_prior_family = NA,
  n_prior_pars = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>comparison_list</code></td>
<td>
<p>the output from a call to
<code>create_comparison_data</code> or <code>reduce_comparison_data</code>.
Note that in order to correctly specify the prior, if
<code>reduce_comparison_data</code> is used to the reduce the number of
record pairs that are potential matches, then the output of
<code>reduce_comparison_data</code> (not
<code>create_comparison_data</code>) should be used for this argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mus, nus</code></td>
<td>
<p>The hyperparameters of the Dirichlet priors for the <code class="reqn">m</code>
and <code class="reqn">u</code> parameters for the comparisons among matches and non-matches,
respectively. These are positive <code>numeric</code> vectors which have length
equal to the number of  columns of <code>comparison_list$comparisons</code> times
the number of file pairs
<code>(comparison_list$K * (comparison_list$K + 1) / 2)</code>. If set to
<code>NA</code>, flat priors are used. We recommend using flat priors for <code class="reqn">m</code>
and <code class="reqn">u</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flat</code></td>
<td>
<p>A <code>numeric</code> indicator of whether a flat prior for partitions
should be used.  <code>flat</code> should be <code>1</code> if a flat prior is used, and
<code>flat</code> should be <code>0</code> if a structured prior is used. If a flat prior
is used, the remaining arguments should be set to <code>NA</code>. Otherwise, the
remaining arguments should be specified. We do not recommend using a flat
prior for partitions in general.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphas</code></td>
<td>
<p>The hyperparameters for the Dirichlet-multinomial overlap table
prior, a positive <code>numeric</code> vector of length
<code>2 ^ comparison_list$K - 1</code>. The indexing of these hyperparameters is
based on the the <code>comparison_list$K</code>-bit binary representation of the
inclusion patterns of the overlap table. To give a few examples, suppose
<code>comparison_list$K</code> is <code>3</code>. <code>1</code> in <code>3</code>-bit binary is
<code>001</code>, so <code>alphas[1]</code> is the hyperparameter for the
<code>001</code> cell of the overlap table, representing clusters containing only
records from the third file. <code>2</code> in <code>3</code>-bit binary is
<code>010</code>, so <code>alphas[2]</code> is the hyperparameter for the
<code>010</code> cell of the overlap table, representing clusters containing only
records from the second file. <code>3</code> in <code>3</code>-bit binary is
<code>011</code>, so <code>alphas[3]</code> is the hyperparameter for the
<code>011</code> cell of the overlap table, representing clusters containing only
records from the second and third files. If set to <code>NA</code>, the
hyperparameters will all be set to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dup_upper_bound</code></td>
<td>
<p>A <code>numeric</code> vector indicating the maximum number
of duplicates, from each file, allowed in each cluster. For a given file
<code>k</code>, <code>dup_upper_bound[k]</code> should be between <code>1</code> and
<code>comparison_list$file_sizes[k]</code>, i.e. even if you don't want to impose
an upper bound, you have to implicitly place an upper bound: the number of
records in a file. If set to <code>NA</code>, the upper bound for file <code>k</code>
will be set to <code>1</code> if no duplicates are allowed for that file, or
<code>comparison_list$file_sizes[k]</code> if duplicates are allowed for that file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dup_count_prior_family</code></td>
<td>
<p>A <code>character</code> vector indicating the
prior distribution family used for the number of duplicates in each cluster,
for each file. Currently the only option is <code>"Poisson"</code> for a Poisson
prior, truncated to lie between <code>1</code> and <code>dup_upper_bound[k]</code>. The
mean parameter of the Poisson distribution is specified using the
<code>dup_count_prior_pars</code> argument. If set to <code>NA</code>, a Poisson prior
with mean <code>1</code> will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dup_count_prior_pars</code></td>
<td>
<p>A <code>list</code> containing the parameters for
the prior distribution for the number of duplicates in each cluster, for each
file. For file <code>k</code>, when <code>dup_count_prior_family[k]="Poisson"</code>,
<code>dup_count_prior_pars[[k]]</code> is a positive constant representing the mean
of the Poisson prior.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_prior_family</code></td>
<td>
<p>A <code>character</code> indicating the prior distribution
family used for <code>n</code>, the number of clusters represented in the
records. Note that this includes records determined not to be potential
matches to any other records using <code>reduce_comparison_data</code>.
Currently the there are two options: <code>"uniform"</code> for a uniform prior
for <code>n</code>, i.e. <code class="reqn">p(n) \propto 1</code>, and <code>"scale"</code> for a scale prior
for <code>n</code>, i.e. <code class="reqn">p(n) \propto 1/n</code>. If set to <code>NA</code>, a uniform
prior will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_prior_pars</code></td>
<td>
<p>Currently set to <code>NA</code>. When more prior distribution
families for <code>n</code> are implemented, this will be a vector of parameters
for those priors.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The purpose of this function is to specify prior distributions for all
parameters of the model. Please note that if
<code>reduce_comparison_data</code> is used to the reduce the number of
record pairs that are potential matches, then the output of
<code>reduce_comparison_data</code> (not
<code>create_comparison_data</code>) should be used as input.
</p>
<p>For the hyperparameters of the Dirichlet priors for the <code class="reqn">m</code>
and <code class="reqn">u</code> parameters for the comparisons among matches and non-matches,
respectively, we recommend using a flat prior. This is accomplished by
setting <code>mus=NA</code> and <code>nus=NA</code>. Informative prior specifications
are possible, but in practice they will be overwhelmed by the large number of
comparisons.
</p>
<p>For the prior for partitions, we do not recommend using a flat prior. Instead
we recommend using our structure prior for partitions. By setting
<code>flat=0</code> and the remaining arguments to <code>NA</code>, one obtains the
default specification for the structured prior that we have found to perform
well in simulation studies. The structured prior for partitions is specified
as follows:
</p>

<ul>
<li>
<p> Specify a prior for <code>n</code>, the number of clusters represented in
the records. Note that this includes records determined not to be potential
matches to any other records using <code>reduce_comparison_data</code>.
Currently, a uniform prior and a scale prior for <code>n</code> are supported.
Our default specification uses a uniform prior.
</p>
</li>
<li>
<p> Specify a prior for the overlap table (see the documentation for
<code>alphas</code> for more information).  Currently a Dirichlet-multinomial
prior is supported. Our default specification sets all hyperparameters of
the Dirichlet-multinomial prior to <code>1</code>.
</p>
</li>
<li>
<p> For each file, specify a prior for the number of duplicates in each
cluster. As a part of this prior, we specify the maximum number of records
in a cluster for each file, through <code>dup_upper_bound</code>. When there
are assumed to be no duplicates in a file, the maximum number of records in
a cluster for that file is set to <code>1</code>. When there are assumed to be
duplicates in a file, we recommend setting the maximum number of records in
a cluster for that file to be less than the file size, if prior knowledge
allows. Currently, a Poisson prior for the the number of duplicates in
each cluster is supported. Our default specification uses a Poisson prior
with mean <code>1</code>.
</p>
</li>
</ul>
<p>Please contact the package maintainer if you need new prior families
for <code>n</code> or the number of duplicates in each cluster to be supported.
</p>


<h3>Value</h3>

<p>a list containing:
</p>

<dl>
<dt><code>mus</code></dt>
<dd>
<p>The hyperparameters of the Dirichlet priors for the
<code>m</code> parameters for the comparisons among matches.</p>
</dd>
<dt><code>nus</code></dt>
<dd>
<p>The hyperparameters of the Dirichlet priors for the
<code>u</code> parameters for the comparisons among non-matches. Includes data
from comparisons of record pairs that were declared to not be potential
matches using <code>reduce_comparison_data</code>.</p>
</dd>
<dt><code>flat</code></dt>
<dd>
<p>A <code>numeric</code> indicator of whether a flat prior for
partitions should be used. <code>flat</code> is <code>1</code> if a flat prior is used,
and <code>flat</code> is <code>0</code> if a structured prior is used.</p>
</dd>
<dt><code>no_dups</code></dt>
<dd>
<p>A <code>numeric</code> indicator of whether no duplicates
are allowed in all of the files.</p>
</dd>
<dt><code>alphas</code></dt>
<dd>
<p>The hyperparameters for the Dirichlet-multinomial
overlap table prior, a positive <code>numeric</code> vector of length
<code>2 ^ comparison_list$K</code>, where the first element is <code>0</code>.</p>
</dd>
<dt><code>alpha_0</code></dt>
<dd>
<p>The sum of <code>alphas</code>.</p>
</dd>
<dt><code>dup_upper_bound</code></dt>
<dd>
<p>A <code>numeric</code> vector indicating the
maximum number of duplicates, from each file, allowed in each cluster. For
a given file <code>k</code>, <code>dup_upper_bound[k]</code> should be between <code>1</code>
and <code>comparison_list$file_sizes[k]</code>, i.e. even if you don't want to
impose an upper bound, you have to implicitly place an upper bound: the
number of records in a file.</p>
</dd>
<dt><code>log_dup_count_prior</code></dt>
<dd>
<p>A <code>list</code> containing the log density
of the prior distribution for the number of duplicates in each cluster, for
each file.</p>
</dd>
<dt><code>log_n_prior</code></dt>
<dd>
<p>A <code>numeric</code> vector containing the log
density of the prior distribution for the number of clusters represented in
the records.</p>
</dd>
<dt><code>nus_specified</code></dt>
<dd>
<p>The <code>nus</code> before data from comparisons of
record pairs that were declared to not be potential matches using
<code>reduce_comparison_data</code> are added. Used for input checking.</p>
</dd>
</dl>
<h3>References</h3>

<p>Serge Aleshin-Guendel &amp; Mauricio Sadinle (2022). Multifile Partitioning for Record Linkage and Duplicate Detection. <em>Journal of the
American Statistical Association</em>. [doi: <a href="https://doi.org/10.1080/01621459.2021.2013242">10.1080/01621459.2021.2013242</a>] [<a href="https://arxiv.org/abs/2110.03839">arXiv</a>]
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example with small no duplicate dataset
data(no_dup_data_small)

# Create the comparison data
comparison_list &lt;- create_comparison_data(no_dup_data_small$records,
 types = c("bi", "lv", "lv", "lv", "lv", "bi", "bi"),
 breaks = list(NA,  c(0, 0.25, 0.5),  c(0, 0.25, 0.5),
               c(0, 0.25, 0.5), c(0, 0.25, 0.5),  NA, NA),
 file_sizes = no_dup_data_small$file_sizes,
 duplicates = c(0, 0, 0))

# Specify the prior
prior_list &lt;- specify_prior(comparison_list, mus = NA, nus = NA, flat = 0,
 alphas = rep(1, 7), dup_upper_bound = c(1, 1, 1),
 dup_count_prior_family = NA, dup_count_prior_pars = NA,
 n_prior_family = "uniform", n_prior_pars = NA)

# Example with small duplicate dataset
data(dup_data_small)

# Create the comparison data
comparison_list &lt;- create_comparison_data(dup_data_small$records,
 types = c("bi", "lv", "lv", "lv", "lv", "bi", "bi"),
 breaks = list(NA,  c(0, 0.25, 0.5),  c(0, 0.25, 0.5),
               c(0, 0.25, 0.5), c(0, 0.25, 0.5),  NA, NA),
 file_sizes = dup_data_small$file_sizes,
 duplicates = c(1, 1, 1))

# Reduce the comparison data
# The following line corresponds to only keeping pairs of records for which
# neither gname nor fname disagree at the highest level
pairs_to_keep &lt;- (comparison_list$comparisons[, "gname_DL_3"] != TRUE) &amp;
 (comparison_list$comparisons[, "fname_DL_3"] != TRUE)
reduced_comparison_list &lt;- reduce_comparison_data(comparison_list,
 pairs_to_keep, cc = 1)

# Specify the prior
prior_list &lt;- specify_prior(reduced_comparison_list, mus = NA, nus = NA,
 flat = 0, alphas = rep(1, 7), dup_upper_bound = c(10, 10, 10),
 dup_count_prior_family = c("Poisson", "Poisson", "Poisson"),
 dup_count_prior_pars = list(c(1), c(1), c(1)), n_prior_family = "uniform",
 n_prior_pars = NA)
</code></pre>


</div>