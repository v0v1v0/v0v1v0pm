<div class="container">

<table style="width: 100%;"><tr>
<td>find_bayes_estimate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find the Bayes Estimate of a Partition</h2>

<h3>Description</h3>

<p>Find the (approximate) Bayes estimate of a partition based on MCMC samples
of the partition and a specified loss function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">find_bayes_estimate(
  partitions,
  burn_in,
  L_FNM = 1,
  L_FM1 = 1,
  L_FM2 = 2,
  L_A = Inf,
  max_cc_size = nrow(partitions),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>partitions</code></td>
<td>
<p>Posterior samples of the partition, where each column
is one sample and the partition is represented as an <code>integer</code> vector of
arbitrary labels, as produced by the output of a call to
<code>gibbs_sampler</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn_in</code></td>
<td>
<p>The number of samples to discard for burn in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L_FNM</code></td>
<td>
<p>Positive loss for a false non-match. Default is <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L_FM1</code></td>
<td>
<p>Positive loss for a type 1 false match. Default is <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L_FM2</code></td>
<td>
<p>Positive loss for a type 2 false match. Default is <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L_A</code></td>
<td>
<p>Positive loss for abstaining from making a decision for a record.
Default is <code>Inf</code>, i.e. decisions are made for all records.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_cc_size</code></td>
<td>
<p>The maximum allowable connected component size over which
the posterior expected loss is minimized. Default is <code>nrow(partitions)</code>,
i.e. no approximation is used. When <code>is.infinite(L_A)</code>, we recommend
setting this argument to <code>50</code>, then increasing based on a computational
budget. When <code>!is.infinite(L_A)</code>, we recommend setting this argument to
<code>10-12</code>, then increasing based on a computational budget (although an
increase of <code>1</code> in this argument can in the worst case lead to a
doubling in computation time).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A <code>logical</code> indicator of whether progress messages should
be print (default <code>TRUE</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector, the same length of a column of <code>partitions</code> containing the
(approximate) Bayes estimate of the partition. If <code>!is.infinite(L_A)</code>
the output may be a partial estimate. A positive number <code>l</code> in index
<code>i</code> indicates that record <code>i</code> is in the same cluster as every other
record <code>j</code> with <code>l</code> in index <code>j</code>. A value of <code>-1</code> in
index <code>i</code> indicates that the Bayes estimate abstained from  making a
decision for record <code>i</code>.
</p>


<h3>References</h3>

<p>Serge Aleshin-Guendel &amp; Mauricio Sadinle (2022). Multifile Partitioning for Record Linkage and Duplicate Detection. <em>Journal of the
American Statistical Association</em>. [doi: <a href="https://doi.org/10.1080/01621459.2021.2013242">10.1080/01621459.2021.2013242</a>][<a href="https://arxiv.org/abs/2110.03839">arXiv</a>]
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example with small no duplicate dataset
data(no_dup_data_small)

# Create the comparison data
comparison_list &lt;- create_comparison_data(no_dup_data_small$records,
 types = c("bi", "lv", "lv", "lv", "lv", "bi", "bi"),
 breaks = list(NA,  c(0, 0.25, 0.5),  c(0, 0.25, 0.5),
               c(0, 0.25, 0.5), c(0, 0.25, 0.5),  NA, NA),
 file_sizes = no_dup_data_small$file_sizes,
 duplicates = c(0, 0, 0))

# Specify the prior
prior_list &lt;- specify_prior(comparison_list, mus = NA, nus = NA, flat = 0,
 alphas = rep(1, 7), dup_upper_bound = c(1, 1, 1),
 dup_count_prior_family = NA, dup_count_prior_pars = NA,
 n_prior_family = "uniform", n_prior_pars = NA)

# Find initialization for the matching (this step is optional)
# The following line corresponds to only keeping pairs of records as
# potential matches in the initialization for which neither gname nor fname
# disagree at the highest level
pairs_to_keep &lt;- (comparison_list$comparisons[, "gname_DL_3"] != TRUE) &amp;
 (comparison_list$comparisons[, "fname_DL_3"] != TRUE)
Z_init &lt;- initialize_partition(comparison_list, pairs_to_keep, seed = 42)

# Run the Gibbs sampler
results &lt;- gibbs_sampler(comparison_list, prior_list, n_iter = 1000,
 Z_init = Z_init, seed = 42)

# Find the full Bayes estimate

full_estimate &lt;- find_bayes_estimate(results$partitions, burn_in = 100,
 L_FNM = 1, L_FM1 = 1, L_FM2 = 2, L_A = Inf, max_cc_size = 50)

# Find the partial Bayes estimate
partial_estimate &lt;- find_bayes_estimate(results$partitions, burn_in = 100,
 L_FNM = 1, L_FM1 = 1, L_FM2 = 2, L_A = 0.1, max_cc_size = 12)


# Example with small duplicate dataset
data(dup_data_small)

# Create the comparison data
comparison_list &lt;- create_comparison_data(dup_data_small$records,
 types = c("bi", "lv", "lv", "lv", "lv", "bi", "bi"),
 breaks = list(NA,  c(0, 0.25, 0.5),  c(0, 0.25, 0.5),
               c(0, 0.25, 0.5), c(0, 0.25, 0.5),  NA, NA),
 file_sizes = dup_data_small$file_sizes,
 duplicates = c(1, 1, 1))

# Reduce the comparison data
# The following line corresponds to only keeping pairs of records for which
# neither gname nor fname disagree at the highest level
pairs_to_keep &lt;- (comparison_list$comparisons[, "gname_DL_3"] != TRUE) &amp;
 (comparison_list$comparisons[, "fname_DL_3"] != TRUE)
reduced_comparison_list &lt;- reduce_comparison_data(comparison_list,
 pairs_to_keep, cc = 1)

# Specify the prior
prior_list &lt;- specify_prior(reduced_comparison_list, mus = NA, nus = NA,
 flat = 0, alphas = rep(1, 7), dup_upper_bound = c(10, 10, 10),
 dup_count_prior_family = c("Poisson", "Poisson", "Poisson"),
 dup_count_prior_pars = list(c(1), c(1), c(1)), n_prior_family = "uniform",
 n_prior_pars = NA)

# Run the Gibbs sampler
results &lt;- gibbs_sampler(reduced_comparison_list, prior_list, n_iter = 1000,
 seed = 42)

# Find the full Bayes estimate

full_estimate &lt;- find_bayes_estimate(results$partitions, burn_in = 100,
 L_FNM = 1, L_FM1 = 1, L_FM2 = 2, L_A = Inf, max_cc_size = 50)

# Find the partial Bayes estimate
partial_estimate &lt;- find_bayes_estimate(results$partitions, burn_in = 100,
 L_FNM = 1, L_FM1 = 1, L_FM2 = 2, L_A = 0.1, max_cc_size = 12)

</code></pre>


</div>