<div class="container">

<table style="width: 100%;"><tr>
<td>multimodelCJS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multimodel inference for 'multimark' open population survival models</h2>

<h3>Description</h3>

<p>This function performs Bayesian multimodel inference for a set of 'multimark' open population survival (i.e., Cormack-Jolly-Seber) models using the reversible jump Markov chain Monte Carlo (RJMCMC) algorithm proposed by Barker &amp; Link (2013).
</p>


<h3>Usage</h3>

<pre><code class="language-R">multimodelCJS(
  modlist,
  modprior = rep(1/length(modlist), length(modlist)),
  monparms = "phi",
  miter = NULL,
  mburnin = 0,
  mthin = 1,
  M1 = NULL,
  pbetapropsd = 1,
  zppropsd = NULL,
  phibetapropsd = 1,
  zphipropsd = NULL,
  sigppropshape = 1,
  sigppropscale = 0.01,
  sigphipropshape = 1,
  sigphipropscale = 0.01,
  printlog = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>modlist</code></td>
<td>
<p>A list of individual model output lists returned by <code>multimarkCJS</code>. The models must have the same number of chains and MCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modprior</code></td>
<td>
<p>Vector of length <code>length(modlist)</code> containing prior model probabilities. Default is <code>modprior = rep(1/length(modlist), length(modlist))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monparms</code></td>
<td>
<p>Parameters to monitor. Only parameters common to all models can be monitored (e.g., "<code>pbeta[(Intercept)]</code>", "<code>phibeta[(Intercept)]</code>", "<code>psi</code>"), but derived survival ("<code>phi</code>") and capture ("<code>p</code>") probabilities can also be monitored. Default is <code>monparms = "phi"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miter</code></td>
<td>
<p>The number of RJMCMC iterations per chain. If <code>NULL</code>, then the number of MCMC iterations for each individual model chain is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mburnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= mburnin &lt; miter</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mthin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M1</code></td>
<td>
<p>Integer vector indicating the initial model for each chain, where <code>M1_j=i</code> initializes the RJMCMC algorithm for chain j in the model corresponding to <code>modlist[[i]]</code> for i=1,...,  <code>length(modlist)</code>. If <code>NULL</code>, the algorithm for all chains is initialized in the most general model. Default is <code>M1=NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pbetapropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, pbetapropsd) proposal distribution for "<code>pbeta</code>"  parameters. Default is <code>pbetapropsd=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zppropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, zppropsd) proposal distribution for "<code>zp</code>"  parameters. Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. If <code>NULL</code>, zppropsd = sqrt(sigma2_zp) is used. Default is <code>zppropsd=NULL</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phibetapropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, phibetapropsd) proposal distribution for "<code>phibeta</code>"  parameters. Default is <code>phibetapropsd=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zphipropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, zphipropsd) proposal distribution for "<code>zphi</code>"  parameters. Only applies if at least one (but not all) model(s) include individual hetergeneity in survival probability. If <code>NULL</code>, zphipropsd = sqrt(sigma2_zphi) is used. Default is <code>zphipropsd=NULL</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigppropshape</code></td>
<td>
<p>Scaler specifying the shape parameter of the invGamma(shape = sigppropshape, scale = sigppropscale) proposal distribution for "<code>sigma2_zp</code>". Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. Default is <code>sigppropshape=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigppropscale</code></td>
<td>
<p>Scaler specifying the scale parameter of the invGamma(shape = sigppropshape, scale = sigppropscale) proposal distribution for "<code>sigma2_zp</code>". Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. Default is <code>sigppropscale=0.01</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigphipropshape</code></td>
<td>
<p>Scaler specifying the shape parameter of the invGamma(shape = sigphipropshape, scale = sigphipropscale) proposal distribution for "<code>sigma2_zphi</code>". Only applies if at least one (but not all) model(s) include individual hetergeneity in survival probability. Default is <code>sigphipropshape=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigphipropscale</code></td>
<td>
<p>Scaler specifying the scale parameter of the invGamma(shape = sigphipropshape, scale = sigphipropscale) proposal distribution for "<code>sigma_zphi</code>". Only applies if at least one (but not all) model(s) include individual hetergeneity in survival probability. Default is <code>sigphipropscale=0.01</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for "Unix-like" machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that setting <code>parms="all"</code> is required when fitting individual <code>multimarkCJS</code> models to be included in <code>modlist</code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>rjmcmc</code></td>
<td>
<p>Reversible jump Markov chain Monte Carlo object of class <code>mcmc.list</code>. Includes RJMCMC output for monitored parameters and the current model at each iteration ("<code>M</code>").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.prob</code></td>
<td>
<p>A list of calculated posterior model probabilities for each chain, including the overall posterior model probabilities across all chains.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Barker, R. J. and Link. W. A. 2013. Bayesian multimodel inference by RJMCMC: a Gibbs sampling approach. The American Statistician 67: 150-156.
</p>


<h3>See Also</h3>

<p><code>multimarkCJS</code>, <code>processdata</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Generate object of class "multimarksetup" from simulated data
data_type = "always"
noccas &lt;- 5
phibetaTime &lt;- seq(2,0,length=noccas-1) # declining trend in survival
data &lt;- simdataCJS(noccas=5,phibeta=phibetaTime,data.type=data_type)
setup &lt;- processdata(data$Enc.Mat,data.type=data_type)

#Run single chain using the default model. Note parms="all".
sim.pdot.phidot &lt;- multimarkCJS(mms=setup,parms="all",iter=1000,adapt=500,burnin=500)

#Run single chain with temporal trend for phi. Note parms="all".
sim.pdot.phiTime &lt;- multimarkCJS(mms=setup,mod.phi=~Time,parms="all",iter=1000,adapt=500,burnin=500)

#Perform RJMCMC using defaults
modlist &lt;- list(mod1=sim.pdot.phidot,mod2=sim.pdot.phiTime)
sim.M &lt;- multimodelCJS(modlist=modlist)

#Posterior model probabilities
sim.M$pos.prob

#multimodel posterior summary for survival (display first cohort only)
summary(sim.M$rjmcmc[,paste0("phi[1,",1:(noccas-1),"]")])

</code></pre>


</div>