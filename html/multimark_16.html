<div class="container">

<table style="width: 100%;"><tr>
<td>multimodelClosed</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multimodel inference for 'multimark' closed population abundance models</h2>

<h3>Description</h3>

<p>This function performs Bayesian multimodel inference for a set of 'multimark' closed population abundance models using the reversible jump Markov chain Monte Carlo (RJMCMC) algorithm proposed by Barker &amp; Link (2013).
</p>


<h3>Usage</h3>

<pre><code class="language-R">multimodelClosed(
  modlist,
  modprior = rep(1/length(modlist), length(modlist)),
  monparms = "N",
  miter = NULL,
  mburnin = 0,
  mthin = 1,
  M1 = NULL,
  pbetapropsd = 1,
  zppropsd = NULL,
  sigppropshape = 6,
  sigppropscale = 4,
  printlog = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>modlist</code></td>
<td>
<p>A list of individual model output lists returned by <code>multimarkClosed</code> or <code>markClosed</code>. The models must have the same number of chains and MCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modprior</code></td>
<td>
<p>Vector of length <code>length(modlist)</code> containing prior model probabilities. Default is <code>modprior = rep(1/length(modlist), length(modlist))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monparms</code></td>
<td>
<p>Parameters to monitor. Only parameters common to all models can be monitored (e.g., "<code>pbeta[(Intercept)]</code>", "<code>N</code>"), but derived capture ("<code>p</code>") and recapture ("<code>c</code>") probabilities can also be monitored. Default is <code>monparms = "N"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miter</code></td>
<td>
<p>The number of RJMCMC iterations per chain. If <code>NULL</code>, then the number of MCMC iterations for each individual model chain is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mburnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= mburnin &lt; miter</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mthin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M1</code></td>
<td>
<p>Integer vector indicating the initial model for each chain, where <code>M1_j=i</code> initializes the RJMCMC algorithm for chain j in the model corresponding to <code>modlist[[i]]</code> for i=1,...,  <code>length(modlist)</code>. If <code>NULL</code>, the algorithm for all chains is initialized in the most general model. Default is <code>M1=NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pbetapropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, pbetapropsd) proposal distribution for "<code>pbeta</code>"  parameters. Default is <code>pbetapropsd=1</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zppropsd</code></td>
<td>
<p>Scaler specifying the standard deviation of the Normal(0, zppropsd) proposal distribution for "<code>zp</code>"  parameters. Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. If <code>NULL</code>, zppropsd = sqrt(sigma2_zp) is used. Default is <code>zppropsd=NULL</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigppropshape</code></td>
<td>
<p>Scaler specifying the shape parameter of the invGamma(shape = sigppropshape, scale = sigppropscale) proposal distribution for <code>sigma_zp</code>. Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. Default is <code>sigppropshape=6</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigppropscale</code></td>
<td>
<p>Scaler specifying the scale parameter of the invGamma(shape = sigppropshape, scale = sigppropscale) proposal distribution for <code>sigma_zp</code>. Only applies if at least one (but not all) model(s) include individual hetergeneity in detection probability. Default is <code>sigppropscale=4</code>. See Barker &amp; Link (2013) for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for "Unix-like" machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that setting <code>parms="all"</code> is required when fitting individual <code>multimarkClosed</code> or <code>markClosed</code> models to be included in <code>modlist</code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>rjmcmc</code></td>
<td>
<p>Reversible jump Markov chain Monte Carlo object of class <code>mcmc.list</code>. Includes RJMCMC output for monitored parameters and the current model at each iteration ("<code>M</code>").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.prob</code></td>
<td>
<p>A list of calculated posterior model probabilities for each chain, including the overall posterior model probabilities across all chains.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>References</h3>

<p>Barker, R. J. and Link. W. A. 2013. Bayesian multimodel inference by RJMCMC: a Gibbs sampling approach. The American Statistician 67: 150-156.
</p>


<h3>See Also</h3>

<p><code>multimarkClosed</code>, <code>markClosed</code>, <code>processdata</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Generate object of class "multimarksetup"
setup &lt;- processdata(bobcat)
 
#Run single chain using the default model for bobcat data. Note parms="all".
bobcat.dot &lt;- multimarkClosed(mms=setup,parms="all",iter=1000,adapt=500,burnin=500)

#Run single chain for bobcat data with time effects. Note parms="all".
bobcat.time &lt;- multimarkClosed(mms=setup,mod.p=~time,parms="all",iter=1000,adapt=500,burnin=500)

#Perform RJMCMC using defaults
modlist &lt;- list(mod1=bobcat.dot,mod2=bobcat.time)
bobcat.M &lt;- multimodelClosed(modlist=modlist,monparms=c("N","p"))

#Posterior model probabilities
bobcat.M$pos.prob
 
#multimodel posterior summary for abundance
summary(bobcat.M$rjmcmc[,"N"])

</code></pre>


</div>