<div class="container">

<table style="width: 100%;"><tr>
<td>markCJS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit open population survival models for “traditional” capture-mark-recapture data consisting of a single mark type</h2>

<h3>Description</h3>

<p>This function fits Cormack-Jolly-Seber (CJS) open population models for survival probability (<code class="reqn">\phi</code>) and capture probability (<code class="reqn">p</code>) for “traditional” capture-mark-recapture data consisting of a single mark type. Using Bayesian analysis methods, Markov chain Monte Carlo (MCMC) is used to draw samples from the joint posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">markCJS(
  Enc.Mat,
  covs = data.frame(),
  mod.p = ~1,
  mod.phi = ~1,
  parms = c("pbeta", "phibeta"),
  nchains = 1,
  iter = 12000,
  adapt = 1000,
  bin = 50,
  thin = 1,
  burnin = 2000,
  taccept = 0.44,
  tuneadjust = 0.95,
  proppbeta = 0.1,
  propzp = 1,
  propsigmap = 1,
  propphibeta = 0.1,
  propzphi = 1,
  propsigmaphi = 1,
  pbeta0 = 0,
  pSigma0 = 1,
  phibeta0 = 0,
  phiSigma0 = 1,
  l0p = 1,
  d0p = 0.01,
  l0phi = 1,
  d0phi = 0.01,
  initial.values = NULL,
  link = "probit",
  printlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Enc.Mat</code></td>
<td>
<p>A matrix of observed encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions. With a single mark type, encounter histories consist of only non-detections (0) and type 1 encounters (1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covs</code></td>
<td>
<p>A data frame of temporal covariates for detection probabilities (ignored unless <code>mms=NULL</code>). The number of rows in the data frame must equal the number of sampling occasions. Covariate names cannot be "time", "age", or "h"; these names are reserved for temporal, behavioral, and individual effects when specifying <code>mod.p</code> and <code>mod.phi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.p</code></td>
<td>
<p>Model formula for detection probability (<code class="reqn">p</code>). For example, <code>mod.p=~1</code> specifies no effects (i.e., intercept only), <code>mod.p~time</code> specifies temporal effects, <code>mod.p~age</code> specifies age effects, <code>mod.p~h</code> specifies individual heterogeneity, and <code>mod.p~time+age</code> specifies additive temporal and age effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.phi</code></td>
<td>
<p>Model formula for survival probability (<code class="reqn">\phi</code>). For example, <code>mod.phi=~1</code> specifies no effects (i.e., intercept only), <code>mod.phi~time</code> specifies temporal effects, <code>mod.phi~age</code> specifies age effects, <code>mod.phi~h</code> specifies individual heterogeneity, and <code>mod.phi~time+age</code> specifies additive temporal and age effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parms</code></td>
<td>
<p>A character vector giving the names of the parameters and latent variables to monitor. Possible parameters are probit-scale detection probability parameters ("<code>pbeta</code>" for <code class="reqn">p</code> and "<code>phibeta</code>" for <code class="reqn">\phi</code>), probit-scale individual heterogeneity variance terms ("<code>sigma2_zp</code>" for <code class="reqn">p</code> and "<code>sigma2_zphi</code>" for <code class="reqn">\phi</code>), and probit-scale individual effects ("<code>zp</code>" and "<code>zphi</code>"). Latent variable indicators for whether each individual was alive (1) or dead (0) during each sampling occasion ("<code>q</code>") and the log likelihood ("<code>loglike</code>") may also be monitored. Setting <code>parms="all"</code> monitors all possible parameters and latent variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nchains</code></td>
<td>
<p>The number of parallel MCMC chains for the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The number of MCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt</code></td>
<td>
<p>Ignored; no adaptive phase is needed for "probit" link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bin</code></td>
<td>
<p>Ignored; no adaptive phase is needed for "probit" link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= burnin &lt; iter</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>taccept</code></td>
<td>
<p>Ignored; no adaptive phase is needed for "probit" link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuneadjust</code></td>
<td>
<p>Ignored; no adaptive phase is needed for "probit" link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proppbeta</code></td>
<td>
<p>Ignored; no adaptive phase is needed for "probit" link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propzp</code></td>
<td>
<p>Ignored; no adaptive phase is needed for "probit" link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propsigmap</code></td>
<td>
<p>Ignored; no adaptive phase is needed for "probit" link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propphibeta</code></td>
<td>
<p>Ignored; no adaptive phase is needed for "probit" link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propzphi</code></td>
<td>
<p>Ignored; no adaptive phase is needed for "probit" link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propsigmaphi</code></td>
<td>
<p>Ignored; no adaptive phase is needed for "probit" link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pbeta0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of pbeta ~ multivariateNormal(pbeta0, pSigma0) prior. If <code>pbeta0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>pbeta0 = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pSigma0</code></td>
<td>
<p>Scaler or k x k matrix specifying covariance matrix of pbeta ~ multivariateNormal(pbeta0, pSigma0) prior. If <code>pSigma0</code> is a scaler, then this value is used for all pSigma0[j,j] for j = 1, ..., k (with pSigma[j,l] = 0 for all <code class="reqn">j \ne l</code>). Default is <code>pSigma0 = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phibeta0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of phibeta ~ multivariateNormal(phibeta0, phiSigma0) prior. If <code>phibeta0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>phibeta0 = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phiSigma0</code></td>
<td>
<p>Scaler or k x k matrix specifying covariance matrix of phibeta ~ multivariateNormal(phibeta0, phiSigma0) prior. If <code>phiSigma0</code> is a scaler, then this value is used for all phiSigma0[j,j] for j = 1, ..., k (with phiSigma[j,l] = 0 for all <code class="reqn">j \ne l</code>). Default is <code>phiSigma0 = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l0p</code></td>
<td>
<p>Specifies "shape" parameter for [sigma2_zp] ~ invGamma(l0p,d0p) prior. Default is <code>l0p = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d0p</code></td>
<td>
<p>Specifies "scale" parameter for [sigma2_zp] ~ invGamma(l0p,d0p) prior. Default is <code>d0p = 0.01</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l0phi</code></td>
<td>
<p>Specifies "shape" parameter for [sigma2_zphi] ~ invGamma(l0phi,d0phi) prior. Default is <code>l0phi = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d0phi</code></td>
<td>
<p>Specifies "scale" parameter for [sigma2_zphi] ~ invGamma(l0phi,d0phi) prior. Default is <code>d0phi = 0.01</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.values</code></td>
<td>
<p>OOptional list of <code>nchain</code> list(s) specifying initial values for "<code>pbeta</code>", "<code>phibeta</code>", "<code>sigma2_zp</code>", "<code>sigma2_zphi</code>", "<code>zp</code>", "<code>zphi</code>", and "<code>q</code>". Default is <code>initial.values = NULL</code>, which causes initial values to be generated automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>Link function for survival and capture probabilities. Only probit link is currently implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for "Unix-like" machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional "<code>parameters</code>" arguments for specifying <code>mod.p</code> and <code>mod.phi</code>. See <code>RMark::make.design.data</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The first time <code>markCJS</code> (or <code>markClosed</code>) is called, it will likely produce a firewall warning alerting users that R has requested the ability to accept incoming network connections. Incoming network connections are required to use parallel processing as implemented in <code>multimarkCJS</code>. Note that setting <code>parms="all"</code> is required for any <code>markCJS</code> model output to be used in <code>multimodelCJS</code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>Markov chain Monte Carlo object of class <code>mcmc.list</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.p</code></td>
<td>
<p>Model formula for detection probability (as specified by <code>mod.p</code> above).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.phi</code></td>
<td>
<p>Model formula for survival probability (as specified by <code>mod.phi</code> above).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.delta</code></td>
<td>
<p>Formula always <code>NULL</code>; only for internal use in <code>multimodelCJS</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DM</code></td>
<td>
<p>A list of design matrices for detection and survival probability respectively generated by <code>mod.p</code> and <code>mod.phi</code>, where DM$p is the design matrix for capture probability (<code class="reqn">p</code>) and DM$phi is the design matrix for survival probability (<code class="reqn">\phi</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.values</code></td>
<td>
<p>A list containing the parameter and latent variable values at iteration <code>iter</code> for each chain. Values are provided for "<code>pbeta</code>", "<code>phibeta</code>", "<code>sigma2_zp</code>", "<code>sigma2_zphi</code>", "<code>zp</code>", "<code>zphi</code>", and "<code>q</code>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mms</code></td>
<td>
<p>An object of class <code>multimarksetup</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>See Also</h3>

<p><code>processdata</code>, <code>multimodelCJS</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# These examples are excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Simulate open population data using defaults
data &lt;- simdataCJS(delta_1=1,delta_2=0)$Enc.Mat

#Fit default open population model
sim.dot &lt;- markCJS(data)

#Posterior summary for monitored parameters
summary(sim.dot$mcmc)
plot(sim.dot$mcmc)

#Fit ``age'' model with 2 age classes (e.g., juvenile and adult) for survival
#using 'parameters' and 'right' arguments from RMark::make.design.data
sim.age &lt;- markCJS(data,mod.phi=~age,
           parameters=list(Phi=list(age.bins=c(0,1,4))),right=FALSE)
summary(getprobsCJS(sim.age))

</code></pre>


</div>