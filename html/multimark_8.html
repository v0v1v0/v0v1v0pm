<div class="container">

<table style="width: 100%;"><tr>
<td>markClosed</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit closed population abundance models for “traditional” capture-mark-recapture data consisting of a single mark type</h2>

<h3>Description</h3>

<p>This function fits closed population abundance models for “traditional” capture-mark-recapture data consisting of a single mark type using Bayesian analysis methods. Markov chain Monte Carlo (MCMC) is used to draw samples from the joint posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">markClosed(
  Enc.Mat,
  covs = data.frame(),
  mod.p = ~1,
  parms = c("pbeta", "N"),
  nchains = 1,
  iter = 12000,
  adapt = 1000,
  bin = 50,
  thin = 1,
  burnin = 2000,
  taccept = 0.44,
  tuneadjust = 0.95,
  proppbeta = 0.1,
  propzp = 1,
  propsigmap = 1,
  npoints = 500,
  a = 25,
  mu0 = 0,
  sigma2_mu0 = 1.75,
  initial.values = NULL,
  printlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Enc.Mat</code></td>
<td>
<p>A matrix of observed encounter histories with rows corresponding to individuals and columns corresponding to sampling occasions. With a single mark type, encounter histories consist of only non-detections (0) and type 1 encounters (1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covs</code></td>
<td>
<p>A data frame of temporal covariates for detection probabilities (ignored unless <code>mms=NULL</code>). The number of rows in the data frame must equal the number of sampling occasions. Covariate names cannot be "time", "age", or "h"; these names are reserved for temporal, behavioral, and individual effects when specifying <code>mod.p</code> and <code>mod.phi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.p</code></td>
<td>
<p>Model formula for detection probability. For example, <code>mod.p=~1</code> specifies no effects (i.e., intercept only), <code>mod.p~time</code> specifies temporal effects, <code>mod.p~c</code> specifies behavioral reponse (i.e., trap "happy" or "shy"), <code>mod.p~h</code> specifies individual heterogeneity, and <code>mod.p~time+c</code> specifies additive temporal and behavioral effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parms</code></td>
<td>
<p>A character vector giving the names of the parameters and latent variables to monitor. Possible parameters are logit-scale detection probability parameters ("<code>pbeta</code>"), population abundance ("<code>N</code>"), logit-scale individual heterogeneity variance term ("<code>sigma2_zp</code>"), and logit-scale individual effects ("<code>zp</code>"). The log posterior density ("<code>logPosterior</code>") may also be monitored. Setting <code>parms="all"</code> monitors all possible parameters and latent variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nchains</code></td>
<td>
<p>The number of parallel MCMC chains for the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The number of MCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt</code></td>
<td>
<p>The number of iterations for proposal distribution adaptation. If <code>adapt = 0</code> then no adaptation occurs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bin</code></td>
<td>
<p>Bin length for calculating acceptance rates during adaptive phase (<code>0 &lt; bin &lt;= iter</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>Thinning interval for monitored parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Number of burn-in iterations (<code>0 &lt;= burnin &lt; iter</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>taccept</code></td>
<td>
<p>Target acceptance rate during adaptive phase (<code>0 &lt; taccept &lt;= 1</code>). Acceptance rate is monitored every <code>bin</code> iterations. Default is <code>taccept = 0.44</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuneadjust</code></td>
<td>
<p>Adjustment term during adaptive phase (<code>0 &lt; tuneadjust &lt;= 1</code>). If acceptance rate is less than <code>taccept</code>, then proposal term (<code>proppbeta</code>, <code>propzp</code>, or <code>propsigmap</code>) is multiplied by <code>tuneadjust</code>. If acceptance rate is greater than or equal to <code>taccept</code>, then proposal term is divided by <code>tuneadjust</code>. Default is <code>tuneadjust = 0.95</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proppbeta</code></td>
<td>
<p>Scaler or vector (of length k) specifying the initial standard deviation of the Normal(pbeta[j], proppbeta[j]) proposal distribution. If <code>proppbeta</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>proppbeta = 0.1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propzp</code></td>
<td>
<p>Scaler or vector (of length M) specifying the initial standard deviation of the Normal(zp[i], propzp[i]) proposal distribution. If <code>propzp</code> is a scaler, then this value is used for all i = 1, ..., M individuals. Default is <code>propzp = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propsigmap</code></td>
<td>
<p>Scaler specifying the initial Gamma(shape = 1/<code>propsigmap</code>, scale = sigma_zp * <code>propsigmap</code>) proposal distribution for sigma_zp = sqrt(sigma2_zp). Default is <code>propsigmap=1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npoints</code></td>
<td>
<p>Number of Gauss-Hermite quadrature points to use for numerical integration. Accuracy increases with number of points, but so does computation time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Scale parameter for [sigma_z] ~ half-Cauchy(a) prior for the individual hetegeneity term sigma_zp = sqrt(sigma2_zp). Default is “uninformative” <code>a = 25</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu0</code></td>
<td>
<p>Scaler or vector (of length k) specifying mean of pbeta[j] ~ Normal(mu0[j], sigma2_mu0[j]) prior. If <code>mu0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>mu0 = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2_mu0</code></td>
<td>
<p>Scaler or vector (of length k) specifying variance of pbeta[j] ~ Normal(mu0[j], sigma2_mu0[j]) prior. If <code>sigma2_mu0</code> is a scaler, then this value is used for all j = 1, ..., k. Default is <code>sigma2_mu0 = 1.75</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.values</code></td>
<td>
<p>Optional list of <code>nchain</code> list(s) specifying initial values for "<code>pbeta</code>", "<code>zp</code>", "<code>sigma2_zp</code>", and "<code>N</code>". Default is <code>initial.values = NULL</code>, which causes initial values to be generated automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printlog</code></td>
<td>
<p>Logical indicating whether to print the progress of chains and any errors to a log file in the working directory. Ignored when <code>nchains=1</code>. Updates are printed to log file as 1% increments of <code>iter</code> of each chain are completed. With &gt;1 chains, setting <code>printlog=TRUE</code> is probably most useful for Windows users because progress and errors are automatically printed to the R console for "Unix-like" machines (i.e., Mac and Linux) when <code>printlog=FALSE</code>. Default is <code>printlog=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional "<code>parameters</code>" arguments for specifying <code>mod.p</code>. See <code>make.design.data</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The first time <code>markClosed</code> (or <code>markCJS</code>) is called, it will likely produce a firewall warning alerting users that R has requested the ability to accept incoming network connections. Incoming network connections are required to use parallel processing as implemented in <code>markClosed</code>. Note that setting <code>parms="all"</code> is required for any <code>markClosed</code> model output to be used in <code>multimodelClosed</code>.
</p>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>Markov chain Monte Carlo object of class <code>mcmc.list</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.p</code></td>
<td>
<p>Model formula for detection probability (as specified by <code>mod.p</code> above).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.delta</code></td>
<td>
<p>Formula always <code>NULL</code>; only for internal use in <code>multimodelClosed</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DM</code></td>
<td>
<p>A list of design matrices for detection probability generated for model <code>mod.p</code>, where DM$p is the design matrix for initial capture probability (p) and DM$c is the design matrix for recapture probability (c).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.values</code></td>
<td>
<p>A list containing the parameter and latent variable values at iteration <code>iter</code> for each chain. Values are provided for "<code>pbeta</code>", "<code>zp</code>", "<code>sigma2_zp</code>", and "<code>N</code>".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mms</code></td>
<td>
<p>An object of class <code>multimarksetup</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Brett T. McClintock
</p>


<h3>See Also</h3>

<p><code>multimodelClosed</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# This example is excluded from testing to reduce package check time
# Example uses unrealistically low values for nchain, iter, and burnin

#Run single chain using the default model for simulated ``traditional'' data
data&lt;-simdataClosed(delta_1=1,delta_2=0)$Enc.Mat
sim.dot&lt;-markClosed(data)

#Posterior summary for monitored parameters
summary(sim.dot$mcmc)
plot(sim.dot$mcmc)

</code></pre>


</div>