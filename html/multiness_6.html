<div class="container">

<table style="width: 100%;"><tr>
<td>multiness_sim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate from the MultiNeSS model</h2>

<h3>Description</h3>

<p><code>multiness_sim</code> simulates a realization of the Gaussian
or logistic MultiNeSS model with Gaussian latent positions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multiness_sim(n,m,d1,d2,model,sigma,self_loops,opts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>A positive integer, the number of nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>A positive integer, the number of layers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d1</code></td>
<td>
<p>A non-negative integer, the number of common latent dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d2</code></td>
<td>
<p>A non-negative integer, the number of individual latent dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A string which provides choice of model,
either <code>'gaussian'</code> or <code>'logistic'</code>. Defaults to <code>'gaussian'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>A positive scalar or numeric vector of length <code>m</code>,
the entry-wise standard deviation for the Gaussian noise for all layers
(if a scalar) or for each layer (if a vector). Ignored under the logistic
model. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>self_loops</code></td>
<td>
<p>A Boolean, if <code>FALSE</code>, all diagonal entries are set
to zero. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opts</code></td>
<td>
<p>A list, containing additional optional arguments:
</p>

<dl>
<dt>density_shift</dt>
<dd>
<p>A positive scalar, for the logistic model only, a shift
subtracted from the log-odds of each edge to control overall edge density. Defaults to <code>0</code>.</p>
</dd>
<dt>dependence_type</dt>
<dd>
<p>A string, valid choices are <code>'all'</code> or
<code>'U_only'</code> for the Gaussian model; <code>'all'</code> for the logistic
model. If <code>'all'</code>, <code class="reqn">V</code> and <code class="reqn">U_k</code>; and <code class="reqn">U_k</code> and <code class="reqn">U_l</code>
(for <code class="reqn">k \neq l</code>) have expected canonical correlation approximately equal to
|<code class="reqn">rho</code>| (see <code>rho</code>).
If <code>'U_only'</code>, <code class="reqn">U_k</code> and <code class="reqn">U_l</code> (for <code class="reqn">k \neq l</code>) have expected
canonical correlation approximately equal to |<code class="reqn">rho</code>| (see <code>rho</code>).
Defaults to <code>'all'</code>.</p>
</dd>
<dt>gamma</dt>
<dd>
<p>A positive scalar, the standard deviation of the entries of
the latent position matrices <code class="reqn">V</code> and <code class="reqn">U_k</code>. Defaults to <code>1</code>.</p>
</dd>
<dt>return_density</dt>
<dd>
<p>A Boolean, if <code>TRUE</code> and <code>model='logistic'</code>, the function will return an array containing
the overall edge density. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>return_P</dt>
<dd>
<p>A Boolean, if <code>TRUE</code>, the function will return an array containing
the expected adjacency matrices. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>rho</dt>
<dd>
<p>A positive scalar in the interval (-1,1), controls the expected canonical
correlation between latent position matrices (see <code>dependence_type</code>).
Defaults to <code>0</code>.</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The common and individual latent positions, <code class="reqn">V</code> and <code class="reqn">U_k</code>
respectively, are generated as
Gaussian random variables with standard deviation <code>opts$gamma</code>, and
dependence controlled by the optional
arguments <code>opts$dependence_type</code> and <code>opts$rho</code>.
</p>
<p>Under the Gaussian model, the <code class="reqn">n \times n</code> adjacency matrix for layer <code class="reqn">k=1,...,m</code>
has independent Gaussian entries with standard deviation <code>sigma</code> and
mean given by
</p>
<p style="text-align: center;"><code class="reqn">E(A_k) = VV^{T} + U_kU_k^{T}.</code>
</p>

<p>Under the logistic model, the <code class="reqn">n \times n</code> adjacency matrix for layer <code class="reqn">k=1,...,m</code>
has independent Bernoulli entries with mean given by
</p>
<p style="text-align: center;"><code class="reqn">E(A_k) = g(VV^{T} + U_kU_k^{T}),</code>
</p>

<p>where <code class="reqn">g</code> denotes the element-wise application of the inverse logistic
link (<code>expit</code>) function. Under both models, <code>self_loops</code> provides
an option to set the diagonal entries of the adjacency matrices to zero.
</p>


<h3>Value</h3>

<p>A list is returned with the realizations of the latent dimensions
and the multiplex network:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>An array of dimension <code class="reqn">n \times n \times m</code>, the realized
multiplex network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>A matrix of dimension <code class="reqn">n \times d1</code>, the realized common
latent positions. If <code>d1=0</code>, returns <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>An array of dimension <code class="reqn">n \times d2 \times m</code>, the realized
individual latent positions. If <code>d2=0</code>, returns <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>If specified, an array of dimension <code class="reqn">n \times n \times m</code>, the expected
multiplex network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density</code></td>
<td>
<p>If specified and <code>model='logistic'</code>, the overall edge density.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># gaussian model, uncorrelated latent positions
data1 &lt;- multiness_sim(n=100,m=4,d1=2,d2=2,
                      model="gaussian")

# logistic model, correlated latent positions
data2 &lt;- multiness_sim(n=100,m=4,d1=2,d2=2,
                       model="logistic",
                       self_loops=FALSE,
                       opts=list(dependence_type="all",rho=.3,return_density=TRUE))

</code></pre>


</div>