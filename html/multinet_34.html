<div class="container">

<table style="width: 100%;"><tr>
<td>multinet.generation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generation of multilayer networks
</h2>

<h3>Description</h3>

<p>The grow_ml function generates a multilayer network by letting it grow for a number of steps, where for each step three events can happen: (1) evolution according to internal dynamics (in which case a specific internal evolution model is used), (2) evolution importing edges from another layer, and (3) no action. The functions evolution_pa_ml and evolution_er_ml define, respectively, an evolutionary model based on preferential attachment and an evolutionary model where edges are created by choosing random end points, as in the ER random graph model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">grow_ml(num.actors, num.steps, models, pr.internal, pr.external, dependency)
evolution_pa_ml(m0,m)
evolution_er_ml(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>num.actors</code></td>
<td>
<p>The number of actors from which new nodes are selected during the generation process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.steps</code></td>
<td>
<p>Number of timestamps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p>A vector containing one evolutionary model for each layer to be generated. Evolutionary models are defined using the <code>evolution_*_ml</code> functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pr.internal</code></td>
<td>
<p>A vector with (for each layer) the probability that at each step the layer evolves according to the internal evolutionary model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pr.external</code></td>
<td>
<p>A vector with (for each layer) the probability that at each step the layer evolves importing edges from another layer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dependency</code></td>
<td>
<p>A matrix LxL where element (i,j) indicates the probability that layer i will import an edge from layer j in case an external event is triggered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m0</code></td>
<td>
<p>Initial number of nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Number of edges created for each new vertex joining the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of vertices (created at the beginning, before starting adding edges).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>grow_ml</code> returns a multilayer network. <code>evolution_*_ml</code> return evolutionary models that are used by <code>grow_ml</code> to decide how each layer should grow.
</p>


<h3>References</h3>

<p>Magnani, Matteo, and Luca Rossi. 2013. Formation of Multiple Networks. In Social Computing, Behavioral-Cultural Modeling and Prediction, 257-264. Springer Berlin Heidelberg.
</p>


<h3>See Also</h3>

<p>multinet.predefined, multinet.IO
</p>


<h3>Examples</h3>

<pre><code class="language-R"># we generate a network with two layers, one growing according
# to the Preferential Attachment model and one growing by selecting
# new edges uniformly at random.
models &lt;- c(evolution_pa_ml(3,1), evolution_er_ml(50))
# all the probability vectors must have the same number of
# fields, one for each layer: two in this example
# by defining pr.internal and pr.external, we are also implicitely defining
# pr.no.action (1 minus the other probabilities, for each field/layer).
pr_external &lt;- c(.5,0)
pr_internal &lt;- c(.5,.5)
# each layer will import edges from the other if needed
# (not the second layer in this example: it has 0 probability of external events)
dependency &lt;- matrix(c(0,1,1,0),2,2)
# 100 steps of network growing, adding actors from a pool of 100
grow_ml(100, 100, models, pr_internal, pr_external, dependency)
</code></pre>


</div>