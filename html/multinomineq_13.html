<div class="container">

<table style="width: 100%;"><tr>
<td>count_binom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Count How Many Samples Satisfy Linear Inequalities (Binomial)</h2>

<h3>Description</h3>

<p>Draws prior/posterior samples for product-binomial data and counts how many samples are
inside the convex polytope defined by
(1) the inequalities <code>A*x &lt;= b</code> or
(2) the convex hull over the vertices <code>V</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">count_binom(
  k,
  n,
  A,
  b,
  V,
  map,
  prior = c(1, 1),
  M = 10000,
  steps,
  start,
  cmin = 0,
  maxiter = 500,
  burnin = 5,
  progress = TRUE,
  cpu = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>vector of observed response frequencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of choices per item type.
If <code>k=n=0</code>, Bayesian inference is relies on the prior distribution only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a matrix with one row for each linear inequality constraint and one
column for each of the free parameters. The parameter space is defined
as all probabilities <code>x</code> that fulfill the order constraints  <code>A*x &lt;= b</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>a vector of the same length as the number of rows of <code>A</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>a matrix of vertices (one per row) that define the polytope of
admissible parameters as the convex hull over these points
(if provided, <code>A</code> and <code>b</code> are ignored).
Similar as for <code>A</code>, columns of <code>V</code> omit the last value for each
multinomial condition (e.g., a1,a2,a3,b1,b2 becomes a1,a2,b1).
Note that this method is comparatively slow since it solves linear-programming problems
to test whether a point is inside  a polytope (Fukuda, 2004) or to run the Gibbs sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>optional: numeric vector of the same length as <code>k</code> with integers
mapping the frequencies <code>k</code> to the free parameters/columns of <code>A</code>/<code>V</code>,
thereby allowing for equality constraints (e.g., <code>map=c(1,1,2,2)</code>).
Reversed probabilities <code>1-p</code> are coded by negative integers.
Guessing probabilities of .50 are encoded by zeros. The default assumes
different parameters for each item type: <code>map=1:ncol(A)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>a vector with two positive numbers defining the shape parameters
of the beta prior distributions for each binomial rate parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>number of posterior samples drawn from the encompassing model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>an integer vector that indicates the row numbers at which the matrix <code>A</code>
is split for a stepwise computation of the Bayes factor (see details).
<code>M</code> can be a vector with the number of samples drawn
in each step from the (partially) order-constrained models  using Gibbs sampling.
If <code>cmin&gt;0</code>, samples are drawn for each step until <code>count[i]&gt;=cmin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>only relevant if <code>steps</code> is defined or <code>cmin&gt;0</code>:
a vector with starting values in the interior of the polytope.
If missing, an approximate maximum-likelihood estimate is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cmin</code></td>
<td>
<p>if <code>cmin&gt;0</code>: minimum number of counts per step in the automatic stepwise procedure.
If <code>steps</code> is not defined, <code>steps=c(1,2,3,4,...)</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>if <code>cmin&gt;0</code>: maximum number of sampling runs in the automatic stepwise procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>number of burnin samples per step that are discarded. Since the
maximum-likelihood estimate is used as a start value (which is updated for each step in
the stepwise procedure in <code>count_multinom</code>), the <code>burnin</code>
number can be smaller than in other MCMC applications.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>whether a progress bar should be shown (if <code>cpu=1</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpu</code></td>
<td>
<p>either the number of CPUs used for parallel sampling, or a parallel
cluster  (e.g., <code>cl &lt;- parallel::makeCluster(3)</code>).
All arguments of the function call are passed directly to each core,
and thus the total number of samples is <code>M*number_cpu</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Counts the number of random samples drawn from beta distributions that satisfy
the convex, linear-inequalitiy constraints. The function is useful to compute
the encompassing Bayes factor for testing inequality-constrained models
(see <code>bf_binom</code>; Hojtink, 2011).
</p>
<p>The stepwise computation of the Bayes factor proceeds as follows:
If the steps are defined as <code>steps=c(5,10)</code>, the BF is computed in three steps by comparing:
(1) Unconstrained model vs. inequalities in <code>A[1:5,]</code>;
(2) use posterior based on inequalities in <code>A[1:5,]</code> and check inequalities <code>A[6:10,]</code>;
(3) sample from A[1:10,] and check inequalities in <code>A[11:nrow(A),]</code> (i.e., all inequalities).
</p>


<h3>Value</h3>

<p>a matrix with the columns
</p>

<ul>
<li>
<p><code>count</code>: number of samples in polytope / that satisfy order constraints
</p>
</li>
<li>
<p><code>M</code>: the  total number of samples in each step
</p>
</li>
<li>
<p><code>steps</code>: the <code>"steps"</code> used to sample from the polytope
(i.e., the row numbers of <code>A</code> that were considered  stepwise)
</p>
</li>
</ul>
<p>with the attributes:
</p>

<ul>
<li>
<p><code>proportion</code>: estimated probability that samples are in polytope
</p>
</li>
<li>
<p><code>se</code>: standard error of probability estimate
</p>
</li>
<li>
<p><code>const_map</code>: logarithm of the binomial constants that
have to be considered due to equality constraints
</p>
</li>
</ul>
<h3>References</h3>

<p>Hoijtink, H. (2011). Informative Hypotheses: Theory and Practice for Behavioral and Social Scientists. Boca Raton, FL: Chapman &amp; Hall/CRC.
</p>
<p>Fukuda, K. (2004). Is there an efficient way of determining whether a given point q is in the convex hull of a given finite set S of points in Rd? Retrieved from <a href="https://www.cs.mcgill.ca/~fukuda/soft/polyfaq/node22.html">https://www.cs.mcgill.ca/~fukuda/soft/polyfaq/node22.html</a>
</p>


<h3>See Also</h3>

<p><code>bf_binom</code>, <code>count_multinom</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### a set of linear order constraints:
### x1 &lt; x2 &lt; .... &lt; x6 &lt; .50
A &lt;- matrix(
  c(
    1, -1, 0, 0, 0, 0,
    0, 1, -1, 0, 0, 0,
    0, 0, 1, -1, 0, 0,
    0, 0, 0, 1, -1, 0,
    0, 0, 0, 0, 1, -1,
    0, 0, 0, 0, 0, 1
  ),
  ncol = 6, byrow = TRUE
)
b &lt;- c(0, 0, 0, 0, 0, .50)

### check whether a specific vector is inside the polytope:
A %*% c(.05, .1, .12, .16, .19, .23) &lt;= b


### observed frequencies and number of observations:
k &lt;- c(0, 3, 2, 5, 3, 7)
n &lt;- rep(10, 6)

### count prior samples and compare to analytical result
prior &lt;- count_binom(0, 0, A, b, M = 5000, steps = 1:4)
prior # to get the proportion: attr(prior, "proportion")
(.50)^6 / factorial(6)

### count posterior samples + get Bayes factor
posterior &lt;- count_binom(k, n, A, b, M = 2000, steps = 1:4)
count_to_bf(posterior, prior)

### automatic stepwise algorithm
prior &lt;- count_binom(0, 0, A, b, M = 500, cmin = 200)
posterior &lt;- count_binom(k, n, A, b, M = 500, cmin = 200)
count_to_bf(posterior, prior)

</code></pre>


</div>