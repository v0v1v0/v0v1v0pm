<div class="container">

<table style="width: 100%;"><tr>
<td>sampling_multinom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Posterior Sampling for Inequality-Constrained Multinomial Models</h2>

<h3>Description</h3>

<p>Uses Gibbs sampling to draw posterior samples for binomial and multinomial
models with linear inequality-constraints.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sampling_multinom(
  k,
  options,
  A,
  b,
  V,
  prior = rep(1, sum(options)),
  M = 5000,
  start,
  burnin = 10,
  progress = TRUE,
  cpu = 1
)

sampling_binom(
  k,
  n,
  A,
  b,
  V,
  map = 1:ncol(A),
  prior = c(1, 1),
  M = 5000,
  start,
  burnin = 10,
  progress = TRUE,
  cpu = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>the number of choices for each alternative ordered by item type (e.g.
<code>c(a1,a2,a3,  b1,b2)</code> for a ternary and a binary item type).
The length of <code>k</code> must be equal to the sum of <code>options</code>.
The default <code>k=0</code> is equivalent to sampling from the prior.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>number of observable categories/probabilities for each item
type/multinomial distribution, e.g., <code>c(3,2)</code> for a ternary and binary item.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a matrix with one row for each linear inequality constraint and one
column for each of the free parameters. The parameter space is defined
as all probabilities <code>x</code> that fulfill the order constraints  <code>A*x &lt;= b</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>a vector of the same length as the number of rows of <code>A</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>a matrix of vertices (one per row) that define the polytope of
admissible parameters as the convex hull over these points
(if provided, <code>A</code> and <code>b</code> are ignored).
Similar as for <code>A</code>, columns of <code>V</code> omit the last value for each
multinomial condition (e.g., a1,a2,a3,b1,b2 becomes a1,a2,b1).
Note that this method is comparatively slow since it solves linear-programming problems
to test whether a point is inside  a polytope (Fukuda, 2004) or to run the Gibbs sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>the prior parameters of the Dirichlet-shape parameters.
Must have the same length as <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>number of posterior samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>only relevant if <code>steps</code> is defined or <code>cmin&gt;0</code>:
a vector with starting values in the interior of the polytope.
If missing, an approximate maximum-likelihood estimate is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>number of burnin samples that are discarded. Can be chosen to be
small if the maxmimum-a-posteriori estimate is used as the (default) starting value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>whether a progress bar should be shown (if <code>cpu=1</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpu</code></td>
<td>
<p>either the number of CPUs using separate MCMC chains in parallel,
or a parallel cluster (e.g., <code>cl &lt;- parallel::makeCluster(3)</code>).
All arguments of the function call are passed directly to each core,
and thus the total number of samples is <code>M*number_cpu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of choices per item type.
If <code>k=n=0</code>, Bayesian inference is relies on the prior distribution only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>optional: numeric vector of the same length as <code>k</code> with integers
mapping the frequencies <code>k</code> to the free parameters/columns of <code>A</code>/<code>V</code>,
thereby allowing for equality constraints (e.g., <code>map=c(1,1,2,2)</code>).
Reversed probabilities <code>1-p</code> are coded by negative integers.
Guessing probabilities of .50 are encoded by zeros. The default assumes
different parameters for each item type: <code>map=1:ncol(A)</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Draws posterior samples for binomial/multinomial random utility models that
assume a mixture over predefined preference orders/vertices that jointly define
a convex polytope via the set of inequalities <code>A * x &lt; b</code> or as the
convex hull of a set of vertices <code>V</code>.
</p>


<h3>Value</h3>

<p>an <code>mcmc</code> matrix (or an <code>mcmc.list</code> if <code>cpu&gt;1</code>) with
posterior samples of the binomial/multinomial probability parameters.
See <code>mcmc</code>) .
</p>


<h3>References</h3>

<p>Myung, J. I., Karabatsos, G., &amp; Iverson, G. J. (2005). A Bayesian approach to testing decision making axioms. <em>Journal of Mathematical Psychology, 49</em>, 205-225. <a href="https://doi.org/10.1016/j.jmp.2005.02.004">doi:10.1016/j.jmp.2005.02.004</a>
</p>


<h3>See Also</h3>

<p><code>count_multinom</code>, <code>ml_multinom</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">############### binomial ##########################
A &lt;- matrix(
  c(
    1, 0, 0, # x1 &lt; .50
    1, 1, 1, # x1+x2+x3 &lt; 1
    0, 2, 2, # 2*x2+2*x3 &lt; 1
    0, -1, 0, # x2 &gt; .2
    0, 0, 1
  ), # x3 &lt; .1
  ncol = 3, byrow = TRUE
)
b &lt;- c(.5, 1, 1, -.2, .1)
samp &lt;- sampling_binom(c(5, 12, 7), c(20, 20, 20), A, b)
head(samp)
plot(samp)


############### multinomial ##########################
# binary and ternary choice:
#           (a1,a2   b1,b2,b3)
k &lt;- c(15, 9, 5, 2, 17)
options &lt;- c(2, 3)

# columns:   (a1,  b1,b2)
A &lt;- matrix(
  c(
    1, 0, 0, # a1 &lt; .20
    0, 2, 1, # 2*b1+b2 &lt; 1
    0, -1, 0, # b1 &gt; .2
    0, 0, 1
  ), # b2 &lt; .4
  ncol = 3, byrow = TRUE
)
b &lt;- c(.2, 1, -.2, .4)
samp &lt;- sampling_multinom(k, options, A, b)
head(samp)
plot(samp)
</code></pre>


</div>