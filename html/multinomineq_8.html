<div class="container">

<table style="width: 100%;"><tr>
<td>bf_binom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayes Factor for Linear Inequality Constraints</h2>

<h3>Description</h3>

<p>Computes the Bayes factor for product-binomial/-multinomial models with
linear order-constraints (specified via: <code>A*x &lt;= b</code> or the convex hull <code>V</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">bf_binom(k, n, A, b, V, map, prior = c(1, 1), log = FALSE, ...)

bf_multinom(
  k,
  options,
  A,
  b,
  V,
  prior = rep(1, sum(options)),
  log = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>vector of observed response frequencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of choices per item type.
If <code>k=n=0</code>, Bayesian inference is relies on the prior distribution only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a matrix with one row for each linear inequality constraint and one
column for each of the free parameters. The parameter space is defined
as all probabilities <code>x</code> that fulfill the order constraints  <code>A*x &lt;= b</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>a vector of the same length as the number of rows of <code>A</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>a matrix of vertices (one per row) that define the polytope of
admissible parameters as the convex hull over these points
(if provided, <code>A</code> and <code>b</code> are ignored).
Similar as for <code>A</code>, columns of <code>V</code> omit the last value for each
multinomial condition (e.g., a1,a2,a3,b1,b2 becomes a1,a2,b1).
Note that this method is comparatively slow since it solves linear-programming problems
to test whether a point is inside  a polytope (Fukuda, 2004) or to run the Gibbs sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>optional: numeric vector of the same length as <code>k</code> with integers
mapping the frequencies <code>k</code> to the free parameters/columns of <code>A</code>/<code>V</code>,
thereby allowing for equality constraints (e.g., <code>map=c(1,1,2,2)</code>).
Reversed probabilities <code>1-p</code> are coded by negative integers.
Guessing probabilities of .50 are encoded by zeros. The default assumes
different parameters for each item type: <code>map=1:ncol(A)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>a vector with two positive numbers defining the shape parameters
of the beta prior distributions for each binomial rate parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>whether to return the log-Bayes factor instead of the Bayes factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to <code>count_binom</code> or
<code>count_multinom</code> (e.g., <code>M</code>, <code>steps</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>number of observable categories/probabilities for each item
type/multinomial distribution, e.g., <code>c(3,2)</code> for a ternary and binary item.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For more control, use <code>count_binom</code> to specifiy how many samples
should be drawn from the prior and posterior, respectively. This is especially
recommended if the same prior distribution (and thus the same prior probability/integral)
is used for computing BFs for multiple data sets that differ only in the
observed frequencies <code>k</code> and the sample size <code>n</code>.
In this case, the prior probability/proportion of the parameter space in line
with the inequality constraints can be computed once with high precision
(or even analytically), and only the posterior probability/proportion needs
to be estimated separately for each unique vector <code>k</code>.
</p>


<h3>Value</h3>

<p>a matrix with two columns (Bayes factor and SE of approximation) and three rows:
</p>

<ul>
<li> <p><code>`bf_0u`</code>:  constrained vs. unconstrained (saturated) model
</p>
</li>
<li> <p><code>`bf_u0`</code>:  unconstrained vs. constrained model
</p>
</li>
<li> <p><code>`bf_00'`</code>: constrained vs. complement of inequality-constrained model
(e.g., pi&gt;.2 becomes pi&lt;=.2; this assumes identical equality constraints for both models)
</p>
</li>
</ul>
<h3>References</h3>

<p>Karabatsos, G. (2005). The exchangeable multinomial model as an approach to testing deterministic axioms of choice and measurement. Journal of Mathematical Psychology, 49(1), 51-69. <a href="https://doi.org/10.1016/j.jmp.2004.11.001">doi:10.1016/j.jmp.2004.11.001</a>
</p>
<p>Regenwetter, M., Davis-Stober, C. P., Lim, S. H., Guo, Y., Popova, A., Zwilling, C., â€¦ Messner, W. (2014). QTest: Quantitative testing of theories of binary choice. Decision, 1(1), 2-34. <a href="https://doi.org/10.1037/dec0000007">doi:10.1037/dec0000007</a>
</p>


<h3>See Also</h3>

<p><code>count_binom</code> and <code>count_multinom</code> for
for more control on the number of prior/posterior samples and
<code>bf_nonlinear</code> for nonlinear order constraints.
</p>


<h3>Examples</h3>

<pre><code class="language-R">k &lt;- c(0, 3, 2, 5, 3, 7)
n &lt;- rep(10, 6)

# linear order constraints:
#             p1 &lt;p2 &lt;p3 &lt;p4 &lt;p5 &lt;p6 &lt;.50
A &lt;- matrix(
  c(
    1, -1, 0, 0, 0, 0,
    0, 1, -1, 0, 0, 0,
    0, 0, 1, -1, 0, 0,
    0, 0, 0, 1, -1, 0,
    0, 0, 0, 0, 1, -1,
    0, 0, 0, 0, 0, 1
  ),
  ncol = 6, byrow = TRUE
)
b &lt;- c(0, 0, 0, 0, 0, .50)

# Bayes factor: unconstrained vs. constrained
bf_binom(k, n, A, b, prior = c(1, 1), M = 10000)
bf_binom(k, n, A, b, prior = c(1, 1), M = 2000, steps = c(2, 4, 5))
bf_binom(k, n, A, b, prior = c(1, 1), M = 1000, cmin = 200)

</code></pre>


</div>