<div class="container">

<table style="width: 100%;"><tr>
<td>multiplex-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Algebraic Tools for the Analysis of Multiple Social Networks
</h2>

<h3>Description</h3>

<p>One of the aims of the <code>"multiplex"</code> package is to meet the necessity to count with an analytic tool specially designed for social networks with relations at different levels. 
In this sense, <code>"multiplex"</code> counts with functions that models the local role algebras of the network based on the simple and compound relations existing in the system.
<code>"multiplex"</code> has also a procedure for the construction and analysis of signed networks through the semiring structure. 
With <code>"multiplex"</code>, the different relational patterns at the dyadic level in the network can be obtained as well, which can serve for a further analysis with different types of structural theories.
</p>
<p>It is also possible to take the attributes of the actors in the analysis of multiple networks with different forms to incorporate this kind of information to the existing relational structures. 
For instance, the network exposure of the actors can be taken in the context of multiple networks in this case, or else the attributes can be embedded in the resulted algebraic structures.
</p>


<h3>Details</h3>


<table>
<tr>
<td style="text-align: left;">
Package: </td>
<td style="text-align: left;"> multiplex </td>
</tr>
<tr>
<td style="text-align: left;">
Type: </td>
<td style="text-align: left;"> Package </td>
</tr>
<tr>
<td style="text-align: left;">
Version: </td>
<td style="text-align: left;"> 3.7 </td>
</tr>
<tr>
<td style="text-align: left;">
Date: </td>
<td style="text-align: left;"> 30 September 2024 </td>
</tr>
<tr>
<td style="text-align: left;">
License: </td>
<td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
<td style="text-align: left;">
LazyLoad: </td>
<td style="text-align: left;"> yes </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>One way to work with this package is typically by starting with a specific algebraic structure like a semigroup that is a closed system made of a set of elements and an associative operation on it. 
This algebraic structure is constructed by the <code>semigroup</code> function, and it takes an array of (usually but not necessarily) multiple binary relations, which constitute the generator relations. 
The Word Table and the Edge Table serve to describe completely the semigroup, and they are constructed with the functions <code>wordT</code> and <code>edgeT</code> respectively. 
Unique relations of the complete semigroup are given by the <code>strings</code> function together with the set of equations with strings of length <code class="reqn">k</code>. 
The <code>partial.order</code> function specifies the ordering of the string elements in the semigroup, and the function <code>hasse</code> (or function <code>diagram</code> with this type) 
produces the lattice of inclusions of a structure having ordered relations.
</p>
<p>Semigroups can be analysed further by the <code>green.rel</code> function, and their found equivalence classes can be visualized as “<code>egg-box</code>” type with the <code>diagram</code> function. 
Semigroups can be reduced as well with a decomposition process, which can be based on congruence or <code class="reqn">\pi</code>-relations of the unique strings. 
In this case <code>pi.rels</code>, <code>cngr</code>, and <code>decomp</code> will make this job for you either for an abstract or a partially ordered structure.
</p>
<p>In addition, it is possible to analyse structural balance in signed networks, which are built by <code>signed</code>, through the algebraic structure of the semiring. 
A semiring is an algebraic structure that combines an abstract semigroup with identity under multiplication and a commutative monoid under addition. 
The <code>semiring</code> function is capable to perform both balance and cluster semiring either with cycles or semicycles.
</p>
<p>There are other capabilities in the package that are not strictly algebraic. 
For instance, the <code>dichot</code> serves to dichotomize the input data with a specified cut-off value, <code>rm.isol</code> removes isolated nodes, and the <code>perm</code> function performs an automorphism of the elements in the representative array. 
All these functions are built for multiple networks represented by high dimensional structures that can be constructed by function <code>zbind</code> to produce three-dimensional arrays. 
</p>
<p>Furthermore, <code>"multiplex"</code> creates a Relation-Box with the <code>rbox</code> function, and it implements the Compositional Equivalence expressed in the cumulated person hierarchy of the network computed with the <code>cph</code> function.
</p>
<p>Relational bundles are identified through the <code>bundles</code> function, which provides lists of pair relations. 
The <code>transf</code> function serves to transform pairwise list data into a matrix form and viceversa. 
The enumeration of the different bundle classes is given by <code>bundle.census</code>, while <code>summaryBundles</code> prints the bundle class patterns results. 
An advantage of counting with the bundle patterns is that the different types of bundles serve to establish a system inside the network, in which it is possible to measure the network exposure in multivariate relational systems. 
Such features can be realized via the <code>rel.sys</code> and <code>expos</code> functions, respectively. 
Several attributes can be derived by <code>galois</code>, which provides an algebraic approach for the analysis of two-mode networks.
</p>
<p>Finally, multivariate network data can be created using a <em>s</em>end <em>r</em>eceive <em>t</em>ies edge list format that can be loaded and transformed to arrays through the <code>edgel</code> function. 
Other formats for multiple network data like <b>UCINET</b> <code>dl</code> or <b>Visone</b> <code>gml</code> can be imported and exported as well with the <code>"multiplex"</code> package. 
Visualization of multiple network structures is possible with the <code>"multigraph"</code> package that depends on <code>"multiplex"</code>. 
</p>


<h3>Author(s)</h3>

<p>J. Antonio Rivero Ostoic
</p>
<p>Maintainer: Antonio Rivero Ostoic &lt;multiplex@post.com&gt;
</p>


<h3>References</h3>

<p>Pattison, P.E. <em>Algebraic Models for Social Networks</em>. Structural Analysis in the Social Sciences. Cambridge University Press. 1993.
</p>
<p>Boyd, J.P. <em>Social Semigroups. A unified theory of scaling and blockmodelling as applied to social networks</em>. George Mason University Press. 1991.
</p>
<p>Lorrain, F. and H.C. White, “Structural Equivalence of Individuals in Social Networks.” <em>Journal of Mathematical Sociology</em>, 1, 49-80. 1971.
</p>
<p>Boorman, S.A. and H.C. White, “Social Structure from Multiple Networks. II. Role Structures.” <em>American Journal of Sociology</em>, 81 (6), 1384-1446. 1976.
</p>
<p>Ostoic, J.A.R. <em>Algebraic Analysis of Social Networks</em>. Wiley Series in Computational and Quantitative Social Sciences. Wiley. 2021.
</p>


<h3>See Also</h3>

<p><code>multigraph</code>, <code>bmgraph</code>, <code>ccgraph</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># create the data: two binary relations among three elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 3 ) )

# dichotomize it with customized cutoff value
dichot(arr, c = 3)

# preview
prev(arr)

# create the semigroup and look at Green's relations
semigroup(arr) |&gt; 
  green.rel()

# look at string relations
strings(arr)
</code></pre>


</div>