<div class="container">

<table style="width: 100%;"><tr>
<td>optLambdas_mgcv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Find optimal ridge penalties with maximimum marginal likelihood
</h2>

<h3>Description</h3>

<p>Optimizes a marginal likelihood score w.r.t. ridge penalties for multiple data blocks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optLambdas_mgcv(penaltiesinit=NULL, XXblocks,Y, pairing=NULL, model=NULL, reltol=1e-4,
  optmethod=ifelse(length(penaltiesinit)==1,"Brent", "Nelder-Mead"),maxItropt=500,
  tracescore=TRUE, fixedpen=NULL, fixedseed =TRUE, sigmasq = 1,
  opt.sigma=ifelse(model=="linear",TRUE, FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>penaltiesinit</code></td>
<td>

<p>Numeric vector. Initial values for penaltyparameters. May be obtained from <code>fastCV2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>XXblocks</code></td>
<td>

<p>List of <code>nxn</code> matrices. Usually output of <code>createXXblocks</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>

<p>Response vector: numeric, binary, factor or <code>survival</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairing</code></td>
<td>
<p>Numerical vector of length 3 or <code>NULL</code> when pairs are absent. Represents the indices (in <code>XXblocks</code>) of the two data blocks involved in pairing, plus the index of the paired block.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>Character. Any of <code>c("linear", "logistic", "cox")</code>. Is inferred from
<code>Y</code> when <code>NULL</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>

<p>Scalar. Relative tolerance for optimization methods.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optmethod</code></td>
<td>

<p>Character. Optimization method. Any of the methods <code>c("Brent", "Nelder-Mead", "Sann")</code> may be used, but
<code>"Nelder-Mead"</code> is generally recommended. Other unconstrained methods offered by <code>optim</code> may also be used, but have not been tested.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxItropt</code></td>
<td>

<p>Integer. Maximum number of iterations for <code>optmethod</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tracescore</code></td>
<td>

<p>Boolean. Should the output of the scores be traced?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedpen</code></td>
<td>

<p>Integer vector or <code>NULL</code>. Contains indices of data types of which penalty
is fixed to the corresponding value in <code>penaltiesinit</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedseed</code></td>
<td>

<p>Boolean. Should the initialization be fixed? For reproducibility.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmasq</code></td>
<td>
<p>Default error variance.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.sigma</code></td>
<td>
<p>Boolean. Should the error variance be optimized as well? Only relevant for <code>model="linear"</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <code>gam</code> for details on how the marginal likelihood is computed.
</p>


<h3>Value</h3>

<p>List, with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>optres</code></td>
<td>
<p>Output of the optimizer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optpen</code></td>
<td>
<p>Vector with determined optimal penalties</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allsc</code></td>
<td>
<p>Matrix with marginal likelihood scores for all penalty parameter configurations used by the optimizer</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>optLambdas_mgcvWrap</code> for i) (recommended) optimization in two steps: first global, then local; and ii) sequential optimization
when some data types are preferred over others. A full demo and data are available from:<br><a href="https://drive.google.com/open?id=1NUfeOtN8-KZ8A2HZzveG506nBwgW64e4">https://drive.google.com/open?id=1NUfeOtN8-KZ8A2HZzveG506nBwgW64e4</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(dataXXmirmeth)
resp &lt;- dataXXmirmeth[[1]]
XXmirmeth &lt;- dataXXmirmeth[[2]]

# Find initial lambdas: fast CV per data block separately.
cvperblock2 &lt;- fastCV2(XXblocks=XXmirmeth,Y=resp,kfold=10,fixedfolds = TRUE)
lambdas &lt;- cvperblock2$lambdas

# Create (repeated) CV-splits of the data.
leftout &lt;- CVfolds(Y=resp,kfold=10,nrepeat=3,fixedfolds = TRUE)

# Compute cross-validated score for initial lambdas
CVscore(penalties=lambdas, XXblocks=XXmirmeth,Y=resp,folds=leftout,
score="loglik")

# Optimize by using marginal likelihood criterion
jointlambdas2 &lt;- optLambdas_mgcvWrap(penaltiesinit=lambdas, XXblocks=XXmirmeth,
Y=resp)

# Optimal lambdas
optlambdas &lt;- jointlambdas2$optpen

</code></pre>


</div>