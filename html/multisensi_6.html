<div class="container">

<table style="width: 100%;"><tr>
<td>basis.mine</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
A function to decompose multivariate data on a user-defined basis
</h2>

<h3>Description</h3>

<p>The <code>basis.mine</code> function decomposes a multivariate data set on a user-defined basis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">basis.mine(simuls, basis.args = list(
        baseL=1*outer(sort(0:(ncol(simuls)-1)%%5),0:4,"==") ) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>simuls</code></td>
<td>
<p>a data.frame of size <code>N x T</code>, typically a set of <code>N</code> simulation outputs of length <code>T</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis.args</code></td>
<td>
<p>a list of arguments for the polynomial decomposition. The <code>baseL</code> argument is a matrix of size <code>T x d</code> containing the coordinates of the <code>d</code> basis vectors.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> The default <code>basis.args</code> argument generates a projection on a moving-average basis. But if in the <code>multisensi</code> function this <code>basis.args</code> argument is not given for <code>reduction=basis.mine</code>, the execution will be stopped.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>a data.frame of size <code>N x d</code>, where <code>d</code> is the number of basis vectors. It contains the coefficients of the decomposition for each row of the <code>simuls</code> data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>a matrix of size <code>T x d</code>. It contains the vectors of the user-defined basis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call.info</code></td>
<td>
<p>list with the element <code>reduction="matrix"</code></p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">data(biomasseY)
M &lt;- 1*outer(sort(0:(ncol(biomasseY)-1)%%5),0:4,"==")
norm.M &lt;- sqrt(colSums(M^2)) 
for (i in 1:ncol(M)){
    M[,i]=M[,i]/norm.M[i]
}

res &lt;- basis.mine(biomasseY, basis.args=list(baseL=M))

</code></pre>


</div>