<div class="container">

<table style="width: 100%;"><tr>
<td>multisom.stochastic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multisom for stochastic version</h2>

<h3>Description</h3>

<p>This function implements the stochastic version of MultiSOM algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multisom.stochastic(data = NULL, xheight = 7, xwidth = 7,
                  topo = c("rectangular", "hexagonal"),
                  neighbouhood.fct =c("bubble","gaussian"),
                  dist.fcts = NULL, rlen = 100,alpha = c(0.05, 0.01),
                  radius = c(2, 1.5, 1.2, 1), index = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>the data matrix of observations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xheight</code></td>
<td>

<p>the x-dimension of the map
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xwidth</code></td>
<td>

<p>the y-dimension of the map
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>topo</code></td>
<td>

<p>the topology used to build the grid.The following are permitted:
<code>"hexagonal"</code>
<code>"rectangular"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbouhood.fct</code></td>
<td>

<p>the neighbouhood function type. The following are permitted:
<code>"gaussian"</code>
<code>"bubble"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.fcts</code></td>
<td>

<p>The metric used to determine the distance function. Possible choices are:
<code>"sumofsquares"</code>
<code>"euclidean"</code>
<code>"manhattan"</code>
<code>"tanimoto"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rlen</code></td>
<td>

<p>the maximum number of iterations to be done
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>learning rate, a vector of two numbers indicating the
amount of change. Default is to decline linearly from 0.05 to 0.01
over <code>rlen</code> updates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>the radius of the neighbourhood, either given as a
single number or a vector (start, stop). If it is given as a single
number the radius will run from the given number to the negative
value of that number; as soon as the neighbourhood gets smaller than
one only the winning unit will be updated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>

<p>vector of the index to be calculated. This should be one of : "db", "dunn",
"silhouette", "ptbiserial", "ch", "cindex", "ratkowsky", "mcclain", "gamma",
"gplus", "tau", "ccc", "scott", "marriot", "trcovw", "tracew", "friedman",
"rubin", "ball", "sdbw", "dindex", "hubert", "sv", "xie-beni", "hartigan",
"ssi", "xu", "rayturi", "pbm", "banfeld", "all" (all indices will be used)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>All.index.by.layer</code></td>
<td>

<p>Values of indices for each layer.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Best.nc</code></td>
<td>

<p>Best number of clusters proposed by each index and the corresponding index value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Best.partition</code></td>
<td>

<p>Partition that corresponds to the best number of clusters
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Sarra Chair and Malika Charrad
</p>


<h3>Examples</h3>

<pre><code class="language-R">## A real data example

data&lt;-as.matrix(iris[,-c(5)])

res&lt;-multisom.stochastic(data, xheight = 8, xwidth = 8,"hexagonal","gaussian",
                    dist.fcts = NULL, rlen = 100,alpha = c(0.05, 0.01),
                    radius = c(2, 1.5, 1.2, 1),c("db","ratkowsky","dunn"))

res$All.index.by.layer
res$Best.nc

</code></pre>


</div>