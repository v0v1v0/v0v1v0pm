<div class="container">

<table style="width: 100%;"><tr>
<td>CCM_boot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Run multispatial CCM algorithm on two time series
</h2>

<h3>Description</h3>

<p>Runs the multispatial convergent cross mapping algorithm on two time series, A and B, to determine whether process A is a forcing process (i.e., causally affects) or process B. A and B do not need to be from single, long time series, but rather can be combinations of many (e.g. spatially-replicated) time series. See "Arguments" for details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CCM_boot(A, B, E, tau=1,
DesiredL=((tau*(E-1)+(E+1)):length(A)-E+2),
iterations=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>

<p>Time series that is being tested as a forcing process (i.e., the causal process). Should be a single vector. If data come from multiple time series, gaps between these should be marked with an "NA". E.g., c(1,2,3, NA, 1,2,3) implies two time series, each of length 3. Order of plots does not matter (because they will be shuffled during bootstrapping), but should match the order used in B.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>

<p>Time series that is being tested as a response process (i.e., the process being affected by the causal process). Should be a single vector. If data come from multiple time series, gaps between these should be marked with an "NA". E.g., c(1,2,3, NA, 1,2,3) implies two time series, each of length 3. Order of plots does not matter (because they will be shuffled during bootstrapping), but should match the order used in A.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>

<p>Embedding dimension to use for the analysis. Should be based on dimension that provides the best prediction of process A against itself using function "SSR_pred_boot" (state space reconstruction).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>Number of time steps to use for lagged components in the attractor space. Defaults to 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DesiredL</code></td>
<td>

<p>Desired library lengths for which to compute CCM. Defaults to the maximum possible length ((tau * (E - 1) + (E + 1)):length(A) - E + 2) (though number of resulting predictions may be smaller because of gaps in the time series). Shortening this list (e.g., only predicting every nth element) will reduce run-time for the algorithm, but may also reduce ability to detect causal relations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>

<p>Number of iterations for bootstrapping. Defaults to 100.
</p>
</td>
</tr>
</table>
<h3>Value</h3>



<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Input process A</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Aest</code></td>
<td>
<p>Estimated values of A from B using CCM, for the last (longest) library length considered</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Input process B</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>Pearson correlation coefficient of estimates of A from B for each library length tested</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varrho</code></td>
<td>
<p>Variance of rho based on bootstrapping for each library length</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdevrho</code></td>
<td>
<p>Standard error (i.e., sqrt(var/n)) of the mean of rho for each library length</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lobs</code></td>
<td>
<p>Library lengths for which rho was calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>Embedding dimension used for the analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Time lag length used for the analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FULLinfo</code></td>
<td>
<p>Includes all output from .C call. Much of this is redundant with the variables listed above. Best not to look at this.</p>
</td>
</tr>
</table>
<h3>Warning</h3>

<p>If you do not separate distinct time series with "NA" as described in "Arguments", they will not be treated as such!
</p>


<h3>Author(s)</h3>

<p>Adam Clark
</p>


<h3>References</h3>

<p>Sugihara, G., R. May, H. Ye, C. Hsieh, E. Deyle, M. Fogarty, and S. Munch. 2012. Detecting Causality in Complex Ecosystems. Science 338.
</p>
<p>Adam T. Clark, H. Ye, Forest Isbell, Ethan R. Deyle, Jane Cowles, David Tilman, and George Sugihara. 2015. Spatial ’convergent cross mapping’ to detect causal relationships from short time-series. Ecology, 96(6):1174–1181.
</p>


<h3>See Also</h3>

<p>SSR_pred_boot, SSR_check_signal, ccmtest
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Simulate data to use for multispatial CCM test
#See function for details - A is causally forced by B,
#but the reverse is not true.
ccm_data_out&lt;-make_ccm_data()
Accm&lt;-ccm_data_out$Accm
Bccm&lt;-ccm_data_out$Bccm

#Set optimal E - see multispatialCCM for details
E_A&lt;-2
E_B&lt;-3

#Run the CCM test
#E_A and E_B are the embedding dimensions for A and B.
#tau is the length of time steps used (default is 1)
#iterations is the number of bootsrap iterations (default 100)
# Does A "cause" B?
CCM_boot_A&lt;-CCM_boot(Accm, Bccm, E_A, tau=1, iterations=10)
# Does B "cause" A?
CCM_boot_B&lt;-CCM_boot(Bccm, Accm, E_B, tau=1, iterations=10)
</code></pre>


</div>