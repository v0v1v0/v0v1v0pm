<div class="container">

<table style="width: 100%;"><tr>
<td>SSR_pred_boot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
State space reconstruction function
</h2>

<h3>Description</h3>

<p>Predict elements of A using B using state space reconstruction. If A=B, then the algorithm uses cross validation to assess the ability of historical portions of the A time series to predict future components of the time series. This function can be used to find the embedding dimension E that maximizes predictive ability.</p>


<h3>Usage</h3>

<pre><code class="language-R">SSR_pred_boot(A, B = A, E, tau = 1, predstep = 1, matchSugi = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>

<p>Process to be compared to B, or to itself. Should be a single vector. If data come from multiple time series, gaps between these should be marked with an "NA".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>

<p>Process to be compared to A. If left empty, algorithm defaults to A=B.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>

<p>Embedding dimension to use for the analysis. Should be based on dimension that provides the best prediction of process A against itself using function "SSR_pred_boot" (state space reconstruction).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>Number of time steps to use for lagged components in the attractor space. Defaults to 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predstep</code></td>
<td>

<p>Number of time steps into the future to make predictions from past observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matchSugi</code></td>
<td>

<p>Set to 1 to match results in Sugihara et al. publication described below, which removes only point i in cross validation - if 0, then removes all points within X(t-(E-1)):X(t+1)
</p>
</td>
</tr>
</table>
<h3>Value</h3>



<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Returns variable from input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Aest</code></td>
<td>
<p>Estimated values for A</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Returns variable from input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>Returns variable from input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Returns variable from input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pAlength</code></td>
<td>
<p>Length of A from input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pBlength</code></td>
<td>
<p>Length of B from input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predstep</code></td>
<td>
<p>Returns variable from input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prepvec</code></td>
<td>
<p>Returns 1 if A and B were treated as same process</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmatchSugi</code></td>
<td>
<p>Returns variable from input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptablelib</code></td>
<td>
<p>List of library lengths that were used for the analysis, adjusting for ends and gaps in the library</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plengthacceptablelib</code></td>
<td>
<p>Length of library that was used for the analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>Pearson correlation coefficient describing predictive ability of A against B or against itself</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Adam Clark
</p>


<h3>References</h3>

<p>Sugihara, G., R. May, H. Ye, C. Hsieh, E. Deyle, M. Fogarty, and S. Munch. 2012. Detecting Causality in Complex Ecosystems. Science 338.
</p>
<p>Adam T. Clark, H. Ye, Forest Isbell, Ethan R. Deyle, Jane Cowles, David Tilman, and George Sugihara. 2015. Spatial ’convergent cross mapping’ to detect causal relationships from short time-series. Ecology, 96(6):1174–1181.
</p>


<h3>See Also</h3>

<p>CCM_boot, SSR_check_signal, ccmtest
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Simulate data to use for multispatial CCM test
#See function for details - A is causally forced by B,
#but the reverse is not true.
ccm_data_out&lt;-make_ccm_data()
Accm&lt;-ccm_data_out$Accm
Bccm&lt;-ccm_data_out$Bccm

#Calculate optimal E
maxE&lt;-5 #Maximum E to test
#Matrix for storing output
Emat&lt;-matrix(nrow=maxE-1, ncol=2); colnames(Emat)&lt;-c("A", "B")

#Loop over potential E values and calculate predictive ability
#of each process for its own dynamics
for(E in 2:maxE) {
  #Uses defaults of looking forward one prediction step (predstep)
  #And using time lag intervals of one time step (tau)
  Emat[E-1,"A"]&lt;-SSR_pred_boot(A=Accm, E=E, predstep=1, tau=1)$rho
  Emat[E-1,"B"]&lt;-SSR_pred_boot(A=Bccm, E=E, predstep=1, tau=1)$rho
}

#Look at plots to find E for each process at which
#predictive ability rho is maximized
matplot(2:maxE, Emat, type="l", col=1:2, lty=1:2,
          xlab="E", ylab="rho", lwd=2)
legend("bottomleft", c("A", "B"), lty=1:2, col=1:2, lwd=2, bty="n")

#Results will vary depending on simulation.
#Using the seed we provide,
#maximum E for A should be 2, and maximum E for B should be 3.
#For the analyses in the paper, we use E=2 for all simulations.
</code></pre>


</div>