<div class="container">

<table style="width: 100%;"><tr>
<td>spec.mtm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute and plot multitaper spectrum estimates</h2>

<h3>Description</h3>

<p>Computes and plots adaptive or nonadaptive multitaper spectrum estimates from
contiguous time series objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spec.mtm(timeSeries, nw=4.0, k=7, nFFT="default", taper=c("dpss"),
         centre=c("Slepian"), dpssIN=NULL, returnZeroFreq=TRUE,
         Ftest=FALSE, jackknife=FALSE, jkCIProb=.95, adaptiveWeighting=TRUE,
         maxAdaptiveIterations=100, plot=TRUE, na.action=na.fail,
         returnInternals=FALSE, sineAdaptive=FALSE, sineSmoothFact=0.2,
         dtUnits=c("default"), deltat=NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>timeSeries</code></td>
<td>
<p>A time series of equally spaced data, this can be
created by the ts() function where deltat is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nw</code></td>
<td>
<p>nw a positive double precision number, the time-bandwidth
parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>k a positive integer, the number of tapers, often 2*nw.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nFFT</code></td>
<td>
<p>This function pads the data before computing the fft. nFFT
indicates the total length of the data after padding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>taper</code></td>
<td>
<p>Choose between dpss-based multitaper (the default,'dpss') or sine taper
method. In the case of the sine taper, parameter nw is useless, and both Ftest
and jackknife are forced to FALSE. The sine taper also has two specific parameters
below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centre</code></td>
<td>
<p>The time series is centred using one of three methods: expansion
onto discrete prolate spheroidal sequences ('Slepian'), arithmetic mean ('arithMean'), 
trimmed mean ('trimMean'), or not at all ('none'). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dpssIN</code></td>
<td>
<p>Allows the user to enter a dpss object which has already
been created. This can save computation time when Slepians with
the same bandwidth parameter and same number of tapers are used repeatedly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnZeroFreq</code></td>
<td>
<p>Boolean variable indicating if the zeroth
frequency (DC component) should be returned for all applicable arrays.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ftest</code></td>
<td>
<p>Boolean variable indicating if the Ftest result should be
computed and returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jackknife</code></td>
<td>
<p>Boolean variable indicating if jackknifed confidence
intervals should be computed and returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jkCIProb</code></td>
<td>
<p>Decimal value indicating the jackknife probability for
calculating jackknife confidence intervals. The default returns a
95% confidence interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptiveWeighting</code></td>
<td>
<p>Boolean flag for enabling/disabling adaptively weighted
spectrum estimates. Defaults to <code>TRUE</code>. The <code>FALSE</code> case gives complex
Fourier transforms equivalent to direct estimates with Slepian sequences as tapers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxAdaptiveIterations</code></td>
<td>
<p>Maximum number of iterations in the
adaptive multitaper calculation. Generally convergence is quick, and should
require less than 100 iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>Boolean variable indicating if the spectrum should be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>Action to take if NAs exist in the data, the default
is to fail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnInternals</code></td>
<td>
<p>Return the weighted eigencoefficients, complex mean values, and so on. These are necessary for extensions to the multitaper, including magnitude-squared coherence (function mtm.coh in this package). Note:
The internal ($mtm) variables eigenCoefs and eigenCoefWt correspond to
the multitaper eigencoefficients. The eigencoefficients correspond to
equation (3.4) and weights, eigenCoefWt, correspond to sqrt(|d_k(f)|^2) from equation (5.4) in Thomson's 1982 paper. This is because the square root values contained in eigenCoefWt are commonly used in additional calculations (example: eigenCoefWt * eigenCoefs). The
values returned in mtm$cmv correspond to the the estimate of the
coefficients hat(mu)(f) in equation (13.5) in Thomson (1982), or to the
estimate of hat(C)_1 at frequency 1 in equation (499) form Percival and Walden (1993)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sineAdaptive</code></td>
<td>
<p>In the case of using the sine taper method, choose between
non-adaptive and adaptive taper choice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sineSmoothFact</code></td>
<td>
<p>The sine taper option has an inherent smoothing parameter that
can be set between 0.01 and 0.5. Lower values indicate smaller amounts of smoothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dtUnits</code></td>
<td>
<p>Allows indication of the units of delta-t for accurate frequency axis
labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltat</code></td>
<td>
<p>Time step for observations. If not in seconds, dtUnits should be set to indicate
the proper units for plot labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters, such as xaxs="i" which are passed to
the plotting function. Not all parameters are supported.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The value log can be set to “yes” (default), “no”, or “dB”
as in the function plot.spec.</p>


<h3>References</h3>

<p>Thomson, D.J (1982)
Spectrum estimation and harmonic analysis. <em>Proceedings of the IEEE</em>
Volume <b>70</b>, Number 9, pp. 1055–1096.
</p>
<p>Percival, D.B. and Walden, A.T. (1993)
<em>Spectral analysis for physical applications</em>
Cambridge University Press. 
</p>
<p>Riedel, K.S. and Sidorenko, A. (1995)
Minimum bias multiple taper spectral estimation. <em>IEEE Transactions on Signal Processing</em>
Volume <b>43</b>, Number 1, pp. 188–195.
</p>


<h3>See Also</h3>

 <p><code>plot.mtm</code> and <code>plot.spec</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">## default behaviour, dpss tapers; deltat and dtUnits set to ensure axis accuracy
data(willamette)
spec.mtm(willamette, nw=4.0, k=8, deltat=1/12, dtUnits="year")
spec.mtm(willamette, nw=4.0, k=8, nFFT=2048, deltat=1/12, dtUnits="year")

## if you have a ts object, you can skip the deltat and dtUnits parameters
will.ts &lt;- ts(data=willamette, start=1950.75, freq=12)
spec.mtm(will.ts, nw=4.0, k=8)

## using Sine Tapers
spec.mtm(will.ts, k=10, taper="sine", sineAdaptive=FALSE)
spec.mtm(will.ts, k=10, taper="sine", sineAdaptive=TRUE, 
         maxAdaptiveIterations=100, sineSmoothFact=0.05)
</code></pre>


</div>