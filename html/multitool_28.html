<div class="container">

<table style="width: 100%;"><tr>
<td>run_multiverse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run a multiverse based on a complete decision grid</h2>

<h3>Description</h3>

<p>Run a multiverse based on a complete decision grid
</p>


<h3>Usage</h3>

<pre><code class="language-R">run_multiverse(.grid, ncores = 1, save_model = FALSE, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.grid</code></td>
<td>
<p>a <code>tibble</code> produced by <code>expand_decisions</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>numeric. The number of cores you want to use for parallel
processing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save_model</code></td>
<td>
<p>logical, indicates whether to save the model object in its
entirety. The default is <code>FALSE</code> because model objects are usually
large and under the hood, <code>parameters</code> and
<code>performance</code> is used to summarize the most useful
model information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show_progress</code></td>
<td>
<p>logical, whether to show a progress bar while running.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a single <code>tibble</code> containing tidied results for the model and
any post-processing tests/tasks. For each unique test (e.g., an <code>lm</code>
or <code>aov</code> called on an <code>lm</code>), a list column with the function name
is created with <code>parameters</code> and
<code>performance</code> and any warnings or messages printed
while fitting the models. Internally, modeling and post-processing
functions are checked to see if there are tidy or glance methods available.
If not, <code>summary</code> will be called instead.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# Decision pipeline
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2,scale(include3) &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_preprocess(process_name = "scale_iv", 'mutate({ivs} = scale({ivs}))') |&gt;
  add_preprocess(process_name = "scale_mod", mutate({mods} := scale({mods}))) |&gt;
  add_model("no covariates",lm({dvs} ~ {ivs} * {mods})) |&gt;
  add_model("covariate", lm({dvs} ~ {ivs} * {mods} + cov1)) |&gt;
  add_postprocess("aov", aov())

pipeline_grid &lt;- expand_decisions(full_pipeline)

# Run the whole multiverse
the_multiverse &lt;- run_multiverse(pipeline_grid[1:10,])
</code></pre>


</div>