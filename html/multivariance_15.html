<div class="container">

<table style="width: 100%;"><tr>
<td>dependence.structure</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>determines the dependence structure</h2>

<h3>Description</h3>

<p>Determines the dependence structure as described in [3].
</p>


<h3>Usage</h3>

<pre><code class="language-R">dependence.structure(
  x,
  vec = 1:ncol(x),
  verbose = TRUE,
  detection.aim = NULL,
  type = "conservative",
  structure.type = "clustered",
  c.factor = 2,
  list.cdm = NULL,
  alpha = 0.05,
  p.adjust.method = "holm",
  stop.too.many = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>matrix, each row of the matrix is treated as one sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec</code></td>
<td>
<p>vector, it indicates which columns are initially treated together as one sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>boolean, if <code>TRUE</code> details are printed during the detection and whenever a cluster is newly detected the (so far) detected dependence structure is plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detection.aim</code></td>
<td>
<p><code>=NULL</code> or a list of vectors which indicate the expected detection, see below for more details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>the method used for the detection, one of '<code>conservative</code>','<code>resample</code>','<code>pearson_approx</code>' or '<code>consistent</code>'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structure.type</code></td>
<td>
<p>either the '<code>clustered</code>' or the '<code>full</code>' structure is detected</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.factor</code></td>
<td>
<p>numeric, larger than 0, a constant factor used in the case of '<code>type = "consistent"</code>'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.cdm</code></td>
<td>
<p>not required, the list of doubly centered distance matrices corresponding to <code>x</code> speeds up the computation if given</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>numeric between 0 and 1, the significance level used for the tests</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.adjust.method</code></td>
<td>
<p>a string indicating the p-value adjustment for multiple testing, see <code>p.adjust.methods</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop.too.many</code></td>
<td>
<p>numeric, upper limit for the number of tested tuples. A warning is issued if it is used. Use <code>stop.too.many = NULL</code> for no limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>these are passed to <code>find.cluster</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Performs the detection of the dependence structure as described in [3]. In the <code>clustered</code> structure variables are clustered and treated as one variable as soon as a dependence is detected, the <code>full</code> structure treats always each variable separately. The detection is either based on tests with significance level <code>alpha</code> or a <code>consistent</code> estimator is used. The latter yields (in the limit for increasing sample size) under very mild conditions always the correct dependence structure (but the convergence might be very slow).
</p>
<p>If <code>fixed.rejection.level</code> is not provided, the significance level <code>alpha</code> is used to determine which multivariances are significant using the distribution-free rejection level. As default the Holm method is used for p-value correction corresponding to multiple testing.
</p>
<p>The resulting graph can be simplified (pairwise dependence can be represented by edges instead of vertices) using <code>clean.graph</code>.
</p>
<p>Advanced:
The argument <code>detection.aim</code> is currently only implemented for <code>structure.type = clustered</code>. It can be used to check, if an expected dependence structure was detected. This might be useful for simulation studies to determine the empirical power of the detection algorithm. Hereto  <code>detection.aim</code> is set to a list of vectors which indicate the expected detected dependence structures (one for each run of <code>find.cluster</code>). The vector has as first element the <code>k</code> for which k-tuples are detected (for this aim the detection stops without success if no k-tuple is found), and the other elements, indicate to which clusters all present vertices belong after the detection, e.g. <code>c(3,2,2,1,2,1,1,2,1)</code> expects that 3-tuples are detected and in the graph are 8 vertices (including those representing the detected 3 dependencies), the order of the 2's and 1's indicate which vertices belong to which cluster. If <code>detection.aim</code> is provided, the vector representing the actual detection is printed, thus one can use the output with copy-paste to fix successively the expected detection aims.
</p>
<p>Note that a failed detection might invoke the warning:
</p>
<pre>
run$mem == detection.aim[[k]][-1] :
longer object length is not a multiple of shorter object length
</pre>


<h3>Value</h3>

<p>returns a list with elements:
</p>

<dl>
<dt><code>multivariances</code></dt>
<dd>
<p>calculated multivariances,</p>
</dd>
<dt><code>cdms</code></dt>
<dd>
<p>calculated doubly centered distance matrices,</p>
</dd>
<dt><code>graph</code></dt>
<dd>
<p>graph representing the dependence structure,</p>
</dd>
<dt><code>detected</code></dt>
<dd>
<p>boolean, this is only included if a <code>detection.aim</code> is given,</p>
</dd>
<dt><code>number.of.dep.tuples</code></dt>
<dd>
<p>vector, with the number of dependent tuples for each tested order. For the full dependence structure a value of -1 indicates that all tuples of this order are already lower order dependent, a value of -2 indicates that there were more than <code>stop.too.many</code> tuples,</p>
</dd>
<dt><code>structure.type</code></dt>
<dd>
<p>either <code>clustered</code> or <code>full</code>,</p>
</dd>
<dt><code>type</code></dt>
<dd>
<p>the type of p-value estimation or consistent estimation used,</p>
</dd>
<dt><code>total.number.of.tests</code></dt>
<dd>
<p>numeric vector, with the number of tests for each group of tests,</p>
</dd>
<dt><code>typeI.error.prob</code></dt>
<dd>
<p>estimated probability of a type I error,</p>
</dd>
<dt><code>alpha</code></dt>
<dd>
<p>significance level used if a p-value estimation procedure is used,</p>
</dd>
<dt><code>c.factor</code></dt>
<dd>
<p>factor used if a consistent estimation procedure is used,</p>
</dd>
<dt><code>parameter.range</code></dt>
<dd>
<p>significance levels (or 'c.factor' values) which yield the same detection result.</p>
</dd>
</dl>
<h3>References</h3>

<p>For the theoretic background see the reference [3] given on the main help page of this package: multivariance-package.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# structures for the datasets included in the package
dependence.structure(dep_struct_several_26_100)
dependence.structure(dep_struct_star_9_100)
dependence.structure(dep_struct_iterated_13_100)
dependence.structure(dep_struct_ring_15_100)

# basic examples:

x = coins(100) # 3-dependent
dependence.structure(x)

colnames(x) = c("A","B","C")
dependence.structure(x) # names of variables are used as labels

dependence.structure(coins(100),vec = c(1,1,2))
# 3-dependent rv of which the first two rv are used together as one rv, thus 2-dependence.

dependence.structure(x,vec = c(1,1,2)) # names of variables are used as labels


dependence.structure(cbind(coins(200),coins(200,k=5)),verbose = TRUE)
#1,2,3 are 3-dependent, 4,..,9 are 6-dependent

# similar to the the previous example, but
# the pair 1,3 is treated as one sample,
# anagously the pair 2,4. In the resulting structure one does not
# see anymore that the dependence of 1,2,3,4 with the rest is due
# to 4.
dependence.structure(cbind(coins(200),coins(200,k=5)),
                           vec = c(1,2,1,2,3,4,5,6,7),verbose = TRUE)


### Advanced:

# How to check the empirical power of the detection algorithm?
# Use a dataset for which the structure is detected, e.g. dep_struct_several_26_100.
# run:
dependence.structure(dep_struct_several_26_100,
                     detection.aim = list(c(ncol(dep_struct_several_26_100))))
# The output provides the first detection aim. Now we run the same line with the added
# detection aim
dependence.structure(dep_struct_several_26_100,detection.aim = list(c(3,1, 1, 1, 2, 2, 2, 3, 4,
  5, 6, 7, 8, 8, 8, 9, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1, 2, 8, 9),
  c(ncol(dep_struct_several_26_100))))
# and get the next detection aim ... thus we finally obtain all detection aims.
# now we can run the code with new sample data ....
N = 100
dependence.structure(cbind(coins(N,2),tetrahedron(N),coins(N,4),tetrahedron(N),
                           tetrahedron(N),coins(N,3),coins(N,3),rnorm(N)),
                     detection.aim = list(c(3,1, 1, 1, 2, 2, 2, 3, 4, 5, 6, 7, 8, 8, 8,
  9, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1, 2, 8, 9),
  c(4,1, 1, 1, 2, 2, 2, 3, 4, 5, 6, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11,
    11, 12, 1, 2, 8, 9, 10, 11),
  c(5, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 1,
    2, 4, 5, 6, 7, 3),
  c(5, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 1,
    2, 4, 5, 6, 7, 3)))$detected
# ... and one could start to store the results and compute the rate of successes.

# ... or one could try to check how many samples are necessary for the detection:
re = numeric(100)
for (i in 2:100) {
  re[i] =
    dependence.structure(dep_struct_several_26_100[1:i,],verbose = FALSE,
                         detection.aim = list(c(3,1, 1, 1, 2, 2, 2, 3, 4, 5, 6, 7, 8,
      8, 8, 9, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1, 2, 8, 9),
      c(4,1, 1, 1, 2, 2, 2, 3, 4, 5, 6, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 11,
        11, 11, 12, 1, 2, 8, 9, 10, 11),
      c(5, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7,
        8, 1, 2, 4, 5, 6, 7, 3),
      c(5, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7,
        8, 1, 2, 4, 5, 6, 7, 3)))$detected
  print(paste("First", i,"samples. Detected?", re[i]==1))
}
cat(paste("Given the 1 to k'th row the structure is not detected for k =",which(re == FALSE),"\n"))

</code></pre>


</div>