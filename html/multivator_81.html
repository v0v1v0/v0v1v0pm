<div class="container">

<table style="width: 100%;"><tr>
<td>optimal_params</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Optimization of the hyperparameters
</h2>

<h3>Description</h3>

<p>Optimization of the hyperparameters using a sequence of subfunctions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optimal_params     (expt, LoF, start_hp, option = "a", ...)
optimal_B          (expt, LoF, start_hp, option = "a", verbose=FALSE, ...)
optimal_identical_B(expt, LoF, start_hp, verbose=FALSE, ...)
optimal_diag_M     (expt, LoF, start_hp)
optimal_M          (expt, LoF, start_hp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expt</code></td>
<td>

<p>Object of class <code>experiment</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LoF</code></td>
<td>

<p>List of functions
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_hp</code></td>
<td>

<p>Start value for the hyperparameters, an object of class <code>mhp</code>.
The various optimization routines use the different parts of
<code>start_hp</code> as start points, and incrementally update it
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>option</code></td>
<td>

<p>In function <code>optimal_B()</code> and consequently
<code>optimal_params()</code>, a character indicating whether to allow the
scales to differ or not.
</p>

<ul>
<li>
<p> Default option “<code>a</code>” is the simplest: each
univariate <code>B</code> matrix is a multiple of the identity matrix.
</p>
</li>
<li>
<p> Option “<code>b</code>” allows the <code>B</code> matrices to be
any (positive definite) diagonal matrix.
</p>
</li>
<li>
<p> Option “<code>c</code>” specifies that <code>B[,,j]</code> is
diagonal for each <code>j</code> and furthermore that
<code>B[i,i,1]=B[i,i,2]=...=B[i,i,r]</code>.  This option calls
<code>optimal_identical_B()</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>In function <code>optimal_B()</code>, Boolean with <code>TRUE</code> meaning
to print debugging information and default	<code>FALSE</code> meaning not
to print anything
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments passed to the optimization routine
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The user-friendly wrapper function is <code>optimal_params()</code>.  This
calls function <code>optimal_B()</code> first, as most of the analysis is
conditional on <code>B</code>.  Then <code>optimal_diag_M()</code> is called; this
places the maximum likelihood estimate for <code class="reqn">\sigma^2</code> on
the diagonal of <code>M</code>.  Finally, <code>optimal_M()</code> is called,
which assigns the off-diagonal elements of <code>M</code>.
</p>
<p>Each of the subfunctions returns an object appropriate for insertion
into a <code>mhp</code> object.
</p>
<p>The “meat” of <code>optimal_params()</code> is
</p>
<pre>
       B(out)  &lt;- optimal_B     (mm, d, LoF, start_hp=out, option=option, ...)
  diag(M(out)) &lt;- optimal_diag_M(mm, d, LoF, start_hp=out, ...)
       M(out)  &lt;- optimal_M     (mm, d, LoF, start_hp=out, ...)
  return(out)
</pre>
<p>See how object <code>out</code> is modified sequentially, it being used as a
start point for the next function.
</p>


<h3>Value</h3>

<p>Returns a <code>mhp</code> object.
</p>


<h3>Note</h3>

<p>Function <code>optimal_diag_M()</code> uses MLEs for the diagonals, but using
each type of observation separately.  It is conceivable that there is 
information that is not being used here.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(mtoys)

optimal_params(toy_expt,toy_LoF,toy_mhp,option='c',control=list(maxit=1))
</code></pre>


</div>