<div class="container">

<table style="width: 100%;"><tr>
<td>%when%</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Define constraints for combinations of analysis paths in the multiverse</h2>

<h3>Description</h3>

<p>Users can specify conditions for which a particular analysis path may or may not be valid
using either the <code>%when%</code> operator or the <code>branch_assert</code> function.
</p>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>Logical</code></td>
<td>
<p>predicates defined in terms of the parameters and their options in the multiverse.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>A user can specify multiple different analysis options at each step of the analysis
process using <code>branch()</code>. However, it is possible that the values of certain parameters might be
conditional on the values of certain other parameters.
</p>
<p>The conditional or the "implies" relationship between two statements, <em>A</em> and <em>A</em> has the meaning,
"if <em>A</em> is true, then <em>B</em> is also true." We evaluate this relationship using classical logic:
<code class="reqn">A \Longrightarrow B</code> is an abbreviation for <code class="reqn">\neg A \lor B</code>
</p>


<h3>See Also</h3>

<p><code>vignette("conditions")</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
M.1 &lt;- multiverse()

# There are different ways to specifying conditions
# One way is to use the %when% operator
# the %when% operator can be specified after the option name
inside(M.1, {
    df &lt;- data.frame (x = 1:10 ) %&gt;%
        mutate( y = branch( values_y, TRUE, FALSE )) %&gt;%
        mutate( z = branch(values_z,
            "constant" ~ 5,
            "linear" ~ x + 1,
            "sum" %when% (values_y == TRUE) ~ (x + y)
        ))
})

# or it can be specified after the expression for computing the option value
inside(M.1, {
    df &lt;- data.frame (x = 1:10 ) %&gt;%
        mutate( y = branch( values_y, TRUE, FALSE )) %&gt;%
        mutate( z = branch(values_z,
            "constant" ~ 5,
            "linear" ~ x + 1,
            "sum" ~ (x + y) %when% (values_y == TRUE)
        ))
})

# an advantage of the '%when' operator is that it can also be used when the
# option names are not specified for branches.
# when option names are not specified for branches, option names are assigned to
# the branches. For character, logical or numeric expressions, option names are of the
# same type (i.e. character, logical or numeric expressions respectively)
# For expressions of type symbol or call, options names are characters strings
# containing the expression.
# see the next two examples:
M.2 &lt;- multiverse()

inside(M.2, {
 df &lt;- data.frame (x = 1:10 ) %&gt;%
   mutate( y = branch( values_y, TRUE, FALSE )) %&gt;%
   mutate( z = branch(values_z,
          5,
          x + 1,
          (x + y) %when% (values_y == TRUE)
   ))
})

M.3 &lt;- multiverse()
inside(M.3, {
 df &lt;- data.frame (x = 1:10 ) %&gt;%
   filter( branch( values_x,
       TRUE,
       x &gt; 2 | x &lt; 6
   )) %&gt;%
   mutate( z = branch(values_z,
          5,
          x + 1,
          (x^2) %when% (values_x == 'x &gt; 2 | x &lt; 6')
   ))
})

# or it can be specified after the expression for computing the option value
M.4 &lt;- multiverse()
inside(M.4, {
    df &lt;- data.frame (x = 1:10 ) %&gt;%
        mutate( y = branch( values_y, TRUE, FALSE )) %&gt;%
        mutate( z = branch(values_z,
            "constant" ~ 5,
            "linear" ~ x + 1,
            "sum" ~ x + y
        )) %&gt;%
        branch_assert( values_z != "sum" | values_y == TRUE )
})


</code></pre>


</div>