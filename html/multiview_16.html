<div class="container">

<table style="width: 100%;"><tr>
<td>multiview</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform cooperative learning using the direct algorithm for
two or more views.</h2>

<h3>Description</h3>

<p><code>multiview</code> uses <code>glmnet::glmnet()</code> to do most of its work and
therefore takes many of the same parameters, but an intercept is
always included and several other parameters do not
apply. Such inapplicable arguments are overridden and warnings issued.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multiview(
  x_list,
  y,
  rho = 0,
  family = gaussian(),
  weights = NULL,
  offset = NULL,
  alpha = 1,
  nlambda = 100,
  lambda.min.ratio = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  standardize = TRUE,
  intercept = TRUE,
  thresh = 1e-07,
  maxit = 1e+05,
  penalty.factor = rep(1, nvars),
  exclude = list(),
  lower.limits = -Inf,
  upper.limits = Inf,
  trace.it = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A description of the error distribution and link
function to be used in the model. This is the result of a call to
a family function. Default is stats::gaussian. (See
stats::family for details on family functions.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>observation weights. Can be total counts if
responses are proportion matrices. Default is 1 for each
observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A vector of length <code>nobs</code> that is included in
the linear predictor (a <code>nobs x nc</code> matrix for the
<code>"multinomial"</code> family).  Useful for the <code>"poisson"</code>
family (e.g. log of exposure time), or for refining a model by
starting at a current fit. Default is <code>NULL</code>. If supplied,
then values must also be supplied to the <code>predict</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>.  The penalty is defined as
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge
penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a
fraction of <code>lambda.max</code>, the (data derived) entry value
(i.e. the smallest value for which all coefficients are
zero). The default depends on the sample size <code>nobs</code>
relative to the number of variables <code>nvars</code>. If <code>nobs &gt;
  nvars</code>, the default is <code>0.0001</code>, close to zero.  If
<code>nobs &lt; nvars</code>, the default is <code>0.01</code>.  A very small
value of <code>lambda.min.ratio</code> will lead to a saturated fit in
the <code>nobs &lt; nvars</code> case. This is undefined for
<code>"binomial"</code> and <code>"multinomial"</code> models, and
<code>glmnet</code> will exit gracefully when the percentage deviance
explained is almost 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence, default
<code>NULL</code>. Typical usage is to have the program compute its own
<code>lambda</code> sequence. This sequence, in general, is different from
that used in the <code>glmnet::glmnet()</code> call (named <code>lambda</code>)
Supplying a value of <code>lambda</code> overrides this. WARNING: use with
care. Avoid supplying a single value for <code>lambda</code> (for
predictions after CV use <code>stats::predict()</code> instead.  Supply
instead a decreasing sequence of <code>lambda</code> values as <code>multiview</code>
relies on its warms starts for speed, and its often faster to fit
a whole path than compute a single fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical flag for x variable standardization,
prior to fitting the model sequence. The coefficients are always
returned on the original scale. Default is
<code>standardize=TRUE</code>.  If variables are in the same units
already, you might not wish to standardize. See details below for
y standardization with <code>family="gaussian"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Should intercept(s) be fitted (default <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each
inner coordinate-descent loop continues until the maximum change
in the objective after any coefficient update is less than
<code>thresh</code> times the null deviance. Defaults value is
<code>1E-7</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda
values; default is 10^5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to
each coefficient. This is a number that multiplies <code>lambda</code>
to allow differential shrinkage. Can be 0 for some variables,
which implies no shrinkage, and that variable is always included
in the model. Default is 1 for all variables (and implicitly
infinity for variables listed in <code>exclude</code>). Note: the
penalty factors are internally rescaled to sum to nvars, and the
lambda sequence will reflect this change.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>Indices of variables to be excluded from the
model. Default is none. Equivalent to an infinite penalty factor
for the variables excluded (next item).  Users can supply instead
an <code>exclude</code> function that generates the list of indices.  This
function is most generally defined as <code style="white-space: pre;">⁠function(x_list, y, ...)⁠</code>,
and is called inside <code>multiview</code> to generate the indices for
excluded variables.  The <code>...</code> argument is required, the others
are optional.  This is useful for filtering wide data, and works
correctly with <code>cv.multiview</code>. See the vignette 'Introduction'
for examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient;
default <code>-Inf</code>. Each of these must be non-positive. Can be
presented as a single value (which will then be replicated), else
a vector of length <code>nvars</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient;
default <code>Inf</code>. See <code>lower.limits</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then a progress bar is
displayed; useful for big models that take a long time to fit.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The current code can be slow for "large" data sets, e.g. when the
number of features is larger than 1000.  It can be helpful to see
the progress of multiview as it runs; to do this, set trace.it = 1
in the call to multiview or cv.multiview.  With this, multiview
prints out its progress along the way.  One can also pre-filter the
features to a smaller set, using the exclude option, with a filter
function.
</p>
<p>If there are missing values in the feature matrices: we recommend
that you center the columns of each feature matrix, and then fill
in the missing values with 0.
</p>
<p>For example, <br><code>x &lt;- scale(x,TRUE,FALSE)</code> <br><code>x[is.na(x)] &lt;- 0</code> <br><code>z &lt;- scale(z,TRUE,FALSE)</code> <br><code>z[is.na(z)] &lt;- 0</code> <br></p>
<p>Then run multiview in the usual way. It will exploit the assumed shared latent factors
to make efficient use of the available data.
</p>


<h3>Value</h3>

<p>An object with S3 class <code style="white-space: pre;">⁠"multiview","*" ⁠</code>, where <code>"*"</code> is
<code>"elnet"</code>, <code>"lognet"</code>, <code>"multnet"</code>, <code>"fishnet"</code> (poisson),
<code>"coxnet"</code> or <code>"mrelnet"</code> for the various types of models.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>For <code>"elnet"</code>, <code>"lognet"</code>, <code>"fishnet"</code> and <code>"coxnet"</code>
models, a <code style="white-space: pre;">⁠nvars x length(lambda)⁠</code> matrix of coefficients, stored
in sparse column format (<code>"CsparseMatrix"</code>). For <code>"multnet"</code> and
<code>"mgaussian"</code>, a list of <code>nc</code> such matrices, one for each class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>glmnet::glmnet()</code> <code>lambda</code>
values used. When <code>alpha=0</code>, the largest lambda reported does not
quite give the zero coefficients reported (<code>lambda=inf</code> would in
principle).  Instead, the largest <code>lambda</code> for <code>alpha=0.001</code> is
used, and the sequence of <code>lambda</code> values is derived from this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The sequence of lambda values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mvlambda</code></td>
<td>
<p>The
corresponding sequence of multiview lambda values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained (for
<code>"elnet"</code>, this is the R-square). The deviance calculations
incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the
log-likelihood for the saturated model (a model with a free
parameter per observation). Hence dev.ratio=1-dev/nulldev.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined
to be 2*(loglike_sat -loglike(Null)); The NULL model refers to
the intercept model, except for the Cox, where it is the 0
model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each
value of <code>lambda</code>. For <code>"multnet"</code>, this is the number of
variables with a nonzero coefficient for <em>any</em> class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfmat</code></td>
<td>
<p>For <code>"multnet"</code> and <code>"mrelnet"</code> only. A matrix
consisting of the number of nonzero coefficients per class</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>dimension of coefficient matrix (ices)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npasses</code></td>
<td>
<p>total passes
over the data summed over all lambda values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>a
logical variable indicating whether an offset was included in the
model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors (largely
for internal debugging).</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>print</code>, <code>coef</code>, <code>coef_ordered</code>, <code>predict</code>, and <code>plot</code>
methods for <code>"multiview"</code>, and the <code>"cv.multiview"</code> function.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Gaussian
x = matrix(rnorm(100 * 20), 100, 20)
z = matrix(rnorm(100 * 10), 100, 10)
y = rnorm(100)
fit1 = multiview(list(x=x,z=z), y, rho = 0)
print(fit1)

# extract coefficients at a single value of lambda
coef(fit1, s = 0.01) 

# extract ordered (standardized) coefficients at a single value of lambda
coef_ordered(fit1, s = 0.01) 

# make predictions
predict(fit1, newx = list(x[1:10, ],z[1:10, ]), s = c(0.01, 0.005))

# make a path plot of features for the fit
plot(fit1, label=TRUE)

# Binomial
by = sample(c(0,1), 100, replace = TRUE)
fit2 = multiview(list(x=x,z=z), by, family = binomial(), rho=0.5)
predict(fit2, newx = list(x[1:10, ],z[1:10, ]), s = c(0.01, 0.005), type="response")
coef_ordered(fit2, s = 0.01) 
plot(fit2, label=TRUE)

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = multiview(list(x=x,z=z), py, family = poisson(), rho=0.5)
predict(fit3, newx = list(x[1:10, ],z[1:10, ]), s = c(0.01, 0.005), type="response")
coef_ordered(fit3, s = 0.01) 
plot(fit3, label=TRUE)

</code></pre>


</div>