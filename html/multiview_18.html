<div class="container">

<table style="width: 100%;"><tr>
<td>multiview.cox.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a Cox regression model with elastic net regularization for a single
value of lambda</h2>

<h3>Description</h3>

<p>Fit a Cox regression model via penalized maximum likelihood for a single
value of lambda. Can deal with (start, stop] data and strata, as well as
sparse design matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multiview.cox.fit(
  x_list,
  x,
  y,
  rho,
  weights,
  lambda,
  alpha = 1,
  offset = rep(0, nobs),
  thresh = 1e-10,
  maxit = 1e+05,
  penalty.factor = rep(1, nvars),
  exclude = c(),
  lower.limits = -Inf,
  upper.limits = Inf,
  warm = NULL,
  from.cox.path = FALSE,
  save.fit = FALSE,
  trace.it = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the <code>cbind</code>ed matrices in <code>x_list</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>observation weights. Can be total counts if
responses are proportion matrices. Default is 1 for each
observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A single value for the <code>lambda</code> hyperparameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>.  The penalty is defined as
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge
penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A vector of length <code>nobs</code> that is included in
the linear predictor (a <code>nobs x nc</code> matrix for the
<code>"multinomial"</code> family).  Useful for the <code>"poisson"</code>
family (e.g. log of exposure time), or for refining a model by
starting at a current fit. Default is <code>NULL</code>. If supplied,
then values must also be supplied to the <code>predict</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each
inner coordinate-descent loop continues until the maximum change
in the objective after any coefficient update is less than
<code>thresh</code> times the null deviance. Defaults value is
<code>1E-7</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda
values; default is 10^5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to
each coefficient. This is a number that multiplies <code>lambda</code>
to allow differential shrinkage. Can be 0 for some variables,
which implies no shrinkage, and that variable is always included
in the model. Default is 1 for all variables (and implicitly
infinity for variables listed in <code>exclude</code>). Note: the
penalty factors are internally rescaled to sum to nvars, and the
lambda sequence will reflect this change.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>Indices of variables to be excluded from the
model. Default is none. Equivalent to an infinite penalty factor
for the variables excluded (next item).  Users can supply instead
an <code>exclude</code> function that generates the list of indices.  This
function is most generally defined as <code style="white-space: pre;">⁠function(x_list, y, ...)⁠</code>,
and is called inside <code>multiview</code> to generate the indices for
excluded variables.  The <code>...</code> argument is required, the others
are optional.  This is useful for filtering wide data, and works
correctly with <code>cv.multiview</code>. See the vignette 'Introduction'
for examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient;
default <code>-Inf</code>. Each of these must be non-positive. Can be
presented as a single value (which will then be replicated), else
a vector of length <code>nvars</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient;
default <code>Inf</code>. See <code>lower.limits</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warm</code></td>
<td>
<p>Either a <code>glmnetfit</code> object or a list (with names <code>beta</code>
and <code>a0</code> containing coefficients and intercept respectively) which can
be used as a warm start. Default is <code>NULL</code>, indicating no warm start.
For internal use only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from.cox.path</code></td>
<td>
<p>Was <code>multiview.cox.fit()</code> called from <code>multiview.path()</code>?
Default is FALSE.This has implications for computation of the penalty factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.fit</code></td>
<td>
<p>Return the warm start object? Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then a progress bar is
displayed; useful for big models that take a long time to fit.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>WARNING: Users should not call <code>multiview.cox.fit</code> directly. Higher-level
functions in this package call <code>multiview.cox.fit</code> as a subroutine. If a
warm start object is provided, some of the other arguments in the function
may be overriden.
</p>
<p><code>multiview.cox.fit</code> solves the elastic net problem for a single, user-specified
value of lambda. <code>multiview.cox.fit</code> works for Cox regression models, including
(start, stop] data and strata. It solves the problem using iteratively
reweighted least squares (IRLS). For each IRLS iteration, <code>multiview.cox.fit</code>
makes a quadratic (Newton) approximation of the log-likelihood, then calls
<code>elnet.fit</code> to minimize the resulting approximation.
</p>
<p>In terms of standardization: <code>multiview.cox.fit</code> does not standardize <code>x</code>
and <code>weights</code>. <code>penalty.factor</code> is standardized so that they sum
up to <code>nvars</code>.
</p>


<h3>Value</h3>

<p>An object with class "coxnet", "glmnetfit" and "glmnet". The list
returned contains more keys than that of a "glmnet" object.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>Intercept value, <code>NULL</code> for "cox" family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x 1</code> matrix of coefficients, stored in sparse matrix
format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>Dimension of coefficient matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Lambda value used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained. The deviance
calculations incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood
for the saturated model (a model with a free parameter per observation).
Hence dev.ratio=1-dev/nulldev.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to be
2*(loglike_sat -loglike(Null)). The null model refers to the 0 model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npasses</code></td>
<td>
<p>Total passes over the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors (largely for internal
debugging).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A logical variable indicating whether an offset was included
in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warm_fit</code></td>
<td>
<p>If <code>save.fit=TRUE</code>, output of C++ routine, used for
warm starts. For internal use only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Family used for the model, always "cox".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>A logical variable: was the algorithm judged to have
converged?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>A logical variable: is the fitted value on the boundary of
the attainable values?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj_function</code></td>
<td>
<p>Objective function value at the solution.</p>
</td>
</tr>
</table>
</div>