<div class="container">

<table style="width: 100%;"><tr>
<td>multiview.cox.path</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a Cox regression model with elastic net regularization for a path of
lambda values</h2>

<h3>Description</h3>

<p>Fit a Cox regression model via penalized maximum likelihood for a path of
lambda values. Can deal with (start, stop] data and strata, as well as
sparse design matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multiview.cox.path(
  x_list,
  x,
  y,
  rho = 0,
  weights = NULL,
  lambda = NULL,
  offset = NULL,
  alpha = 1,
  nlambda = 100,
  lambda.min.ratio = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  standardize = TRUE,
  intercept = TRUE,
  thresh = 1e-07,
  exclude = integer(0),
  penalty.factor = rep(1, nvars),
  lower.limits = -Inf,
  upper.limits = Inf,
  maxit = 1e+05,
  trace.it = 0,
  nvars,
  nobs,
  xm,
  xs,
  control,
  vp,
  vnames,
  is.offset
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the <code>cbind</code>ed matrices in <code>x_list</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>observation weights. Can be total counts if
responses are proportion matrices. Default is 1 for each
observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence, default
<code>NULL</code>. Typical usage is to have the program compute its own
<code>lambda</code> sequence. This sequence, in general, is different from
that used in the <code>glmnet::glmnet()</code> call (named <code>lambda</code>)
Supplying a value of <code>lambda</code> overrides this. WARNING: use with
care. Avoid supplying a single value for <code>lambda</code> (for
predictions after CV use <code>stats::predict()</code> instead.  Supply
instead a decreasing sequence of <code>lambda</code> values as <code>multiview</code>
relies on its warms starts for speed, and its often faster to fit
a whole path than compute a single fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A vector of length <code>nobs</code> that is included in
the linear predictor (a <code>nobs x nc</code> matrix for the
<code>"multinomial"</code> family).  Useful for the <code>"poisson"</code>
family (e.g. log of exposure time), or for refining a model by
starting at a current fit. Default is <code>NULL</code>. If supplied,
then values must also be supplied to the <code>predict</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>.  The penalty is defined as
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge
penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a
fraction of <code>lambda.max</code>, the (data derived) entry value
(i.e. the smallest value for which all coefficients are
zero). The default depends on the sample size <code>nobs</code>
relative to the number of variables <code>nvars</code>. If <code>nobs &gt;
  nvars</code>, the default is <code>0.0001</code>, close to zero.  If
<code>nobs &lt; nvars</code>, the default is <code>0.01</code>.  A very small
value of <code>lambda.min.ratio</code> will lead to a saturated fit in
the <code>nobs &lt; nvars</code> case. This is undefined for
<code>"binomial"</code> and <code>"multinomial"</code> models, and
<code>glmnet</code> will exit gracefully when the percentage deviance
explained is almost 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical flag for x variable standardization,
prior to fitting the model sequence. The coefficients are always
returned on the original scale. Default is
<code>standardize=TRUE</code>.  If variables are in the same units
already, you might not wish to standardize. See details below for
y standardization with <code>family="gaussian"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Should intercept(s) be fitted (default <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each
inner coordinate-descent loop continues until the maximum change
in the objective after any coefficient update is less than
<code>thresh</code> times the null deviance. Defaults value is
<code>1E-7</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>Indices of variables to be excluded from the
model. Default is none. Equivalent to an infinite penalty factor
for the variables excluded (next item).  Users can supply instead
an <code>exclude</code> function that generates the list of indices.  This
function is most generally defined as <code style="white-space: pre;">⁠function(x_list, y, ...)⁠</code>,
and is called inside <code>multiview</code> to generate the indices for
excluded variables.  The <code>...</code> argument is required, the others
are optional.  This is useful for filtering wide data, and works
correctly with <code>cv.multiview</code>. See the vignette 'Introduction'
for examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to
each coefficient. This is a number that multiplies <code>lambda</code>
to allow differential shrinkage. Can be 0 for some variables,
which implies no shrinkage, and that variable is always included
in the model. Default is 1 for all variables (and implicitly
infinity for variables listed in <code>exclude</code>). Note: the
penalty factors are internally rescaled to sum to nvars, and the
lambda sequence will reflect this change.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient;
default <code>-Inf</code>. Each of these must be non-positive. Can be
presented as a single value (which will then be replicated), else
a vector of length <code>nvars</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient;
default <code>Inf</code>. See <code>lower.limits</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda
values; default is 10^5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then a progress bar is
displayed; useful for big models that take a long time to fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvars</code></td>
<td>
<p>the number of variables (total)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>the number of observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xm</code></td>
<td>
<p>the column means vector (could be zeros if <code>standardize = FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xs</code></td>
<td>
<p>the column std dev vector (could be 1s if <code>standardize = FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>the multiview control object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vp</code></td>
<td>
<p>the variable penalities (processed)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vnames</code></td>
<td>
<p>the variable names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.offset</code></td>
<td>
<p>a flag indicating if offset is supplied or not</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Sometimes the sequence is truncated before <code>nlambda</code> values of lambda
have been used. This happens when <code>cox.path</code> detects that the
decrease in deviance is marginal (i.e. we are near a saturated fit).
</p>


<h3>Value</h3>

<p>An object of class "coxnet" and "glmnet".
</p>
<table>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>Intercept value, <code>NULL</code> for "cox" family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x length(lambda)</code> matrix of coefficients, stored in
sparse matrix format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>Dimension of coefficient matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of lambda values used. When alpha=0, the
largest lambda reported does not quite give the zero coefficients reported
(lambda=inf would in principle). Instead, the largest lambda for alpha=0.001
is used, and the sequence of lambda values is derived from this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained. The deviance
calculations incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood
for the saturated model (a model with a free parameter per observation).
Hence dev.ratio=1-dev/nulldev.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to be
2*(loglike_sat -loglike(Null)). The null model refers to the 0 model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npasses</code></td>
<td>
<p>Total passes over the data summed over all lambda values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors (largely for internal
debugging).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A logical variable indicating whether an offset was included
in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">set.seed(2)
nobs &lt;- 100; nvars &lt;- 15
xvec &lt;- rnorm(nobs * nvars)
xvec[sample.int(nobs * nvars, size = 0.4 * nobs * nvars)] &lt;- 0
x &lt;- matrix(xvec, nrow = nobs)
beta &lt;- rnorm(nvars / 3)
fx &lt;- x[, seq(nvars / 3)] %*% beta / 3
ty &lt;- rexp(nobs, exp(fx))
tcens &lt;- rbinom(n = nobs, prob = 0.3, size = 1)
jsurv &lt;- survival::Surv(ty, tcens)
fit1 &lt;- glmnet:::cox.path(x, jsurv)

# works with sparse x matrix
x_sparse &lt;- Matrix::Matrix(x, sparse = TRUE)
fit2 &lt;- glmnet:::cox.path(x_sparse, jsurv)

# example with (start, stop] data
set.seed(2)
start_time &lt;- runif(100, min = 0, max = 5)
stop_time &lt;- start_time + runif(100, min = 0.1, max = 3)
status &lt;- rbinom(n = nobs, prob = 0.3, size = 1)
jsurv_ss &lt;- survival::Surv(start_time, stop_time, status)
fit3 &lt;- glmnet:::cox.path(x, jsurv_ss)

# example with strata
jsurv_ss2 &lt;- glmnet::stratifySurv(jsurv_ss, rep(1:2, each = 50))
fit4 &lt;- glmnet:::cox.path(x, jsurv_ss2)
</code></pre>


</div>