<div class="container">

<table style="width: 100%;"><tr>
<td>multiview.path</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a GLM with elastic net regularization for a path of lambda values</h2>

<h3>Description</h3>

<p>Fit a generalized linear model via penalized maximum likelihood for a path of
lambda values. Can deal with any GLM family.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multiview.path(
  x_list,
  y,
  rho = 0,
  weights = NULL,
  lambda,
  nlambda,
  user_lambda = FALSE,
  alpha = 1,
  offset = NULL,
  family = gaussian(),
  standardize = TRUE,
  intercept = TRUE,
  thresh = 1e-07,
  maxit = 1e+05,
  penalty.factor = rep(1, nvars),
  exclude = integer(0),
  lower.limits = -Inf,
  upper.limits = Inf,
  trace.it = 0,
  x,
  nvars,
  nobs,
  xm,
  xs,
  control,
  vp,
  vnames,
  start_val,
  is.offset
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>observation weights. Can be total counts if
responses are proportion matrices. Default is 1 for each
observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence, default
<code>NULL</code>. Typical usage is to have the program compute its own
<code>lambda</code> sequence. This sequence, in general, is different from
that used in the <code>glmnet::glmnet()</code> call (named <code>lambda</code>)
Supplying a value of <code>lambda</code> overrides this. WARNING: use with
care. Avoid supplying a single value for <code>lambda</code> (for
predictions after CV use <code>stats::predict()</code> instead.  Supply
instead a decreasing sequence of <code>lambda</code> values as <code>multiview</code>
relies on its warms starts for speed, and its often faster to fit
a whole path than compute a single fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_lambda</code></td>
<td>
<p>a flag indicating if user supplied the lambda sequence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>.  The penalty is defined as
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge
penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A vector of length <code>nobs</code> that is included in
the linear predictor (a <code>nobs x nc</code> matrix for the
<code>"multinomial"</code> family).  Useful for the <code>"poisson"</code>
family (e.g. log of exposure time), or for refining a model by
starting at a current fit. Default is <code>NULL</code>. If supplied,
then values must also be supplied to the <code>predict</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A description of the error distribution and link
function to be used in the model. This is the result of a call to
a family function. Default is stats::gaussian. (See
stats::family for details on family functions.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical flag for x variable standardization,
prior to fitting the model sequence. The coefficients are always
returned on the original scale. Default is
<code>standardize=TRUE</code>.  If variables are in the same units
already, you might not wish to standardize. See details below for
y standardization with <code>family="gaussian"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Should intercept(s) be fitted (default <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each
inner coordinate-descent loop continues until the maximum change
in the objective after any coefficient update is less than
<code>thresh</code> times the null deviance. Defaults value is
<code>1E-7</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda
values; default is 10^5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to
each coefficient. This is a number that multiplies <code>lambda</code>
to allow differential shrinkage. Can be 0 for some variables,
which implies no shrinkage, and that variable is always included
in the model. Default is 1 for all variables (and implicitly
infinity for variables listed in <code>exclude</code>). Note: the
penalty factors are internally rescaled to sum to nvars, and the
lambda sequence will reflect this change.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>Indices of variables to be excluded from the
model. Default is none. Equivalent to an infinite penalty factor
for the variables excluded (next item).  Users can supply instead
an <code>exclude</code> function that generates the list of indices.  This
function is most generally defined as <code style="white-space: pre;">⁠function(x_list, y, ...)⁠</code>,
and is called inside <code>multiview</code> to generate the indices for
excluded variables.  The <code>...</code> argument is required, the others
are optional.  This is useful for filtering wide data, and works
correctly with <code>cv.multiview</code>. See the vignette 'Introduction'
for examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient;
default <code>-Inf</code>. Each of these must be non-positive. Can be
presented as a single value (which will then be replicated), else
a vector of length <code>nvars</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient;
default <code>Inf</code>. See <code>lower.limits</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then a progress bar is
displayed; useful for big models that take a long time to fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the <code>cbind</code>ed matrices in <code>x_list</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvars</code></td>
<td>
<p>the number of variables (total)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>the number of observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xm</code></td>
<td>
<p>the column means vector (could be zeros if <code>standardize = FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xs</code></td>
<td>
<p>the column std dev vector (could be 1s if <code>standardize = FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>the multiview control object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vp</code></td>
<td>
<p>the variable penalities (processed)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vnames</code></td>
<td>
<p>the variable names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_val</code></td>
<td>
<p>the result of first call to <code>get_start</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.offset</code></td>
<td>
<p>a flag indicating if offset is supplied or not</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>multiview.path</code> solves the elastic net problem for a path of lambda values.
It generalizes <code>multiview::multiview</code> in that it works for any GLM family.
</p>
<p>Sometimes the sequence is truncated before <code>nlam</code> values of lambda
have been used. This happens when <code>multiview.path</code> detects that the decrease
in deviance is marginal (i.e. we are near a saturated fit).
</p>


<h3>Value</h3>

<p>An object with class <code>"multiview"</code> <code>"glmnetfit"</code> and <code>"glmnet"</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code style="white-space: pre;">⁠nvars x length(lambda)⁠</code> matrix of coefficients, stored in
sparse matrix format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>Dimension of coefficient matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of lambda values used. When alpha=0, the
largest lambda reported does not quite give the zero coefficients reported
(lambda=inf would in principle). Instead, the largest lambda for alpha=0.001
is used, and the sequence of lambda values is derived from this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The sequence of lambda values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mvlambda</code></td>
<td>
<p>The corresponding sequence of multiview lambda values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained. The deviance
calculations incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood
for the saturated model (a model with a free parameter per observation).
Hence dev.ratio=1-dev/nulldev.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to be
2*(loglike_sat -loglike(Null)). The null model refers to the intercept model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npasses</code></td>
<td>
<p>Total passes over the data summed over all lambda values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors (largely for internal
debugging).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A logical variable indicating whether an offset was included
in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Family used for the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td>
</tr>
</table>
</div>