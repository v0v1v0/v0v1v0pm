<div class="container">

<table style="width: 100%;"><tr>
<td>predict.cv.multiview</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make predictions from a "cv.multiview" object.</h2>

<h3>Description</h3>

<p>This function makes predictions from a cross-validated multiview model, using
the stored <code>"multiview"</code> object, and the optimal value chosen for
<code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'cv.multiview'
predict(object, newx, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Fitted <code>"cv.multiview"</code> or object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newx</code></td>
<td>
<p>List of new view matrices at which predictions are to be made.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the value <code>s="lambda.1se"</code> stored
on the CV <code>object</code>. Alternatively <code>s="lambda.min"</code> can be used. If
<code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be
used. (For historical reasons we use the symbol 's' rather than 'lambda' to
reference this parameter)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function makes it easier to use the results of cross-validation to make
a prediction.
</p>


<h3>Value</h3>

<p>The object returned depends on the ... argument which is passed
on to the <code>predict</code> method for <code>multiview</code> objects.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Gaussian
# Generate data based on a factor model
set.seed(1)
x = matrix(rnorm(100*10), 100, 10)
z = matrix(rnorm(100*10), 100, 10)
U = matrix(rnorm(100*5), 100, 5)
for (m in seq(5)){
    u = rnorm(100)
    x[, m] = x[, m] + u
    z[, m] = z[, m] + u
    U[, m] = U[, m] + u}
x = scale(x, center = TRUE, scale = FALSE)
z = scale(z, center = TRUE, scale = FALSE)
beta_U = c(rep(0.1, 5))
y = U %*% beta_U + 0.1 * rnorm(100)
fit1 = cv.multiview(list(x=x,z=z), y, rho = 0.3)
predict(fit1, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min")

# Binomial

by = 1 * (y &gt; median(y)) 
fit2 = cv.multiview(list(x=x,z=z), by, family = binomial(), rho = 0.9)
predict(fit2, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min", type = "response")

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = cv.multiview(list(x=x,z=z), py, family = poisson(), rho = 0.6)
predict(fit3, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min", type = "response")

</code></pre>


</div>