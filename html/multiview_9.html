<div class="container">

<table style="width: 100%;"><tr>
<td>cv.multiview</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform k-fold cross-validation for cooperative learning</h2>

<h3>Description</h3>

<p>Does k-fold cross-validation (CV) for multiview and produces a CV curve.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.multiview(
  x_list,
  y,
  family = gaussian(),
  rho = 0,
  weights = NULL,
  offset = NULL,
  lambda = NULL,
  type.measure = c("default", "mse", "deviance", "class", "auc", "mae", "C"),
  nfolds = 10,
  foldid = NULL,
  alignment = c("lambda", "fraction"),
  grouped = TRUE,
  keep = FALSE,
  trace.it = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A description of the error distribution and link
function to be used in the model. This is the result of a call to
a family function. Default is stats::gaussian. (See
stats::family for details on family functions.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Offset vector (matrix) as in <code>multiview</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence, default
<code>NULL</code>. Typical usage is to have the program compute its own
<code>lambda</code> sequence. This sequence, in general, is different from
that used in the <code>glmnet::glmnet()</code> call (named <code>lambda</code>). Note
that this is done for the full model (master sequence), and
separately for each fold.  The fits are then aligned using the
glmnet lambda sequence associated with the master sequence (see
the <code>alignment</code> argument for additional details). Adapting
<code>lambda</code> for each fold leads to better convergence. When
<code>lambda</code> is supplied, the same sequence is used everywhere, but
in some GLMs can lead to convergence issues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.measure</code></td>
<td>
<p>loss to use for cross-validation. Currently
five options, not all available for all models. The default is
<code>type.measure="deviance"</code>, which uses squared-error for gaussian
models (a.k.a <code>type.measure="mse"</code> there), deviance for logistic
and poisson regression, and partial-likelihood for the Cox model.
<code>type.measure="class"</code> applies to binomial and multinomial
logistic regression only, and gives misclassification error.
<code>type.measure="auc"</code> is for two-class logistic regression only,
and gives area under the ROC curve. <code>type.measure="mse"</code> or
<code>type.measure="mae"</code> (mean absolute error) can be used by all
models except the <code>"cox"</code>; they measure the deviation from the
fitted mean to the response.  <code>type.measure="C"</code> is Harrel's
concordance measure, only available for <code>cox</code> models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>number of folds - default is 10. Although <code>nfolds</code>
can be as large as the sample size (leave-one-out CV), it is not
recommended for large datasets. Smallest value allowable is
<code>nfolds=3</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,
<code>nfold</code> can be missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alignment</code></td>
<td>
<p>This is an experimental argument, designed to fix
the problems users were having with CV, with possible values
<code>"lambda"</code> (the default) else <code>"fraction"</code>. With <code>"lambda"</code> the
<code>lambda</code> values from the master fit (on all the data) are used to
line up the predictions from each of the folds. In some cases
this can give strange values, since the effective <code>lambda</code> values
in each fold could be quite different. With <code>"fraction"</code> we line
up the predictions in each fold according to the fraction of
progress along the regularization. If in the call a <code>lambda</code>
argument is also provided, <code>alignment="fraction"</code> is ignored
(with a warning).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grouped</code></td>
<td>
<p>This is an experimental argument, with default
<code>TRUE</code>, and can be ignored by most users. For all models except
the <code>"cox"</code>, this refers to computing <code>nfolds</code> separate
statistics, and then using their mean and estimated standard
error to describe the CV curve. If <code>grouped=FALSE</code>, an error
matrix is built up at the observation level from the predictions
from the <code>nfold</code> fits, and then summarized (does not apply to
<code>type.measure="auc"</code>). For the <code>"cox"</code> family, <code>grouped=TRUE</code>
obtains the CV partial likelihood for the Kth fold by
<em>subtraction</em>; by subtracting the log partial likelihood
evaluated on the full dataset from that evaluated on the on the
(K-1)/K dataset. This makes more efficient use of risk sets. With
<code>grouped=FALSE</code> the log partial likelihood is computed only on
the Kth fold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>If <code>keep=TRUE</code>, a <em>prevalidated</em> array is returned
containing fitted values for each observation and each value of
<code>lambda</code>. This means these fits are computed with this
observation and the rest of its fold omitted. The <code>foldid</code> vector
is also returned.  Default is keep=FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then progress bars are displayed;
useful for big models that take a long time to fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments that can be passed to <code>multiview</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The current code can be slow for "large" data sets, e.g. when the
number of features is larger than 1000.  It can be helpful to see
the progress of multiview as it runs; to do this, set trace.it = 1
in the call to multiview or cv.multiview.  With this, multiview
prints out its progress along the way.  One can also pre-filter the
features to a smaller set, using the exclude option, with a filter
function.
</p>
<p>If there are missing values in the feature matrices:
we recommend that you center the columns of each feature matrix, and then fill in the missing values with 0.
</p>
<p>For example, <br><code>x &lt;- scale(x,TRUE,FALSE)</code> <br><code>x[is.na(x)] &lt;- 0</code> <br><code>z &lt;- scale(z,TRUE,FALSE)</code> <br><code>z[is.na(z)] &lt;- 0</code> <br></p>
<p>Then run multiview in the usual way. It will exploit the assumed shared latent factors
to make efficient use of the available data.
</p>
<p>The function runs <code>multiview</code> <code>nfolds+1</code> times; the first to get the
<code>lambda</code> sequence, and then the remainder to compute the fit with each
of the folds omitted. The error is accumulated, and the average error and
standard deviation over the folds is computed.  Note that <code>cv.multiview</code>
does NOT search for values for <code>rho</code>. A specific value should be
supplied, else <code>rho=0</code> is assumed by default. If users would like to
cross-validate <code>rho</code> as well, they should call <code>cv.multiview</code> with
a pre-computed vector <code>foldid</code>, and then use this same fold vector in
separate calls to <code>cv.multiview</code> with different values of <code>rho</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.multiview"</code> is returned, which is a
list with the ingredients of the cross-validation
fit. </p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvm</code></td>
<td>
<p>The mean cross-validated error - a vector of length
<code>length(lambda)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvsd</code></td>
<td>
<p>estimate of standard error of
<code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvup</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvlo</code></td>
<td>
<p>lower
curve = <code>cvm-cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nzero</code></td>
<td>
<p>number of non-zero coefficients
at each <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>a text string indicating type of
measure (for plotting purposes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiview.fit</code></td>
<td>
<p>a fitted
multiview object for the full data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>value of
<code>lambda</code> that gives minimum <code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.1se</code></td>
<td>
<p>largest
value of <code>lambda</code> such that error is within 1 standard error of
the minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.preval</code></td>
<td>
<p>if <code>keep=TRUE</code>, this is the array
of prevalidated fits. Some entries can be <code>NA</code>, if that and
subsequent values of <code>lambda</code> are not reached for that fold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p>if <code>keep=TRUE</code>, the fold assignments used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>a one column matrix with the indices of <code>lambda.min</code>
and <code>lambda.1se</code> in the sequence of coefficients, fits etc.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># Gaussian
# Generate data based on a factor model
set.seed(1)
x = matrix(rnorm(100*20), 100, 20)
z = matrix(rnorm(100*20), 100, 20)
U = matrix(rnorm(100*5), 100, 5)
for (m in seq(5)){
    u = rnorm(100)
    x[, m] = x[, m] + u
    z[, m] = z[, m] + u
    U[, m] = U[, m] + u}
x = scale(x, center = TRUE, scale = FALSE)
z = scale(z, center = TRUE, scale = FALSE)
beta_U = c(rep(0.1, 5))
y = U %*% beta_U + 0.1 * rnorm(100)
fit1 = cv.multiview(list(x=x,z=z), y, rho = 0.3)

# plot the cross-validation curve
plot(fit1)

# extract coefficients
coef(fit1, s="lambda.min")

# extract ordered coefficients
coef_ordered(fit1, s="lambda.min")

# make predictions
predict(fit1, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min")

# Binomial

by = 1 * (y &gt; median(y)) 
fit2 = cv.multiview(list(x=x,z=z), by, family = binomial(), rho = 0.9)
predict(fit2, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min", type = "response")
plot(fit2)
coef(fit2, s="lambda.min")
coef_ordered(fit2, s="lambda.min")

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = cv.multiview(list(x=x,z=z), py, family = poisson(), rho = 0.6)
predict(fit3, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min", type = "response") 
plot(fit3)
coef(fit3, s="lambda.min")
coef_ordered(fit3, s="lambda.min")

</code></pre>


</div>