<div class="container">

<table style="width: 100%;"><tr>
<td>mcr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Multiway Covariates Regression
</h2>

<h3>Description</h3>

<p>Fits Smilde and Kiers's Multiway Covariates Regression (MCR) model to connect a 3-way predictor array and a 2-way response array that share a common mode. Parameters are estimated via alternating least squares with optional constraints.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcr(X, Y, nfac = 1, alpha = 0.5, nstart = 10, 
    model = c("parafac", "parafac2", "tucker"),
    const = NULL, control = NULL, weights = NULL,
    Afixed = NULL, Bfixed = NULL, Cfixed = NULL, Dfixed = NULL,
    Astart = NULL, Bstart = NULL, Cstart = NULL, Dstart = NULL,
    Astruc = NULL, Bstruc = NULL, Cstruc = NULL, Dstruc = NULL,
    Amodes = NULL, Bmodes = NULL, Cmodes = NULL, Dmodes = NULL,
    maxit = 500, ctol = 1e-4, parallel = FALSE, cl = NULL, 
    output = c("best", "all"), verbose = TRUE, backfit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>Three-way predictor array with <code>dim = c(I,J,K)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>

<p>Two-way response array with <code>dim = c(K,L)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfac</code></td>
<td>

<p>Number of factors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>Tuning parameter between 0 and 1. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>

<p>Number of random starts.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>Model for <code>X</code>. Defaults to "parafac".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>

<p>Character vector of length 4 giving the constraints for <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> (defaults to unconstrained). See <code>const</code> for the 24 available options. Ignored if <code>model = "tucker"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>List of parameters controlling options for smoothness constraints. This is passed to <code>const.control</code>, which describes the available options.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Vector of length <code>K</code> giving non-negative weights for fitting via weighted least squares. Defaults to vector of ones.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Afixed</code></td>
<td>

<p>Used to fit model with fixed Mode A weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bfixed</code></td>
<td>

<p>Used to fit model with fixed Mode B weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cfixed</code></td>
<td>

<p>Used to fit model with fixed Mode C weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dfixed</code></td>
<td>

<p>Used to fit model with fixed Mode D weights. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Astart</code></td>
<td>

<p>Starting Mode A weights. Default uses random weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bstart</code></td>
<td>

<p>Starting Mode B weights. Default uses random weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cstart</code></td>
<td>

<p>Starting Mode C weights. Default uses random weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dstart</code></td>
<td>

<p>Starting Mode D weights. Default uses random weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Astruc</code></td>
<td>

<p>Structure constraints for Mode A weights. See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bstruc</code></td>
<td>

<p>Structure constraints for Mode B weights. See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cstruc</code></td>
<td>

<p>Structure constraints for Mode C weights. Ignored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dstruc</code></td>
<td>

<p>Structure constraints for Mode D weights. See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Amodes</code></td>
<td>

<p>Mode ranges for Mode A weights (for unimodality constraints). See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bmodes</code></td>
<td>

<p>Mode ranges for Mode B weights (for unimodality constraints). See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cmodes</code></td>
<td>

<p>Mode ranges for Mode C weights (for unimodality constraints). Ignored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dmodes</code></td>
<td>

<p>Mode ranges for Mode D weights (for unimodality constraints). See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctol</code></td>
<td>

<p>Convergence tolerance (R^2 change).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>

<p>Logical indicating if <code>parLapply</code> should be used. See Examples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>

<p>Cluster created by <code>makeCluster</code>. Only used when <code>parallel=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>

<p>Output the best solution (default) or output all <code>nstart</code> solutions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>If <code>TRUE</code>, fitting progress is printed via <code>txtProgressBar</code>. Ignored if <code>parallel=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backfit</code></td>
<td>

<p>Should backfitting algorithm be used for <code>cmls</code>?
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a predictor array <code>X = array(x, dim=c(I,J,K))</code> and a response matrix <code>Y = matrix(y, nrow=K, ncol=L)</code>, the multiway covariates regression (MCR) model assumes a tensor model for <code>X</code> and a bilinear model for <code>Y</code>, which are linked through a common <code>C</code> weight matrix. For example, using the Parafac model for <code>X</code>, the MCR model has the form
</p>

<table>
<tr>
<td style="text-align: left;">
<code> X[i,j,k] = sum A[i,r]*B[j,r]*C[k,r] + Ex[i,j,k] </code> </td>
</tr>
<tr>
<td style="text-align: left;">
and </td>
</tr>
<tr>
<td style="text-align: left;">
<code>   Y[k,l] = sum C[k,r]*D[l,r] + Ey[k,l] </code> </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Parameter matrices are estimated by minimizing the loss function
</p>

<table><tr>
<td style="text-align: center;">
<code>LOSS = alpha * (SSE.X / SSX) + (1 - alpha) * (SSE.Y / SSY)</code>
</td>
</tr></table>
<p>where 
</p>

<table>
<tr>
<td style="text-align: left;">
<code>SSE.X = sum((X - Xhat)^2)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>SSE.Y = sum((Y - Yhat)^2)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
  <code>SSX = sum(X^2)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
  <code>SSY = sum(Y^2)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>When <code>weights</code> are input, <code>SSE.X</code>, <code>SSE.Y</code>, <code>SSX</code>, and <code>SSY</code> are replaced by the corresponding weighted versions.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Predictor A weight matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Predictor B weight matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>Common C weight matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>Response D weight matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>Coefficients. See Note.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LOSS</code></td>
<td>
<p>Value of <code>LOSS</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SSE</code></td>
<td>
<p>Sum of Squared Errors for <code>X</code> and <code>Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rsq</code></td>
<td>
<p>R-squared value for <code>X</code> and <code>Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cflag</code></td>
<td>
<p>Convergence flag. See Note.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>See argument <code>model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>
<p>See argument <code>const</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>See argument <code>control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>See argument <code>weights</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>See argument <code>alpha</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Logical vector indicating whether 'fixed' weights were used for each matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>struc</code></td>
<td>
<p>Logical vector indicating whether 'struc' constraints were used for each matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>Mode A crossproduct matrix. Only if <code>model = "parafac2"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>Core array. Only if <code>model = "tucker"</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>When <code>model = "parafac2"</code>, the arguments <code>Afixed</code>, <code>Astart</code>, and <code>Astruc</code> are treated as the arguments <code>Gfixed</code>, <code>Gstart</code>, and <code>Gstruc</code> from the <code>parafac2</code> function.
</p>
<p>Structure constraints should be specified with a matrix of logicals (TRUE/FALSE), such that FALSE elements indicate a weight should be constrained to be zero. Default uses unstructured weights, i.e., a matrix of all TRUE values. Structure constraints are ignored if <code>model = "tucker"</code>.
</p>
<p>When using unimodal constraints, the <code>*modes</code> inputs can be used to specify the mode search range for each factor. These inputs should be matrices with dimension <code>c(2,nfac)</code> where the first row gives the minimum mode value and the second row gives the maximum mode value (with respect to the indicies of the corresponding weight matrix).
</p>
<p><code>C = Xc %*% W</code> where <code>Xc = matrix(aperm(X,c(3,1,2)),K)</code>
</p>
<p>Output <code>cflag</code> gives convergence information: <code>cflag = 0</code> if algorithm converged normally, <code>cflag = 1</code> if maximum iteration limit was reached before convergence, and <code>cflag = 2</code> if algorithm terminated abnormally due to a problem with the constraints.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Smilde, A. K., &amp; Kiers, H. A. L. (1999). Multiway covariates regression models, <em>Journal of Chemometrics, 13</em>, 31-48.
</p>


<h3>See Also</h3>

<p>The <code>fitted.mcr</code> function creates the model-implied fitted values from a fit <code>"mcr"</code> object.
</p>
<p>The <code>resign.mcr</code> function can be used to resign factors from a fit <code>"mcr"</code> object.
</p>
<p>The <code>rescale.mcr</code> function can be used to rescale factors from a fit <code>"mcr"</code> object.
</p>
<p>The <code>reorder.mcr</code> function can be used to reorder factors from a fit <code>"mcr"</code> object.
</p>
<p>The <code>cmls</code> function (from <b>CMLS</b> package) is called as a part of the alternating least squares algorithm.
</p>
<p>See <code>parafac</code>, <code>parafac2</code>, and <code>tucker</code> for more information about the Parafac, Parafac2, and Tucker models. 
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##########   multiway covariates regression   ##########

# create random data array with Parafac structure
set.seed(3)
mydim &lt;- c(10, 20, 100)
nf &lt;- 2
Amat &lt;- matrix(rnorm(mydim[1]*nf), mydim[1], nf)
Bmat &lt;- matrix(rnorm(mydim[2]*nf), mydim[2], nf)
Cmat &lt;- matrix(rnorm(mydim[3]*nf), mydim[3], nf)
Xmat &lt;- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
EX &lt;- array(rnorm(prod(mydim)), dim = mydim)
EX &lt;- nscale(EX, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + EX

# create response array
ydim &lt;- c(mydim[3], 4)
Dmat &lt;- matrix(rnorm(ydim[2]*nf), ydim[2], nf)
Ymat &lt;- tcrossprod(Cmat, Dmat)
EY &lt;- array(rnorm(prod(ydim)), dim = ydim)
EY &lt;- nscale(EY, 0, ssnew = sumsq(Ymat))   # SNR = 1
Y &lt;- Ymat + EY

# fit MCR model
mcr(X, Y, nfac = nf, nstart = 1)
mcr(X, Y, nfac = nf, nstart = 1, model = "parafac2")
mcr(X, Y, nfac = nf, nstart = 1, model = "tucker")



## Not run: 

##########   parallel computation   ##########

# create random data array with Parafac structure
set.seed(3)
mydim &lt;- c(10, 20, 100)
nf &lt;- 2
Amat &lt;- matrix(rnorm(mydim[1]*nf), mydim[1], nf)
Bmat &lt;- matrix(rnorm(mydim[2]*nf), mydim[2], nf)
Cmat &lt;- matrix(rnorm(mydim[3]*nf), mydim[3], nf)
Xmat &lt;- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
EX &lt;- array(rnorm(prod(mydim)), dim = mydim)
EX &lt;- nscale(EX, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + EX

# create response array
ydim &lt;- c(mydim[3], 4)
Dmat &lt;- matrix(rnorm(ydim[2]*nf), ydim[2], nf)
Ymat &lt;- tcrossprod(Cmat, Dmat)
EY &lt;- array(rnorm(prod(ydim)), dim = ydim)
EY &lt;- nscale(EY, 0, ssnew = sumsq(Ymat))   # SNR = 1
Y &lt;- Ymat + EY

# fit MCR-Parafac model (10 random starts -- sequential computation)
set.seed(1)
system.time({mod &lt;- mcr(X, Y, nfac = nf)})
mod

# fit MCR-Parafac model (10 random starts -- parallel computation)
cl &lt;- makeCluster(detectCores())
ce &lt;- clusterEvalQ(cl, library(multiway))
clusterSetRNGStream(cl, 1)
system.time({mod &lt;- mcr(X, Y, nfac = nf, parallel = TRUE, cl = cl)})
mod
stopCluster(cl)


## End(Not run)


</code></pre>


</div>