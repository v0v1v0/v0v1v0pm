<div class="container">

<table style="width: 100%;"><tr>
<td>parafac2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Parallel Factor Analysis-2
</h2>

<h3>Description</h3>

<p>Fits Richard A. Harshman's Parallel Factors-2 (Parafac2) model to 3-way or 4-way ragged data arrays. Parameters are estimated via alternating least squares with optional constraints.
</p>


<h3>Usage</h3>

<pre><code class="language-R">parafac2(X, nfac, nstart = 10, const = NULL, control = NULL,
         Gfixed = NULL, Bfixed = NULL, Cfixed = NULL, Dfixed = NULL,
         Gstart = NULL, Bstart = NULL, Cstart = NULL, Dstart = NULL,
         Gstruc = NULL, Bstruc = NULL, Cstruc = NULL, Dstruc = NULL,
         Gmodes = NULL, Bmodes = NULL, Cmodes = NULL, Dmodes = NULL,
         maxit = 500, ctol = 1e-4, parallel = FALSE, cl = NULL,
         output = c("best", "all"), verbose = TRUE, backfit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>For 3-way Parafac2: list of length <code>K</code> where <code>k</code>-th element is <code>I[k]</code>-by-<code>J</code> matrix or three-way data array with <code>dim=c(I,J,K)</code>. For 4-way Parafac2: list of length <code>L</code> where <code>l</code>-th element is <code>I[l]</code>-by-<code>J</code>-by-<code>K</code> array or four-way data array with <code>dim=c(I,J,K,L)</code>. Missing data are allowed (see Note).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfac</code></td>
<td>

<p>Number of factors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>

<p>Number of random starts.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>

<p>Character vector of length 3 or 4 giving the constraints for each mode (defaults to unconstrained). See <code>const</code> for the 24 available options. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>List of parameters controlling options for smoothness constraints. This is passed to <code>const.control</code>, which describes the available options.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gfixed</code></td>
<td>

<p>Used to fit model with fixed Phi matrix: <code>crossprod(Gfixed) = Phi</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bfixed</code></td>
<td>

<p>Used to fit model with fixed Mode B weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cfixed</code></td>
<td>

<p>Used to fit model with fixed Mode C weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dfixed</code></td>
<td>

<p>Used to fit model with fixed Mode D weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gstart</code></td>
<td>

<p>Starting Mode A crossproduct matrix: <code>crossprod(Gstart) = Phi</code>. Default uses random weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bstart</code></td>
<td>

<p>Starting Mode B weights. Default uses random weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cstart</code></td>
<td>

<p>Starting Mode C weights. Default uses random weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dstart</code></td>
<td>

<p>Starting Mode D weights. Default uses random weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gstruc</code></td>
<td>

<p>Structure constraints for Mode A crossproduct matrix: <code>crossprod(Gstruc) = Phistruc</code>. See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bstruc</code></td>
<td>

<p>Structure constraints for Mode B weights. See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cstruc</code></td>
<td>

<p>Structure constraints for Mode C weights. See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dstruc</code></td>
<td>

<p>Structure constraints for Mode D weights. See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gmodes</code></td>
<td>

<p>Mode ranges for Mode A weights (for unimodality constraints). Ignored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bmodes</code></td>
<td>

<p>Mode ranges for Mode B weights (for unimodality constraints). See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cmodes</code></td>
<td>

<p>Mode ranges for Mode C weights (for unimodality constraints). See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dmodes</code></td>
<td>

<p>Mode ranges for Mode D weights (for unimodality constraints). See Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctol</code></td>
<td>

<p>Convergence tolerance (R^2 change).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>

<p>Logical indicating if <code>parLapply</code> should be used. See Examples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>

<p>Cluster created by <code>makeCluster</code>. Only used when <code>parallel=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>

<p>Output the best solution (default) or output all <code>nstart</code> solutions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>If <code>TRUE</code>, fitting progress is printed via <code>txtProgressBar</code>. Ignored if <code>parallel=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backfit</code></td>
<td>

<p>Should backfitting algorithm be used for <code>cmls</code>?
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a list of matrices <code>X[[k]] = matrix(xk,I[k],J)</code> for <code>k = seq(1,K)</code>, the 3-way Parafac2 model (with Mode A nested in Mode C) can be written as
</p>

<table>
<tr>
<td style="text-align: right;">
<code>X[[k]] = tcrossprod(A[[k]] %*% diag(C[k,]), B) + E[[k]]</code> </td>
</tr>
<tr>
<td style="text-align: right;"> 
subject to <code>crossprod(A[[k]]) = Phi</code> </td>
</tr>
<tr>
<td style="text-align: right;"> 
</td>
</tr>
</table>
<p>where <code>A[[k]] = matrix(ak,I[k],R)</code> are the Mode A (first mode) weights for the <code>k</code>-th level of Mode C (third mode), <code>Phi</code> is the common crossproduct matrix shared by all <code>K</code> levels of Mode C, <code>B = matrix(b,J,R)</code> are the Mode B (second mode) weights, <code>C = matrix(c,K,R)</code> are the Mode C (third mode) weights, and <code>E[[k]] = matrix(ek,I[k],J)</code> is the residual matrix corresponding to <code>k</code>-th level of Mode C.
</p>
<p>Given a list of arrays <code>X[[l]] = array(xl, dim = c(I[l],J,K))</code> for <code>l = seq(1,L)</code>, the 4-way Parafac2 model (with Mode A nested in Mode D) can be written as
</p>

<table>
<tr>
<td style="text-align: right;">
<code>X[[l]][,,k] = tcrossprod(A[[l]] %*% diag(D[l,]*C[k,]), B) + E[[l]][,,k]</code> </td>
</tr>
<tr>
<td style="text-align: right;"> 
subject to <code>crossprod(A[[l]]) = Phi</code> </td>
</tr>
<tr>
<td style="text-align: right;"> 
</td>
</tr>
</table>
<p>where <code>A[[l]] = matrix(al,I[l],R)</code> are the Mode A (first mode) weights for the <code>l</code>-th level of Mode D (fourth mode), <code>Phi</code> is the common crossproduct matrix shared by all <code>L</code> levels of Mode D, <code>D = matrix(d,L,R)</code> are the Mode D (fourth mode) weights, and <code>E[[l]] = array(el, dim = c(I[l],J,K))</code> is the residual array corresponding to <code>l</code>-th level of Mode D.
</p>
<p>Weight matrices are estimated using an alternating least squares algorithm with optional constraints.
</p>


<h3>Value</h3>

<p>If <code>output = "best"</code>, returns an object of class <code>"parafac2"</code> with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>List of Mode A weight matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Mode B weight matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>Mode C weight matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>Mode D weight matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>Mode A crossproduct matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SSE</code></td>
<td>
<p>Sum of Squared Errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rsq</code></td>
<td>
<p>R-squared value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GCV</code></td>
<td>
<p>Generalized Cross-Validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf</code></td>
<td>
<p>Effective degrees of freedom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cflag</code></td>
<td>
<p>Convergence flag. See Note.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>
<p>See argument <code>const</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>See argument <code>control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>Logical vector indicating whether 'fixed' weights were used for each mode.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>struc</code></td>
<td>
<p>Logical vector indicating whether 'struc' constraints were used for each mode.</p>
</td>
</tr>
</table>
<p>Otherwise returns a list of length <code>nstart</code> where each element is an object of class <code>"parafac2"</code>.
</p>


<h3>Warnings </h3>

<p>The algorithm can perform poorly if the number of factors <code>nfac</code> is set too large.
</p>


<h3>Note</h3>

<p>Missing data should be specified as <code>NA</code> values in the input <code>X</code>. The missing data are randomly initialized and then iteratively imputed as a part of the algorithm.
</p>
<p>Structure constraints should be specified with a matrix of logicals (TRUE/FALSE), such that FALSE elements indicate a weight should be constrained to be zero. Default uses unstructured weights, i.e., a matrix of all TRUE values. 
</p>
<p>When using unimodal constraints, the <code>*modes</code> inputs can be used to specify the mode search range for each factor. These inputs should be matrices with dimension <code>c(2,nfac)</code> where the first row gives the minimum mode value and the second row gives the maximum mode value (with respect to the indicies of the corresponding weight matrix).
</p>
<p>Output <code>cflag</code> gives convergence information: <code>cflag = 0</code> if algorithm converged normally, <code>cflag = 1</code> if maximum iteration limit was reached before convergence, and <code>cflag = 2</code> if algorithm terminated abnormally due to a problem with the constraints.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Harshman, R. A. (1972). PARAFAC2: Mathematical and technical notes. <em>UCLA Working Papers in Phonetics, 22</em>, 30-44.
</p>
<p>Helwig, N. E. (2013). The special sign indeterminacy of the direct-fitting Parafac2 model: Some implications, cautions, and recommendations, for Simultaneous Component Analysis. <em>Psychometrika, 78</em>, 725-739.
</p>
<p>Helwig, N. E. (2017). Estimating latent trends in multivariate longitudinal data via Parafac2 with functional and structural constraints. <em>Biometrical Journal, 59</em>(4), 783-803.
</p>
<p>Helwig, N. E. (in prep). Constrained parallel factor analysis via the R package multiway.
</p>
<p>Kiers, H. A. L., ten Berge, J. M. F., &amp; Bro, R. (1999). PARAFAC2-part I: A direct-fitting algorithm for the PARAFAC2 model. <em>Journal of Chemometrics, 13</em>, 275-294.
</p>


<h3>See Also</h3>

<p>The <code>fitted.parafac2</code> function creates the model-implied fitted values from a fit <code>"parafac2"</code> object.
</p>
<p>The <code>resign.parafac2</code> function can be used to resign factors from a fit <code>"parafac2"</code> object.
</p>
<p>The <code>rescale.parafac2</code> function can be used to rescale factors from a fit <code>"parafac2"</code> object.
</p>
<p>The <code>reorder.parafac2</code> function can be used to reorder factors from a fit <code>"parafac2"</code> object.
</p>
<p>The <code>cmls</code> function (from <b>CMLS</b> package) is called as a part of the alternating least squares algorithm.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##########   3-way example   ##########

# create random data list with Parafac2 structure
set.seed(3)
mydim &lt;- c(NA, 10, 20)
nf &lt;- 2
nk &lt;- rep(c(50, 100, 200), length.out = mydim[3])
Gmat &lt;- matrix(rnorm(nf^2), nrow = nf, ncol = nf)
Bmat &lt;- matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf)
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Xmat &lt;- Emat &lt;- Amat &lt;- vector("list", mydim[3])
for(k in 1:mydim[3]){
  Amat[[k]] &lt;- matrix(rnorm(nk[k]*nf), nrow = nk[k], ncol = nf)
  Amat[[k]] &lt;- svd(Amat[[k]], nv = 0)$u %*% Gmat
  Xmat[[k]] &lt;- tcrossprod(Amat[[k]] %*% diag(Cmat[k,]), Bmat)
  Emat[[k]] &lt;- matrix(rnorm(nk[k]*mydim[2]), nrow = nk[k], ncol = mydim[2])
}
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- mapply("+", Xmat, Emat)

# fit Parafac2 model (unconstrained)
pfac &lt;- parafac2(X, nfac = nf, nstart = 1)
pfac

# check solution
Xhat &lt;- fitted(pfac)
sse &lt;- sumsq(mapply("-", Xmat, Xhat))
sse / (sum(nk) * mydim[2])
crossprod(pfac$A[[1]])
crossprod(pfac$A[[2]])
pfac$Phi

# reorder and resign factors
pfac$B[1:4,]
pfac &lt;- reorder(pfac, 2:1)
pfac$B[1:4,]
pfac &lt;- resign(pfac, mode="B")
pfac$B[1:4,]
Xhat &lt;- fitted(pfac)
sse &lt;- sumsq(mapply("-", Xmat, Xhat))
sse / (sum(nk) * mydim[2])

# rescale factors
colSums(pfac$B^2)
colSums(pfac$C^2)
pfac &lt;- rescale(pfac, mode = "C", absorb = "B")
colSums(pfac$B^2)
colSums(pfac$C^2)
Xhat &lt;- fitted(pfac)
sse &lt;- sumsq(mapply("-", Xmat, Xhat))
sse / (sum(nk) * mydim[2])


##########   4-way example   ##########

# create random data list with Parafac2 structure
set.seed(4)
mydim &lt;- c(NA, 10, 20, 5)
nf &lt;- 3
nk &lt;- rep(c(50,100,200), length.out = mydim[4])
Gmat &lt;- matrix(rnorm(nf^2), nrow = nf, ncol = nf)
Bmat &lt;- scale(matrix(rnorm(mydim[2]*nf), nrow = mydim[2], ncol = nf), center = FALSE)
cseq &lt;- seq(-3, 3, length=mydim[3])
Cmat &lt;- cbind(pnorm(cseq), pgamma(cseq+3.1, shape=1, rate=1)*(3/4), pt(cseq-2, df=4)*2)
Dmat &lt;- scale(matrix(runif(mydim[4]*nf)*2, nrow = mydim[4], ncol = nf), center = FALSE)
Xmat &lt;- Emat &lt;- Amat &lt;- vector("list",mydim[4])
for(k in 1:mydim[4]){
  aseq &lt;- seq(-3, 3, length.out = nk[k])
  Amat[[k]] &lt;- cbind(sin(aseq), sin(abs(aseq)), exp(-aseq^2))
  Amat[[k]] &lt;- svd(Amat[[k]], nv = 0)$u %*% Gmat
  Xmat[[k]] &lt;- array(tcrossprod(Amat[[k]] %*% diag(Dmat[k,]),
                                krprod(Cmat, Bmat)), dim = c(nk[k], mydim[2], mydim[3]))
  Emat[[k]] &lt;- array(rnorm(nk[k] * mydim[2] * mydim[3]), dim = c(nk[k], mydim[2], mydim[3]))
}
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- mapply("+", Xmat, Emat)

# fit Parafac model (smooth A, unconstrained B, monotonic C, non-negative D)
pfac &lt;- parafac2(X, nfac = nf, nstart = 1, 
                 const = c("smooth", "uncons", "moninc", "nonneg"))
pfac

# check solution
Xhat &lt;- fitted(pfac)
sse &lt;- sumsq(mapply("-", Xmat, Xhat))
sse / (sum(nk) * mydim[2] * mydim[3])
crossprod(pfac$A[[1]])
crossprod(pfac$A[[2]])
pfac$Phi


## Not run: 

##########   parallel computation   ##########

# create random data list with Parafac2 structure
set.seed(3)
mydim &lt;- c(NA, 10, 20)
nf &lt;- 2
nk &lt;- rep(c(50, 100, 200), length.out = mydim[3])
Gmat &lt;- matrix(rnorm(nf^2), nrow = nf, ncol = nf)
Bmat &lt;- matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf)
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Xmat &lt;- Emat &lt;- Hmat &lt;- vector("list", mydim[3])
for(k in 1:mydim[3]){
  Hmat[[k]] &lt;- svd(matrix(rnorm(nk[k] * nf), nrow = nk[k], ncol = nf), nv = 0)$u
  Xmat[[k]] &lt;- tcrossprod(Hmat[[k]] %*% Gmat %*% diag(Cmat[k,]), Bmat)
  Emat[[k]] &lt;- matrix(rnorm(nk[k] * mydim[2]), nrow = nk[k], mydim[2])
}
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- mapply("+", Xmat, Emat)

# fit Parafac2 model (10 random starts -- sequential computation)
set.seed(1)
system.time({pfac &lt;- parafac2(X, nfac = nf)})
pfac

# fit Parafac2 model (10 random starts -- parallel computation)
cl &lt;- makeCluster(detectCores())
ce &lt;- clusterEvalQ(cl, library(multiway))
clusterSetRNGStream(cl, 1)
system.time({pfac &lt;- parafac2(X, nfac = nf, parallel = TRUE, cl = cl)})
pfac
stopCluster(cl)

## End(Not run)

</code></pre>


</div>