<div class="container">

<table style="width: 100%;"><tr>
<td>cpd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
N-way Canonical Polyadic Decomposition
</h2>

<h3>Description</h3>

<p>Fits Frank L. Hitchcock's Canonical Polyadic Decomposition (CPD) to N-way data arrays. Parameters are estimated via alternating least squares.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cpd(X, nfac, nstart = 10, maxit = 500, 
    ctol = 1e-4, parallel = FALSE, cl = NULL, 
    output = "best", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>N-way data array. Missing data are allowed (see Note).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfac</code></td>
<td>

<p>Number of factors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>

<p>Number of random starts.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctol</code></td>
<td>

<p>Convergence tolerance (R^2 change).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>

<p>Logical indicating if <code>parLapply</code> should be used. See Examples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>

<p>Cluster created by <code>makeCluster</code>. Only used when <code>parallel=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>

<p>Output the best solution (default) or output all <code>nstart</code> solutions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>If <code>TRUE</code>, fitting progress is printed via <code>txtProgressBar</code>. Ignored if <code>parallel=TRUE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is an N-way extension of the <code>parafac</code> function without constraints. The form of the CPD for 3-way and 4-way data is given in the documentation for the <code>parafac</code> function. For N &gt; 4, the CPD has the form
</p>

<table><tr>
<td style="text-align: center;">
<code> X[i.1, ..., i.N] = sum A.1[i.1,r] * ... * A.N[i.N,r] + E[i.1, ..., i.N] </code>
</td>
</tr></table>
<p>where <code>A.n</code> are the n-th mode's weights for n = 1, ..., N, and <code>E</code> is the N-way residual array. The summation is for <code>r = seq(1,R)</code>.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>List of length N containing the weights for each mode.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SSE</code></td>
<td>
<p>Sum of Squared Errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rsq</code></td>
<td>
<p>R-squared value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GCV</code></td>
<td>
<p>Generalized Cross-Validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edf</code></td>
<td>
<p>Effective degrees of freedom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cflag</code></td>
<td>
<p>Convergence flag. See Note.</p>
</td>
</tr>
</table>
<h3>Warnings </h3>

<p>The algorithm can perform poorly if the number of factors <code>nfac</code> is set too large.
</p>


<h3>Note</h3>

<p>Missing data should be specified as <code>NA</code> values in the input <code>X</code>. The missing data are randomly initialized and then iteratively imputed as a part of the algorithm.
</p>
<p>Output <code>cflag</code> gives convergence information: <code>cflag = 0</code> if algorithm converged normally and <code>cflag = 1</code> if maximum iteration limit was reached before convergence.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Harshman, R. A. (1970). Foundations of the PARAFAC procedure: Models and conditions for an "explanatory" multimodal factor analysis. <em>UCLA Working Papers in Phonetics, 16</em>, 1-84.
</p>
<p>Harshman, R. A., &amp; Lundy, M. E. (1994). PARAFAC: Parallel factor analysis. <em>Computational Statistics and Data Analysis, 18</em>, 39-72.
</p>
<p>Hitchcock, F. L. (1927). The expression of a tensor or a polyadic as a sum of products. <em>Journal of Mathematics and Physics, 6</em>, 164-189.
</p>


<h3>See Also</h3>

<p>The <code>parafac</code> function provides a more flexible implemention for 3-way and 4-way arrays.
</p>
<p>The <code>fitted.cpd</code> function creates the model-implied fitted values from a fit <code>"cpd"</code> object.
</p>
<p>The <code>resign.cpd</code> function can be used to resign factors from a fit <code>"cpd"</code> object.
</p>
<p>The <code>rescale.cpd</code> function can be used to rescale factors from a fit <code>"cpd"</code> object.
</p>
<p>The <code>reorder.cpd</code> function can be used to reorder factors from a fit <code>"cpd"</code> object.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##########   3-way example   ##########

# create random data array with CPD/Parafac structure
set.seed(3)
mydim &lt;- c(50, 20, 5)
nf &lt;- 3
Amat &lt;- matrix(rnorm(mydim[1]*nf), nrow = mydim[1], ncol = nf)
Bmat &lt;- matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf)
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Xmat &lt;- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + Emat

# fit CPD model
set.seed(0)
cano &lt;- cpd(X, nfac = nf, nstart = 1)
cano

# fit Parafac model
set.seed(0)
pfac &lt;- parafac(X, nfac = nf, nstart = 1)
pfac


##########   4-way example   ##########

# create random data array with CPD/Parafac structure
set.seed(4)
mydim &lt;- c(30,10,8,10)
nf &lt;- 4
aseq &lt;- seq(-3, 3, length.out = mydim[1])
Amat &lt;- cbind(dnorm(aseq), dchisq(aseq+3.1, df=3),
              dt(aseq-2, df=4), dgamma(aseq+3.1, shape=3, rate=1))
Bmat &lt;- svd(matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf), nv = 0)$u
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Cstruc &lt;- Cmat &gt; 0.5
Cmat &lt;- Cmat * Cstruc
Dmat &lt;- matrix(runif(mydim[4]*nf), nrow = mydim[4], ncol = nf)
Xmat &lt;- tcrossprod(Amat, krprod(Dmat, krprod(Cmat, Bmat)))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + Emat

# fit CPD model
set.seed(0)
cano &lt;- cpd(X, nfac = nf, nstart = 1)
cano

# fit Parafac model
set.seed(0)
pfac &lt;- parafac(X, nfac = nf, nstart = 1)
pfac


##########   5-way example   ##########

# create random data array with CPD/Parafac structure
set.seed(5)
mydim &lt;- c(5, 6, 7, 8, 9)
nmode &lt;- length(mydim)
nf &lt;- 3
Amat &lt;- vector("list", nmode)
for(n in 1:nmode) {
  Amat[[n]] &lt;- matrix(rnorm(mydim[n] * nf), mydim[n], nf)
}
Zmat &lt;- krprod(Amat[[3]], Amat[[2]])
for(n in 4:5) Zmat &lt;- krprod(Amat[[n]], Zmat)
Xmat &lt;- tcrossprod(Amat[[1]], Zmat)
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + Emat

# fit CPD model
set.seed(0)
cano &lt;- cpd(X, nfac = nf, nstart = 1)
cano


</code></pre>


</div>