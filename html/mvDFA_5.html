<div class="container">

<table style="width: 100%;"><tr>
<td>simulate_cMTS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximate correlated time series with given Hurst Exponent</h2>

<h3>Description</h3>

<p>Approximation of correlated time series with given "Hurst" exponents. Internally <code>longmemo::simFGN0</code> or <code>longmemo::simFGN.fft</code> are used which simulate Gaussian series by generating fractional ARIMA(0,h,0) models (with $h=H-1/2$, <code>longmemo::FGN0</code>), or fractional Gaussian noise <code>longmemo::FGN.fft</code>. We cautiously note that we use empirical scaling (i.e., the variances are scaled to be 1 in the sample not the population), hence the between sample variance may be underrepresented. We further note that the covariance estimates for correlated time series (not using increments) is unstable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simulate_cMTS(
  N,
  H,
  Sigma,
  simulation_process = "FGN0",
  decomposition = "chol",
  cor_increments = TRUE,
  X0 = rep(0, ncol(Sigma))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Length of Times Series</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>Hurst Exponents for <code>d</code> time series. These are then mixed using one of two different decompositions of the given covariance matrix <code>Sigma</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>Positive semi definite covariance matrix of desired multi-dimensional time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simulation_process</code></td>
<td>
<p>The simulation process passed to the <code>longmemo::sim...</code> function. Can either be <code>longmemo::simFGN.fft</code> (using FFT) or <code>longmemo::simFGN0</code> (using fractional gaussian processes). FGN0 looks more like <code>rnorm</code>, when <code>H=0.5</code>. <code>DEFAULT</code> to <code>"FGN0"</code>. Use <code>simulation_process="FGN.fft"</code> to use the FFT based version.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decomposition</code></td>
<td>
<p>Character whether the Cholesky decomposition <code>"chol"</code> (or <code>"cholesky"</code>) should be used or whether the eigen decomposition should be used (<code>decomposition = "eigen"</code>). <code>DEFAULT</code> to <code>"chol"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor_increments</code></td>
<td>
<p>Logical, whether to correlate the increments or the time series themselves. Default to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X0</code></td>
<td>
<p>Starting values for the time series if increments are correlated. Default to <code>rep(0, ncol(Sigma))</code>, i.e., the zero vector of required length.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a multivariate correlated time series with covariance matrix <code>Sigma</code>. The Hurst exponents are only approximating the univariate ones, since they result from mixed time series. Uncorrelated time series keep their univariate Hurst exponents <code>H</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">Sigma &lt;- matrix(.5, 3, 3); diag(Sigma) &lt;- c(1,2,3)
data &lt;- simulate_cMTS(N = 10^5, Sigma = Sigma, H = c(.2, .5, .7),
                      cor_increments = TRUE)
cov(data)
cov(apply(data,2,diff))
</code></pre>


</div>