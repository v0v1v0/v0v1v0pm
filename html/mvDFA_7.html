<div class="container">

<table style="width: 100%;"><tr>
<td>simulate_MTS_mixed_white_pink_brown</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximate correlated time series from white, pink and brown noise from independent realization of normal variables</h2>

<h3>Description</h3>

<p>Approximation of correlated time series representing "white", "pink" or "brown" noise from independent realization of normal variates Internally normal variables are simulated using <code>rnorm</code> and then are cumulated for white or brown noise and we use <code>RobPer::TK95</code> for the generation of pink noise. We cautiously note that we use empirical scaling (i.e., the variances are scaled to be 1 in the sample not the population), hence the between sample variance may be underrepresented. We further note that the covariance estimates for correlated time series (not using increments) is unstable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simulate_MTS_mixed_white_pink_brown(
  N,
  Sigma,
  process = "white",
  decomposition = "chol",
  cor_increments = TRUE,
  X0 = rep(0, ncol(Sigma))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Length of multivariate Times Series</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>Positive semi definite covariance matrix the increments of desired multi dimensional time series. The dimensionality of Sigma sets the dimension of the time series. The variance scale the time. If the variances are all 1, then each data point represents one unit of time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>process</code></td>
<td>
<p>Type of process. Can either be "white", "brown" or "pink". Default to "white". If process is a vector, a mixture of the three process is generated, correlated by Sigma.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decomposition</code></td>
<td>
<p>Character whether the Cholesky decomposition <code>"chol"</code> (or <code>"cholesky"</code>) should be used or whether the eigen decomposition should be used (<code>decomposition = "eigen"</code>). <code>DEFAULT</code> to <code>"chol"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor_increments</code></td>
<td>
<p>Logical, whether to correlate the increments or the time series themselves. Default to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X0</code></td>
<td>
<p>Starting values for the time series if increments are correlated. Default to <code>rep(0, ncol(Sigma))</code>, i.e., the zero vector of required length.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a multivariate correlated time series with covariance matrix 'Sigma'. The Hurst exponents are only approximating the univariate ones, since they result from mixed time series. Here, a mixture of "white", "pink" and "brown" noise can be chosen from. Uncorrelated time series keep their univariate Hurst exponent 'H'.
</p>


<h3>Examples</h3>

<pre><code class="language-R">Sigma &lt;- matrix(.5, 3, 3); diag(Sigma) &lt;- c(1,2,3)
data &lt;- simulate_MTS_mixed_white_pink_brown(N = 10^5, Sigma = Sigma,
                                            process = c("white", "pink", "brown"),
                                            cor_increments = FALSE)
cov(data) # unstable covariances
cov(apply(data,2,diff))
</code></pre>


</div>