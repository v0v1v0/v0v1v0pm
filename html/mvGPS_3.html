<div class="container">

<table style="width: 100%;"><tr>
<td>gen_D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate Bivariate Multivariate Exposure</h2>

<h3>Description</h3>

<p>Generate exposure from a bivariate normal distribution confounded by a set of
variables <code>C</code>=\(C1, C2).
</p>


<h3>Usage</h3>

<pre><code class="language-R">gen_D(
  method,
  n,
  rho_cond,
  s_d1_cond,
  s_d2_cond,
  k,
  C_mu,
  C_cov,
  C_var,
  C_sigma = NULL,
  d1_beta,
  d2_beta,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character value identifying which method to use when generating
bivariate exposure. Options include "matrix_normal", "uni_cond", and "vector_normal".
See details for a brief explanation of each method. <code>uni_cond</code> is fastest</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer value total number of units</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho_cond</code></td>
<td>
<p>scalar value identifying conditional correlation of exposures given covariates between \[0, 1\]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s_d1_cond</code></td>
<td>
<p>scalar value for conditional standard deviation of <code>D1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s_d2_cond</code></td>
<td>
<p>scalar value for conditional standard deviation of <code>D2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer value determining number of covariates to generate in <code>C</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C_mu</code></td>
<td>
<p>numeric vector of mean values for covariates. Must be same length as <code>k</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C_cov</code></td>
<td>
<p>scalar value representing constant correlation between covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C_var</code></td>
<td>
<p>scalar value representing constant variance of covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C_sigma</code></td>
<td>
<p>numeric matrix representing the covariance matrix of covariates.
Default is NULL and will use <code>C_var</code> and <code>C_var</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d1_beta</code></td>
<td>
<p>numeric vector of length <code>k</code> defining the mean of <code>D1</code> with respect to the covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d2_beta</code></td>
<td>
<p>numeric vector of length <code>k</code> defining the mean of <code>D2</code> with respect to the covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>integer value setting the seed of random generator to produce repeatable results. set to NULL by default</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Generating Confounders</h4>

<p>We assume that there are a total of <code>k</code> confounders that are generated
from a multivariate normal distribution with equicorrelation covariance, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_{C}=\phi(\mathbf{1}\mathbf{1}^{T}-\mathbf{I})+\mathbf{I}\sigma^{2}_{C},</code>
</p>

<p>where <code class="reqn">\mathbf{1}</code> is the column vector with all entries equal to 1,
<code class="reqn">\mathbf{I}</code> is the identity matrix, <code class="reqn">\sigma^{2}_{C}</code> is a constant
standard deviation for all confounders, and <code class="reqn">\phi</code> is the covariance of
any two confounders. Therefore, our random confounders
<code>C</code> follow the distribution
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{C}\sim N_{k}(\boldsymbol{\mu}_{C}, \Sigma_{C}).</code>
</p>

<p>We draw a total of <code>n</code> samples from this multivariate normal distribution
using <code>mvrnorm</code>.
</p>



<h4>Generating Bivariate Exposure</h4>

<p>The first step when generating the bivariate exposure is to specify the
effects of the confounders <code>C</code>. We control this for each exposure value
using the arguments <code>d1_beta</code> and <code>d2_beta</code> such that
</p>
<p style="text-align: center;"><code class="reqn">E[D_{1}\mid \mathbf{C}]=\boldsymbol{\beta}^{T}_{D1}\mathbf{C}</code>
</p>
<p> and
</p>
<p style="text-align: center;"><code class="reqn">E[D_{2}\mid \mathbf{C}]=\boldsymbol{\beta}^{T}_{D2}\mathbf{C}</code>
</p>
<p>.
</p>
<p>Note that by specifying <code>d1_beta</code> and <code>d2_beta</code> separately that the
user can control the amount of overlap in the confounders for each exposure,
and how many of the variables in <code>C</code> are truly related to the exposures.
For instance to have the exposure have identical confounding effects
<code>d1_beta</code>=<code>d2_beta</code>, and they have separate confounding if there are
zero non-zero elements in common between <code>d1_beta</code> and <code>d2_beta</code>.
</p>
<p>To generate the bivariate conditional distribution of exposures given the set
of confounders <code>C</code> we have the following three methods:
</p>

<ul>
<li>
<p> "matrix_normal"
</p>
</li>
<li>
<p> "uni_cond"
</p>
</li>
<li>
<p> "vector_normal"
</p>
</li>
</ul>
<p>"matrix_normal" uses the function <code>rmatnorm</code> to
generate all <code>n</code> samples as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{D}\mid\mathbf{C}\sim N_{n \times 2}(\boldsymbol{\beta}\mathbf{C}, \mathbf{I}_{n}, \Omega)</code>
</p>

<p>where <code class="reqn">\boldsymbol{\beta}</code> is a column vector containing <code class="reqn">\boldsymbol{\beta}^{T}_{D1}</code>
and <code class="reqn">\boldsymbol{\beta}^{T}_{D2}</code>, and <code class="reqn">\Omega</code> is the conditional covariance matrix.
</p>
<p>"vector_normal" simply vectorizes the matrix_normal method above to generate
a vector of length <code class="reqn">n \times 2</code>.
</p>
<p>"uni_cond" specifies the bivariate exposure using univariate conditional
factorization, which in the case of bivariate normal results in two univariate
normal expressions.
</p>
<p>In general, we suggest using the univariate conditional, "uni_cond", method
when generating exposures as it is substantially faster than both the
matrix normal and vector normal approaches.
</p>
<p>Note that the options use regular expression matching and can be specified
uniquely using either "m", "u", or "v".
</p>



<h4>Marginal Covariance of Exposures</h4>

<p>As described above the exposures are drawn conditional on the set <code>C</code>,
so the marginal covariance of exposures is defined as
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_{D}= \boldsymbol{\beta}\Sigma_{C}\boldsymbol{\beta}^{T}+\Omega.</code>
</p>

<p>In our function we return the true marginal covariance <code class="reqn">\Sigma_{D}</code> as well
as the true marginal correlation <code class="reqn">\rho_{D}</code>.
</p>



<h3>Value</h3>


<ul>
<li> <p><code>D</code>: nx2 numeric matrix of the sample values for the exposures given the set <code>C</code>
</p>
</li>
<li> <p><code>C</code>: nxk numeric matrix of the sampled values for the confounding set <code>C</code>
</p>
</li>
<li> <p><code>D_Sigma</code>: 2x2 numeric matrix of the true marginal covariance of exposures
</p>
</li>
<li> <p><code>rho</code>: numeric scalar representing the true marginal correlation of exposures
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">#generate bivariate exposures. D1 confounded by C1 and C2. D2 by C2 and C3
#uses univariate conditional normal to draw samples
sim_dt &lt;- gen_D(method="u", n=200, rho_cond=0.2, s_d1_cond=2, s_d2_cond=2, k=3,
C_mu=rep(0, 3), C_cov=0.1, C_var=1, d1_beta=c(0.5, 1, 0), d2_beta=c(0, 0.3, 0.75), seed=06112020)
D &lt;- sim_dt$D
C &lt;- sim_dt$C

#observed correlation should be close to true marginal value
cor(D); sim_dt$rho


#Use vector normal method instead of univariate method to draw samples
sim_dt &lt;- gen_D(method="v", n=200, rho_cond=0.2, s_d1_cond=2, s_d2_cond=2, k=3,
C_mu=rep(0, 3), C_cov=0.1, C_var=1, d1_beta=c(0.5, 1, 0), d2_beta=c(0, 0.3, 0.75), seed=06112020)

</code></pre>


</div>