<div class="container">

<table style="width: 100%;"><tr>
<td>mvOU</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Multivariate Ornstein-Uhlenbeck model of continuous traits evolution

</h2>

<h3>Description</h3>

<p>This function allows the fitting of a multivariate Ornstein-Uhlenbeck (OU1) model with possibly multiple optima (OUM) for different "selective regimes". A "phylo" object with SIMMAP-like mapping of ancestral states is required to subdivise the tree (or branches) into "selective regimes".
Species measurement errors or dispersions can also be included in the model.

</p>


<h3>Usage</h3>

<pre><code class="language-R">mvOU(tree, data, error = NULL, model = c("OUM", "OU1"), param = list(sigma = NULL,
    alpha = NULL, vcv = "fixedRoot", decomp = c("cholesky","spherical","eigen","qr",
    "diagonal","upper","lower")), method = c("rpf", "sparse", "inverse",
    "pseudoinverse", "univarpf"), scale.height = FALSE, optimization = c("L-BFGS-B",
    "Nelder-Mead", "subplex"), control = list(maxit = 20000), precalc = NULL, 
    diagnostic = TRUE, echo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>

<p>Phylogenetic tree with mapped ancestral states in phytools' SIMMAP format for "OUM" model.
(See make.simmap, paintBranches, paintSubTree, and make.era.map functions from the phytools package). A "phylo" object can be used with model "OU1".

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Matrix or data frame with species in rows and continuous traits in columns. NA values are allowed with the "rpf", "inverse", and "pseudoinverse" methods.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error</code></td>
<td>

<p>Matrix or data frame with species in rows and continuous trait sampling variance (squared standard errors) in columns.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>Choose between "OUM" for a multiple selective regime model, or "OU1" for a unique selective regime for the whole tree.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>

<p>List of arguments to be passed to the function. See details below.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>Choose between "rpf", "sparse", "inverse", "pseudoinverse", or "univarpf" for computing the log-likelihood during the fitting process. See details below.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.height</code></td>
<td>

<p>Whether the tree should be scaled to unit length or not.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimization</code></td>
<td>

<p>Methods used by the optimization routines (see ?optim and ?subplex for details). The "fixed" method returns the log-likelihood function only.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>Max. bound for the number of iteration of the optimizer; other options can be fixed in the list. (See ?optim or ?subplex for details).

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precalc</code></td>
<td>

<p>Optional. Precalculation of fixed parameters. See ?mvmorph.Precalc for details.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnostic</code></td>
<td>

<p>Whether the convergence diagnostics should be returned or not.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>echo</code></td>
<td>

<p>Whether the results must be returned or not.

</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The mvOU function fits a multivariate model of evolution according to an Ornstein-Uhlenbeck process:
</p>
<p style="text-align: center;"><code class="reqn">dX(t) = A(\Theta - X(t))dt + \Sigma^{1/2}dW(t)</code>
</p>

<p>The user can incorporate measurement errors and uses SIMMAP-like mapping of ancestral states (phytools objects of class "simmap"). SIMMAP mapping allows one to assign parts of branches to different selective regimes for estimating regime-specific evolutionary optima. See the package vignette: browseVignettes("mvMORPH").
</p>
<p>Mapping of ancestral states can be done using the "make.simmap", "make.era.map" or "paintSubTree" functions from the "phytools" package.
</p>
<p>The "method" argument allows the user to try different algorithms for computing the log-likelihood. The <code>"rpf"</code>, <code>"univarpf"</code> (for univariate analysis) and <code>"sparse"</code> methods use fast GLS algorithms based on factorization to avoid explicit computation of the inverse of the variance-covariance matrix and its determinant during log-likelihood estimation. The <code>"inverse"</code> approach uses a "stable" (based on QR decomposition) explicit computation of the inverse and determinant of the matrix and is therefore slower. The <code>"pseudoinverse"</code> method uses a generalized inverse that is safer for matrix near singularity but highly time consuming. See ?mvLL for details.
</p>
<p>Arguments in the <b>"param"</b> <code>list</code> are:
</p>
<p><b>"sigma"</b> or <b>"alpha"</b> - Starting values for the likelihood search can be specified through the "alpha" and "sigma" arguments in the param list. It is also possible to test for the significance of the off-diagonal sigma (scatter) and alpha (drift) matrix in the full model by making comparison with a constrained model (using sigma="constraint", or alpha="constraint") in the "param" argument list. You can also provide starting values for the constrained model. For instance, for two traits use sigma=list("constraint", c(0.5,0.5))  (or alpha=list("constraint", c(0.5,0.5))).
</p>
<p><b>"decomp"</b> - You can further constrain the alpha matrix by specifying the decomposition of the matrix through the "decomp" argument in the "param" list. The multivariate Ornstein-Uhlenbeck model is described by the spectral decomposition of the alpha matrix. It is possible to parameterize the alpha matrix to be decomposable using various parameterizations (e.g., on its eigenvalues with different biological interpretations; Sy et al. 1997, Bartoszek et al. 2012; Clavel et al. 2015). For a symmetric matrix parameterization, the user can choose the <code>"cholesky"</code>, <code>"eigen"</code>, or <code>"spherical"</code> option. 
</p>
<p>For general square (non-symmetric) matrices the <code>"svd"</code>, <code>"qr"</code> and <code>"schur"</code> parameterizations can be used. The <code>"schur"</code> parameterization constrains the eigenvalues of the alpha matrix to be real numbers. The <code>"svd+"</code>, <code>"qr+"</code> or <code>"eigen+"</code> options force the eigenvalues to be positives by taking their logarithm. It is also possible to specify <code>"diagonal"</code> which is similar to the use of the "constraint" argument for "alpha" argument, or to use <code>"equal"</code> and <code>"equaldiagonal"</code>. Finally, one can specify that the alpha matrix is <code>"upper"</code> or <code>"lower"</code> triangular (i.e., one process affect the other unilateraly). Details can be found in the package vignette: browseVignettes("mvMORPH") and on Clavel et al. 2015.
</p>
<p><b>"decompSigma"</b> - The sigma matrix is parameterized by various methods to ensure its positive definiteness (Pinheiro and Bates, 1996). These methods can be accessed through the "decompSigma" argument and are the <code>"cholesky"</code>, <code>"eigen+"</code>, and <code>"spherical"</code> parameterization. The sigma matrix can also be forced to be diagonal using <code>"diagonal"</code> or <code>"equaldiagonal"</code> and forced to have the same variances using <code>"equal"</code>. Details can be found in the package vignette: browseVignettes("mvMORPH").
</p>
<p><b>"vcv"</b> - It is possible to specify in the "param" list what kind of variance-covariance matrix to use with the "vcv" argument, depending on how the root is treated. 
The <code>vcv="randomRoot"</code> option assumes that the value at the root is a random variable with the stationary distribution of the process. It cannot be used with the "sparse" method to speed up the computations. The <code>vcv="fixedRoot"</code> option assumes that the root is a fixed parameter. On ultrametric trees both approaches should converge on the same results when the OU process is stationary.
</p>
<p><b>"root"</b> - This argument allows the user to specify if the ancestral state at the root (theta 0) should be estimated (<code>root=TRUE</code>), or assumed to be at the oldest regime state stationary distribution (<code>root=FALSE</code>). An alternative is to follow Beaulieu et al. (2012) and explicitly drop the root state influence (<code>root="stationary"</code>). The first option should be used with non-ultrametric trees (i.e., with fossil species; e.g., Hansen 1997) where information on the ancestral state is directly available from the data. Note that estimating shifts from the ancestral state to the optimum(s) from extant species can be problematic and it can be preferable to assume each regime optimum(s) to be at the stationary distribution.
</p>
<p>For the <b>"decomp"</b> and <b>"decompSigma</b> arguments, a user-defined matrix with integer values taken as indices of the parameters to be estimated can be provided. See ?mvBM and ?mvRWTS.
</p>
<p>Note on the returned Hessian matrix in the result list (param$opt$hessian):
</p>
<p>The hessian is the matrix of second order partial derivatives of the likelihood function with respect to the maximum likelihood parameter values. This matrix provides a measure of the steepness of the likelihood surface in the vicinity of the optimum. The eigen-decomposition of the hessian matrix allows assessing the reliability of the model fit (even if the optimizer has converged).
When the optimization function does not converge on a stable result, the user may consider increasing the "maxit" argument in the "control" option, or try a simpler model with fewer parameters to estimate. Changing the starting values ("alpha" and "sigma" options in the param list) as well as the optimizing method ("optimization" option) may helps sometimes (e.g., alpha=runif(3) for a two-trait analysis with random starting values - i.e., the lower triangular alpha matrix). Note that the number of starting values to provide depends on the matrix decomposition chosen for the alpha parameter (p*(p+1)/2 values for symmetric alpha matrix, but p*p values for non-symmetric ones - with p the number of traits).
</p>



<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>LogLik </code></td>
<td>
<p>The log-likelihood of the optimal model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AIC </code></td>
<td>
<p>Akaike Information Criterion for the optimal model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AICc </code></td>
<td>
<p>Sample size-corrected AIC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta </code></td>
<td>
<p>Estimated ancestral states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha </code></td>
<td>
<p>Matrix of estimated alpha values (strength of selection).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma </code></td>
<td>
<p>Evolutionary rate matrix (drift).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence </code></td>
<td>
<p>Convergence status of the optimizing function; "0" indicates convergence. (see ?optim for details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hess.values </code></td>
<td>
<p>Reliability of the likelihood estimates calculated through the eigen-decomposition of the hessian matrix. "0" means that a reliable estimate has been reached. See details above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param </code></td>
<td>
<p>List of model fit parameters (optimization, method, model, number of parameters...).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>llik </code></td>
<td>
<p>The log-likelihood function evaluated in the model fit "$llik(par, root.mle=TRUE)".</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function partly uses a modified version of the C code from the "OUCH" package built by Aaron King, as well as a C code which is part of the "ape" package by Emmanuel Paradis.  I kindly thank those authors for sharing their sources.
Note that Bartoszek et al. (2012) proposed the mvSLOUCH package also dedicated to multivariate Ornstein-Uhlenbeck processes, which allows fitting regression models with randomly evolving predictor variables.
</p>
<p>The "symmetric", "nsymmetric", "symmetricPositive", and "nsymPositive" options for the "decomp" argument are deprecated.

</p>


<h3>Author(s)</h3>

<p>Julien Clavel

</p>


<h3>References</h3>

<p>Bartoszek K., Pienaar J., Mostad P., Andersson S., Hansen T.F. 2012. A phylogenetic comparative method for studying multivariate adaptation. J. Theor. Biol. 314:204-215.
</p>
<p>Beaulieu J.M., Jhwueng D.-C., Boettiger C., O'Meara B.C. 2012. Modeling stabilizing selection: Expanding the Ornstein-Uhlenbeck model of adaptive evolution. Evolution. 66:2369-2389.
</p>
<p>Butler M.A., King A.A. 2004. Phylogenetic comparative analysis: a modeling approach for adaptive evolution. Am. Nat. 164:683-695.
</p>
<p>Clavel J., Escarguel G., Merceron G. 2015. mvMORPH: an R package for fitting multivariate evolutionary models to morphometric data. Methods Ecol. Evol. 6(11):1311-1319.
</p>
<p>Hansen T.F. 1997. Stabilizing selection and the comparative analysis of adaptation. Evolution. 51:1341-1351.
</p>
<p>Pinheiro J.C., Bates D.M. 1996. Unconstrained parameterizations for variance-covariance matrices. Stat. Comput. 6:289-296.
</p>
<p>Sy J.P., Taylor J.M.G., Cumberland W.G. 1997. A stochastic model for the analysis of bivariate longitudinal AIDS data. Biometrics. 53:542-555.

</p>


<h3>See Also</h3>

<p><code>mvMORPH</code>
<code>mvgls</code>
<code>halflife</code>
<code>stationary</code>
<code>mvBM</code>
<code>mvEB</code>
<code>mvSHIFT</code>
<code>mvOUTS</code>
<code>mvRWTS</code>
<code>mvSIM</code>
<code>LRT</code>
<code>optim</code>
<code>make.simmap</code>
<code>make.era.map</code>
<code>paintSubTree</code>

</p>


<h3>Examples</h3>

<pre><code class="language-R"># Simulated dataset
set.seed(14)
# Generating a random tree
tree&lt;-pbtree(n=50)

# Setting the regime states of tip species
sta&lt;-as.vector(c(rep("Forest",20),rep("Savannah",30))); names(sta)&lt;-tree$tip.label

# Making the simmap tree with mapped states
tree&lt;-make.simmap(tree,sta , model="ER", nsim=1)
col&lt;-c("blue","orange"); names(col)&lt;-c("Forest","Savannah")

# Plot of the phylogeny for illustration
plotSimmap(tree,col,fsize=0.6,node.numbers=FALSE,lwd=3, pts=FALSE)

# Simulate the traits
alpha&lt;-matrix(c(2,0.5,0.5,1),2)
sigma&lt;-matrix(c(0.1,0.05,0.05,0.1),2)
theta&lt;-c(2,3,1,1.3)
data&lt;-mvSIM(tree, param=list(sigma=sigma, alpha=alpha, ntraits=2, theta=theta,
            names_traits=c("head.size","mouth.size")), model="OUM", nsim=1)

## Fitting the models

# OUM - Analysis with multiple optima
 mvOU(tree, data)

# OU1 - Analysis with a unique optimum
 mvOU(tree, data, model="OU1", method="sparse")

# various options
mvOU(tree, data, model="OUM", method="sparse", scale.height=FALSE,
    param=list(decomp="svd", root="stationary"))# non-symmetric alpha
mvOU(tree, data, model="OUM", method="sparse", scale.height=FALSE,
    param=list(decomp="qr", root=TRUE)) # non-symmetric alpha
mvOU(tree, data, model="OUM", method="sparse", scale.height=FALSE,
    param=list(decomp="cholesky", root=TRUE)) # symmetric-positive
# OUCH setting
mvOU(tree, data, model="OUM", method="rpf", scale.height=FALSE,
    param=list(decomp="cholesky", root=FALSE, vcv="ouch"))

## Univariate case - FAST with RPF
 set.seed(14)
 tree&lt;-pbtree(n=500)

# Setting the regime states of tip species
 sta&lt;-as.vector(c(rep("Forest",200),rep("Savannah",300))); names(sta)&lt;-tree$tip.label

# Making the simmap tree with mapped states
 tree&lt;-make.simmap(tree,sta , model="ER", nsim=1)
 col&lt;-c("blue","orange"); names(col)&lt;-c("Forest","Savannah")

# Plot of the phylogeny for illustration
 plotSimmap(tree,col,fsize=0.6,node.numbers=FALSE,lwd=3, pts=FALSE)

# Parameters
 alpha&lt;-2.5
 sigma&lt;-0.1
 theta&lt;-c(0,2)
 data&lt;-mvSIM(tree, param=list(sigma=sigma, alpha=alpha, ntraits=1, theta=theta,
             names_traits=c("body_size")), model="OUM", nsim=1)

# Fit the model
 system.time(mvOU(tree, data, model="OUM", method="univarpf",
                param=list(root="stationary")))
 system.time(mvOU(tree, data, model="OU1", method="univarpf",
                param=list(root="stationary")))

# Add measurement error
 error=rnorm(500,sd=0.1)
 mvOU(tree, data+error, error=rep(0.1^2,500), model="OUM", method="univarpf",
    param=list(root="stationary"))

	
</code></pre>


</div>