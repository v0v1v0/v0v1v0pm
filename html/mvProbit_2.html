<div class="container">

<table style="width: 100%;"><tr>
<td>mvProbitMargEff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Expectations and Marginal Effects from Multivariate Probit Models</h2>

<h3>Description</h3>

<p><code>mvProbitExp</code> calculates expected outcomes 
from multivariate probit models.
</p>
<p><code>mvProbitMargEff</code> calculates marginal effects of the explanatory variables
on expected outcomes from multivariate probit models.
</p>
<p>The <code>margEff</code> method for objects of class <code>"mvProbit"</code>
is a wrapper function
that (for the convenience of the user)
extracts the relevant information from the estimation results
and then calls <code>mvProbitMargEff</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mvProbitExp( formula, coef, sigma = NULL, data,
   cond = FALSE, algorithm = "GHK", nGHK = 1000, random.seed = 123, ... )

mvProbitMargEff( formula, coef, sigma = NULL, vcov = NULL, data,
   cond = FALSE, algorithm = "GHK", nGHK = 1000, 
   eps = 1e-06, dummyVars = NA, addMean = FALSE, 
   returnJacobian = FALSE, random.seed = 123,
   ... )

## S3 method for class 'mvProbit'
margEff( object, data = eval( object$call$data ),
   cond = FALSE, othDepVar = NULL, dummyVars = object$dummyVars, 
   atMean = FALSE, calcVCov = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a one-sided or two-sided <code>"formula"</code>:
a symbolic description of the model
(currently, all binary outcome variables must have 
the same explanatory variables).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>a numeric vector of the model coefficients;
if argument <code>sigma</code> is not specified,
this vector must also include the correlation coefficients;
the order of elements is explained in the section “details”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>optional argument for specifying
the covariance/correlation matrix of the residuals
(must be symmetric and have ones on its diagonal);
if this argument is not specified, 
the correlation coefficients must be specified by argument <code>coef</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>an optional symmetric matrix 
specifying the variance-covariance matrix of all coefficients 
(model coefficients and correlation coefficients);
if this argument is specified,
the approximate variance covariance matrices of the marginal effects
are calculated and returned as an attribute (see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a <code>data.frame</code> containing the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond</code></td>
<td>
<p>logical value indicating 
whether (marginal effects on) conditional expectations (if <code>TRUE</code>)
or (marginal effects on) unconditional expectations (if <code>FALSE</code>, default)
should be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>algorithm for computing integrals 
of the multivariate normal distribution,
either function <code>GenzBretz()</code>, <code>Miwa()</code>, or <code>TVPACK()</code>
(see documentation of <code>pmvnorm</code>)
or character string <code>"GHK"</code> 
(see documentation of <code>ghkvec</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nGHK</code></td>
<td>
<p>numeric value specifying the number of simulation draws 
of the GHK algorithm for computing integrals 
of the multivariate normal distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>numeric, the difference between the two values 
of each (numerical) explanatory
variable that is used for the numerical differentiation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dummyVars</code></td>
<td>
<p>optional vector containing the names (character strings)
of explanatory variables
that should be treated as dummy variables (see section ‘Details’).
If <code>NA</code> (the default), dummy variables are detected automatically,
i.e. all explanatory variables
which contain only zeros and ones or only <code>TRUE</code> and <code>FALSE</code>
in the data set specified by argument <code>data</code>
are treated as dummy variables.
If <code>NULL</code>,
no variable is treated as dummy variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addMean</code></td>
<td>
<p>logical.
If <code>TRUE</code>, the mean of values of all marginal effects are added
in an additional row at the bottom of the returned data.frame.
If argument <code>returnJacobian</code> is <code>TRUE</code>,
the Jacobian of the mean marginal effects with respect to the coefficients 
is included in the returned array of the Jacobians
(in an additional slot at the end of the first dimension).
If argument <code>vcov</code> of <code>mvProbitMargEff</code> is specified 
or argument <code>calcVCov</code> of the <code>margEff</code> method is <code>TRUE</code>,
the variance covariance matrix of the mean marginal effects
is included in the returned array of the variance covariance matrices
(in an additional slot at the end of the first dimension).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnJacobian</code></td>
<td>
<p>logical.
If <code>TRUE</code>, the Jacobian of the marginal effects 
with respect to the coefficients is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.seed</code></td>
<td>
<p>an integer used to seed R's random number generator;
this is to ensure replicability 
when computing (cumulative) probabilities of the multivariate normal distribution
which is required to calculate the conditional expectations;
<code>set.seed( random.seed )</code> is called each time before
a (cumulative) probability of the multivariate normal distribution 
is computed;
defaults to 123.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>"mvProbit"</code>
(returned by <code>mvProbit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>othDepVar</code></td>
<td>
<p>optional scalar or vector for specifying
the values of the (other) dependent variables
when calculating the marginal effects on the conditional expectations.
If this argument is a scalar (zero or one), 
it is assumed that all (other) dependent variables have this value
at all observations.
If this argument is a vector (filled with zeros or ones)
with length equal to the number of dependent variables, 
it is assumed that the vector of dependent variables has these values
at all observations.
If this argument is <code>NULL</code> (the default), 
the dependent variables are assumed to have the values 
that these variables have in the data set <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>atMean</code></td>
<td>
<p>logical. 
If <code>TRUE</code>, the marginal effects are calculated
not at each observation 
but at the mean values across all observations 
of the variables in the data set specified by argument <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calcVCov</code></td>
<td>
<p>logical. 
If <code>TRUE</code>, 
the approximate variance covariance matrices of the marginal effects
are calculated and returned as an attribute (see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to <code>mvProbitExp</code> are passed
to <code>pmvnorm</code>
when calculating conditional expectations;
additional arguments of <code>mvProbitMargEff</code> are passed
to <code>mvProbitExp</code> and possibly further
to <code>pmvnorm</code>;
additional arguments of the <code>margEff</code> method are passed
to <code>mvProbitMargEff</code>
and possibly further to <code>mvProbitMargEff</code>
and <code>pmvnorm</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When calculating (marginal effects on) unconditional expectations,
the left-hand side of argument <code>formula</code> is ignored.
When calculating (marginal effects on) conditional expectations
and argument <code>formula</code> is a one-sided formula
(i.e. only the right-hand side is specified)
or argument <code>othDepOne</code> is <code>TRUE</code>,
(the marginal effects on) the conditional expectations 
are calculated based on the assumption
that all other dependent variables are one.
</p>
<p>The computation of the marginal effects
of dummy variables 
(i.e. variables specified in argument <code>dummyVars</code>)
ignores argument <code>eps</code> 
and evaluates the effect of increasing these variables from zero to one.
The marginal effects of (continuous) variables 
(i.e. variables not specified in argument <code>dummyVars</code>)
are calculated by evaluating the effect 
of increasing these variables from their actual values minus <code>0.5 * eps</code> 
to their actual values plus <code>0.5 * eps</code> (divided by <code>eps</code>).
</p>
<p>If the model has <code class="reqn">n</code> dependent variables (equations)
and <code class="reqn">k</code> explanatory variables in each equation,
the order of the model coefficients in argument <code>coef</code> must be as follows:
<code class="reqn">b_{1,1}</code>, ..., <code class="reqn">b_{1,k}</code>, 
<code class="reqn">b_{2,1}</code>, ..., <code class="reqn">b_{2,k}</code>, ...,
<code class="reqn">b_{n,1}</code>, ..., <code class="reqn">b_{n,k}</code>,
where <code class="reqn">b_{i,j}</code> is the coefficient
of the <code class="reqn">j</code>th explanatory variable in the <code class="reqn">i</code>th equation.
If argument <code>sigma</code> is not specified,
argument <code>coef</code> must additionally include following elements:
<code class="reqn">R_{1,2}</code>, <code class="reqn">R_{1,3}</code>, <code class="reqn">R_{1,4}</code>, ..., <code class="reqn">R_{1,n}</code>,
<code class="reqn">R_{2,3}</code>, <code class="reqn">R_{2,4}</code>, ..., <code class="reqn">R_{2,n}</code>, ...,
<code class="reqn">R_{n-1,n}</code>,
where <code class="reqn">R_{i,j}</code> is the correlation coefficient corresponding to
the <code class="reqn">i</code>th and <code class="reqn">j</code>th equation.
</p>
<p>If argument <code>vcov</code> of function <code>mvProbitMargEff</code> is specified
or argument <code>calcVCov</code> of the <code>margEff</code> method is <code>TRUE</code>,
the approximate variance covariance matrices of the marginal effects
are calculated at each observation by using the ‘delta method’,
where the jacobian matrix of the marginal effects 
with respect to the coefficients is obtained by numerical differentiation.
</p>
<p>The ‘state’ (or ‘seed’) of R's random number generator 
is saved at the beginning of the call to these functions
and restored at the end
so that these functions do <em>not</em> affect the generation 
of random numbers outside this function
although the random seed is set to argument <code>random.seed</code>
and the calculation of the (cumulative) multivariate normal distribution
uses random numbers.
</p>


<h3>Value</h3>

<p><code>mvProbitExp</code> returns a data frame 
containing the expectations of the dependent variables.
</p>
<p><code>mvProbitMargEff</code> and the <code>margEff</code> method return a data frame 
containing the marginal effects of the explanatory variables
on the expectations of the dependent variables.
</p>
<p>If argument <code>vcov</code> of function <code>mvProbitMargEff</code> is specified
or argument <code>calcVCov</code> of the <code>margEff</code> method is <code>TRUE</code>,
the returned data frame has an attribute <code>vcov</code>,
which is a three-dimensional array,
where the first dimension corresponds to the observation
and the latter two dimensions span the approximate variance covariance matrix
of the marginal effects calculated for each observation.
</p>
<p>If argument <code>returnJacobian</code> of function <code>mvProbitMargEff</code>
or method <code>margEff</code> is set to <code>TRUE</code>,
the returned data frame has an attribute <code>jacobian</code>,
which is a three-dimensional array
that contains the Jacobian matrices of the marginal effects 
with respect to the coefficients at each observation,
where the first dimension corresponds to the observations,
the second dimension corresponds to the marginal effects,
and the third dimension corresponds to the coefficients.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Greene, W.H. (1996): 
<em>Marginal Effects in the Bivariate Probit Model</em>,
NYU Working Paper No. EC-96-11. 
Available at <a href="https://www.ssrn.com/abstract=1293106">https://www.ssrn.com/abstract=1293106</a>.
</p>


<h3>See Also</h3>

<p><code>mvProbit</code>,
<code>mvProbitLogLik</code>,
<code>probit</code>,
<code>glm</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## generate a simulated data set
set.seed( 123 )
# number of observations
nObs &lt;- 10

# generate explanatory variables
xData &lt;- data.frame( 
   const = rep( 1, nObs ),
   x1 = as.numeric( rnorm( nObs ) &gt; 0 ),
   x2 = as.numeric( rnorm( nObs ) &gt; 0 ),
   x3 = rnorm( nObs ),
   x4 = rnorm( nObs ) )

# model coefficients
beta &lt;- c(  0.8,  1.2, -1.0,  1.4, -0.8,
           -0.6,  1.0,  0.6, -1.2, -1.6,
            0.5, -0.6, -0.7,  1.1,  1.2 )

# covariance matrix of error terms
library( miscTools )
sigma &lt;- symMatrix( c( 1, 0.2, 0.4, 1, -0.1, 1 ) )

# unconditional expectations of dependent variables
yExp &lt;- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
   sigma = sigma, data = xData )
print( yExp )

# marginal effects on unconditional expectations of dependent variables
margEffUnc &lt;- mvProbitMargEff( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
   sigma = sigma, data = xData )
print( margEffUnc )

# conditional expectations of dependent variables
# (assuming that all other dependent variables are one)
yExpCond &lt;- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = beta,
   sigma = sigma, data = xData, cond = TRUE )
print( yExpCond )

# marginal effects on conditional expectations of dependent variables
# (assuming that all other dependent variables are one)
margEffCond &lt;- mvProbitMargEff( ~ x1 + x2 + x3 + x4, coef = beta,
   sigma = sigma, data = xData, cond = TRUE )
print( margEffCond )

# conditional expectations of dependent variables
# (assuming that all other dependent variables are zero)
xData$y1 &lt;- 0
xData$y2 &lt;- 0
xData$y3 &lt;- 0
yExpCond0 &lt;- mvProbitExp( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
   coef = beta, sigma = sigma, data = xData, cond = TRUE )
print( yExpCond0 )

# marginal effects on conditional expectations of dependent variables
# (assuming that all other dependent variables are zero)
margEffCond0 &lt;- mvProbitMargEff( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
   coef = beta, sigma = sigma, data = xData, cond = TRUE )
print( margEffCond0 )
</code></pre>


</div>