<div class="container">

<table style="width: 100%;"><tr>
<td>mvProbitLogLik</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Log Likelihood Values for Multivariate Probit Models</h2>

<h3>Description</h3>

<p>Function <code>mvProbitLogLik</code> calculates log likelihood values 
of multivariate probit models.
</p>
<p>The <code>logLik</code> model returns or calculates log likelihood values 
of multivariate probit models estimated by <code>mvProbit</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mvProbitLogLik( formula, coef, sigma = NULL, data,
   algorithm = "GHK", nGHK = 1000, 
   returnGrad = oneSidedGrad, oneSidedGrad = FALSE, eps = 1e-6, 
   random.seed = 123, ... )

## S3 method for class 'mvProbit'
logLik( object, coef = NULL, data = NULL, 
   algorithm = NULL, nGHK = NULL, random.seed = NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a <code>"formula"</code>:
a symbolic description of the model
(currently, all binary outcome variables must have the same regressors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>a numeric vector of the model coefficients;
if argument <code>sigma</code> is not specified,
this vector must also include the correlation coefficients;
the order of elements is explained in the section “details”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>optional argument for specifying
the covariance/correlation matrix of the residuals
(must be symmetric and have ones on its diagonal);
if this argument is not specified, 
the correlation coefficients must be specified by argument <code>coef</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a <code>data.frame</code> containing the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>algorithm for computing integrals 
of the multivariate normal distribution,
either function <code>GenzBretz()</code>, <code>Miwa()</code>, or <code>TVPACK()</code>
(see documentation of <code>pmvnorm</code>)
or character string <code>"GHK"</code> 
(see documentation of <code>ghkvec</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nGHK</code></td>
<td>
<p>numeric value specifying the number of simulation draws 
of the GHK algorithm for computing integrals 
of the multivariate normal distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnGrad</code></td>
<td>
<p>logical. If <code>TRUE</code>, the returned object
has an attribute <code>"gradient"</code>,
which is a matrix and provides 
the gradients of the log-likelihood function
with respect to all parameters 
(<code>coef</code> and upper triangle of <code>sigma</code>)
evaluated at each observation
and obtained by (two-sided) numeric finite-difference differentiation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oneSidedGrad</code></td>
<td>
<p>logical. If <code>TRUE</code>,
attribute <code>"gradient"</code> of the returned object
is obtained by one-sided numeric finite-difference differentiation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>numeric. The step size for the numeric
finite-distance differentiation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.seed</code></td>
<td>
<p>an integer used to seed R's random number generator;
this is to ensure replicability 
when computing (cumulative) probabilities of the multivariate normal distribution
which is required to calculate the log likelihood values;
<code>set.seed( random.seed )</code> is called each time before
a (cumulative) probability of the multivariate normal distribution 
is computed;
defaults to 123.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>"mvProbit"</code>
(returned by <code>mvProbit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments are passed
to <code>pmvnorm</code>
when calculating conditional expectations.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the <code>logLik</code> method is called with <code>object</code>
as the only argument,
it returns the log-likelihood value 
found in the maximum likelihood estimation.
If any other argument is not <code>NULL</code>,
the <code>logLik</code> method calculates the log-likelihood value
by calling <code>mvProbitLogLik</code>.
All arguments that are <code>NULL</code>,
are taken from argument <code>object</code>.
</p>
<p>If the model has <code class="reqn">n</code> dependent variables (equations)
and <code class="reqn">k</code> explanatory variables in each equation,
the order of the model coefficients in argument <code>coef</code> must be as follows:
<code class="reqn">b_{1,1}</code>, ..., <code class="reqn">b_{1,k}</code>, 
<code class="reqn">b_{2,1}</code>, ..., <code class="reqn">b_{2,k}</code>, ...,
<code class="reqn">b_{n,1}</code>, ..., <code class="reqn">b_{n,k}</code>,
where <code class="reqn">b_{i,j}</code> is the coefficient
of the <code class="reqn">j</code>th explanatory variable in the <code class="reqn">i</code>th equation.
If argument <code>sigma</code> is not specified,
argument <code>coef</code> must additionally include following elements:
<code class="reqn">R_{1,2}</code>, <code class="reqn">R_{1,3}</code>, <code class="reqn">R_{1,4}</code>, ..., <code class="reqn">R_{1,n}</code>,
<code class="reqn">R_{2,3}</code>, <code class="reqn">R_{2,4}</code>, ..., <code class="reqn">R_{2,n}</code>, ...,
<code class="reqn">R_{n-1,n}</code>,
where <code class="reqn">R_{i,j}</code> is the correlation coefficient corresponding to
the <code class="reqn">i</code>th and <code class="reqn">j</code>th equation.
</p>
<p>The ‘state’ (or ‘seed’) of R's random number generator 
is saved at the beginning of the <code>mvProbitLogLik</code> function 
and restored at the end of this function 
so that this function does <em>not</em> affect the generation 
of random numbers outside this function
although the random seed is set to argument <code>random.seed</code>
and the calculation of the (cumulative) multivariate normal distribution
uses random numbers.
</p>


<h3>Value</h3>

<p><code>mvProbitLogLik</code> returns a vector 
containing the log likelihood values for each observation.
</p>
<p>If argument <code>returnGrad</code> is <code>TRUE</code>,
the vector returned by <code>mvProbitLogLik</code> 
has an attribute <code>"gradient"</code>,
which is a matrix and provides 
the gradients of the log-likelihood function
with respect to all parameters 
(<code>coef</code> and upper triangle of <code>sigma</code>)
evaluated at each observation
and obtained by numeric finite-difference differentiation.
</p>
<p>The <code>logLik</code> method returns the total log likelihood value
(sum over all observations) 
with attribute <code>df</code> equal to the number of estimated parameters
(model coefficients and correlation coefficients).
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Greene, W.H. (1996): 
<em>Marginal Effects in the Bivariate Probit Model</em>,
NYU Working Paper No. EC-96-11. 
Available at <a href="https://www.ssrn.com/abstract=1293106">https://www.ssrn.com/abstract=1293106</a>.
</p>


<h3>See Also</h3>

<p><code>mvProbit</code>,
<code>mvProbitMargEff</code>,
<code>probit</code>,
<code>glm</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## generate a simulated data set
set.seed( 123 )
# number of observations
nObs &lt;- 10

# generate explanatory variables
xMat &lt;- cbind( 
   const = rep( 1, nObs ),
   x1 = as.numeric( rnorm( nObs ) &gt; 0 ),
   x2 = as.numeric( rnorm( nObs ) &gt; 0 ),
   x3 = rnorm( nObs ),
   x4 = rnorm( nObs ) )

# model coefficients
beta &lt;- cbind( c(  0.8,  1.2, -1.0,  1.4, -0.8 ),
               c( -0.6,  1.0,  0.6, -1.2, -1.6 ),
               c(  0.5, -0.6, -0.7,  1.1,  1.2 ) )

# covariance matrix of error terms
library( miscTools )
sigma &lt;- symMatrix( c( 1, 0.2, 0.4, 1, -0.1, 1 ) )

# generate dependent variables
yMatLin &lt;- xMat %*% beta 
yMat &lt;- ( yMatLin + rmvnorm( nObs, sigma = sigma ) ) &gt; 0
colnames( yMat ) &lt;- paste( "y", 1:3, sep = "" )

# log likelihood values
myData &lt;- as.data.frame( cbind( xMat, yMat ) )
logLikVal &lt;- mvProbitLogLik( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
   coef = c( beta ), sigma = sigma, data = myData )
print( logLikVal )
</code></pre>


</div>