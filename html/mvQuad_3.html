<div class="container">

<table style="width: 100%;"><tr>
<td>createNIGrid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>creates a grid for numerical integration.</h2>

<h3>Description</h3>

<p><code>createNIGrid</code> Creates a grid for multivariate numerical integration.
The Grid can be based on different quadrature- and construction-rules.
</p>


<h3>Usage</h3>

<pre><code class="language-R">createNIGrid(dim = NULL, type = NULL, level = NULL,
  ndConstruction = "product", level.trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>number of dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>quadrature rule (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>accuracy level (typically number of grid points for the underlying 1D quadrature rule)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndConstruction</code></td>
<td>
<p>character vector which denotes the construction rule
for multidimensional grids.
</p>

<dl>
<dt><code>product</code></dt>
<dd>
<p>for product rule, returns a "full grid" (default)</p>
</dd>
<dt><code>sparse</code></dt>
<dd>
<p>for combination technique, leads to a regular "sparse grid".</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level.trans</code></td>
<td>
<p>logical variable denotes either to take the levels as number
of grid points (FALSE = default) or to transform in that manner that number of
grid points = 2^(levels-1) (TRUE). Alternatively <code>level.trans</code> can be a function, which takes (n x d)-matrix and returns
a matrix with the same dimensions (see the example; this feature is particularly useful for the 'sparse' construction rule,
to account for different importance of the dimensions).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following quadrature rules are supported (build-in).
</p>

<dl>
<dt><code>cNC1, cNC2, ..., cNC6</code></dt>
<dd>
<p>closed Newton-Cotes Formula of degree 1-6 (1=trapezoidal-rule; 2=Simpson's-rule; ...),
initial interval of integration: [0, 1]</p>
</dd>
<dt><code>oNC0, oNC1, ..., oNC3</code></dt>
<dd>
<p>open Newton-Cote Formula of degree 0-3 (0=midpoint-rule; ...),
initial interval of integration: [0, 1]</p>
</dd>
<dt><code>GLe, GKr</code></dt>
<dd>
<p>Gauss-Legendre and Gauss-Kronrod rule for an initial interval of integration: [0, 1]</p>
</dd>
<dt><code>nLe</code></dt>
<dd>
<p>nested Gauss-Legendre rule for an initial interval of integration: [0, 1] (Knut Petras (2003). Smolyak cubature of given polynomial degree with few nodes for increasing dimension. Numerische Mathematik 93, 729-753)</p>
</dd>
<dt><code>GLa</code></dt>
<dd>
<p>Gauss-Laguerre rule for an initial interval of integration: [0, INF)</p>
</dd>
<dt><code>GHe</code></dt>
<dd>
<p>Gauss-Hermite rule for an initial interval of integration: (-INF, INF)</p>
</dd>
<dt><code>nHe</code></dt>
<dd>
<p>nested Gauss-Hermite rule for an initial interval of integration: (-INF, INF) (A. Genz and B. D. Keister (1996). Fully symmetric interpolatory rules for multiple integrals over infinite regions with Gaussian weight." Journal of Computational and Applied Mathematics 71, 299-309)</p>
</dd>
<dt>
<code>GHN</code>, <code>nHN</code>
</dt>
<dd>
<p>(nested) Gauss-Hermite rule as before but weights are multiplied by the standard normal density (<code class="reqn">\hat(w)_i = w_i * \phi(x_i)</code>).</p>
</dd>
<dt><code>Leja</code></dt>
<dd>
<p>Leja-Points for an initial interval of integration: [0, 1]</p>
</dd>
</dl>
<p>The argument <code>type</code> and <code>level</code> can also be vector-value, different for each dimension (the later only for "product rule"; see examples)
</p>


<h3>Value</h3>

<p>Returns an object of class 'NIGrid'. This object is basically an environment
containing nodes and weights and a list of features for this special grid. This
grid can be used for numerical integration (via <code>quadrature</code>)
</p>


<h3>References</h3>

<p>Philip J. Davis, Philip Rabinowitz (1984): Methods of Numerical Integration
</p>
<p>F. Heiss, V. Winschel (2008): Likelihood approximation by numerical integration on sparse grids, Journal of Econometrics
</p>
<p>H.-J. Bungartz, M. Griebel (2004): Sparse grids, Acta Numerica
</p>


<h3>See Also</h3>

<p><code>rescale</code>, <code>quadrature</code>, <code>print</code>, <code>plot</code> and <code>size</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## 1D-Grid --&gt; closed Newton-Cotes Formula of degree 1 (trapeziodal-rule)
myGrid &lt;- createNIGrid(dim=1, type="cNC1", level=10)
print(myGrid)
## 2D-Grid --&gt; nested Gauss-Legendre rule
myGrid &lt;- createNIGrid(dim=2, type=c("GLe","nLe"), level=c(4, 7))
rescale(myGrid, domain = rbind(c(-1,1),c(-1,1)))
plot(myGrid)
print(myGrid)
myFun &lt;- function(x){
   1-x[,1]^2*x[,2]^2
}
quadrature(f = myFun, grid = myGrid)
## level transformation
levelTrans &lt;- function(x){
  tmp &lt;- as.matrix(x)
  tmp[, 2] &lt;- 2*tmp[ ,2]
  return(tmp)
}
nw &lt;- createNIGrid(dim=2, type="cNC1", level = 3,
   level.trans = levelTrans, ndConstruction = "sparse")
plot(nw)
</code></pre>


</div>