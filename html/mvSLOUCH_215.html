<div class="container">

<table style="width: 100%;"><tr>
<td>parametric.bootstrap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parametric bootstrap for confidence intervals</h2>

<h3>Description</h3>

<p>The function performs a parametric bootstrap for confidence
intervals for estimates of the evolutionary model. 
The user may specify what parameters are to have 
their confidence intervals returned. The user is recommended to install 
the suggested package  <span class="pkg">PCMBaseCpp</span> which significantly speeds up the 
calculations (see Details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">parametric.bootstrap(estimated.model, phyltree, 
values.to.bootstrap = NULL, regimes = NULL, 
root.regime = NULL, M.error = NULL, predictors = NULL, 
kY = NULL, numboot = 100, Atype = NULL, Syytype = NULL, 
diagA = NULL, parameter_signs = NULL, start_point_for_optim = NULL,
parscale = NULL, min_bl = 0.0003, maxiter = c(10,50,100), estimateBmethod="ML")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>estimated.model</code></td>
<td>

<p>An estimated by evolutionary model. It can be e.g. the output of <br><code>BrownianMotionModel()</code>, <code>ouchModel()</code>, <code>mvslouchModel()</code> <br>
or <code>estimate.evolutionary.model()</code>. 
In the last case the model under <code>BestModel</code> is analyzed. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The "standard" <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>. The <code>root.edge</code> field is ignored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values.to.bootstrap</code></td>
<td>

<p>A vector of parameter/composite statistic names that the user is interested in. They
are extracted from the bootstrapped elements for easy access.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regimes</code></td>
<td>

<p>A vector or list of regimes. If vector then each entry corresponds to each of <code>phyltree</code>'s
branches, i.e. to each row of <code>phyltree$edge</code>. If list then each list entry corresponds to a tip node
and is a vector for regimes on that lineage. If <code>NULL</code>, then a constant regime is assumed on
the whole tree.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root.regime</code></td>
<td>

<p>The regime at the root of the tree. If not given, then it is taken as the regime that is present
on the root's daughter lineages and is the most frequent one in the <code>regimes</code> vector. If more
than one regime has the same maximum frequency, then alphabetically first one of the maximum ones
is taken.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M.error</code></td>
<td>

<p>An optional measurement error covariance structure. The measurement errors between species are assumed 
independent. The program tries to recognize the structure of the passed matrix and accepts the following 
possibilities :
</p>

<ul>
<li>
<p>a single number that is a common measurement error for all tips and species,
</p>
</li>
<li>
<p>a m element vector with each value corresponding to a variable, measurement errors are independent
between variables and each species is assumed to have the same measurement errors,
</p>
</li>
<li>
<p>a m x m ((number of variables) x (number of variables)) matrix, all species will
have the same measurement error,
</p>
</li>
<li>
<p>a list of length n (number of species), each list element is the covariance structure 
for the appropriate (numbering according to tree) species, either a single number 
(each variable has same variance), vector (of length m for each variable), or m x m matrix,
the order of the list has to correspond to the order of the nodes in the <code>phyltree</code> object,
</p>
</li>
<li>
<p>NULL no measurement error.
</p>
</li>
</ul>
<p>From version 2.0.0 of mvSLOUCH it is impossible to pass a single joint measurement error matrix 
for all the species and traits. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictors</code></td>
<td>

<p>A vector giving the numbers of the columns from the original data
which are to be considered predictor ones, <em>i.e.</em> conditioned
on in the program output. If not provided then the "X" variables 
are treated as predictors, but this only for the OUBM models (for the others in this case 
none are treated as predictors).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kY</code></td>
<td>

<p>Number of "Y" (response) variables, for the OUBM models. 
The first <code>kY</code>
columns of <code>mY</code> are the "OU" ones, while the rest the "BM" ones.
In more detail this value determines the number of columns of the (simulated) data matrix to treat as response variables ("OU" ones). For example, a 
value of 1 means that only the first column is treated as a response variable, while a value of 3 means the first three 
columns are treated as response variables. Any predictor variables ("BM" ones) the user is interested in setting for a particular model 
should therefore be placed in the final columns of the data matrix, allowing for selecting select <code>kY</code> columns before 
this as response variables ("OU" ones).
If <code>NULL</code> then
it is extracted from the provided model parameters in <code>estimated.model</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numboot</code></td>
<td>

<p>The number of bootstraps to perform.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Atype</code></td>
<td>

<p>The class of the <code>A</code> matrix. It can take one of the following values: 
<br><code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>,
<code>"UpperTri"</code>, <code>"LowerTri"</code>, <br><code>"SymmetricPositiveDefinite"</code>,
<code>"Symmetric"</code>, <code>"DecomposablePositive"</code>, <br><code>"DecomposableNegative"</code>, 
<code>"DecomposableReal"</code>, <code>"Invertible"</code>, <code>"Any"</code>. If <code>NULL</code> then
it is extracted from the provided model parameters in <code>estimated.model</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Syytype</code></td>
<td>

<p>The class of the Syy matrix, ignored if <code>evolmodel</code> equals 
<code>"BM"</code>. Otherwise it can take one of the following values: 
<code>"SingleValueDiagonal"</code>, <code>"Diagonal"</code>,
<code>"UpperTri"</code>, <code>"LowerTri"</code>,  <code>"Symmetric"</code>, <code>"Any"</code>. 
If <code>NULL</code> then it is extracted from the provided model parameters 
in <code>estimated.model</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagA</code></td>
<td>

<p>Should the diagonal of <code>A</code> be forced to be positive (<code>"Positive"</code>), <br>
negative (<code>"Negative"</code>) or the sign free to vary (<code>NULL</code>). 
However, setting this to
a non-<code>NULL</code> value when <code>evolmodel</code> is <code>"mvslouch"</code> might be 
(but simulations concerning this are not conclusive) slightly detrimental to the optimization process 
if <code>Atype</code> is <code>"DecomposablePositive"</code>, <code>"DecomposableNegative"</code>, or
<code>"DecomposableReal"</code>. In these cases <code>A</code> is parametrized by its eigendecomposition.
Additional exponentiation of the diagonal, to ensure positivity, could (but this is uncertain)
make the exploration of the likelihood surface more difficult. 
In the case of <code>Atype</code> being <code>"SymmetricPositiveDefinite"</code>,
the diagonal is always guaranteed to be positive.
If <code>NULL</code> then the function checks if it is not in the provided model parameters 
in <code>estimated.model</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter_signs</code></td>
<td>

<p>WARNING: ONLY use this option if you understand what you are doing! This option
is still in an experimental stage so some setups might not work (please report).
A list allowing the user to control whether specific entries for each model parameter
should be positive, negative, zero or set to a specific (other) value.  The entries
of the list have to be named, the admissible names are <code>"signsA"</code> (for <code>A</code>
matrix), <code>"signsB"</code> (for <code>B</code> matrix), <code>"signsSyy"</code> (for <code>Syy</code>
matrix) and <code>"signsmPsi"</code> (for <code>mPsi</code> matrix) and <code>"signsvY0"</code> (for <code>vY0</code>
matrix). Any other entry in this list will be ignored. Each entry of the list has to
be a matrix of appropriate size, i.e. of the size of the parameter to which it corresponds.
Inside this matrix the possible values are <code>"+"</code> if the given entry is to be positive,
<code>"-"</code> if the given entry is to be negative, <code>x</code>, where <code>x</code> is a number,
if the entry is to be set to specified value or <code>NA</code> if the entry is to be freely 
estimated. See <code>estimate.evolutionary.model</code>, <code>ouchModel</code> and <code>mvslouchModel</code>
for further details, examples and important warnings!
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_point_for_optim</code></td>
<td>

<p>A named list with starting parameters for of the parameters for be optimized by <code>optim()</code>, currently 
only <code>A</code> and <code>Syy</code> for OUOU and OUBM models, i.e. will not work with BM model. 
One may provide both or only one of them.
Make sure that the parameter is consistent with the other parameter restrictions as no check is done and this 
can result in undefined behaviour. For example one may provide this as (provided dimensions and other
parameter restrictions agree) 
</p>
<pre>start_point_for_optim=list(A=rbind(c(2,0),(0,4)), 
Syy=rbind(c(1,0.5),c(0,2))).</pre>
<p>This starting point is always jittered in each bootstrap replicate as the employed
<code>"Nelder-Mead"</code> method in <code>optim()</code> is deterministic.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parscale</code></td>
<td>

<p>A vector to calculate the <code>parscale</code> argument for <code>optim</code>. It is a named
vector with 3 entries, e.g. <br><code>c("parscale_A"=3,"logparscale_A"=5,"logparscale_other"=1)</code>.
The entry <code>parscale_A</code> is the scale for entries of the <code>A</code> matrix,
<code>logparscale_A</code> is the scale for entries of the <code>A</code> matrix that are 
optimized over on the logarithmic scale, e.g. if eigenvalues are assumed to be positive,
then optimization is done over <code>log(eigenvalue)</code> for <code>A</code>'s eigendecomposition
and <code>logparscale_other</code> is the scale for entries other then of <code>A</code>
that are done on the logarithmic scale (e.g. <code>Syy</code>'s diagonal, or other entries
indicated as positive via <code>parameter_signs</code>). If not provided (or if a name of the vector
is misspelled), then made equal  to the example value provided above.  For other elements, then 
mentioned above, that are optimized over by <code>optim()</code>, <code>1</code> is used for <code>optim()</code>'s 
<code>parscale</code>. It is advised that  the user experiments with a couple of different values and 
reads <code>optim</code>'s  man page.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_bl</code></td>
<td>
<p>Value to which <span class="pkg">PCMBase</span>'s <code>PCMBase.Threshold.Skip.Singular</code> should be set.
It indicates that branches of length shorter than <code>min_bl</code> should be skipped in likelihood
calculations. Short branches can result in singular covariance matrices for the transition
density along a branch. The user should adjust this value if a lot of warnings are raised by
<span class="pkg">PCMBase</span>  about singularities during the likelihood calculations.
Furthermore, <span class="pkg">mvSLOUCH</span> sets all branches in the tree shorter than <code>min_bl</code> to <code>min_bl</code>.
However, this does not concern tip branches-these cannot be skipped and hence should be long
enough so that numerical issues are not raised.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>The maximum number of iterations for different components of the estimation
algorithm. A vector of three integers. The first is the number of iterations for phylogenetic
GLS evaluations, i.e. conditional on the other parameters, the regime optima, perhaps <code>B</code>, and perhaps
initial state are estimated by a phylogenetic GLS procedure. After this the other (except of <code>B</code> 
in OUBM model case) parameters are optimized over by <code>optim()</code>. This first
entry controls the number of iterations of this procedure.   The second is the number of iterations inside
the iterated GLS for the OUBM model. In the first step regime optima and <code>B</code> (and perhaps initial state) 
are estimated conditional on the other parameters and current estimate of <code>B</code>, then the estimate of <code>B</code>
is update and the same phylogenetic GLS is repeated (second entry of <code>maxiter</code> number of times).  
Finally, the third is the value of <code>maxiter</code>  passed to <code>optim()</code>, apart from the optimization 
in the Brownian motion and measurement error case. If the bootstrapped model is a Brownian motion one,
then this parameter is ignored, if OUOU, then the second entry is ignored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimateBmethod</code></td>
<td>
<p>Only relevant for OUBM models, should <code>B</code> be estimated by maximum likelihood (default 
value <code>"ML"</code>) or generalized least squares (value <code>"GLS"</code>).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The likelihood calculations are done by the <span class="pkg">PCMBase</span> package. However, there is a
C++ backend, <span class="pkg">PCMBaseCpp</span>. If it is not available, then the likelihood is calculated
slower using pure R. However, with the calculations in C++ up to a 100-fold increase in
speed is possible (more realistically 10-20 times). The <span class="pkg">PCMBaseCpp</span> package is available
from <a href="https://github.com/venelin/PCMBaseCpp">https://github.com/venelin/PCMBaseCpp</a>.
</p>
<p>The setting <code>Atype="Any"</code> means that one assumes the matrix <code>A</code> is eigendecomposable.
If the estimation algorithm hits a defective <code>A</code>, then it sets the log-likelihood at
the minimum value and will try to get out of this dip.
</p>


<h3>Value</h3>

<p>A list with all the bootstrap simulations is returned. The elements of the
list are the following.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>paramatric.bootstrap.estimation.replicates </code></td>
<td>
<p>A list of length
equalling <code>numboot</code>. Each element is the result of the bootstrap
replicate - the estimation results in the format of the output
of <span class="pkg">mvSLOUCH</span> functions, with an additional field <code>data</code>, 
the simulated data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrapped.parameters </code></td>
<td>
<p>If <code>values.to.bootstrap</code> is not <code>NULL</code>
then a list of length equalling length of <code>values.to.bootstrap</code>. Each
element corresponds to the respective element of <code>values.to.bootstrap</code>
and contains a list of the bootstrapped values of this element.</p>
</td>
</tr>
</table>
<h3>Warning</h3>

<p>The estimation can take a long time and hence many bootstrap
replicates will take even more time.The code can produce (a lot of) warnings and 
errors during the search procedure, this is nothing to worry about.
</p>


<h3>Note</h3>

<p>The <span class="pkg">ouch</span> package implements a parametric bootstrap and reading about 
it could be helpful.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Butler, M.A. and A.A. King (2004) 
Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  
American Naturalist 164:683-695.
</p>


<h3>See Also</h3>

<p><code>BrownianMotionModel</code>, <code>estimate.evolutionary.model</code>,
<code>mvslouchModel</code>, <code>ouchModel</code>, <code>bootstrap</code>,
<code>optim</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">RNGversion(min(as.character(getRversion()),"3.6.1"))
set.seed(12345, kind = "Mersenne-Twister", normal.kind = "Inversion")
### We will first simulate a small phylogenetic tree using functions from ape. 
### For simulating the tree one could also use alternative functions, e.g. sim.bd.taxa 
### from the TreeSim package
phyltree&lt;-ape::rtree(5)

## The line below is not necessary but advisable for speed
phyltree&lt;-phyltree_paths(phyltree)

BMparameters&lt;-list(vX0=matrix(0,nrow=3,ncol=1),
Sxx=rbind(c(1,0,0),c(0.2,1,0),c(0.3,0.25,1)))

### Now simulate the data.
BMdata&lt;-simulBMProcPhylTree(phyltree,X0=BMparameters$vX0,Sigma=BMparameters$Sxx)
BMdata&lt;-BMdata[phyltree$tip.label,,drop=FALSE]

### Recover the parameters of the Brownian motion.
BMestim&lt;-BrownianMotionModel(phyltree,BMdata)

### And finally obtain bootstrap confidence intervals for some parameters
BMbootstrap&lt;-parametric.bootstrap(estimated.model=BMestim,phyltree=phyltree,
values.to.bootstrap=c("vX0","StS"),M.error=NULL,numboot=2)
RNGversion(as.character(getRversion()))

## Not run: ##It takes too long to run this
### Define a vector of regimes.
regimes&lt;-c("small","small","large","small","small","large","large","large")

### Define SDE parameters to be able to simulate data under the mvOUBM model.
OUBMparameters&lt;-list(vY0=matrix(c(1,-1),ncol=1,nrow=2),A=rbind(c(9,0),c(0,5)),
B=matrix(c(2,-2),ncol=1,nrow=2),mPsi=cbind("small"=c(1,-1),"large"=c(-1,1)),
Syy=rbind(c(1,0.25),c(0,1)),vX0=matrix(0,1,1),Sxx=matrix(1,1,1),
Syx=matrix(0,ncol=1,nrow=2),Sxy=matrix(0,ncol=2,nrow=1))

### Now simulate the data.
OUBMdata&lt;-simulMVSLOUCHProcPhylTree(phyltree,OUBMparameters,regimes,NULL)
OUBMdata&lt;-OUBMdata[phyltree$tip.label,,drop=FALSE]

### Try to recover the parameters of the mvOUBM model.
OUBMestim&lt;-mvslouchModel(phyltree,OUBMdata,2,regimes,Atype="DecomposablePositive",
Syytype="UpperTri",diagA="Positive",maxiter=c(10,50,100))

### And finally bootstrap with particular interest in the evolutionary and optimal
### regressions

OUBMbootstrap&lt;-parametric.bootstrap(estimated.model=OUBMestim,phyltree=phyltree,
values.to.bootstrap=c("evolutionary.regression","optimal.regression"),
regimes=regimes,root.regime="small",M.error=NULL,predictors=c(3),kY=2,
numboot=5,Atype="DecomposablePositive",Syytype="UpperTri",diagA="Positive",
maxiter=c(10,50,100))


### We now demonstrate an alternative setup
### Define SDE parameters to be able to simulate data under the OUOU model.
OUOUparameters&lt;-list(vY0=matrix(c(1,-1,0.5),nrow=3,ncol=1),
A=rbind(c(9,0,0),c(0,5,0),c(0,0,1)),mPsi=cbind("small"=c(1,-1,0.5),"large"=c(-1,1,0.5)),
Syy=rbind(c(1,0.25,0.3),c(0,1,0.2),c(0,0,1)))

### Now simulate the data.
OUOUdata&lt;-simulOUCHProcPhylTree(phyltree,OUOUparameters,regimes,NULL)
OUOUdata&lt;-OUOUdata[phyltree$tip.label,,drop=FALSE]

### Try to recover the parameters of the OUOU model.
estimResults&lt;-estimate.evolutionary.model(phyltree,OUOUdata,regimes=regimes,
root.regime="small",M.error=NULL,repeats=3,model.setups=NULL,predictors=c(3),kY=2,
doPrint=TRUE,pESS=NULL,maxiter=c(10,50,100))

### And finally bootstrap with particular interest in the evolutionary regression
OUOUbootstrap&lt;-parametric.bootstrap(estimated.model=estimResults,phyltree=phyltree,
values.to.bootstrap=c("evolutionary.regression"),
regimes=regimes,root.regime="small",M.error=NULL,predictors=c(3),kY=NULL,
numboot=5,Atype=NULL,Syytype=NULL,diagA=NULL)

## End(Not run)
</code></pre>


</div>