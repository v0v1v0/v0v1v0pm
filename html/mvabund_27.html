<div class="container">

<table style="width: 100%;"><tr>
<td>glm1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fits a Generalised Linear Models with a LASSO (or L1) penalty, given a value of the penalty parameter.
</h2>

<h3>Description</h3>

<p>Fits a generalised linear model with a LASSO penalty, using an iteratively reweighted local linearisation approach, given a value of the penalty parameter (lamb). Can handle negative binomial family, even with overdispersion parameter unknown, as well as other GLM families. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">glm1(y, X, lambda, family = "negative.binomial", weights = rep(1, length(y)),
     b.init = NA, phi.init = NA, phi.method = "ML", tol = c(1e-08, .Machine$double.eps),
     n.iter = 100, phi.iter = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>A vector of values for the response variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>A design matrix of p explanatory variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>The family of the response variable, see <code>family</code>. Negative binomial with unknown overdispersion can be specified as "negative.binomial", and is the default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>The penalty parameter applied to slope parameters. Different penalties can be specified for different parameters by specifying lamb as a vector, whose length is the number of columns of X. If scalar, this penalty is applied uniformly across all parameters except for the first (assuming that it is an intercept) 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>Observation weights. These might be useful if you want to fit a Poisson point process model...
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.init</code></td>
<td>

<p>Initial slope estimate. Must be a vector of the same length as the number of columns in X.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi.init</code></td>
<td>

<p>Initial estimate of the negative binomial overdispersion parameter. Must be scalar.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi.method</code></td>
<td>

<p>Method of estimating overdispersion.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>A vector of two values, specifying convergence tolerance, and the value to truncate fitted values at.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>

<p>Number of iterations to attempt before bailing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi.iter</code></td>
<td>

<p>Number of iterations estimating the negative binomial overdispersion parameter (if applicable) before returning to slope estimation. Default is one step, i.e. iterating between one-step estimates of beta and phi.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function fits a generalised linear model with a LASSO penalty, sometimes referred to as an L1 penalty or L1 norm, hence the name glm1. The model is fit using a local linearisation approach as in Osborne et al (2000), nested inside iteratively reweighted (penalised) least squares. Look it's not the fastest thing going around, try <code>glmnet</code> if you want something faster (and possibly rougher as an approximation). The main advantage of the <code>glm1</code> function is that it has been written to accept any glm family argument (although not yet tested beyond discrete data!), and also the negative binomial distribution, which is especially useful for modelling overdispersed counts.
</p>
<p>For negative binomial with unknown overdispersion use <code>"negative.binomial"</code>, or if overdispersion is to be specified, use <code>negative.binomial(theta)</code> as in the <code>MASS</code> package. Note that the output refers to phi=1/theta, i.e. the overdispersion is parameterised such that the variance is mu+phi*mu^2. Hence values of phi close to zero suggest little overdispersion, values over one suggest a lot.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>Vector of parameter estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>Vector of predicted values (on scale of the original response)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logLs</code></td>
<td>
<p>Vector of log-likelihoods at each iteration of the model.  The last entry is the log-likelihood for the final fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phis</code></td>
<td>
<p>Estimated overdispersion parameter at each iteration, for a negative binomial fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>Final estimate of the overdispersion parameter, for a negative binomial fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>Vector of score equation values for each parameter in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counter</code></td>
<td>
<p>Number of iterations until convergence. Set to Inf for a model that didn't converge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>Logical for whether the Kuhn-KArush-Tucker conditions are saitsfied.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>David I. Warton &lt;David.Warton@unsw.edu.au&gt;, Ian W. Renner and Luke Wilson.
</p>


<h3>References</h3>

<p>Osborne, M.R., Presnell, B. and Turlach, B.A. (2000) On the LASSO and its dual. Journal of Computational and Graphical Statistics, 9, 319-337.
</p>


<h3>See Also</h3>

<p><code>glm1path</code>, <code>glm1</code>, <code>glm</code>, <code>family</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(spider)
Alopacce &lt;- spider$abund[,1]
X &lt;- model.matrix(~.,data=spider$x) # to get design matrix with intercept term
#fit a LASSO-penalised negative binomial GLM, with penalty parameter 10:
ft = glm1(Alopacce,X,lambda=10)

plot(ft$logLs) # a plot of the log-likelihood, each iteration to convergence
coef(ft) # coefficients in the final model

</code></pre>


</div>