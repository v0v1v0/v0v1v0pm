<div class="container">

<table style="width: 100%;"><tr>
<td>mlocal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Macro-like functions</h2>

<h3>Description</h3>

<p><code>mlocal</code> lets you write a function whose statements are executed in its caller's frame, rather than in its own frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R"># Use only as wrapper of function body, like this:
# my.fun &lt;- function(..., nlocal=sys.parent()) mlocal( expr)
# ... should be replaced by the arguments of "my.fun"
# expr should be replaced by the code of "my.fun"
# nlocal should always be included as shown
mlocal( expr) # Don't use it like this!
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code> expr</code></td>
<td>
<p>the function code, normally a braced expression</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Sometimes it's useful to write a "child" function that can create and modify variables in its parent directly, without using <code>assign</code> or <code>&lt;&lt;-</code> (note that <code>&lt;&lt;-</code> will only work on variables that exist already). This can make for clearer, more modular programming; for example, tedious initializations of many variables can be hidden inside an <code>initialize()</code> statement. The definition of an <code>mlocal</code> function does not have to occur within its caller; the <code>mlocal</code> function can exist as a completely separate R object.
</p>
<p><code>mlocal</code> functions can have arguments just like normal functions. These arguments will temporarily hide any objects of the same name in the <code>nlocal</code> frame (i.e. the calling frame). When the <code>mlocal</code> function exits, its arguments will be deleted from the calling frame and the hidden objects (if any) will be restored. Sometimes it's desirable to avoid cluttering the calling frame with variables that only matter to the <code>mlocal</code> function. A useful convention is to "declare" such temporary variables in your function definition, as defaultless arguments after the <code>nlocal</code> argument.
</p>
<p>The <code>nlocal</code> argument of an <code>mlocal</code> function– which must ALWAYS be included in the definition, with the default specified as <code>sys.parent()</code>– can normally be omitted when invoking your <code>mlocal</code> function. However, you will need to set it explicitly when your function is to be called by another, e.g. <code>lapply</code>; see the third example. A more daring usage is to call e.g. <code>fun.mlocal(nlocal=another.frame.number)</code> so that the statements in <code>fun.mlocal</code> get executed in a completely different frame. A convoluted example can be found in the (internal) function <code>find.debug.HQ</code> in the <span class="pkg">debug</span> package, which creates a frame and then defines a large number of variables in it by calling <code>setup.debug.admin(nlocal=new.frame.number)</code>. As of 2016, you can also set <code>nlocal</code> to be an environment.
</p>
<p><code>mlocal</code> functions can be nested, though this gets confusing. By default, all evaluation will happen in the same frame, that of the original caller.
</p>
<p>Note that (at least at present) all arguments are evaluated as soon as your <code>mlocal</code> function is invoked, rather than by the usual lazy evaluation mechanism. Missing arguments are still OK, though.
</p>
<p>If you call <code>return</code> in an <code>mlocal</code> function, you must call <code>local.return</code> too.
</p>
<p><code>on.exit</code> doesn't work properly. If you want to have exit code in the <code>mlocal</code> function itself, use <code>local.on.exit</code>. I can't find any way to set the exit code in the calling function from within an <code>mlocal</code> function. (Not checked for some years)
</p>
<p>Frame-dependent functions (sys.parent()) etc. will not do what you expect inside an <code>mlocal</code> function. For R versions between at least 1.8 and 2.15, calling the <code>mvb...</code> versions will return information about the <b>caller</b> of the current <code>mlocal()</code> function caller (or the original caller, if there is a chain of <code>mlocal</code>s). For example, <code>mvb.sys.function()</code> returns the definition of the caller, and <code>mvb.sys.parent()</code> the frame of the caller's parent. Note that <code>sys.frame( mvb.sys.nframe())</code> gives the current environment (i.e. where all the variables live), because this is shared between the caller and the <code>mlocal</code> function. Other behaviour seems to depend on the version of R, and in R 2.15 I don't know how to access the definition of the <code>mlocal</code> function itself. This means, for example, that you can't reliably access attributes of the <code>mlocal</code> function itself, though you can access those of its caller via e.g. <code>attr( mvb.sys.function(), "thing")</code>.
</p>


<h3>Value</h3>

<p>As per your function; also see <code>local.return</code>.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code>local.return</code>, <code>local.on.exit</code>, <code>do.in.envir</code>, <code>localfuncs</code>, and R-news 1/3 2001 for a related approach to "macros"
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Tidiness and variable creation
init &lt;- function( nlocal=sys.parent()) mlocal( sqr.a &lt;- a*a)
ffout &lt;- function( a) { init(); sqr.a }
ffout( 5) # 25
# Parameters and temporary variables
ffin &lt;- function( n, nlocal=sys.parent(), a, i) mlocal({
    # this "n" and "a" will temporarily replace caller's "n" and "a"
    print( n)
    a &lt;- 1
    for( i in 1:n)
      a &lt;- a*x
    a
  })
x.to.the.n.plus.1 &lt;- function( x, n) {
    print( ffin( n+1))
    print( n)
    print( ls())
  }
x.to.the.n.plus.1( 3, 2) # prints as follows:
# [1] 3 (in "ffin")
# [1] 27 (result of "ffin")
# [1] 2 (original n)
# [1] "n" "x" (vars in "x.to.the..."-- NB no a or i)
# Use of "nlocal"
ffin &lt;- function( i, nlocal=sys.parent()) mlocal( a &lt;- a+i )
ffout &lt;- function( ivec) { a &lt;- 0; sapply( ivec, ffin, nlocal=sys.nframe()) }
ffout( 1:3) # 1 3 6
</code></pre>


</div>