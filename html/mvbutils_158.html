<div class="container">

<table style="width: 100%;"><tr>
<td>print</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Print values</h2>

<h3>Description</h3>

<p>See base-R documentation of <code>print</code> and <code>print.default</code>. Users should see no difference with the <code>mvbutils</code> versions; they need to be documented and exported in <code>mvbutils</code> for purely technical reasons. There are also three useful special-purpose print methods in <code>mvbutils</code>; see <b>Value</b>.Some of the base-R documentation is reproduced below.
</p>
<p>The motive for redeclaration is to have a seamless transition within the <code>fixr</code> editing system, from the nice simple "source"-attribute system used to store function source-code before R2.14, to the quite extraordinarily complicated "srcref" system used thereafter. <code>mvbutils</code> does so via an augmented version of base-R's print method for functions, without which your careful formatting and commenting would be lost. If a function has a "source" attribute but no "srcref" attribute (as would be the case for many functions created prior to R2.14), then the augmented <code>print.function</code> will use the "source" attribute. There is no difference from base-R in normal use.
</p>
<p>See <b>How to override an s3 method</b> if you really want to understand the technicalities.
</p>


<h3>Usage</h3>

<pre><code class="language-R">print(x, ...) # generic
## Default S3 method:
print(x, ...) # S3 method for default
## S3 method for class 'function'
print(x, useSource=TRUE, ...) # S3 method for function
## S3 method for class 'cat'
print(x, ...) # S3 method for cat
## S3 method for class 'specialprint'
print(x, ...) # S3 method for specialprint
## S3 method for class 'pagertemp'
print(x, ...) # S3 method for pagertemp
## S3 method for class 'call'
print(x, ...) # S3 method for call
## S3 replacement method for class ''&lt;-''
print(x, ...) # S3 method for "&lt;-" (a special sort of call)
## S3 method for class ''(''
print(x, ...) # S3 method for "(" (a special sort of call)
#print(x, ...) # S3 method for "{" (a special sort of call)
## S3 method for class ''if''
print(x, ...) # S3 method for "if" (a special sort of call)
## S3 method for class ''for''
print(x, ...) # S3 method for "for" (a special sort of call)
## S3 method for class ''while''
print(x, ...) # S3 method for "while" (a special sort of call)
## S3 method for class 'name'
print(x, ...) # S3 method for name (symbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code> x</code></td>
<td>
<p>thing to print.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> ...</code></td>
<td>
<p>other arguments passed to <code>NextMethod</code> and/or ignored. There are many special arguments to base-R <code>print.default</code>, as described in its documentation. They are not named individually in the <code>mvbutils</code> version for technical reasons, but you can still use them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> useSource</code></td>
<td>
<p>[print.function] logical, indicating whether to use source references or copies rather than deparsing language objects. The default is to use the original source if it is available. The <code>mvbutils</code> override will print a "source" attribute if one exists but no "srcref" attribute does, whereas base-R post-2.14 would just print a deparsed version of the function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Technically, an <code>invisible</code> version of the object is returned. But the point of <code>print</code> is to display the object. <code>print.function</code> displays source code, as per <b>Description</b>. <code>print.default</code> and <code>print.call</code> need to exist in <code>mvbutils</code> only for technical reasons. The other two special methods are:
<code>print.cat</code> applies to character vectors of S3 class <code>cat</code>, which are printed each on a new line, without the [1] prefix or double-quotes or backslashes. It's ideal for displaying "plain text". Use <code>as.cat</code> to coerce a character vector so that it prints this way.
<code>print.specialprint</code> can be used to ensure an object (of class <code>specialprint</code>) displays in any particular way you want, without bothering to define a new S3 class and write a print method. Just give the object an attribute "print" of mode <code>expression</code>, which can refer to the main argument <code>x</code> and any other arguments. That expression will be run by <code>print.specialprint</code>– see <b>Examples</b>.
<code>print.pagertemp</code> is meant only for internal use by the informal-help viewer.
</p>


<h3>How to override an s3 method</h3>

<p>Suppose you maintain a package <span class="pkg">mypack</span> in which you want to mildly redefine an existing S3 method, like <code>mvbutils</code> does with <code>print.function</code>. (Drastic redefinitions are likely to be a bad idea, but adding or tweaking functionality can occasionally make sense.) The aim is that other packages which import <code>mypack</code> should end up using your redefined method, and so should the user if they have explicitly called <code>library( mypack)</code>. But your redefined method should <em>not</em> be visible to packages that don't import <code>mypack</code>, nor to the user if <code>mypack</code> has only been loaded implicitly (i.e. if <code>mypack</code> is imported by another package, so that <code>asNamespace(mypack)</code> is loaded but <code>package:mypack</code> doesn't appear on the search path). It's hard to find out how to do this. Here's what I have discovered:
</p>

<ul>
<li>
<p> For a <em>new</em> S3 method (i.e. for a class that doesn't already have one), then you just need to mark it as an <code>S3method</code> in the <code>mypack</code> NAMESPACE file (which <code>mvbutils</code> packaging tools do for you automatically). You don't need to document the new method explicitly, and consequently there's no need to export it. The new method will still be found when the generic runs on an object of the appropriate class.
</p>
</li>
<li>
<p> If you're modifying an existing method, you can't just declare it as <code>S3method</code> in the NAMESPACE file of <code>mypack</code>. If that's all you did, R would complain that it already has a registered method for that class— fair enough. Therefore, you also have to redeclare and export the <em>generic</em>, so that there's a "clean slate" for registering the method (specifically, in the S3 methods table for <code>mypack</code>, where the new generic lives). The new generic will probably be identical to the existing generic, very likely just a call to <code>UseMethod</code>. Because it's exported, it needs to be documented; you can either just refer to base-R documentation (but you still need all the formal stuff for Arguments etc, otherwise RCMD CHECK complains), or you can duplicate the base-R doco with a note. <code>help2flatdoc</code> is useful here, assuming you're wisely using <code>mvbutils</code> to build &amp; maintain your package.
</p>
</li>
<li>
<p> If you redeclare the generic, you also need to make sure that your <em>method</em> is <em>exported</em> as well as S3-registered in the NAMESPACE file of <code>mypack</code>. This is somehow connected with the obscure scoping behaviour of <code>UseMethod</code> and I don't really understand it, but the result is: if you don't export your method, then it's not found by the new generic (even though it exists in <code>asNamespace(mypack)</code>, which is the environment of the new generic, and even though your method is also S3-registered in that same environment). Because you export the method, you also need to document it.
</p>
</li>
<li>
<p> Unfortunately, the new generic won't know about the methods already registered for the old generic. So, for most generics (exceptions listed later), you will also have to define a <code>generic.default</code> method in <code>mypack</code>— and you need to export and therefore document it too, as per the previous point. This <code>generic.default</code> just needs to invoke the original generic, so that the already-registered S3 methods are searched. However, this can lead to infinite loops if you're not careful. See <code>mvbutils:::print.default</code> for how to do it. If you were redefining a generic that was originally (or most recently) defined somewhere other than <code>baseenv()</code>, then you'd need to replace the latter with <code>asNamespace(&lt;&lt;original.defining.package&gt;&gt;)</code>.
</p>
</li>
<li>
<p> Because your new <code>generic.default</code> might invoke any of the pre-existing (or subsequently-registered) methods of the <em>original</em> generic, you should just make its argument list <code>x,...</code>. In other words, don't name individual arguments even if they are named in the original <code>generic.default</code> (eg for <code>print.default</code>).
</p>
</li>
<li>
<p> Objects of mode <code>name</code>, <code>call</code>, and <code>"("</code> or <code>"{"</code> or <code>"&lt;-"</code> (special types of <code>call</code>) cause trouble in <code>generic.default</code> (at least using the approach in the previous point, as in <code>mvbutils:::print.default</code>). Unless they have a specific method, the object will be automatically evaluated. So if your generic is ever likely to be invoked on a <code>call</code> object, you'll need a special <code>generic.call</code> method, as in <code>mvbutils:::print.call</code>; the same goes for those other objects.
</p>
</li>
<li>
<p> A few generics— <code>rbind</code> and <code>cbind</code>, for example— use their own internal dispatch mechanism and don't have e.g. an <code>rbind.default</code>. Of course, there is a default behaviour, but it's not defined by an R-level function; see <code>?InternalGenerics</code>. For these generics, the previous point wouldn't work as a way of looking for existing methods. Fortunately, at least for <code>rbind</code>, things seem to "just work" if your redefined generic simply runs the code of the base generic (but don't call the latter directly, or you risk infinite loops— just run its body code). Then, if <em>your</em> generic is run, the search order is (1) methods registered for <em>your</em> generic in <code>asNamespace("mypack")</code>, whether defined in <code>mypack</code> itself or subsequently registered by another package that uses <code>mypack</code>, (2) methods defined/registered for the base generic (ie in the original generic's namespace), (3) the original "implicit default method". But if the <em>original</em> generic is run (e.g. from another package that doesn't import <code>mypack</code>), then step (1) is skipped. This is good; if another package <span class="pkg">pack2</span> imports <code>mypack</code> and registers an S3 method, the S3 registration will go into the <code>mypack</code> S3 lookup table, but if <code>pack2</code> <em>doesn't</em> import <code>mypack</code> then the S3 registration will go into the base S3 lookup table (or the lookup table for whichever package the generic was originally defined in, eg package <span class="pkg">stats</span>).
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Special methods shown below; basic behaviour of 'print', 'print.default',
# and 'print.function' is as for base-R
#cat
ugly.bugly &lt;- c( 'A rose by any other name', 'would annoy taxonomists')
ugly.bugly
#[1] "A rose by any other name"                 "would annoy taxonomists"
as.cat( ugly.bugly) # calls print.cat--- no clutter
#A rose by any other name
#would annoy taxonomists
# nullprint:
biggo &lt;- 1:1000
biggo
# [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
# [2] 19  20  21  22  23  24  25  26  27  28 etc...
oldClass( biggo) &lt;- 'nullprint'
biggo # calls print.nullprint
# nuthin'
# specialprint:
x &lt;- matrix( exp( seq( -20, 19, by=2)), 4, 5)
attr( x, 'print') &lt;- expression( {
    x[] &lt;- sprintf( '%12.2f', x);
    class( x) &lt;- 'noquote';
    attr( x, 'print') &lt;- NULL;
    print( x)
  })
class( x) &lt;- 'specialprint'
x # calls print.specialprint; consistently formatted for once
#     [,1]         [,2]         [,3]         [,4]         [,5]
#[1,]         0.00         0.00         0.02        54.60    162754.79
#[2,]         0.00         0.00         0.14       403.43   1202604.28
#[3,]         0.00         0.00         1.00      2980.96   8886110.52
#[4,]         0.00         0.00         7.39     22026.47  65659969.14

## End(Not run)
</code></pre>


</div>