<div class="container">

<table style="width: 100%;"><tr>
<td>set.finalizer</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Obsolete but automatic finalization for persistent objects created in C.</h2>

<h3>Description</h3>

<p>[Almost certainly obsolete; <code>.Call</code> really is the way to go for newer code, complexity notwithstanding.]
</p>
<p>Suppose you want to create persistent objects in Câ€“ i.e. objects that can be accessed from R by subsequent calls to C. The usual advice is that <code>.C</code> won't work safely because of uncertain disposal, and that you should use <code>.Call</code> and "externalptr" types instead. However, <code>.Call</code> etc is very complicated, and is much harder to use than <code>.C</code> in e.g. numerical settings. As an alternative, <code>set.finalizer</code> provides a safe way to ensure that your <code>.C</code>-created persistent object will tidy itself up when its R pointer is no longer required, just as you can with <code>externalptr</code> objects. There is no need for <code>on.exit</code> or other precautions.
</p>


<h3>Usage</h3>

<pre><code class="language-R"># Always assign the result to a variable-- usually a temporary var inside a function...
# ... which R will destroy when the function ends. EG:
# keeper &lt;- set.finalizer( handle, finalizer.name, PACKAGE=NULL)
set.finalizer( handle, finalizer.name, PACKAGE=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code> handle</code></td>
<td>
<p>[integer vector]. Pointer to your object, of length 1 on 32-bit systems or 2 on 64-bit systems. Will have been returned by your object-creation function in C.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> finalizer.name</code></td>
<td>
<p>Preferably a "native symbol" corresponding to a registered routine in a DLL; alternatively a string that names your <code>.C</code>-callable disposal routine. The routine must take exactly one argument, a 32-bit or 64-bit integer (the handle).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> PACKAGE</code></td>
<td>
<p>[string] iff <code>finalizer.name</code> is <code>character</code>, this is a PACKAGE argument that specifies the DLL.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>You <b>must</b> assign the result to a variable, otherwise your object will be prematurely terminated!
</p>
<p><code>set.finalizer</code> provides a wrapper for R's own <code>reg.finalizer</code>, setting up a dummy "trigger" environment with a registered finalizer. The trigger is defined as an environment rather than the more obvious choice of an external pointer, because the latter would require me to get fancy with <code>.Call</code>. The role of <code>reg.finalizer</code> is to prime the trigger, so that when the trigger is subsequently garbage-collected, your specified <code>.C</code> function is called to do the finalization.
</p>
<p>Note that finalization will only happen after <em>all copies</em> of <code>keeper</code> have been deleted. If you make a "temporary" copy in the global environment, remember to delete it! (Though presumably finalizers are de-registered if R is restarted and the keeper is reloaded, so there shouldn't be cross-session consequences.). Finalization won't necessarily happen immediately the last copy is deleted; you can call <code>gc()</code> to force it.
</p>


<h3>Value</h3>

<p>A list with elements <code>handle</code> and <code>trigger</code>, the second being the environment that will trigger the call when discarded. The first is the original handle; it has storage mode integer so, as per <b>Examples</b>, you don't need to coerce it when subsequently passing it to <code>.C</code>.
</p>


<h3>See Also</h3>

<p>.C, .Call, reg.finalizer
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
myfun &lt;- function( ...) {
  ...0
  # Create object, return pointer, and ensure safe disposal
  keeper &lt;- set.finalizer( .C( "create_thing", handle=integer(2), ...1)$handle,
      "dispose_of_thing")
  "cause" + "crash" # whoops, will cause crash: but finalizer will still be called
  # "dispose_of_thing" had better be the name of a DLL routine that takes a...
  # ... single integer argument, of length 1 or 2
  # Intention was to use the object. First param of DLL routine "use_thing" should
  # be pointer to thing.
  .C( "use_thing", keeper$handle, ...2)
}
myfun(...)

## End(Not run)
</code></pre>


</div>