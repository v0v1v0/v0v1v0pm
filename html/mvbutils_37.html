<div class="container">

<table style="width: 100%;"><tr>
<td>cd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Organizing R workspaces</h2>

<h3>Description</h3>

<p><code>cd</code> allows you to set up and move through a hierarchically-organized set of R workspaces, each corresponding to a directory. While working at any level of the hierarchy, all higher levels are attached on the search path, so you can see objects in the "parents". You can easily switch between workspaces in the same session, you can move objects around in the hierarchy, and you can do several hierarchy-wide things such as searching, even on parts of the hierarchy that aren't currently attached.
</p>


<h3>Usage</h3>

<pre><code class="language-R"># Occasionally: cd()
# Usually: cd(to)
# Rarely:
 cd(to, execute.First = TRUE, execute.Last = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>  to</code></td>
<td>
<p>the path of a task to move to or create, as an unquoted string. If omitted, you'll be given a menu. See <b>Details</b>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>  execute.First</code></td>
<td>
<p>should the <code>.First.task</code> code be executed on attachment? Yes, unless there's a bug in it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>  execute.Last</code></td>
<td>
<p>should the <code>.Last.task</code> code be executed on detachment? Yes, unless there's a bug in it.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>R workspaces can become very cluttered, so that it becomes difficult to keep track of what's what (I have seen workspaces with over 1000 objects in them). If you work on several different projects, it can be awkward to work out where to put "shared" functions– or to remember where things are, if you come back to a project after some months away. And if you just want to test out a bit of code without leaving permanent clutter, but while still being able to "see" your important objects, how do you do it? <code>cd</code> helps with all such problems, by letting you organize all your projects into a single tree structure, regardless of where they are stored on disk. Each workspace is referred to (for historical reasons) as a "task".
</p>
<p>Note that there is a basic choice when working with R: do you keep everything you write in a text file which you <code>source</code> every time you start; or do you store all the objects in a workspace as a binary image in a ".RData" file, and rely on <code>save</code> and <code>load</code>? [Hybrids are possible, too.] Some people prefer the text-based approach, but others including me prefer the binary image approach; my reasons are that binary images let me organize my work across tasks more systematically, and that repeated text-sourcing is much too slow when lengthy analyses or data extractions are involved. The <code>cd</code> system is really geared to the binary image model and, before <code>cd</code> moves to a new task, either up or down the hierarchy, the current workspace is automatically saved to a binary image. Nevertheless, I don't think <code>cd</code> is incompatible with other ways of working, as long as the ".RData" file (actually the <code>tasks</code> object) is not destroyed from session to session. At any rate, some people who work by <code>source</code>ing large code files still seem to find <code>cd</code> useful; it's even possible to use the <code>.First.task</code> feature to auto-load a task's source files into a text editor when you <code>cd</code> to that task. With the ".RData"-only approach, it is highly advisable to have some way of keeping separate text backups, at least of function code. The <code>fixr</code> editing system is geared up to this, and I presume other systems such as ESS are too.
</p>
<p>To use the <code>cd</code> system, you will need to start R in the <b>same</b> workspace every time. This will become your ROOT or home task, from which all other tasks stem. There need not be much in this workspace except for an object called <code>tasks</code> (see below), though you can use it for shared functions that you don't want to organize into a package. From the ROOT task, your first action in a new R session will normally be to use <code>cd</code> to switch to a real task. The <code>cd</code> command is used both to switch between existing tasks, and to create new ones.
</p>
<p>To set yourself up for working with <code>cd</code>, it's probably a good idea to make the ROOT task a completely new blank workspace, so the first step is to (outside R) create an empty folder with some name like "Rstart". [In MS-Windows, you should think about <b>where</b> to put this, to save yourself inordinate typing later on. If you are planning to create a completely new set of folders for your R projects, you might want to put this ROOT folder near the top of the disk directory structure, rather than in the insane default that Windows proffers, which usually looks something like "c:\document...\local...\long...\ridiculous...". However, if you are planning instead to link existing folders into the task hierarchy, then it's better to create the ROOT folder just above, or parallel to, the location of these folders.] Start R in this folder, type <code>library( mvbutils)</code>, and then start linking your existing projects into the task hierarchy. [Of course, this assumes that you do have existing projects. If you don't, then just start creating new tasks.] To link in a project, just type <code>cd()</code> and a menu will appear. The first time, there will be only one option: "CREATE NEW TASK". Select it (or type 0 to quit if you are feeling nervous), and you will be prompted for a "task name", by which R will always subsequently refer to the task. Keep the name short; it doesn't have to be related to the location of the disk directory where the .RData lives. Avoid spaces and weird characters– use periods as separators. Task names are case-sensitive. Next, you'll be asked which disk directory this task refers to. By default, <code>cd</code> expects that you are creating a new task, and therefore suggests putting the directory immediately below the current task directory. However, if you are linking in an existing project, you'll need to supply the directory name. You can save huge amounts of typing by using "." to refer to the current directory, and on *nix systems you can use "~" too. Next, you'll be returned to the R command prompt– but the prompt will have changed, so that the "&gt;" is preceded by the task name. If you type <code>search()</code>, you'll see your ROOT task in position 2, below .GlobalEnv as usual. Despite the name, though, the new .GlobalEnv contains the project you've just linked, and if you type <code>ls()</code>, you should see some familiar objects. Now type <code>cd(0)</code> to move back to the ROOT task (note the changed prompt), type <code>search()</code> and <code>ls()</code> again to orient yourself, and proceed as before to link the rest of your pre-existing tasks into the hierarchy. When you now type <code>cd()</code>, the menu will have more choices. If you select an existing task rather than creating a new one, you will switch straightaway to that workspace; watch the prompt.
</p>
<p>Once you have a hierarchy set up, you can switch the current workspace within the hierarchy by calling e.g. <code>cd(existing.task)</code> (note the lack of quotes), or by calling <code>cd()</code> and picking off the menu. You can move through several levels of the hierarchy at once, using a path specifier such as <code>cd(mytask/data/funcs)</code> or <code>cd(../child.of.sibling)</code>. Path specifiers are just like Unix or Windows disk paths with "/" as the separator, so that "." means "current task" and ".." means "parent". However, the character 0 must be used to denote the ROOT task, so that you have to type <code>cd(0/different.task)</code> rather than <code>cd(/different.task</code>). You can display the entire hierarchy by calling <code>cdtree(0)</code>, or graphically via <code>plot( cdtree( 0))</code>.
</p>
<p>When you first set up your task hierarchy, you'll also want to create or modify the <code>.First</code> function in your ROOT task. At a minimum, this should call <code>library( mvbutils)</code>, but you may also want to set some options controlling the behaviour of <code>cd</code> (see the <b>Options</b> section). If you use other features of <code>mvbutils</code> such as the function-editing interface in <code>fixr</code>, there will be further options to be set in <code>.First</code>. [MAC users: for some strange reason <code>.First</code> just doesn't get called if you are using the "usual" RGUI for MACs. So what you need to do is create a ".Rprofile" file in your ROOT folder using a text editor; this file should both contain the definition of the <code>.First</code> function, and should also call <code>.First()</code> directly. You can also put the <code>.First</code> commands directly into the ".Rprofile" file, but watch out for the side-effect of creating objects in <code>.GlobalEnv</code>.]
</p>
<p>You can create a fully hierarchical structure, with subtasks within subtasks within tasks, etc. Even if your projects don't naturally look like this, you may find the facility useful. When I create a new task, I tend to start with just one level of hierarchy, containing data, function code, and results. When this gets unspeakably messy, I often create one (or more) subtasks, usually putting the basic data at the top level, and functions and results at the lower level. Apart from tidiness, this provides some degree of protection against overwriting the original data. And when even this gets too messy– in one task, I have more than 150 functions, and it is very easy to generate 100s of analysis results– I create another level, keeping "established" functions at the second tier and using the third tier for temporary workspace and results. There are no hard-and-fast rules here, of course, and different people use R in very different ways.
</p>
<p>A task can have <code>.First.task</code> and/or <code>.Last.task</code> functions, which get called immediately after <code>cd</code>ing into the task from its parent, or immediately before <code>cd</code>ing back to its parent, respectively (see <b>Arguments</b>). These can be useful for dynamic loading, loading scripts into a text editor, attaching &amp; detaching datasets, etc., and facilitate the use of tasks as informal packages.
</p>
<p>For turning tasks into formal R packages, consult <code>mvbutils.packaging.tools</code>.
</p>


<h3>How it works</h3>

<p>The mechanism underlying the tree structure is very simple: each task that has any subtasks will contain a character vector called <code>tasks</code>, whose names are the R names of the tasks, and whose elements are the corresponding disk directories. Your ROOT task need contain no more than a <code>.First</code> function and a <code>tasks</code> object.
</p>
<p>You can manually modify the <code>tasks</code> vector, and sometimes this is essential. If you decide to move a disk directory, for example, you can manually change the corresponding element of <code>tasks</code> to reflect the change. (Though if you are moving a whole task hierarchy, e.g. when migrating to a new machine, consult <code>cd.change.all.paths</code>. Having said that, the ability to use relative pathnames in tasks, which is present since about mvbutils version 2.0, makes <code>cd.change.all.paths</code> partly redundant.) You can also rename a task very easily, via something like
</p>
<pre>
  names( tasks)[ names( tasks)=="my.old.name"] &lt;- "my.new.name"
</pre>
<p>You can use similar methods to "reparent" a subtask without changing the directory structure.
</p>
<p>There is (deliberately, to avoid accidents) no completely automatic way of removing tasks. To "hide" a task from the <code>cd</code> system, you first need to be <code>cd</code>ed to its parent; then remove the corresponding element of the <code>tasks</code> object, most easily via e.g.
</p>
<pre>
  tasks &lt;- tasks %without.name% "mysubtask"
</pre>
<p>If you want to remove the directories corresponding to "mysubtask", you have to do so manually, either in the operating system or (for the brave) in R code.
</p>
<p>Remember to <code>Save()</code> at some point after manually modifying <code>tasks</code>.
</p>


<h3>Options</h3>

<p>Various <code>options()</code> can be set, as follows. Remember to put these into your <code>.First</code> function, too.
</p>
<p><code>write.mvb.tasks=TRUE</code> causes a sourceable text representation of the <code>tasks</code> object to be maintained in each directory, in the file <code>tasks.r</code>. This helps in case you accidentally wipe out the .RData file and lose track of where the child tasks live. To create these text representations for the first time throughout the hierarchy, call <code>cd.write.mvb.tasks(0)</code>. You need to put the the <code>options</code> call in your <code>.First</code>.
</p>
<p><code>abbreviate.cdprompt=n</code> controls the length of the prompt string. Only the first <code>n</code> characters of all ancestral task names will be shown. For example, <code>n=1</code> would replace the prompt <code>long.task.name/data/funcs&gt;</code> with <code>l/d/funcs&gt;</code>.
</p>
<p><code>mvbutils.update.history.on.cd=FALSE</code> will prevent automatic saving &amp; reloading of the history file when <code>cd</code> is called.
</p>
<p><code>cd</code> checks the <code>R_HISTFILE</code> environment variable and, if unset, sets it to <code>file.path( getwd()), ".Rhistory")</code>. This (combined with the <code>mvbutils</code> replacement of the standard versions of <code>savehistory</code> and <code>loadhistory</code>– see <code>package?mvbutils</code>) ensures that the same history file is used throughout each and every R session. My experience is that a single master history file is safer. However, if you want to override this behaviour– e.g. if you want to use a separate history file for each task– call something like <code>Sys.setenv( R_HISTFILE=".Rhistory")</code> <b>before</b> the <b>first</b> use of <code>cd</code>.
</p>


<h3>Note</h3>

<p><code>cd</code> calls <code>setwd</code> so that file searches will default to the task directory (see also <code>task.home</code>).
</p>
<p><code>cd</code> always calls <code>Save</code> before attaching a child task on top or moving back up the hierarchy. If you have many and/or big objects, the default behaviour can be slow. You can speed this up– sometimes dramatically– by "mcacheing" some of your objects so that they are stored in separate files– see <code>mlazy</code>.
</p>
<p>If there are no changes to the ".RData" file, <code>cd</code> will not modify the file– in particular, its date-of-access will be unchanged. This helps avoid unnecessary file copying on subsequent synchronization. However, there are several seemingly innocuous operations which change the workspace: calling a random number function (changes <code>.Random.seed</code>), causing an error (creates <code>.Traceback</code>), and causing a warning (creates <code>last.warning</code>). To avoid forcing a change to the entire ".RData" file whenever one of these changes, you can set <code>option( mvbutils.quick.cd=TRUE)</code>; this turns on <code>mcache</code>ing for those objects (see <code>mlazy</code>), so that they are stored in separate mini-files.
</p>
<p><code>cd</code> is only meant to be called interactively, and has only been tested in that context.
</p>
<p><code>cd</code> will issue a warning and refuse to move back up the hierarchy if it detects a non-task attached in position 2. You will need to manually detach any such objects before <code>cd</code>ing back up, or write a <code>.Last.task</code> function to automatically do the detaching. To make sure that <code>library</code> (and any automatic loading of packages, e.g. if triggered by <code>load</code>ing a file referring to a namespace) always inserts packages below ROOT, the <code>.onLoad</code> code in <code>mvbutils</code> makes a minor hack to <code>library</code>, changing the default <code>pos</code> argument accordingly.
</p>
<p>Two objects in the <code>mvb.session.info</code> search environment (see <code>search()</code>) help keep track of what parts of the hierarchy are currently attached; <code>.First.top.search</code> and <code>.Path</code>. The former is set when <code>mvbutils</code> loads, and the latter is updated by <code>cd</code>. Attached tasks can be identified by having a <code>path</code> attribute consisting of a <em>named</em> character vector. Normal packages also have a <code>path</code> attribute, but without <code>names</code>.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code>move</code>, <code>task.home</code>, <code>cdtree</code>, <code>cdfind</code>, <code>cditerate</code>, <code>cd.change.all.paths</code>, <code>cd.write.mvb.tasks</code>, <code>cdprompt</code>, <code>fixr</code>, <code>mlazy</code>
</p>


</div>