<div class="container">

<table style="width: 100%;"><tr>
<td>mvbutils.operators</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Utility operators</h2>

<h3>Description</h3>

<p>Succinct or convenience operators
</p>


<h3>Usage</h3>

<pre><code class="language-R">a %&amp;% b
x %**% y
a %!in% b
vector %except% condition
x %grepling% patt
x %is.not.a% what
x %is.a% what
x %is.not.an% what
x %is.an% what
x %matching% patt
a %not.in% b
a %not.in.range% b
x %perling% patt
x %that.match% patt
x %that.dont.match% patt
a %that.are.in% b
x %without.name% what
a %in.range% b
a %such.that% b
a %SUCH.THAT% b
from %upto% to
from %downto% to
x %where% cond
x %where.warn% cond
a %&lt;-% value # really e.g. {x;y} %&lt;-% list( 'yes', sqrt(pi)) to create x &amp; y
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code> a, b, vector, condition, x, y, what, patt, from, to, cond, value</code></td>
<td>
<p>see <b>Arguments by function</b>.</p>
</td>
</tr></table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code> %&amp;%</code></td>
<td>
<p>character vector. If either is zero-length, so is the result (unlike <code>paste</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> %**%</code></td>
<td>
<p>numeric, possibly a matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> %upto%, %downto%</code></td>
<td>
<p>numeric</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> %is.a%, %in%, etc</code></td>
<td>
<p>logical</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> %&lt;-%</code></td>
<td>
<p>technically NULL return, but it overwrites / creates objects; see below...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> All others</code></td>
<td>
<p>same type as first argument.</p>
</td>
</tr>
</table>
<h3>Arguments by function</h3>

<p><code>%&amp;%</code> a, b: character vectors to be <code>paste</code>d with no separator. If either is zero-length, so is the result (unlike <code>paste</code>).
</p>
<p><code>%**%</code> x, y: matrices or vectors to be multiplied using <code>%*%</code> but with less fuss about dimensions
</p>
<p><code>%!in%</code>, <code>%that.are.in%</code> a, b: vectors (character, numeric, complex, or logical).
</p>
<p><code>%except%</code> vector, condition: character or numeric vectors
</p>
<p><code>%in.range%</code>, <code>%not.in.range%</code> a, b: numeric vectors.
</p>
<p><code>%is.a%</code>, etc. x: object whose class is to be checked
</p>
<p><code>%is.a%</code>, etc. what: class name
</p>
<p><code>%matching%</code>, <code>%that.match%</code>, <code>%that.dont.match%</code>, <code>%grepling%</code>, <code>%perling%</code> x: character vector
</p>
<p><code>%matching%</code>, <code>%that.match%</code>, <code>%that.dont.match%</code>, <code>%grepling%</code>, <code>%perling%</code> patt: character vector of regexps, with perl syntax for <code>%perling%</code>
</p>
<p><code>%such.that%</code>, <code>%SUCH.THAT%</code> a: vector
</p>
<p><code>%such.that%</code>, <code>%SUCH.THAT%</code> b: expression containing a <code>.</code>, to subscript <code>a</code> with
</p>
<p><code>%upto%</code>, <code>%downto%</code> from, to: numeric(1)
</p>
<p><code>%where%</code>, <code>%where.warn%</code> x: data.frame
</p>
<p><code>%where%</code>, <code>%where.warn%</code> cond: unquoted expression to be <code>eval</code>ed in context of <code>x</code>, then in the calling frame of <code>%where%</code> (or <code>.GlobalEnv</code>). Should evaluate to logical (or maybe numeric or character); NA is treated as FALSE. Wrap <code>cond</code> in parentheses to avoid trouble with operator precedence.
</p>
<p><code>%without.name%</code> x: object with <code>names</code> attribute
</p>
<p><code>%without.name%</code> what: character vector of names to drop
</p>
<p><code>%&lt;-%</code> a, value: <code>value</code> should be a list, and <code>a</code> should be e.g. <code>{x;y;z}</code> with as many elements as <code>value</code> has. The elements of <code>value</code> are assigned, in order, to the objects named in <code>a</code>, which are created / overwritten in the calling environment.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p>bquote
</p>


<h3>Examples</h3>

<pre><code class="language-R">"a" %&amp;% "b" # "ab"
matrix( 1:4, 2, 2) %**% matrix( 1:2, 2, 1) # c( 7, 10); '%*%' gives matrix result
matrix( 1:2, 2, 1) %**% matrix( 1:4, 2, 2) # c( 5, 11); '%*%' gives error
1:2 %**% matrix( 1:4, 2, 2) # '%*%' gives matrix result
1:5 %!in% 3:4 # c( TRUE, TRUE, FALSE, FALSE, TRUE)
1:5 %not.in% 3:4 # c( TRUE, TRUE, FALSE, FALSE, TRUE)
1:5 %that.are.in% 3:4 # c( 3, 4)
trf &lt;- try( 1+"nonsense")
if( trf %is.not.a% "try-error") cat( "OK\n") else cat( "not OK\n")
1:5 %except% c(2,4,6) # c(1,3,5)
c( alpha=1, beta=2) %without.name% "alpha" # c( beta=2)
1:5 %in.range% c( 2, 4) # c(F,T,T,T,F)
1:5 %not.in.range% c( 2, 4) # c(T,F,F,F,T)
c( "cat", "hat", "dog", "brick") %matching% c( "at", "ic") # cat hat brick
c( "cat", "hat", "dog", "brick") %that.match% c( "at", "ic") # cat hat brick; ...
# ... synonym for '%matching%'
c( "cat", "hat", "dog", "brick") %that.dont.match% c( "at", "ic") # dog; ...
# ... like '%except%' but for regexps
1 %upto% 2 # 1:2
1 %upto% 0 # numeric( 0); use %upto% rather than : in for-loops to avoid unintended errors
1 %downto% 0 # 1:0
1 %downto% 2 # numeric( 0)
ff &lt;- function( which.row) {
    x &lt;- data.frame( a=1:3, b=4:6)
    x %where% (a==which.row)
  }
ff( 2) # data.frame( a=2, b=5)
x &lt;- data.frame( start=1:3, end=c( 4, 5, 0))
x %where.warn% (start &lt; end) # gives warning about row 3
(1:5) %such.that% (.&gt;2) # 3,4,5
listio &lt;- list( a=1,  b=2)
chars &lt;- cq( a, b)
chars %SUCH.THAT% (listio[[.]]==2) # 'b'; %such.that% won't work because [[]] can't handle xtuples
{x;y} %&lt;-% list( 'yes', sqrt(pi))
# x: [1] "yes"
# y: [1] 1.772
</code></pre>


</div>