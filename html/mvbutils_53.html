<div class="container">

<table style="width: 100%;"><tr>
<td>source.mvb</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Read R code and data from a file or connection</h2>

<h3>Description</h3>

<p><code>source.mvb</code> works like <code>source(local=TRUE)</code>, except you can intersperse free-format data into your code. <code>current.source</code> returns the connection that's currently being read by <code>source.mvb</code>, so you can redirect input accordingly. To do this conveniently inside <code>read.table</code>, you can use <code>from.here</code> to read the next lines as data rather than R code.
</p>


<h3>Usage</h3>

<pre><code class="language-R">source.mvb( con, envir=parent.frame(), max.n.expr=Inf,
  echo=getOption( 'verbose'), print.eval=echo,
  prompt.echo=getOption( 'prompt'), continue.echo=getOption( 'continue'))
current.source()
from.here( EOF=as.character(NA)) # Don't use it like this!
# Use "from.here" only inside "read.table", like so:
# read.table( file=from.here( EOF=), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code> con</code></td>
<td>
<p>a filename or connection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> envir</code></td>
<td>
<p>an environment to evaluate the code in; by default, the environment of the caller of <code>source</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> max.n.expr</code></td>
<td>
<p>finish after evaluating <code>max.n.expr</code> complete expressions, unless file ends first.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> EOF</code></td>
<td>
<p>line which terminates data block; lines afterwards will again be treated as R statements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> ...</code></td>
<td>
<p>other args to <code>read.table</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> echo, print.eval, prompt.echo, continue.echo</code></td>
<td>
<p>as per <code>source</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calls to <code>source.mvb</code> can be nested, because the function maintains a stack of connections currently being read by <code>source.mvb</code>. The stack is stored in the list <code>source.list</code> in the <code>mvb.session.info</code> environment, on the search path. <code>current.source</code> returns the last (most recent) entry of <code>source.list</code>.
</p>
<p>The sequence of operations differs from vanilla <code>source</code>, which parses the entire file and then executes each expression in turn; that's why it can't cope with interspersed data. Instead, <code>source.mvb</code> parses one statement, then executes it, then parses the next, then executes that, etc. Thus, if you include in your file a call to e.g.
</p>
<p><code>text.line &lt;- readLines( con=current.source(), n=1)</code>
</p>
<p>then the next line in the file will be read in to <code>text.line</code>, and execution will continue at the following line. <code>readLines.mvb</code> can be used to read text whose length is not known in advance, until a terminating string is encountered; lines after the terminator, if any, will again be evaluated as R expressions by <code>source.mvb</code>.
</p>
<p>After <code>max.n.expr</code> statements (i.e. syntactically complete R expressions) have been executed, <code>source.mvb</code> will return.
</p>
<p>If the connection was open when <code>source.mvb</code> is called, it is left open; otherwise, it is closed.
</p>
<p>If you want to use <code>read.table</code> or <code>scan</code> etc. inside a <code>source.mvb</code> file, to read either a known number of lines or the rest of the file as data, you can use e.g. <code>read.table( current.source(), ...)</code>.
</p>
<p>If you want to <code>read.table</code> to read an <em>unknown</em> number of lines until a terminator, you could explicitly use <code>readLines.mvb</code>, as shown in the demo "source.mvb.demo.R". However, the process is cumbersome because you have to explicitly open and close a <code>textConnection</code>. Instead, you can just use <code>read.table( from.here( EOF=...), ...)</code> with a non-default <code>EOF</code>, as in <b>Usage</b> and the same demo (but see <b>Note</b>). <code>from.here</code> <em>shouldn't</em> be used inside <code>scan</code>, however, because a temporary file will be left over.
</p>
<p><code>current.source()</code> can also be used inside a source file, to work out the source file's name. Of course, this will only work if the file is being handled by <code>source.mvb</code> rather than <code>source</code>.
</p>
<p>If you type <code>source.list</code> at the R command prompt, you should always see an empty list, because all <code>source.mvb</code> calls should have finished. However, the source list can occasionally become corrupt, i.e. containing invalid connections (I have only had this happen when debugging <code>source.mvb</code> and quitting before the exit code can clean up). If so, you'll get an error message on typing <code>source.list</code> (?an R bug?). Normally this won't matter at all. If it bothers you, try <code>source.list &lt;&lt;- list()</code>.
</p>


<h3>Value</h3>

<p><code>source.mvb</code> returns the value of the last expression executed, but is mainly called for its side-effects of evaluating the code. <code>from.here</code> returns a connection, of class <code>c( "selfdeleting.file", "file", "connection")</code>; see <b>Details</b>. <code>current.source</code> returns a connection.
</p>


<h3>Limitations</h3>

<p>Because <code>source.mvb</code> relies on <code>pushBack</code>, <code>con=stdin()</code> won't work.
</p>


<h3>Note</h3>

<p><code>from.here</code> creates a temporary file, which should be automatically deleted when <code>read.table</code> finishes (with or without an error). Technically, the connection returned by <code>from.here</code> is of class <code>selfdeleting.file</code> inheriting from <code>file</code>; this class has a specific <code>close</code> method, which unlinks the <code>description</code> field of the connection. This trick works inside <code>read.table</code>, which calls <code>close</code> explicitly, but not in <code>scan</code> or <code>closeAllConnections</code>, which ignore the <code>selfdeleting.file</code> class.
</p>
<p><code>from.here()</code> without an explicit terminator is equivalent to <code>readLines( current.source())</code>, and the latter avoids temporary files.
</p>


<h3>See Also</h3>

<p><code>source</code>, <code>readLines.mvb</code>, <code>flatdoc</code>, the demo in "source.mvb.demo.R"
</p>


<h3>Examples</h3>

<pre><code class="language-R"># You wouldn"t normally do it like this:
tt &lt;- tempfile()
cat( "data &lt;- scan( current.source(), what=list( x=0, y=0))",
"27 3",
"35 5",
file=tt, sep="\n")
source.mvb( tt)
unlink( tt)
data # list( x=c( 27, 35), y=c(3, 5))
# "current.source", useful for hacking:
tt &lt;- tempfile()
cat( "cat( \"This code is being read from file\",",
"summary( current.source())$description)", file=tt)
source.mvb( tt)
cat( "\nTo prove the point:\n")
cat( scan( tt, what="", sep="\n"), sep="\n")
unlink( tt)
</code></pre>


</div>