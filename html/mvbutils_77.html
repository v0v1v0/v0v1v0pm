<div class="container">

<table style="width: 100%;"><tr>
<td>fixr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Editing functions, text objects, and scriptlets</h2>

<h3>Description</h3>

<p><code>fixr</code> opens a function (or text object, or "script" stored as an R <code>expression</code>— see <b>Scriptlets</b>) in your preferred text editor. Control returns immediately to the R command line, so you can keep working in R and can be editing several objects simultaneously (cf <code>edit</code>). A session-duration list of objects being edited is maintained, so that each object can be easily sourced back into its rightful workspace. These objects will be updated automatically on file-change if you've run <code>autoedit( TRUE)</code> (e.g. in your <code>.First</code>), or manually by calling <code>FF()</code>. There is an optional automatic text backup facility.
</p>
<p>The safest is to call <code>fixtext</code> to edit text objects, and <code>fixr</code> for functions and everything else. However, <code>fixr</code> can handle both, and for objects that already exist it will preserve the type. For new objects, though, you have to specify the type by calling either <code>fixr</code> or <code>fixtext</code>. If you forget— ie if you really wanted to create a new text object, but instead accidentally typed <code>fixr( mytext)</code>— you will (probably) get a parse error, and <code>mytext</code> will then be "stuck" as a broken function. Your best bet is to copy the actual contents in the text-editor to the clipboard, type <code>fixtext( mytext)</code> in R, paste the old contents into the text-editor, and save the file; R will then reset the type and all should be well.
</p>
<p><code>readr</code> also opens a file in your text editor, but in read-only mode, and doesn't update the backups or the list of objects being edited.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  # Usually: fixr( x) or fixr( x, new.doc=T)
  fixr( x, new=FALSE, install=FALSE, what, fixing, pkg=NULL,
      character.only=FALSE, new.doc=FALSE, force.srcref=FALSE)
  # fixtext really has exact same args as fixr, but technically its args are:
  fixtext( x, ...)
  # Usually: readr( x) but exact same args as fixr, though the defaults are different
  readr( x, ...)
  FF() # manual check and update, usually only needed...
      # ... temporarily if autoedit() stops working
  autoedit( do=TRUE) # stick this line in your .First
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code> x</code></td>
<td>
<p>a quoted or unquoted name of a function, text object, or expression. You can also write <code>mypack$myfun</code>, or <code>mypack::myfun</code>, or <code>mypack:::myfun</code>, or <code>..mypack$myfun</code>, to simultaneously set the <code>pkg</code> argument (only if <code>mypack</code> has been set up with <code>maintain.packages</code>). Note that <code>fixr</code> uses non-standard evaluation of its <code>x</code> argument, unless you specify <code>character.only=TRUE</code>. If your object has a funny name, either quote it and set <code>character.only=TRUE</code>, or pass it directly as...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> character.only</code></td>
<td>
<p>(logical or character) if TRUE, <code>x</code> is treated as a string naming the object to be edited, rather than the unquoted object name. If <code>character.only</code> is a string, it is treated as the name of <code>x</code>, so that eg <code>fixr(char="funny%name")</code> works.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> new.doc</code></td>
<td>
<p>(logical) if TRUE, add skeleton plain-text R-style documentatation, as per <code>add.flatdoc.to</code>. Also use this to create an empty scriptlet for a general (non-function, non-text) object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> force.srcref</code></td>
<td>
<p>(logical) Occasionally there have been problems transferring old code into "new" R, especially when a function has text attributes such as (but not limited to) <code>doc</code>; the symptom is, they appear in the editor just as "# FLAT-FORMAT DOCUMENTATION". This sometimes requires manual poking-around, but usually can be sorted out by calling <code>fixr(...,force.srcref=TRUE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> new</code></td>
<td>
<p>(logical, seldom used) if TRUE, edit a blank function template, rather than any existing object of that name elsewhere in the search path. New edit will go into <code>.GlobalEnv</code> unless argument <code>pkg</code> is set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> install</code></td>
<td>
<p>(logical, rarely used) logical indicating whether to go through the process of asking you about your editor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> what</code></td>
<td>
<p>Don't use this– it's "internal"! [Used by <code>fixtext</code>, which calls <code>fixr</code> with <code>what=""</code> to force text-mode object. <code>what</code> should be an object with the desired class.]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> fixing</code></td>
<td>
<p>(logical, rarely used) FALSE for read-only (i.e. just opening editor to examine the object)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> pkg</code></td>
<td>
<p>(string or environment) if non-NULL, then specifies in which package a specific maintained package (see <code>maintain.packages</code>) <code>x</code> should be looked for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> do</code></td>
<td>
<p>(logical) TRUE =&gt; automatically update objects from altered files; FALSE =&gt; don't.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> ...</code></td>
<td>
<p>other arguments, except <code>what</code> in <code>fixtext</code>, and <code>fixing</code> in <code>readr</code>, are passed to <code>fixr</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>fixr</code> is run for the first time (or if you set <code>install=TRUE</code>), it will ask you for some basic information about your text editor. In particular, you'll need to know what to type at a command prompt to invoke your text editor on a specific file; in Windows, you can usually find this by copying the Properties/Shortcut/Target field of a shortcut, followed by a space and the filename. After supplying these details, <code>fixr</code> will launch the editor and print a message showing some <code>options</code> (<code>"backup.fix"</code>, <code>"edit.scratchdir"</code> and <code>"program.editor"</code>), that will need to be set in your <code>.First</code>. function. You should now be able to do that via <code>fixr(.First)</code>.
</p>
<p>Changes to the temporary files used for editing can be checked for automatically whenever a valid R command is typed (e.g. by typing 0&lt;ENTER&gt;; &lt;ENTER&gt; alone doesn't work). To set this up, call <code>autoedit()</code> once per session, e.g. in your <code>.First</code>. The manual version (ie what <code>autoedit</code> causes to run automatically) is <code>FF()</code>. If any file changes are detected by <code>FF</code>, the code is sourced back in and the appropriate function(s) are modified. <code>FF</code> tries to write functions back into the workspace they came from, which might not be <code>.GlobalEnv</code>. If not, you'll be asked whether you want to <code>Save</code> that workspace (provided it's a task– see <code>cd</code>). <code>FF</code> should still put the function in the right place, even if you've called <code>cd</code> after calling <code>fixr</code> (unless you've detached the original task) or if you <code>move</code>d it. If the function was being <code>mtrace</code>d (see <code>package?debug</code>), <code>FF</code> will re-apply <code>mtrace</code> after loading the edited version. If there is a problem with parsing, the <code>source</code> attribute of the function is updated to the new code, but the function body is invisibly replaced with a <code>stop</code> call, stating that parsing failed.
</p>
<p>If something goes wrong during an automatic call to <code>FF</code>, the automatic-call feature will stop working; this is rare, but can be caused eg by hitting &lt;ESC&gt; while being prompted whether to save a task. To restart the feature in the current R session, do <code>autoedit(F)</code> and then <code>autoedit(T)</code>. It will come back anyway in a new R session.
</p>
<p><code>readr</code> requires a similar installation process. To get the read-only feature, you'll need to add some kind of option/switch on the command line that invokes your text editor in read-only mode; not all text editors support this. Similarly to <code>fixr</code>, you'll need to set <code>options( program.reader=&lt;&lt;something&gt;&gt;)</code> in your <code>.First</code>; the installation process will tell you what to use.
</p>
<p><code>fixr</code>, and of course <code>fixtext</code>, will also edit character vectors. If the object to be edited exists beforehand and has a class attribute, <code>fixr</code> will not change its class; otherwise, the class will be set to "cat". This means that <code>print</code> invokes the <code>print.cat</code> method, which displays text more readably than the default. Any other attributes on character vectors are stripped.
</p>
<p>For functions, the file passed to the editor will have a ".r" extension. For character vectors or other things, the default extension is ".txt", which may not suit you since some editors decide syntax-highlighting based on the file extension. (EG if the object is a character-vector "R script", you might want R-style syntax highlighting.) You can somewhat control that behaviour by setting <code>options()$fixr.suffices</code>, eg
</p>
<pre>
  options( fixr.suffices=c( r='.r', data='.dat'))
</pre>
<p>which will mean that non-function objects whose name ends <code>.r</code> get written to files ending ".r.r", and objects whose name ends <code>.data</code> get written to files ending ".data.dat"; any other non-functions will go to files ending ".txt". This does require you to use some discipline in naming objects, which is no bad thing; FWIW my "scripts" always do have names ending in <code>.r</code>, so that I can see what's what.
</p>
<p><code>fixr</code> creates a blank function template if the object doesn't exist already, or if <code>new=TRUE</code>. If you want to create a new character vector as opposed to a new function, call <code>fixtext</code>, or equivalently set <code>what=""</code> when you call <code>fixr</code>.
</p>
<p>If the function has attributes, the version in the text editor will be wrapped in a <code>structure(...)</code> construct (and you can do this yourself). If a <code>doc</code> attribute exists, it's printed as free-form text at the end of the file, and the call to <code>structure</code> will end with a line similar to:
</p>
<pre>
  ,doc=flatdoc( EOF="&lt;&lt;end of doc&gt;&gt;"))
</pre>
<p>When the file is sourced back in, that line will cause the rest of the file– which should be free-format text, with no escape characters etc.– to be read in as a <code>doc</code> attribute, which can be displayed by <code>help</code>. If you want to add plain-text documentation, you can also add these lines yourself– see <code>flatdoc</code>. Calling <code>fixr( myfun, new.doc=TRUE)</code> sets up a documentation template that you can fill in, ready for later conversion to Rd format in a package (see <code>mvbutils.packaging.tools</code>).
</p>
<p>The list of functions being edited by <code>fixr</code> is stored in the variable <code>fix.list</code> in the <code>mvb.session.info</code> environment. When you quit and restart R, the function files you have been using will stay open in the editor, but <code>fix.list</code> will be empty; hence, updating the file "myfun.r" will not update the corresponding R function. If this happens, just type <code>fixr(myfun)</code> in R and when your editor asks you if you want to replace the on-screen version, say no. Save the file again (some editors require a token modification, such as space-then-delete, first) and R will notice the update. Very very occasionally, you may want to tell R to stop trying to update one of the things it's editing, via eg <code>fixtext &lt;&lt;- fixtext[-3,]</code> if the offending thing is the third row in <code>fixlist</code>; note the double arrow.
</p>
<p>An automatic text backup facility is available from <code>fixr</code>: see <code>?get.backup</code>. The backup system also allows you to sort edited objects by edit date; see <code>?fix.order</code>.
</p>


<h4>Changes with r 2 14</h4>

<p>Time was, functions had their source code (including comments, author's preferred layout, etc) stored in a "source" attribute, a simple character vector that was automatically printed when you looked at the function. Thanks to the fiddly, convoluted, opaque "srcref" system that has replaced "source" as of R 2.14— to no real benefit that I can discern— <code>fixr</code> in versions of <code>mvbutils</code> prior to 2.5.209 didn't work correctly with R 2.14 up. Versions of <code>mvbutils</code> after 2.5.509 should work seamlessly.
</p>
<p>The technical point is that, from R 2.14 onwards, basic R will <em>not</em> show the <code>source</code> attribute when you type a function name without running the function; unless there is a <code>srcref</code> attribute, all you will see is the deparsed raw code. Not nice; so the replacement to <code>print.function</code> in <code>mvbutils</code> will show the <code>source</code> attribute if it and no <code>srcref</code> attribute is present. As soon as you change a function with <code>fixr</code> post-R-2.14, it automatically loses any <code>source</code> attribute and acquires a "proper" <code>srcref</code> attribute, which will from then on.
</p>



<h4>Local function groups</h4>

<p>There are several ways to work with "nested" (or "child" or "lisp-style macro") functions in R, thanks to R's scoping and environment rules; I've used at least four, most often <code>mlocal</code> in package <span class="pkg">mvbutils</span>. One is to keep a bunch of functions together in a <code>local</code> environment so that they (i) know about each other's existence and can access a shared variable pool, (ii) can be edited en bloc, but (iii) don't need to clutter up the "parent" code with the definitions of the children. <code>fixr</code> will happily create &amp; edit such a function-group, as long as you make sure the last statement in <code>local</code> evaluates to a function. For example:
</p>
<pre>
  # after typing 'fixr( secondfun)' in R, put this into your text editor:
  local({
    tot &lt;- 0
    firstfun &lt;- function( i) tot &lt;&lt;- tot+i
    function( j) {
        for( ii in 1:j)
          firstfun( ii)
        tot
      }
  })
</pre>
<p>Note that it's <em>not</em> necessary to assign the last definition to a variable inside the <code>local</code> call, unless you want to be able to reach that function recursively from one of the others, as in the first example for <code>local</code>. Note also that <code>firstfun</code> will not be visible "globally", only from within <code>secondfun</code> when it executes.
</p>
<p><code>secondfun</code> above can be debugged as usual with <code>mtrace</code> in the <span class="pkg">debug</span> package. If you want to turn on mtracing for <code>firstfun</code> without first mtracing <code>secondfun</code> and manually calling <code>mtrace(firstfun)</code> when <code>secondfun</code> appears, do <code>mtrace(firstfun, from=environment( secondfun))</code>.
</p>
<p><b>Note</b>: I <em>think</em> all this works OK in normal use (Oct 2012), but be careful! I doubt it works when building a package, and I'm not sure that R-core intend that it should; you might have to put the local-building code into the <code>.onLoad</code>.
</p>



<h4>Scriptlets</h4>

<p><b>Note</b>: I've really gone off "scriptlets" (writing this in mid 2016). These days I prefer to keep "scripts" as R character-vector objects (because I dislike having lots of separate files), edited by <code>fixtext</code> and manually executed as required by <code>debug::mrun</code>— which also has a debugging option that automatically applies <code>mtrace</code>. I'm not going to remove support for scriptlets in <code>fixr</code>, but I'm not going to try hard to sort out any bugs either. Instructions below are unchanged, and unchecked, from some years ago.
</p>
<p>You can also maintain "scriptlets" with <code>fixr</code>, by embedding the instructions (and comments etc) in an <code>expression(...)</code> statement. Obviously, the result will be an <code>expression</code>; to actually execute a scriptlet after editing it, use <code>eval()</code>. The scriptlet itself is stored in the "source" attribute as a character vector of class <code>cat</code>, and the expression itself is given class <code>thing.with.source</code> so that the source is displayed in preference to the raw expression. Backup files are maintained just as for functions. Only the <em>first</em> syntactically complete statement is returned by <code>fixr</code> (though subsequent material, including extra comments, is always retained in the <code>source</code> attribute); make sure you wrap everything you want done inside that call to <code>expression(...)</code>.
</p>
<p>Two cases I find useful are:
</p>

<ul>
<li>
<p> instructions to create data.frames or matrices by reading from a text file, and maybe doing some initial processing;
</p>
</li>
<li>
<p> expressions for complicated calls with particular datasets to model-fitting functions such as <code>glm</code>.
</p>
</li>
</ul>
<pre>
  # Object creator:
  expression( { # Brace needed for multiple steps
    raw.data &lt;- read.table( "bigfile.txt", header=TRUE, row=NULL)
    # Condense date/time char fields into something more useful:
    raw.data &lt;- within( raw.data, {
      Time &lt;- strptime( paste( DATE, TIME, sep=' '), format="%Y-%m-%d %H:%M:%S")
      rm( DATE, TIME)
    })
    cat( "'raw.data' created OK")
  })
</pre>
<p>and
</p>
<pre>
  # Complicated call:
  expression(
    glm( LHS ~ captain + beard %in% soup, data=alldata %where% (mushroom=='magic'), family=binomial( link=caterpillar))
  )
</pre>
<p>Bear in mind that <code>eval(myscriptlet)</code> takes place in <code>.GlobalEnv</code> unless you tell it not to, so the first example above actually creates <code>raw.data</code> even though it returns NULL. To trace evaluation of <code>myscriptlet</code> with the <span class="pkg">debug</span> package, call <code>debug.eval( myscriptlet)</code>.
</p>
<p>For a new scriptlet <code>mything</code>, the call to <code>fixr</code> should still just be <code>fixr(mything)</code>. However, if you have trouble with this, try <code>fixr( mything, what=list())</code> instead, even if <code>mything</code> won't be a <code>list()</code>. For an existing non-function, you'll need the <code>new=T</code> argument, e.g. <code>fixr( oldthing, new=T)</code>, and you'll then have to manually copy/paste the contents.
</p>
<p>Note that you <b>can't</b> use <code>quote()</code> instead of <code>expression()</code>, because any attempt to display the object will cause it to run instead; this is a quirk of S3 methods!
</p>


<h5>For the brave</h5>

<p>In principle, you can also edit non-expressions the same way. For example, you can create a <code>list</code> directly (not requiring subsequent <code>eval()</code>) via a scriptlet like this:
</p>
<pre>
  list(
    a = 1, # a number
    b = 'aardvark' # a character
  )
</pre>
<p>Nowadays I tend to avoid this, because the code will be executed immediately R detects a changed file, and you have no other (easy) control over when it's evaluated. Also, note that the result will have class <code>thing.with.source</code> (prepended to any other S3 classes it might have), which has its own print method that shows the source; hence you won't see the contents directly when you just type its name, which may or may not be desirable.
</p>




<h3>Troubleshooting</h3>

<p>Rarely, <code>fixr</code> (actually <code>FF</code>) can get confused, and starts returning errors when trying to update objects from their source files. (Switching between "types" of object with the same name— function, expression, character vector— can do this.) In such cases, it can be useful to purge the object from the <code>fix.list</code>, a session-duration data.frame object in workspace <code>mvb.session.info</code> on the search path. Say you are having trouble with object "badthing": then
</p>
<pre>
  fix.list &lt;&lt;- fix.list[ names( fix.list) != 'bad.thing',]
</pre>
<p>will do the trick (note the double arrow). This means <code>FF</code> will no longer look for updates to the source file for <code>badthing</code>, and you are free to again <code>fixr( badthing)</code>.
</p>
<p>To purge the entire <code>fix.list</code>, do this:
</p>

<p>fix.list &lt;&lt;- fix.list[ 0,]
</p>


<h3>Note</h3>

<p><code>fixr</code> is designed to be used with <code>cd</code>; I'm not sure it will work independently.
</p>
<p>Originally, <code>fixr</code> was only for functions, and not even for functions in packages, so that it was mostly an alternative to e.g. ESS; if you liked ESS, you wouldn't have bothered with <code>fixr</code>. However, <code>fixr</code> now has more sophisticated purposes, in particular being AFAIK the only reliable way of interfacing the package-maintenance features in the <span class="pkg">mvbutils</span> package. It would be interesting to find out if it can be integrated with e.g. ESS (which I know only enough about to dislike). Input welcome (but unexpected; none has ever come from ESSers).
</p>


<h3>See Also</h3>

<p><code>.First</code>, <code>edit</code>, <code>cd</code>, <code>get.backup</code>, <code>fix.order</code>, <code>move</code>
</p>


</div>