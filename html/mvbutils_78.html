<div class="container">

<table style="width: 100%;"><tr>
<td>flatdoc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Flat-format documentation</h2>

<h3>Description</h3>

<p>The <code>flatdoc</code> convention lets you edit plain-text documentation in the same file as your function's source code. <code>flatdoc</code> is hardly ever called explicitly, but you will see it in text files produced by <code>fixr</code>; you can also add it to such files yourself. <code>mvbutils</code> extends <code>help</code> so that <code>?myfunc</code> will display this type of documentation for <code>myfunc</code>, even if <code>myfunc</code> isn't in a package. There are no restrictions on the format of informal-help documentation, so <code>flatdoc</code> is useful for adding quick simple help just for you or for colleagues. If your function is to be part of a maintained package (see <code>mvbutils.packaging.tools</code>), then the documentation should follow a slightly more formal structure; use <code>fixr( myfun, new.doc=T)</code> to set up the appropriate template.
</p>


<h3>Usage</h3>

<pre><code class="language-R"># ALWAYS use it like this:
# structure( function( ...) {body},
# doc=flatdoc( EOF="&lt;&lt;end of doc&gt;&gt;"))
# plaintext doco goes here...
# NEVER use it like this:
flatdoc( EOF="&lt;&lt;end of doc&gt;&gt;")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code> EOF</code></td>
<td>
<p>character string showing when plain text ends, as in <code>readlines.mvb</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> body</code></td>
<td>
<p>replace with your function code</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> ...</code></td>
<td>
<p>replace with your function arg list</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Character vector of class <code>docattr</code>, as read from the <code>current.source()</code> (qv) connection. The print method for <code>docattr</code> objects just displays the string "# FLAT-FORMAT DOCUMENTATION", to avoid screen clutter.
</p>


<h3>Internal details</h3>

<p>This section can be safely ignored by almost all users.
</p>
<p>On some text editors, you can modify syntax highlighting so that the "start of comment block" marker is set to the string "doc=flatdoc(".
</p>
<p>It's possible to use <code>flatdoc</code> to read in more than one free-format text attribute. The <code>EOF</code> argument can be used to distinguish one block of free text from the next. These attributes can be accessed from your function via <code>attr( sys.function(), "&lt;&lt;attr.name&gt;&gt;")</code>, and this trick is occasionally useful to avoid having to include multi-line text blocks in your function code; it's syntactically clearer, and avoids having to escape quotes, etc. <code>mvbutils:::docskel</code> shows one example.
</p>
<p><code>fixr</code> uses <code>write.sourceable.function</code> to create text files that use the <code>flatdoc</code> convention. Its counterpart <code>FF</code> reads these files back in after they're edited. The reading-in is not done with <code>source</code> but rather with <code>source.mvb</code>, which understands <code>flatdoc</code>. The call to <code>doc=flatdoc</code> causes the rest of the file to be read in as plain text, and assigned to the <code>doc</code> attribute of the function. Documentation can optionally be terminated before the end of the file with the following line:
</p>
<pre>
  &lt;&lt;end of doc&gt;&gt;
</pre>
<p>or whatever string is given as the argument to <code>flatdoc</code>; this line will cause <code>source.mvb</code> to revert to normal statement processing mode for the rest of the file. Note that vanilla <code>source</code> will not respect <code>flatdoc</code>; you do need to use <code>source.mvb</code>.
</p>
<p><code>flatdoc</code> should never be called from the command line; it should only appear in text files designed for <code>source.mvb</code>.
</p>
<p><em>The rest of this section is probably obsolete, though things should still work.</em>
</p>
<p>If you are writing informal documentation for a group of functions together, you only need to <code>flatdoc</code> one of them, say <code>myfun1</code>. Informal help will work if you modify the others to e.g.
</p>
<pre>
  myfun2 &lt;- structure( function(...) { whatever}, doc=list("myfun1"))
</pre>
<p>If you are writing with <code>doc2Rd</code> in mind and a number of such functions are to be grouped together, e.g. a group of "internal" functions in preparation for formal package release, you may find <code>make.usage.section</code> and <code>make.arguments.section</code> helpful.
</p>


<h3>Author(s)</h3>

<p>Mark Bravington</p>


<h3>See Also</h3>

<p><code>source.mvb</code>, <code>doc2Rd</code>, <code>dochelp</code>, <code>write.sourceable.function</code>, <code>make.usage.section</code>,
</p>
<p><code>make.arguments.section</code>, <code>fixr</code>, the demo in "flatdoc.demo.R"
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Put next lines up to "&lt;&lt;end of doc&gt;&gt;" into a text file &lt;&lt;your filename&gt;&gt;
## and remove the initial hashes
#structure( function( x) {
#  x*x
#}
#,doc=flatdoc("&lt;&lt;end of doc&gt;&gt;"))
#
#Here is some informal documentation for the "SQUARE" function
#&lt;&lt;end of doc&gt;&gt;
## Now try SQUARE &lt;- source.mvb( &lt;&lt;your filename&gt;&gt;); ?SQUARE
## Example with multiple attributes
## Put the next lines up to "&lt;&lt;end of part 2&gt;&gt;"
## into a text file, and remove the single hashes
#myfun &lt;- structure( function( attname) {
#  attr( sys.function(), attname)
#}
#,  att1=flatdoc( EOF="&lt;&lt;end of part 1&gt;&gt;")
#,  att2=flatdoc( EOF="&lt;&lt;end of part 2&gt;&gt;"))
#This goes into "att1"
#&lt;&lt;end of part 1&gt;&gt;
#and this goes into "att2"
#&lt;&lt;end of part 2&gt;&gt;
## Now "source.mvb" that file, to create "myfun"; then:
myfun( 'att1') # "This goes into \\"att1\\""
myfun( 'att2') # "and this goes into \\"att2\\""

## End(Not run)
</code></pre>


</div>