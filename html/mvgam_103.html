<div class="container">

<table style="width: 100%;"><tr>
<td>plot_mvgam_factors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Latent factor summaries for a fitted mvgam object</h2>

<h3>Description</h3>

<p>This function takes a fitted <code>mvgam</code> object and returns plots and summary statistics for
the latent dynamic factors
</p>


<h3>Usage</h3>

<pre><code class="language-R">plot_mvgam_factors(object, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code>mvgam()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p><code>logical</code> specifying whether factors should be plotted</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the model in <code>object</code> was estimated using dynamic factors, it is possible that not all factors
contributed to the estimated trends. This is due to the regularisation penalty that acts independently on each
factor's Gaussian precision, which will squeeze un-needed factors to a white noise process (effectively dropping
that factor from the model). In this function, each factor is tested against a null hypothesis of white noise by
calculating the sum of the factor's 2nd derivatives. A factor that has a larger contribution will have a larger
sum due to the weaker penalty on the factor's precision. If
<code>plot == TRUE</code>, the factors are also plotted.
</p>


<h3>Value</h3>

<p>A <code>dataframe</code> of factor contributions and,
optionally, a series of base <code>R</code> plots
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class="language-R">
simdat &lt;- sim_mvgam()
mod &lt;- mvgam(y ~ s(season, bs = 'cc',
                  k = 6),
            trend_model = AR(),
            use_lv = TRUE,
            n_lv = 2,
            data = simdat$data_train,
            chains = 2)
plot_mvgam_factors(mod)

</code></pre>


</div>