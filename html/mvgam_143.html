<div class="container">

<table style="width: 100%;"><tr>
<td>score.mvgam_forecast</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute probabilistic forecast scores for mvgam objects</h2>

<h3>Description</h3>

<p>Compute probabilistic forecast scores for mvgam objects
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mvgam_forecast'
score(
  object,
  score = "crps",
  log = FALSE,
  weights,
  interval_width = 0.9,
  n_cores = 1,
  ...
)

score(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>mvgam_forecast</code> object. See <code>forecast.mvgam()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p><code>character</code> specifying the type of proper scoring rule to use for evaluation. Options are:
<code>sis</code> (i.e. the Scaled Interval Score), <code>energy</code>, <code>variogram</code>, <code>elpd</code>
(i.e. the Expected log pointwise Predictive Density),
<code>drps</code> (i.e. the Discrete Rank Probability Score) or <code>crps</code> (the Continuous Rank Probability Score).
Note that when choosing <code>elpd</code>, the supplied object must have forecasts on the <code>link</code> scale so that
expectations can be calculated prior to scoring. For all other scores, forecasts should be supplied
on the <code>response</code> scale (i.e. posterior predictions)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p><code>logical</code>. Should the forecasts and truths be logged prior to scoring?
This is often appropriate for comparing
performance of models when series vary in their observation ranges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional <code>vector</code> of weights (where <code>length(weights) == n_series</code>)
for weighting pairwise correlations when evaluating the variogram score for multivariate
forecasts. Useful for down-weighting series that have larger magnitude observations or that
are of less interest when forecasting. Ignored if <code>score != 'variogram'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval_width</code></td>
<td>
<p>proportional value on <code style="white-space: pre;">⁠[0.05,0.95]⁠</code> defining the forecast interval
for calculating coverage and, if <code>score = 'sis'</code>, for calculating the interval score</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p><code>integer</code> specifying number of cores for calculating scores in parallel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a <code>list</code> containing scores and interval coverages per forecast horizon.
If <code>score %in% c('drps', 'crps', 'elpd')</code>,
the list will also contain return the sum of all series-level scores per horizon. If
<code>score %in% c('energy','variogram')</code>, no series-level scores are computed and the only score returned
will be for all series. For all scores apart from <code>elpd</code>, the <code>in_interval</code> column in each series-level
slot is a binary indicator of whether or not the true value was within the forecast's corresponding
posterior empirical quantiles. Intervals are not calculated when using <code>elpd</code> because forecasts
will only contain the linear predictors
</p>


<h3>See Also</h3>

<p><code>forecast.mvgam</code>, <code>ensemble</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Simulate observations for three count-valued time series
data &lt;- sim_mvgam()
# Fit a dynamic model using 'newdata' to automatically produce forecasts
mod &lt;- mvgam(y ~ 1,
            trend_model = RW(),
            data = data$data_train,
            newdata = data$data_test,
            chains = 2)

# Extract forecasts into a 'mvgam_forecast' object
fc &lt;- forecast(mod)

# Compute Discrete Rank Probability Scores and 0.90 interval coverages
fc_scores &lt;- score(fc, score = 'drps')
str(fc_scores)

</code></pre>


</div>