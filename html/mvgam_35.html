<div class="container">

<table style="width: 100%;"><tr>
<td>gratia_mvgam_enhancements</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Enhance mvgam post-processing using gratia functionality</h2>

<h3>Description</h3>

<p>These evaluation and plotting functions exist to allow some popular <code>gratia</code>
methods to work with <code>mvgam</code> models
</p>


<h3>Usage</h3>

<pre><code class="language-R">drawDotmvgam(
  object,
  trend_effects = FALSE,
  data = NULL,
  select = NULL,
  parametric = FALSE,
  terms = NULL,
  residuals = FALSE,
  scales = c("free", "fixed"),
  ci_level = 0.95,
  n = 100,
  n_3d = 16,
  n_4d = 4,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  constant = NULL,
  fun = NULL,
  dist = 0.1,
  rug = TRUE,
  contour = TRUE,
  grouped_by = FALSE,
  ci_alpha = 0.2,
  ci_col = "black",
  smooth_col = "black",
  resid_col = "steelblue3",
  contour_col = "black",
  n_contour = NULL,
  partial_match = FALSE,
  discrete_colour = NULL,
  discrete_fill = NULL,
  continuous_colour = NULL,
  continuous_fill = NULL,
  position = "identity",
  angle = NULL,
  ncol = NULL,
  nrow = NULL,
  guides = "keep",
  widths = NULL,
  heights = NULL,
  crs = NULL,
  default_crs = NULL,
  lims_method = "cross",
  wrap = TRUE,
  envir = environment(formula(object)),
  ...
)

eval_smoothDothilbertDotsmooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  ...
)

eval_smoothDotmodDotsmooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  ...
)

eval_smoothDotmoiDotsmooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted mvgam, the result of a call to <code>mvgam()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend_effects</code></td>
<td>
<p>logical specifying whether smooth terms from the <code>trend_formula</code> should
be drawn. If <code>FALSE</code>, only terms from the observation formula are drawn. If <code>TRUE</code>, only
terms from the <code>trend_formula</code> are drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame of covariate values at which to evaluate the
model's smooth functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p>character, logical, or numeric; which smooths to plot. If
<code>NULL</code>, the default, then all model smooths are drawn.
Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parametric</code></td>
<td>
<p>logical; plot parametric terms also? Note that <code>select</code> is
used for selecting which smooths to plot. The <code>terms</code> argument is used to
select which parametric effects are plotted. The default, as with
<code>mgcv::plot.gam()</code>, is to not draw parametric effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>character; which model parametric terms should be drawn? The
Default of <code>NULL</code> will plot all parametric terms that can be drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>currently ignored for <code>mvgam</code> models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scales</code></td>
<td>
<p>character; should all univariate smooths be plotted with the
same y-axis scale? If <code>scales = "free"</code>, the default, each univariate
smooth has its own y-axis scale. If <code>scales = "fixed"</code>, a common y axis
scale is used for all univariate smooths.
</p>
<p>Currently does not affect the y-axis scale of plots of the parametric
terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci_level</code></td>
<td>
<p>numeric between 0 and 1; the coverage of credible interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>numeric; the number of points over the range of the covariate at
which to evaluate the smooth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_3d, n_4d</code></td>
<td>
<p>numeric; the number of points over the range of last
covariate in a 3D or 4D smooth. The default is <code>NULL</code> which achieves the
standard behaviour of using <code>n</code> points over the range of all covariate,
resulting in <code>n^d</code> evaluation points, where <code>d</code> is the dimension of the
smooth. For <code>d &gt; 2</code> this can result in very many evaluation points and slow
performance. For smooths of <code>d &gt; 4</code>, the value of <code>n_4d</code> will be used for
all dimensions <code style="white-space: pre;">⁠&gt; 4⁠</code>, unless this is <code>NULL</code>, in which case the default
behaviour (using <code>n</code> for all dimensions) will be observed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unconditional</code></td>
<td>
<p>ignored for <code>mvgam</code> models as all appropriate
uncertainties are already included in the posterior estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overall_uncertainty</code></td>
<td>
<p>ignored for <code>mvgam</code> models as all appropriate
uncertainties are already included in the posterior estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constant</code></td>
<td>
<p>numeric; a constant to add to the estimated values of the
smooth. <code>constant</code>, if supplied, will be added to the estimated value
before the confidence band is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>function; a function that will be applied to the estimated values
and confidence interval before plotting. Can be a function or the name of a
function. Function <code>fun</code> will be applied after adding any <code>constant</code>, if
provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>numeric; if greater than 0, this is used to determine when
a location is too far from data to be plotted when plotting 2-D smooths.
The data are scaled into the unit square before deciding what to exclude,
and <code>dist</code> is a distance within the unit square. See
<code>mgcv::exclude.too.far()</code> for further details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug</code></td>
<td>
<p>logical; draw a rug plot at the bottom of each plot for 1-D
smooths or plot locations of data for higher dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contour</code></td>
<td>
<p>logical; should contours be draw on the plot using
<code>ggplot2::geom_contour()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grouped_by</code></td>
<td>
<p>logical; should factor by smooths be drawn as one panel
per level of the factor (<code>FALSE</code>, the default), or should the individual
smooths be combined into a single panel containing all levels (<code>TRUE</code>)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci_alpha</code></td>
<td>
<p>numeric; alpha transparency for confidence or simultaneous
interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci_col</code></td>
<td>
<p>colour specification for the confidence/credible intervals
band. Affects the fill of the interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth_col</code></td>
<td>
<p>colour specification for the smooth line.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid_col</code></td>
<td>
<p>colour specification for residual points. Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contour_col</code></td>
<td>
<p>colour specification for contour lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_contour</code></td>
<td>
<p>numeric; the number of contour bins. Will result in
<code>n_contour - 1</code> contour lines being drawn. See <code>ggplot2::geom_contour()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete_colour</code></td>
<td>
<p>a suitable colour scale to be used when plotting
discrete variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete_fill</code></td>
<td>
<p>a suitable fill scale to be used when plotting
discrete variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>continuous_colour</code></td>
<td>
<p>a suitable colour scale to be used when plotting
continuous variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>continuous_fill</code></td>
<td>
<p>a suitable fill scale to be used when plotting
continuous variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code>ggplot2::guide_axis()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncol, nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code>patchwork::plot_layout()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>widths, heights</code></td>
<td>
<p>The relative widths and heights of each column and
row in the grid. Will get repeated to match the dimensions of the grid. If
there is more than 1 plot and <code>widths = NULL</code>, the value of <code>widths</code> will
be set internally to <code>widths = 1</code> to accommodate plots of smooths that
use a fixed aspect ratio.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crs</code></td>
<td>
<p>the coordinate reference system (CRS) to use for the plot. All
data will be projected into this CRS. See <code>ggplot2::coord_sf()</code> for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default_crs</code></td>
<td>
<p>the coordinate reference system (CRS) to use for the
non-sf layers in the plot. If left at the default <code>NULL</code>, the CRS used is
4326 (WGS84), which is appropriate for spline-on-the-sphere smooths, which
are parameterized in terms of latitude and longitude as coordinates. See
<code>ggplot2::coord_sf()</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lims_method</code></td>
<td>
<p>character; affects how the axis limits are determined. See
<code>ggplot2::coord_sf()</code>. Be careful; in testing of some examples, changing
this to <code>"orthogonal"</code> for example with the chlorophyll-a example from
Simon Wood's GAM book quickly used up all the RAM in my test system and the
OS killed R. This could be incorrect usage on my part; right now the grid
of points at which SOS smooths are evaluated (if not supplied by the user)
can produce invalid coordinates for the corners of tiles as the grid is
generated for tile centres without respect to the spacing of those tiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrap</code></td>
<td>
<p>logical; wrap plots as a patchwork? If <code>FALSE</code>, a list of
ggplot objects is returned, 1 per term plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>an environment to look up the data within.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p>a smooth object of class <code>"gp.smooth"</code> (returned from a model using either the
<code>dynamic()</code> function or the <code>gp()</code> function) or of class <code>"moi.smooth"</code> or <code>"mod.smooth"</code>
(returned from a model using the 'moi' or 'mod' basis).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a fitted <code>mgcv</code> model of clas <code>gam</code> or <code>bam</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These methods allow <code>mvgam</code> models to be <em>Enhanced</em> if users have the <code>gratia</code>
package installed, making available the popular <code>draw()</code> function to plot partial effects
of <code>mvgam</code> smooth functions using <code>ggplot2::ggplot()</code> utilities
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Fit a simple GAM and draw partial effects of smooths using gratia
set.seed(0)
library(ggplot2); theme_set(theme_bw())
library(gratia)
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
mod &lt;- mvgam(y ~ s(x1, bs = 'moi') +
              te(x0, x2), data = dat,
             family = gaussian())

draw(mod)

## End(Not run)
</code></pre>


</div>