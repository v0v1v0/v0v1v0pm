<div class="container">

<table style="width: 100%;"><tr>
<td>forecast.mvgam</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract or compute hindcasts and forecasts for a fitted <code>mvgam</code> object</h2>

<h3>Description</h3>

<p>Extract or compute hindcasts and forecasts for a fitted <code>mvgam</code> object
</p>


<h3>Usage</h3>

<pre><code class="language-R">forecast(object, ...)

## S3 method for class 'mvgam'
forecast(object, newdata, data_test, n_cores = 1, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code>mvgam()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
in addition to any other variables included in the linear predictor of the original <code>formula</code>. If included, the
covariate information in <code>newdata</code> will be used to generate forecasts from the fitted model equations. If
this same <code>newdata</code> was originally included in the call to <code>mvgam</code>, then forecasts have already been
produced by the generative model and these will simply be extracted and plotted. However if no <code>newdata</code> was
supplied to the original model call, an assumption is made that the <code>newdata</code> supplied here comes sequentially
after the data supplied in the original model (i.e. we assume there is no time gap between the last
observation of series 1 in the original data and the first observation for series 1 in <code>newdata</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p><code>integer</code> specifying number of cores for generating forecasts in parallel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>When this has the value <code>link</code> (default) the linear predictor is
calculated on the link scale.
If <code>expected</code> is used, predictions reflect the expectation of the response (the mean)
but ignore uncertainty in the observation process. When <code>response</code> is used,
the predictions take uncertainty in the observation process into account to return
predictions on the outcome scale. When <code>variance</code> is used, the variance of the response
with respect to the mean (mean-variance relationship) is returned.
When <code>type = "terms"</code>, each component of the linear predictor is
returned separately in the form of a <code>list</code> (possibly with standard
errors, if <code>summary = TRUE</code>): this includes parametric model components,
followed by each smooth component, but excludes any offset and any intercept.
Two special cases are also allowed:
type <code>latent_N</code> will return the estimated latent abundances from an
N-mixture distribution, while type <code>detection</code> will return the estimated
detection probability from an N-mixture distribution</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Posterior predictions are drawn from the fitted <code>mvgam</code> and used to simulate a forecast distribution
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_forecast</code> containing hindcast and forecast distributions.
See <code>mvgam_forecast-class</code> for details.
</p>


<h3>See Also</h3>

<p><code>hindcast</code>, <code>score</code>, <code>ensemble</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
simdat &lt;- sim_mvgam(n_series = 3, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train,
            chains = 2)

# Hindcasts on response scale
hc &lt;- hindcast(mod)
str(hc)
plot(hc, series = 1)
plot(hc, series = 2)
plot(hc, series = 3)

# Forecasts on response scale
fc &lt;- forecast(mod, newdata = simdat$data_test)
str(fc)
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

# Forecasts as expectations
fc &lt;- forecast(mod, newdata = simdat$data_test, type = 'expected')
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

# Dynamic trend extrapolations
fc &lt;- forecast(mod, newdata = simdat$data_test, type = 'trend')
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

</code></pre>


</div>