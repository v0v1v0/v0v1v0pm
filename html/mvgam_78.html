<div class="container">

<table style="width: 100%;"><tr>
<td>monotonic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Monotonic splines in mvgam</h2>

<h3>Description</h3>

<p>Uses constructors from package <span class="pkg">splines2</span> to build monotonically increasing
or decreasing splines. Details also in Wang &amp; Yan (2021).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'moi.smooth.spec'
smooth.construct(object, data, knots)

## S3 method for class 'mod.smooth.spec'
smooth.construct(object, data, knots)

## S3 method for class 'moi.smooth'
Predict.matrix(object, data)

## S3 method for class 'mod.smooth'
Predict.matrix(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A smooth specification object, usually generated by a term
<code>s(x, bs = "moi", ...)</code> or <code>s(x, bs = "mod", ...)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a list containing just the data (including any <code>by</code> variable) required by this term, 
with names corresponding to <code>object$term</code> (and <code>object$by</code>). The <code>by</code> variable 
is the last element.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>a list containing any knots supplied for basis setup — in same order and with same names as <code>data</code>. 
Can be <code>NULL</code>. See details for further information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The constructor is not normally called directly,
but is rather used internally by mvgam. If they are not supplied then the
knots of the spline are placed evenly throughout the covariate values to
which the term refers: For example, if fitting 101 data with an 11
knot spline of x then there would be a knot at every 10th (ordered) x value.
The spline is an implementation of the closed-form I-spline basis based
on the recursion formula given by Ramsay (1988), in which the basis coefficients
must be constrained to either be non-negative (for monotonically increasing
functions) or non-positive (monotonically decreasing)
<br><br>
Take note that when using either monotonic basis, the number of basis functions
<code>k</code> must be supplied as an even integer due to the manner in
which monotonic basis functions are constructed
</p>


<h3>Value</h3>

<p>An object of class <code>"moi.smooth"</code> or <code>"mod.smooth"</code>. In addition to
the usual elements of a smooth class documented under <code>smooth.construct</code>,
this object will contain a slot called <code>boundary</code> that defines the endpoints beyond
which the spline will begin extrapolating (extrapolation is flat due to the first
order penalty placed on the smooth function)
</p>


<h3>Note</h3>

<p>This constructor will result in a valid smooth if using a call to
<code>gam</code> or <code>bam</code>, however the resulting
functions will not be guaranteed to be monotonic because constraints on
basis coefficients will not be enforced
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Wang, Wenjie, and Jun Yan. "Shape-Restricted Regression Splines with R Package splines2."
Journal of Data Science 19.3 (2021).
<br><br>
Ramsay, J. O. (1988). Monotone regression splines in action. Statistical Science, 3(4), 425–441.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Simulate data from a monotonically increasing function
set.seed(123123)
x &lt;- runif(80) * 4 - 1
x &lt;- sort(x)
f &lt;- exp(4 * x) / (1 + exp(4 * x))
y &lt;- f + rnorm(80) * 0.1
plot(x, y)

# A standard TRPS smooth doesn't capture monotonicity
library(mgcv)
mod_data &lt;- data.frame(y = y, x = x)
mod &lt;- gam(y ~ s(x, k = 16),
           data = mod_data,
           family = gaussian())

library(marginaleffects)
plot_predictions(mod,
                 by = 'x',
                 newdata = data.frame(x = seq(min(x) - 0.5,
                                              max(x) + 0.5,
                                              length.out = 100)),
                 points = 0.5)

# Using the 'moi' basis in mvgam rectifies this
mod_data$time &lt;- 1:NROW(mod_data)
mod2 &lt;- mvgam(y ~ s(x, bs = 'moi', k = 18),
             data = mod_data,
             family = gaussian(),
             chains = 2)

plot_predictions(mod2,
                 by = 'x',
                 newdata = data.frame(x = seq(min(x) - 0.5,
                                              max(x) + 0.5,
                                              length.out = 100)),
                 points = 0.5)

plot(mod2, type = 'smooth', realisations = TRUE)

# 'by' terms that produce a different smooth for each level of the 'by'
# factor are also allowed
set.seed(123123)
x &lt;- runif(80) * 4 - 1
x &lt;- sort(x)

# Two different monotonic smooths, one for each factor level
f &lt;- exp(4 * x) / (1 + exp(4 * x))
f2 &lt;- exp(3.5 * x) / (1 + exp(3 * x))
fac &lt;- c(rep('a', 80), rep('b', 80))
y &lt;- c(f + rnorm(80) * 0.1,
       f2 + rnorm(80) * 0.2)
plot(x, y[1:80])
plot(x, y[81:160])

# Gather all data into a data.frame, including the factor 'by' variable
mod_data &lt;- data.frame(y, x, fac = as.factor(fac))
mod_data$time &lt;- 1:NROW(mod_data)

# Fit a model with different smooths per factor level
mod &lt;- mvgam(y ~ s(x, bs = 'moi', by = fac, k = 8),
             data = mod_data,
             family = gaussian(),
             chains = 2)

# Visualise the different monotonic functions
plot_predictions(mod, condition = c('x', 'fac', 'fac'),
                 points = 0.5)
plot(mod, type = 'smooth', realisations = TRUE)

# First derivatives (on the link scale) should never be
# negative for either factor level
(derivs &lt;- slopes(mod, variables = 'x',
                 by = c('x', 'fac'),
                 type = 'link'))
all(derivs$estimate &gt; 0)

</code></pre>


</div>