<div class="container">

<table style="width: 100%;"><tr>
<td>coeffs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functionality for <code>coeffs</code> objects</h2>

<h3>Description</h3>

<p>Function <code>coeffs()</code> allows arithmetic operators to be used for the
coefficients of multivariate polynomials, bearing in mind that the
order of coefficients is not determined.  It uses the <code>disord</code>
class of the <a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">coeffs(x)
vars(x)
powers(x)
coeffs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>disord</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>Object of class <code>disord</code>, or length-1 numeric vector</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>(much of the discussion below appears in the vignette of the
<a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> package). 
</p>
<p>Accessing elements of an <code>mvp</code> object is problematic because the
order of the terms of an <code>mvp</code> object is not well-defined.  This
is because the <code>map</code> class of the <code>STL</code> does not specify an
order for the key-value pairs (and indeed the actual order in which
they are stored may be implementation dependent).  The situation is
similar to the <code>hyper2</code> package which uses the <code>STL</code> in a
similar way.
</p>
<p>A <code>coeffs</code> object is a vector of coefficients of a <code>mvp</code>
object.  But it is not a conventional vector; in a conventional
vector, we can identify the first element unambiguously, and the
second, and so on.  An <code>mvp</code> is a map from terms to coefficients,
and a map has no intrinsic ordering: the maps
</p>
<pre>{x -&gt; 1, y -&gt; 3, xy^3 -&gt; 4}</pre>
<p>and </p>
<pre>{xy^3 -&gt; 4, x -&gt; 1, y -&gt; 3}</pre>
<p>are the same map and correspond to the same multinomial (symbolically,
<code class="reqn">x+3y+4xy^3=4xy^3+x+3y</code>).  Thus the coefficients of the
multinomial might be <code>c(1,3,4)</code> or <code>c(4,1,3)</code>, or indeed any
ordering.  But note that any particular ordering imposes an ordering
on the terms.  If we choose <code>c(1,3,4)</code> then the terms are
<code>x,y,xy^3</code>, and if we choose <code>c(4,1,3)</code> the terms are
<code>xy^3,x,y</code>.
</p>
<p>In the package, <code>coeffs()</code> returns an object of class
<code>disord</code>.  This class of object has a slot for the coefficients
in the form of a numeric R vector, but also another slot which uses
hash codes to prevent users from misusing the ordering of the numeric
vector.
</p>
<p>For example, a multinomial <code>x+2y+3z</code> might have coefficients
<code>c(1,2,3)</code> or <code>c(3,1,2)</code>.  Package idiom to extract the
coefficients of a multivariate polynomial <code>a</code> is
<code>coeffs(a)</code>; but this cannot return a standard numeric vector
because a numeric vector has elements in a particular order, and the
coefficients of a multivariate polynomial are stored in an
implementation-specific (and thus unknown) order.
</p>
<p>Suppose we have two multivariate polynomials, <code>a</code> as defined as
above with <code>a=x+2y+3z</code> and <code>b=x+3y+4z</code>.  Even though
<code>a+b</code> is well-defined algebraically, and <code>coeffs(a+b)</code> will
return a well-defined <code>mvp_coeffs</code> object, idiom such as
<code>coeffs(a) + coeffs(b)</code> is not defined because there is no
guarantee that the coefficients of the two multivariate polynomials
are stored in the same order.  We might have
<code>c(1,2,3)+c(1,3,4)=c(2,5,7)</code> or
<code>c(1,2,3)+c(1,4,3)=c(2,6,6)</code>, with neither being more
“correct” than the other.  In the package, <code>coeffs(a) +
  coeffs(b)</code> will return an error.  In the same way <code>coeffs(a) +
  1:3</code> is not defined and will return an error.  Further, idiom such as
<code>coeffs(a) &lt;- 1:3</code> and <code>coeffs(a) &lt;- coeffs(b)</code> are not
defined and will return an error.  However, note that <code>coeffs(a)
  + coeffs(a)</code> and <code>coeffs(a)+coeffs(a)^2</code> are fine, these
returning a <code>mvp_coeffs</code> object specific to <code>a</code>.
</p>
<p>Idiom such as <code>coeffs(a) &lt;- coeffs(a)^2</code> is fine too, for one
does not need to know the order of the coefficients on either side, so
long as the order is the same on both sides.  That would translate
into idiomatic English: “the coefficient of each term of
<code>a</code> becomes its square”; note that this operation is insensitive
to the order of coefficients.  The whole shebang is intended to make
idiom such as <code>coeffs(a) &lt;- coeffs(a)%%2</code> possible (so we can
manipulate polynomials over finite rings, here <code class="reqn">Z/2Z</code>).
</p>
<p>The replacement methods are defined so that an expression like
<code>coeffs(a)[coeffs(a) &gt; 5] &lt;- 5</code> works as expected; the English
idiom would be “Replace any coefficient greater than 5 with 5”.
</p>
<p>To fix ideas, consider <code>a &lt;- rmvp(8)</code>.  Extraction presents
issues; consider <code>coeffs(a)&lt;5</code>.  This object has Boolean elements
but has the same ordering ambiguity as <code>coeffs(a)</code>.  One might
expect that we could use this to extract elements of <code>coeffs(a)</code>,
specifically elements less than 5.  However,
<code>coeffs(a)[coeffs(a)&lt;5]</code> in isolation is meaningless: what can be
done with such an object?  However, it makes sense on the left hand
side of an assignment, as long as the right hand side is a length-one
vector.  Idiom such as
</p>

<ul>
<li>
<pre>coeffs(a)[coeffs(a)&lt;5] &lt;- 4+coeffs(a)[coeffs(a)&lt;5]</pre>
</li>
<li>
<pre>coeffs(a) &lt;- pmax(a,3)</pre>
</li>
</ul>
<p>is algebraically meaningful (“Add 4 to any element less than
5”; “coefficients become the pairwise maximum of themselves and
3”).  The <a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> package uses <code>pmaxdis()</code> rather than
<code>pmax()</code> for technical reasons.
</p>
<p>So the output of <code>coeffs(x)</code> is defined only up to an unknown
rearrangement.  The same considerations apply to the output of
<code>vars()</code>, which returns a list of character vectors in an
undefined order, and the output of <code>powers()</code>, which returns a
numeric list whose elements are in an undefined order.  However, even
though the order of these three objects is undefined individually,
their ordering is jointly consistent in the sense that the first
element of <code>coeffs(x)</code> corresponds to the first element of
<code>vars(x)</code> and the first element of <code>powers(x)</code>.  The
identity of this element is not defined—but whatever it is, the
first element of all three accessor methods refers to it.
</p>
<p>Note also that a single term (something like <code>4a^3*b*c^6</code>) has
the same issue: the variables are not stored in a well-defined order.
This does not matter because the algebraic value of the term does not
depend on the order in which the variables appear and this term would
be equivalent to <code>4b*c^6*a^3</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class="language-R">
(x &lt;- 5+rmvp(6))
(y &lt;- 2+rmvp(6))

coeffs(x)^2
coeffs(y) &lt;- coeffs(y)%%3  # fine, all coeffs of y now modulo 3
y

coeffs(y) &lt;- 4               
y

## Not run: 
coeffs(x) &lt;- coeffs(y)          # not defined, will give an error
coeffs(x) &lt;- seq_len(nterms(x)) # not defined, will give an error

## End(Not run)

</code></pre>


</div>