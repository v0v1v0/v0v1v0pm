<div class="container">

<table style="width: 100%;"><tr>
<td>StaPLR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stacked Penalized Logistic Regression</h2>

<h3>Description</h3>

<p>Fit a two-level stacked penalized (logistic) regression model with a single base-learner and a single meta-learner. Stacked penalized regression models with a Gaussian or Poisson outcome can be fitted using the family argument.
</p>


<h3>Usage</h3>

<pre><code class="language-R">StaPLR(
  x,
  y,
  view,
  view.names = NULL,
  family = "binomial",
  correct.for = NULL,
  alpha1 = 0,
  alpha2 = 1,
  relax = FALSE,
  nfolds = 10,
  na.action = "fail",
  na.arguments = NULL,
  seed = NULL,
  std.base = FALSE,
  std.meta = FALSE,
  ll1 = -Inf,
  ul1 = Inf,
  ll2 = 0,
  ul2 = Inf,
  cvloss = "deviance",
  metadat = "response",
  cvlambda = "lambda.min",
  cvparallel = FALSE,
  lambda.ratio = 1e-04,
  fdev = 0,
  penalty.weights.meta = NULL,
  penalty.weights.base = NULL,
  gamma.seq = c(0.5, 1, 2),
  parallel = FALSE,
  skip.version = TRUE,
  skip.meta = FALSE,
  skip.cv = FALSE,
  progress = TRUE,
  relax.base = FALSE,
  relax.meta = FALSE
)

staplr(
  x,
  y,
  view,
  view.names = NULL,
  family = "binomial",
  correct.for = NULL,
  alpha1 = 0,
  alpha2 = 1,
  relax = FALSE,
  nfolds = 10,
  na.action = "fail",
  na.arguments = NULL,
  seed = NULL,
  std.base = FALSE,
  std.meta = FALSE,
  ll1 = -Inf,
  ul1 = Inf,
  ll2 = 0,
  ul2 = Inf,
  cvloss = "deviance",
  metadat = "response",
  cvlambda = "lambda.min",
  cvparallel = FALSE,
  lambda.ratio = 1e-04,
  fdev = 0,
  penalty.weights.meta = NULL,
  penalty.weights.base = NULL,
  gamma.seq = c(0.5, 1, 2),
  parallel = FALSE,
  skip.version = TRUE,
  skip.meta = FALSE,
  skip.cv = FALSE,
  progress = TRUE,
  relax.base = FALSE,
  relax.meta = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input matrix of dimension nobs x nvars</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>outcome vector of length nobs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>view</code></td>
<td>
<p>a vector of length nvars, where each entry is an integer describing to which view each feature corresponds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>view.names</code></td>
<td>
<p>(optional) a character vector of length nviews specifying a name for each view.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Either a character string representing one of the built-in families, or else a <code>glm()</code> family object. 
For more information, see <code>family</code> argument's documentation in <code>glmnet</code>. Note
that "multinomial", "mgaussian", "cox", or 2-column responses with "binomial" family are not yet supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correct.for</code></td>
<td>
<p>(optional) a matrix with nrow = nobs, where each column is a feature which should be included directly into the meta.learner. By default these features are not penalized (see penalty.weights.meta) and appear at the top of the coefficient list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha1</code></td>
<td>
<p>(base) alpha parameter for glmnet: lasso(1) / ridge(0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha2</code></td>
<td>
<p>(meta) alpha parameter for glmnet: lasso(1) / ridge(0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relax</code></td>
<td>
<p>logical, whether relaxed lasso should be used at base and meta level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>number of folds to use for all cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>character specifying what to do with missing values (NA). Options are "pass", "fail", "mean", "mice", and "missForest". Options "mice" and "missForest" requires the respective R package to be installed. Defaults to "pass".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.arguments</code></td>
<td>
<p>(optional) a named list of arguments to pass to the imputation function (e.g. to <code>mice</code> or <code>missForest</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>(optional) numeric value specifying the seed. Setting the seed this way ensures the results are reproducible even when the computations are performed in parallel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.base</code></td>
<td>
<p>should features be standardized at the base level?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.meta</code></td>
<td>
<p>should cross-validated predictions be standardized at the meta level?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ll1</code></td>
<td>
<p>lower limit(s) for each coefficient at the base-level. Defaults to -Inf.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ul1</code></td>
<td>
<p>upper limit(s) for each coefficient at the base-level. Defaults to Inf.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ll2</code></td>
<td>
<p>lower limit(s) for each coefficient at the meta-level. Defaults to 0 (non-negativity constraints). Does not apply to correct.for features.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ul2</code></td>
<td>
<p>upper limit(s) for each coefficient at the meta-level. Defaults to Inf. Does not apply to correct.for features.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvloss</code></td>
<td>
<p>loss to use for cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metadat</code></td>
<td>
<p>which attribute of the base learners should be used as input for the meta learner? Allowed values are "response", "link", and "class".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvlambda</code></td>
<td>
<p>value of lambda at which cross-validated predictions are made. Defaults to the value giving minimum internal cross-validation error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvparallel</code></td>
<td>
<p>whether to use 'foreach' to fit each CV fold (DO NOT USE, USE OPTION parallel INSTEAD).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.ratio</code></td>
<td>
<p>the ratio between the largest and smallest lambda value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fdev</code></td>
<td>
<p>sets the minimum fractional change in deviance for stopping the path to the specified value, ignoring the value of fdev set through glmnet.control. Setting fdev=NULL will use the value set through glmnet.control instead. It is strongly recommended to use the default value of zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.weights.meta</code></td>
<td>
<p>(optional) either a vector of length nviews containing different penalty factors for the meta-learner, or "adaptive" to calculate the weights from the data. The default value NULL implies an equal penalty for each view. The penalty factor is set to 0 for <code>correct.for</code> features.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.weights.base</code></td>
<td>
<p>(optional) either a list of length nviews, where each entry is a vector containing different penalty factors for each feature in that view, or "adaptive" to calculate the weights from the data. The default value NULL implies an equal penalty for each view. Note that using adaptive weights at the base level is generally only sensible if <code>alpha1</code> &gt; 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma.seq</code></td>
<td>
<p>a sequence of gamma values over which to optimize the adaptive weights. Only used when <code>penalty.weights.meta="adaptive"</code> or <code>penalty.weights.base="adaptive"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>whether to use foreach to fit the base-learners and obtain the cross-validated predictions in parallel. Executes sequentially unless a parallel backend is registered beforehand.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip.version</code></td>
<td>
<p>whether to skip checking the version of the glmnet package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip.meta</code></td>
<td>
<p>whether to skip training the metalearner.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip.cv</code></td>
<td>
<p>whether to skip generating the cross-validated predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>whether to show a progress bar (only supported when parallel = FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relax.base</code></td>
<td>
<p>logical indicating whether relaxed lasso should be employed for fitting the base learners. If <code>TRUE</code>, then CV is done with respect to the mixing parameter gamma as well as lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relax.meta</code></td>
<td>
<p>logical indicating whether relaxed lasso should be employed for fitting the meta learner. If <code>TRUE</code>, then CV is done with respect to the mixing parameter gamma as well as lambda.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object with S3 class "StaPLR".
</p>


<h3>Author(s)</h3>

<p>Wouter van Loon &lt;w.s.van.loon@fsw.leidenuniv.nl&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(012)
n &lt;- 1000
cors &lt;- seq(0.1,0.7,0.1)
X &lt;- matrix(NA, nrow=n, ncol=length(cors)+1)
X[,1] &lt;- rnorm(n)

for(i in 1:length(cors)){
  X[,i+1] &lt;- X[,1]*cors[i] + rnorm(n, 0, sqrt(1-cors[i]^2))
}

beta &lt;- c(1,0,0,0,0,0,0,0)
eta &lt;- X %*% beta
p &lt;- exp(eta)/(1+exp(eta))
y &lt;- rbinom(n, 1, p) ## create binary response
view_index &lt;- rep(1:(ncol(X)/2), each=2)

# Stacked penalized logistic regression
fit &lt;- StaPLR(X, y, view_index)
coef(fit)$meta

new_X &lt;- matrix(rnorm(16), nrow=2)
predict(fit, new_X)

# Stacked penalized linear regression
y &lt;- eta + rnorm(100) ## create continuous response
fit &lt;- StaPLR(X, y, view_index, family = "gaussian")
coef(fit)$meta
coef(fit)$base
new_X &lt;- matrix(rnorm(16), nrow=2)
predict(fit, new_X)

# Stacked penalized Poisson regression
y &lt;- ceiling(eta + 4) ## create count response
fit &lt;- StaPLR(X, y, view_index, family = "poisson")
coef(fit)$meta
coef(fit)$base
new_X &lt;- matrix(rnorm(16), nrow=2)
predict(fit, new_X)

</code></pre>


</div>