<div class="container">

<table style="width: 100%;"><tr>
<td>ltMatrices</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Multiple Lower Triangular Matrices
</h2>

<h3>Description</h3>

<p>A class representing multiple lower triangular matrices and some methods.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ltMatrices(object, diag = FALSE, byrow = FALSE, names = TRUE)
## S3 method for class 'ltMatrices'
as.array(x, symmetric = FALSE, ...)
## S3 method for class 'syMatrices'
as.array(x, ...)
## S3 method for class 'ltMatrices'
diagonals(x, ...)
## S3 method for class 'syMatrices'
diagonals(x, ...)
## S3 method for class 'matrix'
diagonals(x, ...)
## S3 method for class 'integer'
diagonals(x, ...)
diagonals(x) &lt;- value
## S3 replacement method for class 'ltMatrices'
diagonals(x) &lt;- value
## S3 replacement method for class 'syMatrices'
diagonals(x) &lt;- value
## S3 method for class 'ltMatrices'
solve(a, b, transpose = FALSE, ...)
## S3 method for class 'syMatrices'
chol(x, ...)
## S3 method for class 'ltMatrices'
aperm(a, perm, is_chol = FALSE, ...)
Lower_tri(x, diag = FALSE, byrow = attr(x, "byrow"))
Mult(x, y, transpose = FALSE)
Tcrossprod(x, diag_only = FALSE)
Crossprod(x, diag_only = FALSE)
chol2cov(x)
invchol2chol(x)
chol2invchol(x)
invchol2cov(x)
invchol2pre(x)
chol2pre(x)
Dchol(x, D = 1 / sqrt(Tcrossprod(x, diag_only = TRUE)))
invcholD(x, D = sqrt(Tcrossprod(solve(x), diag_only = TRUE)))
chol2cor(x)
invchol2cor(x)
chol2pc(x)
invchol2pc(x)
vectrick(C, S, A, transpose = c(TRUE, TRUE))
standardize(chol, invchol)
destandardize(chol = solve(invchol), invchol, score_schol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a <code>matrix</code> representing the lower triagular elements of
<code class="reqn">N</code> lower triangular matrix, each of dimension <code class="reqn">J \times
                J</code>. Dimensions of <code>object</code> depend on <code>diag</code>: With
diagonal elements, <code>object</code> is a <code class="reqn">J(J+1)/2 \times N</code> matrix,
otherwise, the number of rows is <code class="reqn">J(J - 1) / 2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>
<p>logical, <code>object</code> contains diagonal elements if
<code>TRUE</code>, otherwise unit diagonal elements are assumed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>byrow</code></td>
<td>
<p>logical, <code>object</code> represents matrices in row-major order
if <code>TRUE</code> or, otherwise, in column-major order.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>logical or character vector of length <code class="reqn">J</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>logical, object is interpreted as a symmetric matrix if
<code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag_only</code></td>
<td>
<p>logical, compute diagonal elements of crossproduct only
if <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x,chol,invchol</code></td>
<td>
<p>object of class <code>ltMatrices</code> or <code>syMatrices</code> (for <code>chol</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>a matrix of diagonal elements to be assigned (of dimension <code class="reqn">J \times N</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>object of class <code>ltMatrices</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perm</code></td>
<td>
<p>a permutation of the covariance matrix corresponding to <code>a</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_chol</code></td>
<td>
<p>a logical indicating if <code>a</code> is the Cholesky of the
covariance (<code>chol = TRUE</code>) of the precision matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>a matrix (of dimension <code class="reqn">J \times N</code>) of diagonal elements to be multiplied with.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>matrix with <code class="reqn">J</code> rows.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>matrix with <code class="reqn">J</code> rows.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>an object of class <code>ltMatrices</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>an object of class <code>ltMatrices</code> or a matrix with <code class="reqn">J^2</code> rows 
representing multiple <code class="reqn">J x J</code> matrices (columns of vec operators).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>an object of class <code>ltMatrices</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transpose</code></td>
<td>
<p>a logical of length two indicating if <code>A</code> or <code>B</code> shall be transposed in <code>vectrick</code>.
For <code>solve</code>, this argument being true computes
<code>solve(t(a), b)</code> (in absence of a <code>t()</code> method for <code>ltMatrices</code>
objects).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score_schol</code></td>
<td>
<p>score matrix for a standardized <code>chol</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments, currently ignored.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>ltMatrices</code> interprets a matrix as lower triangular elements of
multiple lower triangular matrices. The corresponding class can be used to
store such matrices efficiently. Matrix multiplications, solutions to linear
systems, explicite inverses, and crossproducts can be computed based on such
objects. Details can be found in the <code>lmvnorm_src</code> package vignette.
</p>


<h3>Value</h3>

<p>The constructor <code>ltMatrices</code> returns objects of class <code>ltMatrices</code>
with corresponding methods.
</p>


<h3>See Also</h3>

<p><code>vignette("lmvnorm_src", package = "mvtnorm")</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
  J &lt;- 4L
  N &lt;- 2L
  dm &lt;- paste0("d", 1:J)
  xm &lt;- paste0("x", 1:N)
  (C &lt;- ltMatrices(matrix(runif(N * J * (J + 1) / 2), 
                          ncol = N, dimnames = list(NULL, xm)), 
                   diag = TRUE, names = dm))

  ## dimensions and names
  dim(C)
  dimnames(C)
  names(C)

  ## subset
  C[,2:3]

  ## multiplication
  y &lt;- matrix(runif(N * J), nrow = J)
  Mult(C, y)

  ## solve
  solve(C)
  solve(C, y)

  ## tcrossprod
  Tcrossprod(C)

  ## convert to matrix
  as.array(solve(C[1,]))[,,1]

</code></pre>


</div>