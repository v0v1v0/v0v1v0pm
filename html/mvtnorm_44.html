<div class="container">

<table style="width: 100%;"><tr>
<td>qmvnorm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Quantiles of the Multivariate Normal Distribution </h2>

<h3>Description</h3>

<p>Computes the equicoordinate quantile function of the multivariate normal
distribution for arbitrary correlation matrices
based on inversion of <code>pmvnorm</code>, using a stochastic root
finding algorithm described in Bornkamp (2018).
</p>


<h3>Usage</h3>

<pre><code class="language-R">qmvnorm(p, interval = NULL, tail = c("lower.tail", "upper.tail", "both.tails"), 
        mean = 0, corr = NULL, sigma = NULL, algorithm = GenzBretz(),
        ptol = 0.001, maxiter = 500, trace = FALSE, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p> probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p> optional, a vector containing the end-points of the
interval to be searched. Does not need to contain the true quantile,
just used as starting values by the root-finder. If equal to NULL
a guess is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tail</code></td>
<td>
<p> specifies which quantiles should be computed.
<code>lower.tail</code> gives the quantile <code class="reqn">x</code> for which 
<code class="reqn">P[X \le x] = p</code>, <code>upper.tail</code> gives <code class="reqn">x</code> with 
<code class="reqn">P[X &gt; x] = p</code> and 
<code>both.tails</code> leads to <code class="reqn">x</code> 
with <code class="reqn">P[-x \le X \le x] = p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p> the mean vector of length n. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr</code></td>
<td>
<p> the correlation matrix of dimension n.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p> the covariance matrix of dimension n. Either <code>corr</code> or
<code>sigma</code> can be specified. If <code>sigma</code> is given, the
problem is standardized internally. If <code>corr</code> is given,
it is assumed that appropriate standardization was performed
by the user. If neither <code>corr</code> nor
<code>sigma</code> is given, the identity matrix is used
for <code>sigma</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p> an object of class <code>GenzBretz</code>,
<code>Miwa</code> or <code>TVPACK</code>
specifying both the algorithm to be used as well as
the associated hyper parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ptol, maxiter, trace</code></td>
<td>
<p>Parameters passed to the stochastic root-finding
algorithm. Iteration stops when the 95% confidence interval
for the predicted quantile is inside [p-ptol, p+ptol]. <code>maxiter</code> is the
maximum number of iterations for the root finding algorithm. <code>trace</code>
prints the iterations of the root finder.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>an object specifying if and how the random number generator
should be initialized, see <code>simulate</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional parameters to be passed to 
<code>GenzBretz</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Only equicoordinate quantiles are computed, i.e., the quantiles in each
dimension coincide. The result is seed dependend.
</p>


<h3>Value</h3>

<p>A list with two components: <code>quantile</code> and <code>f.quantile</code> 
give the location of the quantile and the difference between the distribution
function evaluated at the quantile and <code>p</code>. 
</p>


<h3>References</h3>

<p>Bornkamp, B. (2018). Calculating quantiles of noisy distribution
functions using local linear regressions. <em>Computational
Statistics</em>, <b>33</b>, 487â€“501.
</p>


<h3>See Also</h3>

<p><code>pmvnorm</code>, <code>qmvt</code></p>


<h3>Examples</h3>

<pre><code class="language-R">qmvnorm(0.95, sigma = diag(2), tail = "both")
</code></pre>


</div>