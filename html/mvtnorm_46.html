<div class="container">

<table style="width: 100%;"><tr>
<td>Mvnorm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multivariate Normal Density and Random Deviates</h2>

<h3>Description</h3>

<p>These functions provide the density function and a random number
generator for the multivariate normal
distribution with mean equal to <code>mean</code> and covariance matrix
<code>sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dmvnorm(x, mean = rep(0, p), sigma = diag(p), log = FALSE, checkSymmetry = TRUE)
rmvnorm(n, mean = rep(0, nrow(sigma)), sigma = diag(length(mean)),
           method=c("eigen", "svd", "chol"), pre0.9_9994 = FALSE, 
           checkSymmetry = TRUE, rnorm = stats::rnorm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector or matrix of quantiles. When <code>x</code> is a matrix, each
row is taken to be a quantile and columns correspond to the number of dimensions, 
<code>p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p>mean vector, default is <code>rep(0, length = ncol(x))</code>.
In <code>ldmvnorm</code> or 
<code>sldmvnorm</code>, <code>mean</code> is a matrix with
observation-specific means arranged in columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>covariance matrix, default is <code>diag(ncol(x))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical; if <code>TRUE</code>, densities d are given as log(d).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>string specifying the matrix decomposition used to
determine the matrix root of <code>sigma</code>.  Possible methods are
eigenvalue decomposition (<code>"eigen"</code>, default),
singular value decomposition (<code>"svd"</code>), and
Cholesky decomposition (<code>"chol"</code>).  The
Cholesky is typically fastest, not by much though.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre0.9_9994</code></td>
<td>
<p>logical; if <code>FALSE</code>, the output produced in mvtnorm
versions up to 0.9-9993 is reproduced. In 0.9-9994, the
output is organized such that <code>rmvnorm(10,...)</code> has the
same first ten rows as <code>rmvnorm(100, ...)</code> when called
with the same seed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkSymmetry</code></td>
<td>
<p>logical; if <code>FALSE</code>, skip checking whether the
covariance matrix is symmetric or not. This will speed up the
computation but may cause unexpected outputs when ill-behaved
<code>sigma</code> is provided. The default value is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rnorm</code></td>
<td>
<p>a function with the same interface as
<code>rnorm</code>. This allows switching to other generators of
standard normal variables.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>dmvnorm</code> computes the density function of the multivariate normal
specified by mean and the covariance matrix <code>sigma</code>. 
</p>
<p><code>rmvnorm</code> generates multivariate normal variables. 
</p>


<h3>See Also</h3>

<p><code>pmvnorm</code>, <code>rnorm</code>, <code>qmvnorm</code>,
<code>vignette("lmvnorm_src", package = "mvtnorm")</code></p>


<h3>Examples</h3>

<pre><code class="language-R">dmvnorm(x=c(0,0))
dmvnorm(x=c(0,0), mean=c(1,1))

sigma &lt;- matrix(c(4,2,2,3), ncol=2)
x &lt;- rmvnorm(n=500, mean=c(1,2), sigma=sigma)
colMeans(x)
var(x)
dS &lt;- dmvnorm(x, sigma = sigma)

### alternative interface
C &lt;- t(chol(sigma))
(C &lt;- ltMatrices(C[lower.tri(C, diag = TRUE)], diag = TRUE))
dC &lt;- exp(ldmvnorm(obs = t(x), chol = C, logLik = FALSE))
all.equal(dS, dC)

x &lt;- rmvnorm(n=500, mean=c(1,2), sigma=sigma, method="chol")
colMeans(x)
var(x)

plot(x)
</code></pre>


</div>