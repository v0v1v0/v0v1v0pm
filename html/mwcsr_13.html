<div class="container">

<table style="width: 100%;"><tr>
<td>rmwcs_solver</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate a rmwcs solver</h2>

<h3>Description</h3>

<p>The method is based on relax-and-cut approach and allows to solve
Maximum Weight Subgraph Probleam and its budget and cardinality variants.
By constructing lagrangian
relaxation of MWCS problem necessary graph connectivity constraints are introduced
in the objective function giving upper bound on the weight of the optimal
solution. On the other side, primal heuristic uses individul contribution
of the variables to lagrangian relaxation to find possible solution of the initial
problem. The relaxation is then optimized by using iterative subgradient method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rmwcs_solver(
  timelimit = 1800L,
  max_iterations = 1000L,
  beta_iterations = 5L,
  separation = "strong",
  start_constraints = TRUE,
  pegging = TRUE,
  max_age = 10,
  sep_iterations = 10L,
  sep_iter_freeze = 50L,
  heur_iterations = 10L,
  subgradient = "classic",
  beta = 2,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>timelimit</code></td>
<td>
<p>Timelimit in seconds</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iterations</code></td>
<td>
<p>Maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_iterations</code></td>
<td>
<p>Number of nonimproving iterations until beta is halved</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>separation</code></td>
<td>
<p>Separation: "strong" or "fast"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_constraints</code></td>
<td>
<p>Whether to add flow-conservation/degree constraints at start</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pegging</code></td>
<td>
<p>variable fixing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_age</code></td>
<td>
<p>number of iterations in aging procedure for non-violated  cuts</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep_iterations</code></td>
<td>
<p>Frequency of separating cuts (in iterations)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep_iter_freeze</code></td>
<td>
<p>Number of iterations when a newly separated cut is anaffected by subgradient algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heur_iterations</code></td>
<td>
<p>Frequency of calling heuristic method (in iterations)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subgradient</code></td>
<td>
<p>Subgradient: "classic", "average", "cft"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Initial step size of subgradient algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Should the solving progress and stats be printed?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>One iteration of algorithm includes solving lagrangian relaxation and updating
lagrange multipliers. It may also contain cuts (or connectivity constraints) separation process, run of
heuristic method, variable fixing routine. The initial step size for
subgradient method can be passed as <code>beta</code> argument. If there is no improvement in
upper bound in consequtive <code>beta_iterations</code> iterations the step size is
halved. There are three possible strategies for updating multipliers. See the references
section for the article where differences are discussed.
</p>
<p>Some initial cuts are added at the start of the algorithm if <code>start_constraints</code>
is set to <code>TRUE</code>. Other constraints are separated on the fly and are
unaffected in the next <code>sep_iter_freeze</code> iterations of the subgradient mehod.
Then the corresponding lagrange mutipliers are updated from iteration to iteration.
Aging procedure for cuts is incorporated in the algorithm meaning constraint multipliers
are updated for non-violated cuts for up to <code>max_age</code> iterations from
the point where a cut was violated last time. There are two separation methods
implemented: fast and strong, where tha latter is supposed to minimize number of
variables used in generated constraint while in the former case there is no need to explore
whole graph to construct a constraint.
</p>
<p>A variant of MST approximation of PCSTP is used as Primal Heuristic.
See references for more details.
</p>
<p>The frequences
of running separation process and heuristic are specified in
<code>sep_iterations</code> and <code>heur_iterations</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>mwcs_solver</code>.
</p>


<h3>References</h3>

<p>√Ålvarez-Miranda E., Sinnl M. (2017)
"A Relax-and-Cut framework for large-scale maximum weight connected subgraph problems"
<a href="https://doi.org/10.1016/j.cor.2017.05.015">doi:10.1016/j.cor.2017.05.015</a>
</p>


</div>