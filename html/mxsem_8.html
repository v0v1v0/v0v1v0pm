<div class="container">

<table style="width: 100%;"><tr>
<td>mxsem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>mxsem</h2>

<h3>Description</h3>

<p>Create an extended SEM with <strong>OpenMx</strong> (Boker et al., 2011) using a
<strong>lavaan</strong>-style (Rosseel, 2012) syntax.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mxsem(
  model,
  data,
  scale_loadings = TRUE,
  scale_latent_variances = FALSE,
  add_intercepts = TRUE,
  add_variances = TRUE,
  add_exogenous_latent_covariances = TRUE,
  add_exogenous_manifest_covariances = TRUE,
  lbound_variances = TRUE,
  directed = unicode_directed(),
  undirected = unicode_undirected(),
  return_parameter_table = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>model syntax similar to <strong>lavaan</strong>'s syntax</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>raw data used to fit the model. Alternatively, an object created
with <code>OpenMx::mxData</code> can be used (e.g., <code>OpenMx::mxData(observed = cov(OpenMx::Bollen), means = colMeans(OpenMx::Bollen), numObs = nrow(OpenMx::Bollen), type = "cov")</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_loadings</code></td>
<td>
<p>should the first loading of each latent variable be used for scaling?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_latent_variances</code></td>
<td>
<p>should the latent variances be used for scaling?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_intercepts</code></td>
<td>
<p>should intercepts for manifest variables be added automatically? If set to false, intercepts must be added manually. If no intercepts
are added, <strong>mxsem</strong> will automatically use just the observed covariances and not the observed means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_variances</code></td>
<td>
<p>should variances for manifest and latent variables be added automatically?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_exogenous_latent_covariances</code></td>
<td>
<p>should covariances between exogenous latent variables be
added automatically?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_exogenous_manifest_covariances</code></td>
<td>
<p>should covariances between exogenous manifest variables be
added automatically?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbound_variances</code></td>
<td>
<p>should the lower bound for variances be set to 0.000001?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directed</code></td>
<td>
<p>symbol used to indicate directed effects (regressions and loadings)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>undirected</code></td>
<td>
<p>symbol used to indicate undirected effects (variances and covariances)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_parameter_table</code></td>
<td>
<p>if set to TRUE, the internal parameter table is returend
together with the mxModel</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Setting up SEM can be tedious. The <strong>lavaan</strong> (Rosseel, 2012) package provides a great syntax to
make the process easier. The objective of <strong>mxsem</strong> is to provide a similar syntax
for <strong>OpenMx</strong>. <strong>OpenMx</strong> is a flexible R package for extended SEM. However, note that
<strong>mxsem</strong> only covers a small part of the <strong>OpenMx</strong> framework by focusing on "standard"
SEM. Similar to <strong>lavaan</strong>'s <code>sem()</code>-function, <code>mxsem</code> tries to set up parts
of the model automatically (e.g., adding variances automatically or scaling the
latent variables automatically). If you want to unlock
the full potential of <strong>OpenMx</strong>, <strong>mxsem</strong> may not be the best option.
</p>
<p><strong>Warning</strong>: The syntax and settings of <strong>mxsem</strong> may differ from
<strong>lavaan</strong> in some cases. See <code>vignette("Syntax", package = "mxsem")</code> for more details
on the syntax and the default arguments.
</p>


<h4>Alternatives</h4>

<p>You will find similar functions in the following packages:
</p>

<ul>
<li> <p><a href="https://github.com/mikewlcheung/metasem"><strong>metaSEM</strong></a> (Cheung, 2015) provides a <code>lavaan2RAM</code>
function that can be combined with the <code>create.mxModel</code> function. This combination
offers more features than <strong>mxsem</strong>. For instance, constraints of the form <code>a &lt; b</code>
are supported. In <strong>mxsem</strong> such constraints require algebras (e.g., <code style="white-space: pre;">⁠!diff; a := b - exp(diff)⁠</code>).
</p>
</li>
<li> <p><a href="https://github.com/tbates/umx"><strong>umx</strong></a> (Bates et al., 2019)
provides the <code>umxRAM</code> and <code>umxLav2RAM</code> functions that can parse single <strong>lavaan</strong>-style
statements (e.g., <code>eta =~ y1 + y2 + y3</code>)
or an entire <strong>lavaan</strong> models to <strong>OpenMx</strong> models.
</p>
</li>
<li> <p><a href="https://github.com/cjvanlissa/tidySEM"><strong>tidySEM</strong></a> (van Lissa, 2023) provides the
<code>as_ram</code> function to translate <strong>lavaan</strong> syntax to <strong>OpenMx</strong> and also implements a unified syntax to
specify both, <strong>lavaan</strong> and <strong>OpenMx</strong> models. Additionally, it works well with the
<strong>tidyverse</strong>.
</p>
</li>
<li> <p><a href="https://github.com/OpenMx/ezMx"><strong>ezMx</strong></a> (Bates, et al. 2014) simplifies fitting SEM with <strong>OpenMx</strong>
and also provides a translation of <strong>lavaan</strong> models to <strong>OpenMx</strong> with the
<code>lavaan.to.OpenMx</code> function.
</p>
</li>
</ul>
<p>Because <strong>mxsem</strong> implements the syntax parser from scratch, it can extend the
<strong>lavaan</strong> syntax to account for specific <strong>OpenMx</strong> features. This enables
implicit transformations with curly braces.
</p>



<h4>Citation</h4>

<p>Cite <strong>OpenMx</strong> (Boker et al., 2011) for the modeling and <strong>lavaan</strong> for the
syntax (Rosseel, 2012). <strong>mxsem</strong> itself is just a very small package and lets
<strong>OpenMx</strong> do all the heavy lifting.
</p>



<h4>Defaults</h4>

<p>By default, <strong>mxsem</strong> scales latent variables by setting the loadings on the first
item to 1. This can be changed by setting <code>scale_loadings = FALSE</code> in the function
call. Setting <code>scale_latent_variances = TRUE</code> sets latent variances to 1 for
scaling.
</p>
<p><strong>mxsem</strong> will add intercepts for all manifest variables as well as variances for
all manifest and latent variables. A lower bound of 1e-6 will be added to all
variances. Finally, covariances for all exogenous variables will be added.
All of these options can be changed when calling <strong>mxsem</strong>.
</p>



<h4>Syntax</h4>

<p>The syntax is, for the most part, identical to that of <strong>lavaan</strong>. The following
specifies loadings of a latent variable <code>eta</code> on manifest variables <code>y1</code>-<code>y4</code>:
</p>
<div class="sourceCode"><pre>eta =~ y1 + y2 + y3
</pre></div>
<p>Regressions are specified with <code>~</code>:
</p>
<div class="sourceCode"><pre>xi  =~ x1 + x2 + x3
eta =~ y1 + y2 + y3
# predict eta with xi:
eta ~  xi
</pre></div>
<p>Add covariances with <code style="white-space: pre;">⁠~~⁠</code>
</p>
<div class="sourceCode"><pre>xi  =~ x1 + x2 + x3
eta =~ y1 + y2 + y3
# predict eta with xi:
eta ~  xi
x1 ~~ x2
</pre></div>
<p>Intercepts are specified with <code>~1</code>
</p>
<div class="sourceCode"><pre>xi  =~ x1 + x2 + x3
eta =~ y1 + y2 + y3
# predict eta with xi:
eta ~  xi
x1 ~~ x2

eta ~ 1
</pre></div>



<h4>Parameter labels and constraints</h4>

<p>Add labels to parameters as follows:
</p>
<div class="sourceCode"><pre>xi  =~ l1*x1 + l2*x2 + l3*x3
eta =~ l4*y1 + l5*y2 + l6*y3
# predict eta with xi:
eta ~  b*xi
</pre></div>
<p>Fix parameters by using numeric values instead of labels:
</p>
<div class="sourceCode"><pre>xi  =~ 1*x1 + l2*x2 + l3*x3
eta =~ 1*y1 + l5*y2 + l6*y3
# predict eta with xi:
eta ~  b*xi
</pre></div>



<h4>Bounds</h4>

<p>Lower and upper bounds allow for constraints on parameters. For instance,
a lower bound can prevent negative variances.
</p>
<div class="sourceCode"><pre>xi  =~ 1*x1 + l2*x2 + l3*x3
eta =~ 1*y1 + l5*y2 + l6*y3
# predict eta with xi:
eta ~  b*xi
# residual variance for x1
x1 ~~ v*x1
# bound:
v &gt; 0
</pre></div>
<p>Upper bounds are specified with v &lt; 10. Note that the parameter label must always
come first. The following is not allowed: <code>0 &lt; v</code> or <code>10 &gt; v</code>.
</p>



<h4>(Non-)linear constraints</h4>

<p>Assume that latent construct <code>eta</code> was observed twice, where <code>eta1</code> is the first
observation and <code>eta2</code> the second. We want to define the loadings of <code>eta2</code>
on its observations as <code>l_1 + delta_l1</code>. If <code>delta_l1</code> is zero, we have measurement
invariance.
</p>
<div class="sourceCode"><pre>eta1 =~ l1*y1 + l2*y2 + l3*y3
eta2 =~ l4*y4 + l5*y5 + l6*y6
# define new delta-parameter
!delta_1; !delta_2; !delta_3
# redefine l4-l6
l4 := l1 + delta_1
l5 := l2 + delta_2
l6 := l3 + delta_3
</pre></div>
<p>Alternatively, implicit transformations can be used as follows:
</p>
<div class="sourceCode"><pre>eta1 =~ l1*y1 + l2*y2 + l3*y3
eta2 =~ {l1 + delta_1} * y4 + {l2 + delta_2} * y5 + {l3 + delta_3} * y6
</pre></div>
<p>Specific labels for the transformation results can also be provided:
</p>
<div class="sourceCode"><pre>eta1 =~ l1*y1 + l2*y2 + l3*y3
eta2 =~ {l4 := l1 + delta_1} * y4 + {l5 := l2 + delta_2} * y5 + {l6 := l3 + delta_3} * y6
</pre></div>
<p>This is inspired by the approach in <strong>metaSEM</strong> (Cheung, 2015).
</p>



<h4>Definition variables</h4>

<p>Definition variables allow for person-specific parameter constraints. Use the
<code>data.</code>-prefix to specify definition variables.
</p>
<div class="sourceCode"><pre>I =~ 1*y1 + 1*y2 + 1*y3 + 1*y4 + 1*y5
S =~ data.t_1 * y1 + data.t_2 * y2 + data.t_3 * y3 + data.t_4 * y4 + data.t_5 * y5

I ~ int*1
S ~ slp*1
</pre></div>



<h4>Starting Values</h4>

<p><strong>mxsem</strong> differs from <strong>lavaan</strong> in the specification of starting values. Instead
of providing starting values in the model syntax, the <code>set_starting_values</code>
function is used.
</p>



<h4>References</h4>


<ul>
<li>
<p> Bates, T. C., Maes, H., &amp; Neale, M. C. (2019). umx: Twin and Path-Based Structural Equation Modeling in R. Twin Research and Human Genetics, 22(1), 27–41. https://doi.org/10.1017/thg.2019.2
</p>
</li>
<li>
<p> Bates, T. C., Prindle, J. J. (2014). ezMx. https://github.com/OpenMx/ezMx
</p>
</li>
<li>
<p> Boker, S. M., Neale, M., Maes, H., Wilde, M., Spiegel, M., Brick, T., Spies, J., Estabrook, R., Kenny, S., Bates, T., Mehta, P., &amp; Fox, J. (2011).
OpenMx: An Open Source Extended Structural Equation Modeling Framework. Psychometrika, 76(2), 306–317. https://doi.org/10.1007/s11336-010-9200-6
</p>
</li>
<li>
<p> Cheung, M. W.-L. (2015). metaSEM: An R package for meta-analysis using structural equation modeling. Frontiers in Psychology, 5. https://doi.org/10.3389/fpsyg.2014.01521
</p>
</li>
<li>
<p> Rosseel, Y. (2012). lavaan: An R package for structural equation modeling. Journal of Statistical Software, 48(2), 1–36. https://doi.org/10.18637/jss.v048.i02
</p>
</li>
<li>
<p> van Lissa, C. J. (2023). tidySEM: Tidy Structural Equation Modeling. R package version 0.2.4, https://cjvanlissa.github.io/tidySEM/.
</p>
</li>
</ul>
<h3>Value</h3>

<p>mxModel object that can be fitted with mxRun or mxTryHard. If return_parameter_table
is TRUE, a list with the mxModel and the parameter table is returned.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># THE FOLLOWING EXAMPLE IS ADAPTED FROM LAVAAN
library(mxsem)

model &lt;- '
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + a1*y2 + b*y3 + c1*y4
     dem65 =~ y5 + a2*y6 + b*y7 + c2*y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60

  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'

fit &lt;- mxsem(model = model,
            data  = OpenMx::Bollen) |&gt;
  mxTryHard()
omxGetParameters(fit)


model_transformations &lt;- '
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + a1*y2 + b1*y3 + c1*y4
     dem65 =~ y5 + {a2 := a1 + delta_a}*y6 + {b2 := b1 + delta_b}*y7 + c2*y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60

  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'

fit &lt;- mxsem(model = model_transformations,
            data  = OpenMx::Bollen) |&gt;
  mxTryHard()
omxGetParameters(fit)
</code></pre>


</div>